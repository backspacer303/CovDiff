<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>TargetInstrInfo.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- llvm/CodeGen/TargetInstrInfo.h - Instruction Info --------*- C++ -*-===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This file describes the target machine instruction set to the code generator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">#ifndef LLVM_CODEGEN_TARGETINSTRINFO_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">#define LLVM_CODEGEN_TARGETINSTRINFO_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "llvm/ADT/ArrayRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/ADT/Uniformity.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/CodeGen/MIRFormatter.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/CodeGen/MachineOutliner.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/CodeGen/RegisterClassInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/CodeGen/VirtRegMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/MC/MCInstrInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/Support/BranchProbability.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include <cstddef></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include <vector></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">class DFAPacketizer;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">class InstrItineraryData;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">class LiveIntervals;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">class LiveVariables;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">class MachineLoop;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">class MachineMemOperand;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">class MachineRegisterInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">class MCAsmInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">class MCInst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">struct MCSchedModel;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">class Module;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">class ScheduleDAG;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">class ScheduleDAGMI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">class ScheduleHazardRecognizer;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">class SDNode;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">class SelectionDAG;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">class SMSchedule;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">class SwingSchedulerDAG;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">class RegScavenger;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">class TargetRegisterClass;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">class TargetRegisterInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">class TargetSchedModel;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">class TargetSubtargetInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">enum class MachineCombinerPattern;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">enum class MachineTraceStrategy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">template <class T> class SmallVectorImpl;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">using ParamLoadedValue = std::pair<MachineOperand, DIExpression*>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">struct DestSourcePair {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">  const MachineOperand *Destination;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">  const MachineOperand *Source;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="coveredLine">  DestSourcePair(const MachineOperand &Dest, const MachineOperand &Src)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="coveredLine">      : Destination(&Dest), Source(&Src) {}</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">/// Used to describe a register and immediate addition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">struct RegImmPair {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">  Register Reg;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">  int64_t Imm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="uncoveredLine">  RegImmPair(Register Reg, int64_t Imm) : Reg(Reg), Imm(Imm) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">/// Used to describe addressing mode similar to ExtAddrMode in CodeGenPrepare.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">/// It holds the register values, the scale value and the displacement.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">struct ExtAddrMode {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">  Register BaseReg;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">  Register ScaledReg;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">  int64_t Scale;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">  int64_t Displacement;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">//---------------------------------------------------------------------------</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">/// TargetInstrInfo - Interface to description of machine instruction set</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">class TargetInstrInfo : public MCInstrInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="coveredLine">  TargetInstrInfo(unsigned CFSetupOpcode = ~0u, unsigned CFDestroyOpcode = ~0u,</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">                  unsigned CatchRetOpcode = ~0u, unsigned ReturnOpcode = ~0u)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="coveredLine">      : CallFrameSetupOpcode(CFSetupOpcode),</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="coveredLine">        CallFrameDestroyOpcode(CFDestroyOpcode), CatchRetOpcode(CatchRetOpcode),</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="coveredLine">        ReturnOpcode(ReturnOpcode) {}</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">  TargetInstrInfo(const TargetInstrInfo &) = delete;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">  TargetInstrInfo &operator=(const TargetInstrInfo &) = delete;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">  virtual ~TargetInstrInfo();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">  static bool isGenericOpcode(unsigned Opc) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">    return Opc <= TargetOpcode::GENERIC_OP_END;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">  static bool isGenericAtomicRMWOpcode(unsigned Opc) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">    return Opc >= TargetOpcode::GENERIC_ATOMICRMW_OP_START &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">           Opc <= TargetOpcode::GENERIC_ATOMICRMW_OP_END;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">  /// Given a machine instruction descriptor, returns the register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">  /// class constraint for OpNum, or NULL.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">  virtual</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">  const TargetRegisterClass *getRegClass(const MCInstrDesc &MCID, unsigned OpNum,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">                                         const TargetRegisterInfo *TRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">                                         const MachineFunction &MF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">  /// Return true if the instruction is trivially rematerializable, meaning it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">  /// has no side effects and requires no operands that aren't always available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">  /// This means the only allowed uses are constants and unallocatable physical</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">  /// registers so that the instructions result is independent of the place</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">  /// in the function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="coveredLine">  bool isTriviallyReMaterializable(const MachineInstr &MI) const {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="coveredLine">    return MI.getOpcode() == TargetOpcode::IMPLICIT_DEF ||</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="coveredLine">           (MI.getDesc().isRematerializable() &&</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="uncoveredLine">            (isReallyTriviallyReMaterializable(MI) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="coveredLine">             isReallyTriviallyReMaterializableGeneric(MI)));</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">  /// Given \p MO is a PhysReg use return if it can be ignored for the purpose</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">  /// of instruction rematerialization or sinking.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="uncoveredLine">  virtual bool isIgnorableUse(const MachineOperand &MO) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">  /// For instructions with opcodes for which the M_REMATERIALIZABLE flag is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">  /// set, this hook lets the target specify whether the instruction is actually</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">  /// trivially rematerializable, taking into consideration its operands. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">  /// predicate must return false if the instruction has any side effects other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">  /// than producing a value, or if it requres any address registers that are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">  /// not always available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">  /// Requirements must be check as stated in isTriviallyReMaterializable() .</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="uncoveredLine">  virtual bool isReallyTriviallyReMaterializable(const MachineInstr &MI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">  /// This method commutes the operands of the given machine instruction MI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">  /// The operands to be commuted are specified by their indices OpIdx1 and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">  /// OpIdx2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">  /// If a target has any instructions that are commutable but require</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">  /// converting to different instructions or making non-trivial changes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">  /// to commute them, this method can be overloaded to do that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">  /// The default implementation simply swaps the commutable operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">  /// If NewMI is false, MI is modified in place and returned; otherwise, a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">  /// new machine instruction is created and returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">  /// Do not call this method for a non-commutable instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">  /// Even though the instruction is commutable, the method may still</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">  /// fail to commute the operands, null pointer is returned in such cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">  virtual MachineInstr *commuteInstructionImpl(MachineInstr &MI, bool NewMI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">                                               unsigned OpIdx1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">                                               unsigned OpIdx2) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">  /// Assigns the (CommutableOpIdx1, CommutableOpIdx2) pair of commutable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">  /// operand indices to (ResultIdx1, ResultIdx2).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">  /// One or both input values of the pair: (ResultIdx1, ResultIdx2) may be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">  /// predefined to some indices or be undefined (designated by the special</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">  /// value 'CommuteAnyOperandIndex').</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">  /// The predefined result indices cannot be re-defined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">  /// The function returns true iff after the result pair redefinition</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">  /// the fixed result pair is equal to or equivalent to the source pair of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">  /// indices: (CommutableOpIdx1, CommutableOpIdx2). It is assumed here that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">  /// the pairs (x,y) and (y,x) are equivalent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">  static bool fixCommutedOpIndices(unsigned &ResultIdx1, unsigned &ResultIdx2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">                                   unsigned CommutableOpIdx1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">                                   unsigned CommutableOpIdx2);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">  /// For instructions with opcodes for which the M_REMATERIALIZABLE flag is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">  /// set and the target hook isReallyTriviallyReMaterializable returns false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">  /// this function does target-independent tests to determine if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">  /// instruction is really trivially rematerializable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">  bool isReallyTriviallyReMaterializableGeneric(const MachineInstr &MI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">  /// These methods return the opcode of the frame setup/destroy instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">  /// if they exist (-1 otherwise).  Some targets use pseudo instructions in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">  /// order to abstract away the difference between operating with a frame</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">  /// pointer and operating without, through the use of these two instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="coveredLine">  unsigned getCallFrameSetupOpcode() const { return CallFrameSetupOpcode; }</td>
    <td>84</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="coveredLine">  unsigned getCallFrameDestroyOpcode() const { return CallFrameDestroyOpcode; }</td>
    <td>114</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  /// Returns true if the argument is a frame pseudo instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="coveredLine">  bool isFrameInstr(const MachineInstr &I) const {</td>
    <td>82</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="coveredLine">    return I.getOpcode() == getCallFrameSetupOpcode() ||</td>
    <td>164</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="coveredLine">           I.getOpcode() == getCallFrameDestroyOpcode();</td>
    <td>164</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">  /// Returns true if the argument is a frame setup pseudo instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="uncoveredLine">  bool isFrameSetup(const MachineInstr &I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="uncoveredLine">    return I.getOpcode() == getCallFrameSetupOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">  /// Returns size of the frame associated with the given frame instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">  /// For frame setup instruction this is frame that is set up space set up</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">  /// after the instruction. For frame destroy instruction this is the frame</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">  /// freed by the caller.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">  /// Note, in some cases a call frame (or a part of it) may be prepared prior</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">  /// to the frame setup instruction. It occurs in the calls that involve</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">  /// inalloca arguments. This function reports only the size of the frame part</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  /// that is set up between the frame setup and destroy pseudo instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="uncoveredLine">  int64_t getFrameSize(const MachineInstr &I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="uncoveredLine">    assert(isFrameInstr(I) && "Not a frame instruction");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="uncoveredLine">    assert(I.getOperand(0).getImm() >= 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="uncoveredLine">    return I.getOperand(0).getImm();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">  /// Returns the total frame size, which is made up of the space set up inside</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">  /// the pair of frame start-stop instructions and the space that is set up</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">  /// prior to the pair.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">  int64_t getFrameTotalSize(const MachineInstr &I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="uncoveredLine">    if (isFrameSetup(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">      assert(I.getOperand(1).getImm() >= 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">             "Frame size must not be negative");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="uncoveredLine">      return getFrameSize(I) + I.getOperand(1).getImm();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="uncoveredLine">    return getFrameSize(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">  unsigned getCatchReturnOpcode() const { return CatchRetOpcode; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">  unsigned getReturnOpcode() const { return ReturnOpcode; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">  /// Returns the actual stack pointer adjustment made by an instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">  /// as part of a call sequence. By default, only call frame setup/destroy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">  /// instructions adjust the stack, but targets may want to override this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">  /// to enable more fine-grained adjustment, or adjust by a different value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">  virtual int getSPAdjust(const MachineInstr &MI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">  /// Return true if the instruction is a "coalescable" extension instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  /// That is, it's like a copy where it's legal for the source to overlap the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">  /// destination. e.g. X86::MOVSX64rr32. If this returns true, then it's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">  /// expected the pre-extension value is available as a subreg of the result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">  /// register. This also returns the sub-register index in SubIdx.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">  virtual bool isCoalescableExtInstr(const MachineInstr &MI, Register &SrcReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">                                     Register &DstReg, unsigned &SubIdx) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">  /// If the specified machine instruction is a direct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">  /// load from a stack slot, return the virtual or physical register number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">  /// the destination along with the FrameIndex of the loaded stack slot.  If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  /// not, return 0.  This predicate must return 0 if the instruction has</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">  /// any side effects other than loading from the stack slot.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="uncoveredLine">  virtual unsigned isLoadFromStackSlot(const MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">                                       int &FrameIndex) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">  /// Optional extension of isLoadFromStackSlot that returns the number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">  /// bytes loaded from the stack. This must be implemented if a backend</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">  /// supports partial stack slot spills/loads to further disambiguate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">  /// what the load does.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="uncoveredLine">  virtual unsigned isLoadFromStackSlot(const MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">                                       int &FrameIndex,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">                                       unsigned &MemBytes) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="uncoveredLine">    MemBytes = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="uncoveredLine">    return isLoadFromStackSlot(MI, FrameIndex);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">  /// Check for post-frame ptr elimination stack locations as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">  /// This uses a heuristic so it isn't reliable for correctness.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="coveredLine">  virtual unsigned isLoadFromStackSlotPostFE(const MachineInstr &MI,</td>
    <td>55</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">                                             int &FrameIndex) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="coveredLine">    return 0;</td>
    <td>55</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">  /// If the specified machine instruction has a load from a stack slot,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">  /// return true along with the FrameIndices of the loaded stack slot and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">  /// machine mem operands containing the reference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">  /// If not, return false.  Unlike isLoadFromStackSlot, this returns true for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">  /// any instructions that loads from the stack.  This is just a hint, as some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">  /// cases may be missed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">  virtual bool hasLoadFromStackSlot(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">      const MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="">      SmallVectorImpl<const MachineMemOperand *> &Accesses) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">  /// If the specified machine instruction is a direct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">  /// store to a stack slot, return the virtual or physical register number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">  /// the source reg along with the FrameIndex of the loaded stack slot.  If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">  /// not, return 0.  This predicate must return 0 if the instruction has</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">  /// any side effects other than storing to the stack slot.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">  virtual unsigned isStoreToStackSlot(const MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">                                      int &FrameIndex) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">  /// Optional extension of isStoreToStackSlot that returns the number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">  /// bytes stored to the stack. This must be implemented if a backend</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">  /// supports partial stack slot spills/loads to further disambiguate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">  /// what the store does.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="uncoveredLine">  virtual unsigned isStoreToStackSlot(const MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">                                      int &FrameIndex,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">                                      unsigned &MemBytes) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="uncoveredLine">    MemBytes = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="uncoveredLine">    return isStoreToStackSlot(MI, FrameIndex);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">  /// Check for post-frame ptr elimination stack locations as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">  /// This uses a heuristic, so it isn't reliable for correctness.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="coveredLine">  virtual unsigned isStoreToStackSlotPostFE(const MachineInstr &MI,</td>
    <td>63</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">                                            int &FrameIndex) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="coveredLine">    return 0;</td>
    <td>63</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">  /// If the specified machine instruction has a store to a stack slot,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">  /// return true along with the FrameIndices of the loaded stack slot and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">  /// machine mem operands containing the reference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">  /// If not, return false.  Unlike isStoreToStackSlot,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">  /// this returns true for any instructions that stores to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">  /// stack.  This is just a hint, as some cases may be missed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">  virtual bool hasStoreToStackSlot(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">      const MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">      SmallVectorImpl<const MachineMemOperand *> &Accesses) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">  /// Return true if the specified machine instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">  /// is a copy of one stack slot to another and has no other effect.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">  /// Provide the identity of the two frame indices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="uncoveredLine">  virtual bool isStackSlotCopy(const MachineInstr &MI, int &DestFrameIndex,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">                               int &SrcFrameIndex) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">  /// Compute the size in bytes and offset within a stack slot of a spilled</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">  /// register or subregister.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">  /// \param [out] Size in bytes of the spilled value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">  /// \param [out] Offset in bytes within the stack slot.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">  /// \returns true if both Size and Offset are successfully computed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">  /// Not all subregisters have computable spill slots. For example,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">  /// subregisters registers may not be byte-sized, and a pair of discontiguous</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">  /// subregisters has no single offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">  /// Targets with nontrivial bigendian implementations may need to override</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">  /// this, particularly to support spilled vector registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">  virtual bool getStackSlotRange(const TargetRegisterClass *RC, unsigned SubIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">                                 unsigned &Size, unsigned &Offset,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">                                 const MachineFunction &MF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">  /// Return true if the given instruction is terminator that is unspillable,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">  /// according to isUnspillableTerminatorImpl.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="coveredLine">  bool isUnspillableTerminator(const MachineInstr *MI) const {</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="coveredLine">    return MI->isTerminator() && isUnspillableTerminatorImpl(MI);</td>
    <td>32</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">  /// Returns the size in bytes of the specified MachineInstr, or ~0U</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">  /// when this function is not implemented by a target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="uncoveredLine">  virtual unsigned getInstSizeInBytes(const MachineInstr &MI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="uncoveredLine">    return ~0U;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">  /// Return true if the instruction is as cheap as a move instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">  /// Targets for different archs need to override this, and different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="">  /// micro-architectures can also be finely tuned inside.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="coveredLine">  virtual bool isAsCheapAsAMove(const MachineInstr &MI) const {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="coveredLine">    return MI.isAsCheapAsAMove();</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">  /// Return true if the instruction should be sunk by MachineSink.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">  /// MachineSink determines on its own whether the instruction is safe to sink;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="">  /// this gives the target a hook to override the default behavior with regards</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">  /// to which instructions should be sunk.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">  virtual bool shouldSink(const MachineInstr &MI) const { return true; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="">  /// Return false if the instruction should not be hoisted by MachineLICM.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">  /// MachineLICM determines on its own whether the instruction is safe to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">  /// hoist; this gives the target a hook to extend this assessment and prevent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">  /// an instruction being hoisted from a given loop for target specific</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">  /// reasons.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="uncoveredLine">  virtual bool shouldHoist(const MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">                           const MachineLoop *FromLoop) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">  /// Re-issue the specified 'original' instruction at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">  /// specific location targeting a new destination register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">  /// The register in Orig->getOperand(0).getReg() will be substituted by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">  /// DestReg:SubIdx. Any existing subreg index is preserved or composed with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">  /// SubIdx.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">  virtual void reMaterialize(MachineBasicBlock &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">                             MachineBasicBlock::iterator MI, Register DestReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">                             unsigned SubIdx, const MachineInstr &Orig,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="">                             const TargetRegisterInfo &TRI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">  /// Clones instruction or the whole instruction bundle \p Orig and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  /// insert into \p MBB before \p InsertBefore. The target may update operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">  /// that are required to be unique.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">  /// \p Orig must not return true for MachineInstr::isNotDuplicable().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">  virtual MachineInstr &duplicate(MachineBasicBlock &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">                                  MachineBasicBlock::iterator InsertBefore,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">                                  const MachineInstr &Orig) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">  /// This method must be implemented by targets that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">  /// set the M_CONVERTIBLE_TO_3_ADDR flag.  When this flag is set, the target</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">  /// may be able to convert a two-address instruction into one or more true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">  /// three-address instructions on demand.  This allows the X86 target (for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">  /// example) to convert ADD and SHL instructions into LEA instructions if they</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">  /// would require register copies due to two-addressness.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  /// This method returns a null pointer if the transformation cannot be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">  /// performed, otherwise it returns the last new instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">  /// If \p LIS is not nullptr, the LiveIntervals info should be updated for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">  /// replacing \p MI with new instructions, even though this function does not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">  /// remove MI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="uncoveredLine">  virtual MachineInstr *convertToThreeAddress(MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">                                              LiveVariables *LV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">                                              LiveIntervals *LIS) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">  // This constant can be used as an input value of operand index passed to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">  // the method findCommutedOpIndices() to tell the method that the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="">  // corresponding operand index is not pre-defined and that the method</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">  // can pick any commutable operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">  static const unsigned CommuteAnyOperandIndex = ~0U;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">  /// This method commutes the operands of the given machine instruction MI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">  /// The operands to be commuted are specified by their indices OpIdx1 and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">  /// OpIdx2. OpIdx1 and OpIdx2 arguments may be set to a special value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">  /// 'CommuteAnyOperandIndex', which means that the method is free to choose</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">  /// any arbitrarily chosen commutable operand. If both arguments are set to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">  /// 'CommuteAnyOperandIndex' then the method looks for 2 different commutable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">  /// operands; then commutes them if such operands could be found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">  /// If NewMI is false, MI is modified in place and returned; otherwise, a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">  /// new machine instruction is created and returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">  /// Do not call this method for a non-commutable instruction or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">  /// for non-commuable operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">  /// Even though the instruction is commutable, the method may still</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">  /// fail to commute the operands, null pointer is returned in such cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">  MachineInstr *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">  commuteInstruction(MachineInstr &MI, bool NewMI = false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="">                     unsigned OpIdx1 = CommuteAnyOperandIndex,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="">                     unsigned OpIdx2 = CommuteAnyOperandIndex) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">  /// Returns true iff the routine could find two commutable operands in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">  /// given machine instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">  /// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">  /// If any of the INPUT values is set to the special value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">  /// 'CommuteAnyOperandIndex' then the method arbitrarily picks a commutable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">  /// operand, then returns its index in the corresponding argument.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">  /// If both of INPUT values are set to 'CommuteAnyOperandIndex' then method</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">  /// looks for 2 commutable operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">  /// If INPUT values refer to some operands of MI, then the method simply</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">  /// returns true if the corresponding operands are commutable and returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">  /// false otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">  /// For example, calling this method this way:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">  ///     unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">  ///     findCommutedOpIndices(MI, Op1, Op2);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">  /// can be interpreted as a query asking to find an operand that would be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">  /// commutable with the operand#1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">  virtual bool findCommutedOpIndices(const MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">                                     unsigned &SrcOpIdx1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">                                     unsigned &SrcOpIdx2) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">  /// Returns true if the target has a preference on the operands order of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">  /// the given machine instruction. And specify if \p Commute is required to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="">  /// get the desired operands order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="uncoveredLine">  virtual bool hasCommutePreference(MachineInstr &MI, bool &Commute) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">  /// A pair composed of a register and a sub-register index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">  /// Used to give some type checking when modeling Reg:SubReg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">  struct RegSubRegPair {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">    Register Reg;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">    unsigned SubReg;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">    RegSubRegPair(Register Reg = Register(), unsigned SubReg = 0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">        : Reg(Reg), SubReg(SubReg) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">    bool operator==(const RegSubRegPair& P) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">      return Reg == P.Reg && SubReg == P.SubReg;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">    bool operator!=(const RegSubRegPair& P) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">      return !(*this == P);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">  /// A pair composed of a pair of a register and a sub-register index,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">  /// and another sub-register index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">  /// Used to give some type checking when modeling Reg:SubReg1, SubReg2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">  struct RegSubRegPairAndIdx : RegSubRegPair {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">    unsigned SubIdx;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">    RegSubRegPairAndIdx(Register Reg = Register(), unsigned SubReg = 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">                        unsigned SubIdx = 0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">        : RegSubRegPair(Reg, SubReg), SubIdx(SubIdx) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="">  /// Build the equivalent inputs of a REG_SEQUENCE for the given \p MI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">  /// and \p DefIdx.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">  /// \p [out] InputRegs of the equivalent REG_SEQUENCE. Each element of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">  /// the list is modeled as <Reg:SubReg, SubIdx>. Operands with the undef</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">  /// flag are not added to this list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">  /// E.g., REG_SEQUENCE %1:sub1, sub0, %2, sub1 would produce</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">  /// two elements:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="">  /// - %1:sub1, sub0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">  /// - %2<:0>, sub1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">  /// \returns true if it is possible to build such an input sequence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">  /// with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">  /// \pre MI.isRegSequence() or MI.isRegSequenceLike().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">  /// \note The generic implementation does not provide any support for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">  /// MI.isRegSequenceLike(). In other words, one has to override</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">  /// getRegSequenceLikeInputs for target specific instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">  bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">  getRegSequenceInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">                       SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">  /// Build the equivalent inputs of a EXTRACT_SUBREG for the given \p MI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">  /// and \p DefIdx.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">  /// \p [out] InputReg of the equivalent EXTRACT_SUBREG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">  /// E.g., EXTRACT_SUBREG %1:sub1, sub0, sub1 would produce:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">  /// - %1:sub1, sub0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">  /// \returns true if it is possible to build such an input sequence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">  /// with the pair \p MI, \p DefIdx and the operand has no undef flag set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">  /// False otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">  /// \pre MI.isExtractSubreg() or MI.isExtractSubregLike().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">  /// \note The generic implementation does not provide any support for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">  /// MI.isExtractSubregLike(). In other words, one has to override</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">  /// getExtractSubregLikeInputs for target specific instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">  bool getExtractSubregInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">                              RegSubRegPairAndIdx &InputReg) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">  /// Build the equivalent inputs of a INSERT_SUBREG for the given \p MI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">  /// and \p DefIdx.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">  /// \p [out] BaseReg and \p [out] InsertedReg contain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">  /// the equivalent inputs of INSERT_SUBREG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">  /// E.g., INSERT_SUBREG %0:sub0, %1:sub1, sub3 would produce:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">  /// - BaseReg: %0:sub0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">  /// - InsertedReg: %1:sub1, sub3</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">  /// \returns true if it is possible to build such an input sequence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">  /// with the pair \p MI, \p DefIdx and the operand has no undef flag set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">  /// False otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">  /// \pre MI.isInsertSubreg() or MI.isInsertSubregLike().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">  /// \note The generic implementation does not provide any support for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">  /// MI.isInsertSubregLike(). In other words, one has to override</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">  /// getInsertSubregLikeInputs for target specific instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">  bool getInsertSubregInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="">                             RegSubRegPair &BaseReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">                             RegSubRegPairAndIdx &InsertedReg) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="">  /// Return true if two machine instructions would produce identical values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">  /// By default, this is only true when the two instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">  /// are deemed identical except for defs. If this function is called when the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">  /// IR is still in SSA form, the caller can pass the MachineRegisterInfo for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">  /// aggressive checks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">  virtual bool produceSameValue(const MachineInstr &MI0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">                                const MachineInstr &MI1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">                                const MachineRegisterInfo *MRI = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">  /// \returns true if a branch from an instruction with opcode \p BranchOpc</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">  ///  bytes is capable of jumping to a position \p BrOffset bytes away.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">  virtual bool isBranchOffsetInRange(unsigned BranchOpc,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">                                     int64_t BrOffset) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="uncoveredLine">    llvm_unreachable("target did not implement");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">  /// \returns The block that branch instruction \p MI jumps to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="uncoveredLine">  virtual MachineBasicBlock *getBranchDestBlock(const MachineInstr &MI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="uncoveredLine">    llvm_unreachable("target did not implement");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">  /// Insert an unconditional indirect branch at the end of \p MBB to \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">  /// NewDestBB. Optionally, insert the clobbered register restoring in \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">  /// RestoreBB. \p BrOffset indicates the offset of \p NewDestBB relative to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">  /// the offset of the position to insert the new branch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">  virtual void insertIndirectBranch(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="">                                    MachineBasicBlock &NewDestBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">                                    MachineBasicBlock &RestoreBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">                                    const DebugLoc &DL, int64_t BrOffset = 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">                                    RegScavenger *RS = nullptr) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="uncoveredLine">    llvm_unreachable("target did not implement");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">  /// Analyze the branching code at the end of MBB, returning</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">  /// true if it cannot be understood (e.g. it's a switch dispatch or isn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">  /// implemented for a target).  Upon success, this returns false and returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">  /// with the following information in various cases:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">  /// 1. If this block ends with no branches (it just falls through to its succ)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">  ///    just return false, leaving TBB/FBB null.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">  /// 2. If this block ends with only an unconditional branch, it sets TBB to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">  ///    the destination block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">  /// 3. If this block ends with a conditional branch and it falls through to a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">  ///    successor block, it sets TBB to be the branch destination block and a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">  ///    list of operands that evaluate the condition. These operands can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">  ///    passed to other TargetInstrInfo methods to create new branches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="">  /// 4. If this block ends with a conditional branch followed by an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">  ///    unconditional branch, it returns the 'true' destination in TBB, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">  ///    'false' destination in FBB, and a list of operands that evaluate the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">  ///    condition.  These operands can be passed to other TargetInstrInfo</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">  ///    methods to create new branches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">  /// Note that removeBranch and insertBranch must be implemented to support</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">  /// cases where this method returns success.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">  /// If AllowModify is true, then this routine is allowed to modify the basic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">  /// block (e.g. delete instructions after the unconditional branch).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">  /// before calling this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">  virtual bool analyzeBranch(MachineBasicBlock &MBB, MachineBasicBlock *&TBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">                             MachineBasicBlock *&FBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">                             SmallVectorImpl<MachineOperand> &Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">                             bool AllowModify = false) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">  /// Represents a predicate at the MachineFunction level.  The control flow a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">  /// MachineBranchPredicate represents is:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">  ///  Reg = LHS `Predicate` RHS         == ConditionDef</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">  ///  if Reg then goto TrueDest else goto FalseDest</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">  struct MachineBranchPredicate {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">    enum ComparePredicate {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">      PRED_EQ,     // True if two values are equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">      PRED_NE,     // True if two values are not equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">      PRED_INVALID // Sentinel value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">    ComparePredicate Predicate = PRED_INVALID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="">    MachineOperand LHS = MachineOperand::CreateImm(0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">    MachineOperand RHS = MachineOperand::CreateImm(0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">    MachineBasicBlock *TrueDest = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">    MachineBasicBlock *FalseDest = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">    MachineInstr *ConditionDef = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">    /// SingleUseCondition is true if ConditionDef is dead except for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">    /// branch(es) at the end of the basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="">    ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="">    bool SingleUseCondition = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">    explicit MachineBranchPredicate() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">  /// Analyze the branching code at the end of MBB and parse it into the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">  /// MachineBranchPredicate structure if possible.  Returns false on success</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">  /// and true on failure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">  /// If AllowModify is true, then this routine is allowed to modify the basic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">  /// block (e.g. delete instructions after the unconditional branch).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="uncoveredLine">  virtual bool analyzeBranchPredicate(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">                                      MachineBranchPredicate &MBP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">                                      bool AllowModify = false) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="">  /// Remove the branching code at the end of the specific MBB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">  /// This is only invoked in cases where analyzeBranch returns success. It</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">  /// returns the number of instructions that were removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">  /// If \p BytesRemoved is non-null, report the change in code size from the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">  /// removed instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="uncoveredLine">  virtual unsigned removeBranch(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">                                int *BytesRemoved = nullptr) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="uncoveredLine">    llvm_unreachable("Target didn't implement TargetInstrInfo::removeBranch!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">  /// Insert branch code into the end of the specified MachineBasicBlock. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="">  /// operands to this method are the same as those returned by analyzeBranch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="">  /// This is only invoked in cases where analyzeBranch returns success. It</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">  /// returns the number of instructions inserted. If \p BytesAdded is non-null,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">  /// report the change in code size from the added instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">  /// It is also invoked by tail merging to add unconditional branches in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">  /// cases where analyzeBranch doesn't apply because there was no original</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">  /// branch to analyze.  At least this much must be implemented, else tail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">  /// merging needs to be disabled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="">  /// before calling this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">  virtual unsigned insertBranch(MachineBasicBlock &MBB, MachineBasicBlock *TBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">                                MachineBasicBlock *FBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">                                ArrayRef<MachineOperand> Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">                                const DebugLoc &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">                                int *BytesAdded = nullptr) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">    llvm_unreachable("Target didn't implement TargetInstrInfo::insertBranch!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">  unsigned insertUnconditionalBranch(MachineBasicBlock &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="">                                     MachineBasicBlock *DestBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">                                     const DebugLoc &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="">                                     int *BytesAdded = nullptr) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">    return insertBranch(MBB, DestBB, nullptr, ArrayRef<MachineOperand>(), DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">                        BytesAdded);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">  /// Object returned by analyzeLoopForPipelining. Allows software pipelining</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">  /// implementations to query attributes of the loop being pipelined and to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">  /// apply target-specific updates to the loop once pipelining is complete.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="">  class PipelinerLoopInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">    virtual ~PipelinerLoopInfo();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">    /// Return true if the given instruction should not be pipelined and should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">    /// be ignored. An example could be a loop comparison, or induction variable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">    /// update with no users being pipelined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">    virtual bool shouldIgnoreForPipelining(const MachineInstr *MI) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="">    /// Return true if the proposed schedule should used.  Otherwise return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">    /// false to not pipeline the loop. This function should be used to ensure</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="">    /// that pipelined loops meet target-specific quality heuristics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="">    virtual bool shouldUseSchedule(SwingSchedulerDAG &SSD, SMSchedule &SMS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">      return true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">    /// Create a condition to determine if the trip count of the loop is greater</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">    /// than TC, where TC is always one more than for the previous prologue or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">    /// 0 if this is being called for the outermost prologue.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">    ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">    /// If the trip count is statically known to be greater than TC, return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">    /// true. If the trip count is statically known to be not greater than TC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">    /// return false. Otherwise return nullopt and fill out Cond with the test</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">    /// condition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">    ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">    /// Note: This hook is guaranteed to be called from the innermost to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">    /// outermost prologue of the loop being software pipelined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">    virtual std::optional<bool></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">    createTripCountGreaterCondition(int TC, MachineBasicBlock &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">                                    SmallVectorImpl<MachineOperand> &Cond) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">    /// Modify the loop such that the trip count is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">    /// OriginalTC + TripCountAdjust.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">    virtual void adjustTripCount(int TripCountAdjust) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="">    /// Called when the loop's preheader has been modified to NewPreheader.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">    virtual void setPreheader(MachineBasicBlock *NewPreheader) = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">    /// Called when the loop is being removed. Any instructions in the preheader</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">    /// should be removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="">    ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">    /// Once this function is called, no other functions on this object are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">    /// valid; the loop has been removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">    virtual void disposed() = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">  /// Analyze loop L, which must be a single-basic-block loop, and if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="">  /// conditions can be understood enough produce a PipelinerLoopInfo object.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">  virtual std::unique_ptr<PipelinerLoopInfo></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">  analyzeLoopForPipelining(MachineBasicBlock *LoopBB) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">  /// Analyze the loop code, return true if it cannot be understood. Upon</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">  /// success, this function returns false and returns information about the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">  /// induction variable and compare instruction used at the end.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">  virtual bool analyzeLoop(MachineLoop &L, MachineInstr *&IndVarInst,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">                           MachineInstr *&CmpInst) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">  /// Generate code to reduce the loop iteration by one and check if the loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">  /// is finished.  Return the value/register of the new loop count.  We need</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">  /// this function when peeling off one or more iterations of a loop. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">  /// function assumes the nth iteration is peeled first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="uncoveredLine">  virtual unsigned reduceLoopCount(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">                                   MachineBasicBlock &PreHeader,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">                                   MachineInstr *IndVar, MachineInstr &Cmp,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">                                   SmallVectorImpl<MachineOperand> &Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">                                   SmallVectorImpl<MachineInstr *> &PrevInsts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="">                                   unsigned Iter, unsigned MaxIter) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">    llvm_unreachable("Target didn't implement ReduceLoopCount");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">  /// Delete the instruction OldInst and everything after it, replacing it with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">  /// an unconditional branch to NewDest. This is used by the tail merging pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="">  virtual void ReplaceTailWithBranchTo(MachineBasicBlock::iterator Tail,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">                                       MachineBasicBlock *NewDest) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">  /// Return true if it's legal to split the given basic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">  /// block at the specified instruction (i.e. instruction would be the start</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">  /// of a new basic block).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="uncoveredLine">  virtual bool isLegalToSplitMBBAt(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">                                   MachineBasicBlock::iterator MBBI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">  /// Return true if it's profitable to predicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">  /// instructions with accumulated instruction latency of "NumCycles"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">  /// of the specified basic block, where the probability of the instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">  /// being executed is given by Probability, and Confidence is a measure</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">  /// of our confidence that it will be properly predicted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="uncoveredLine">  virtual bool isProfitableToIfCvt(MachineBasicBlock &MBB, unsigned NumCycles,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">                                   unsigned ExtraPredCycles,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">                                   BranchProbability Probability) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="">  /// Second variant of isProfitableToIfCvt. This one</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="">  /// checks for the case where two basic blocks from true and false path</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="">  /// of a if-then-else (diamond) are predicated on mutually exclusive</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">  /// predicates, where the probability of the true path being taken is given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="">  /// by Probability, and Confidence is a measure of our confidence that it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="">  /// will be properly predicted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">  virtual bool isProfitableToIfCvt(MachineBasicBlock &TMBB, unsigned NumTCycles,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">                                   unsigned ExtraTCycles,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">                                   MachineBasicBlock &FMBB, unsigned NumFCycles,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">                                   unsigned ExtraFCycles,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">                                   BranchProbability Probability) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">  /// Return true if it's profitable for if-converter to duplicate instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">  /// of specified accumulated instruction latencies in the specified MBB to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">  /// enable if-conversion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">  /// The probability of the instructions being executed is given by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">  /// Probability, and Confidence is a measure of our confidence that it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="">  /// will be properly predicted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="uncoveredLine">  virtual bool isProfitableToDupForIfCvt(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="">                                         unsigned NumCycles,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">                                         BranchProbability Probability) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">  /// Return the increase in code size needed to predicate a contiguous run of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="">  /// NumInsts instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="uncoveredLine">  virtual unsigned extraSizeToPredicateInstructions(const MachineFunction &MF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">                                                    unsigned NumInsts) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">  /// Return an estimate for the code size reduction (in bytes) which will be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">  /// caused by removing the given branch instruction during if-conversion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="uncoveredLine">  virtual unsigned predictBranchSizeForIfCvt(MachineInstr &MI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">    return getInstSizeInBytes(MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">  /// Return true if it's profitable to unpredicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="">  /// one side of a 'diamond', i.e. two sides of if-else predicated on mutually</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">  /// exclusive predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">  /// e.g.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="">  ///   subeq  r0, r1, #1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">  ///   addne  r0, r1, #1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="">  /// =></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">  ///   sub    r0, r1, #1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">  ///   addne  r0, r1, #1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">  /// This may be profitable is conditional instructions are always executed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="uncoveredLine">  virtual bool isProfitableToUnpredicate(MachineBasicBlock &TMBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="">                                         MachineBasicBlock &FMBB) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">  /// Return true if it is possible to insert a select</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">  /// instruction that chooses between TrueReg and FalseReg based on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">  /// condition code in Cond.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">  /// When successful, also return the latency in cycles from TrueReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">  /// FalseReg, and Cond to the destination register. In most cases, a select</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">  /// instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">  /// Some x86 implementations have 2-cycle cmov instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="">  /// @param MBB         Block where select instruction would be inserted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">  /// @param Cond        Condition returned by analyzeBranch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">  /// @param DstReg      Virtual dest register that the result should write to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">  /// @param TrueReg     Virtual register to select when Cond is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">  /// @param FalseReg    Virtual register to select when Cond is false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">  /// @param CondCycles  Latency from Cond+Branch to select output.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">  /// @param TrueCycles  Latency from TrueReg to select output.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">  /// @param FalseCycles Latency from FalseReg to select output.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="uncoveredLine">  virtual bool canInsertSelect(const MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">                               ArrayRef<MachineOperand> Cond, Register DstReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="">                               Register TrueReg, Register FalseReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">                               int &CondCycles, int &TrueCycles,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">                               int &FalseCycles) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">  /// Insert a select instruction into MBB before I that will copy TrueReg to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="">  /// DstReg when Cond is true, and FalseReg to DstReg when Cond is false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">  /// This function can only be called after canInsertSelect() returned true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">  /// The condition in Cond comes from analyzeBranch, and it can be assumed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="">  /// that the same flags or registers required by Cond are available at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="">  /// insertion point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="">  /// @param MBB      Block where select instruction should be inserted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="">  /// @param I        Insertion point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="">  /// @param DL       Source location for debugging.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="">  /// @param DstReg   Virtual register to be defined by select instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">  /// @param Cond     Condition as computed by analyzeBranch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="">  /// @param TrueReg  Virtual register to copy when Cond is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="">  /// @param FalseReg Virtual register to copy when Cons is false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">  virtual void insertSelect(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">                            MachineBasicBlock::iterator I, const DebugLoc &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="">                            Register DstReg, ArrayRef<MachineOperand> Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="">                            Register TrueReg, Register FalseReg) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="uncoveredLine">    llvm_unreachable("Target didn't implement TargetInstrInfo::insertSelect!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">  /// Analyze the given select instruction, returning true if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">  /// it cannot be understood. It is assumed that MI->isSelect() is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">  /// When successful, return the controlling condition and the operands that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">  /// determine the true and false result values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">  ///   Result = SELECT Cond, TrueOp, FalseOp</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="">  /// Some targets can optimize select instructions, for example by predicating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">  /// the instruction defining one of the operands. Such targets should set</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">  /// Optimizable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">  /// @param         MI Select instruction to analyze.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">  /// @param Cond    Condition controlling the select.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="">  /// @param TrueOp  Operand number of the value selected when Cond is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">  /// @param FalseOp Operand number of the value selected when Cond is false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">  /// @param Optimizable Returned as true if MI is optimizable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">  /// @returns False on success.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">  virtual bool analyzeSelect(const MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">                             SmallVectorImpl<MachineOperand> &Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">                             unsigned &TrueOp, unsigned &FalseOp,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="">                             bool &Optimizable) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="uncoveredLine">    assert(MI.getDesc().isSelect() && "MI must be a select instruction");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">  /// Given a select instruction that was understood by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">  /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">  /// merging it with one of its operands. Returns NULL on failure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">  /// When successful, returns the new select instruction. The client is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">  /// responsible for deleting MI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="">  /// If both sides of the select can be optimized, PreferFalse is used to pick</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="">  /// a side.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">  /// @param MI          Optimizable select instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="">  /// @param NewMIs     Set that record all MIs in the basic block up to \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="">  /// MI. Has to be updated with any newly created MI or deleted ones.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="">  /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="">  /// @returns Optimized instruction or NULL.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="uncoveredLine">  virtual MachineInstr *optimizeSelect(MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="">                                       SmallPtrSetImpl<MachineInstr *> &NewMIs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">                                       bool PreferFalse = false) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="">    // This function must be implemented if Optimizable is ever set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="uncoveredLine">    llvm_unreachable("Target must implement TargetInstrInfo::optimizeSelect!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">  /// Emit instructions to copy a pair of physical registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="">  /// This function should support copies within any legal register class as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">  /// well as any cross-class copies created during instruction selection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="">  /// The source and destination registers may overlap, which may require a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">  /// careful implementation when multiple copy instructions are required for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="">  /// large registers. See for example the ARM target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="uncoveredLine">  virtual void copyPhysReg(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="">                           MachineBasicBlock::iterator MI, const DebugLoc &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="">                           MCRegister DestReg, MCRegister SrcReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="">                           bool KillSrc) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="uncoveredLine">    llvm_unreachable("Target didn't implement TargetInstrInfo::copyPhysReg!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">  /// Allow targets to tell MachineVerifier whether a specific register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">  /// MachineOperand can be used as part of PC-relative addressing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">  /// PC-relative addressing modes in many CISC architectures contain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">  /// (non-PC) registers as offsets or scaling values, which inherently</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="">  /// tags the corresponding MachineOperand with OPERAND_PCREL.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="">  /// @param MO The MachineOperand in question. MO.isReg() should always</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">  /// be true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">  /// @return Whether this operand is allowed to be used PC-relatively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="uncoveredLine">  virtual bool isPCRelRegisterOperandLegal(const MachineOperand &MO) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">  /// Return an index for MachineJumpTableInfo if \p insn is an indirect jump</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="">  /// using a jump table, otherwise -1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="uncoveredLine">  virtual int getJumpTableIndex(const MachineInstr &MI) const { return -1; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">  /// Target-dependent implementation for IsCopyInstr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">  /// If the specific machine instruction is a instruction that moves/copies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">  /// value from one register to another register return destination and source</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">  /// registers as machine operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">  virtual std::optional<DestSourcePair></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">  isCopyInstrImpl(const MachineInstr &MI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">  /// Return true if the given terminator MI is not expected to spill. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">  /// sets the live interval as not spillable and adjusts phi node lowering to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="">  /// not introduce copies after the terminator. Use with care, these are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">  /// currently used for hardware loop intrinsics in very controlled situations,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">  /// created prior to registry allocation in loops that only have single phi</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">  /// users for the terminators value. They may run out of registers if not used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">  /// carefully.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="coveredLine">  virtual bool isUnspillableTerminatorImpl(const MachineInstr *MI) const {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="coveredLine">    return false;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">  /// If the specific machine instruction is a instruction that moves/copies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">  /// value from one register to another register return destination and source</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">  /// registers as machine operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">  /// For COPY-instruction the method naturally returns destination and source</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">  /// registers as machine operands, for all other instructions the method calls</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="">  /// target-dependent implementation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="coveredLine">  std::optional<DestSourcePair> isCopyInstr(const MachineInstr &MI) const {</td>
    <td>23</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="coveredLine">    if (MI.isCopy()) {</td>
    <td>23</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="uncoveredLine">      return DestSourcePair{MI.getOperand(0), MI.getOperand(1)};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="coveredLine">    return isCopyInstrImpl(MI);</td>
    <td>23</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="">  /// If the specific machine instruction is an instruction that adds an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">  /// immediate value and a physical register, and stores the result in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="">  /// the given physical register \c Reg, return a pair of the source</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">  /// register and the offset which has been added.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="uncoveredLine">  virtual std::optional<RegImmPair> isAddImmediate(const MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">                                                   Register Reg) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="">  /// Returns true if MI is an instruction that defines Reg to have a constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="">  /// value and the value is recorded in ImmVal. The ImmVal is a result that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">  /// should be interpreted as modulo size of Reg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="uncoveredLine">  virtual bool getConstValDefinedInReg(const MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">                                       const Register Reg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">                                       int64_t &ImmVal) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="">  /// Store the specified register of the given register class to the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="">  /// stack frame index. The store instruction is to be added to the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">  /// machine basic block before the specified machine instruction. If isKill</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">  /// is true, the register operand is the last use and must be marked kill. If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="">  /// \p SrcReg is being directly spilled as part of assigning a virtual</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="">  /// register, \p VReg is the register being assigned. This additional register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="">  /// argument is needed for certain targets when invoked from RegAllocFast to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">  /// map the spilled physical register to its virtual register. A null register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">  /// can be passed elsewhere.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="uncoveredLine">  virtual void storeRegToStackSlot(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">                                   MachineBasicBlock::iterator MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="">                                   Register SrcReg, bool isKill, int FrameIndex,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="">                                   const TargetRegisterClass *RC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">                                   const TargetRegisterInfo *TRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">                                   Register VReg) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="uncoveredLine">    llvm_unreachable("Target didn't implement "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="">                     "TargetInstrInfo::storeRegToStackSlot!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="">  /// Load the specified register of the given register class from the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="">  /// stack frame index. The load instruction is to be added to the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="">  /// machine basic block before the specified machine instruction. If \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="">  /// DestReg is being directly reloaded as part of assigning a virtual</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">  /// register, \p VReg is the register being assigned. This additional register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="">  /// argument is needed for certain targets when invoked from RegAllocFast to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">  /// map the loaded physical register to its virtual register. A null register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="">  /// can be passed elsewhere.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="uncoveredLine">  virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="">                                    MachineBasicBlock::iterator MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="">                                    Register DestReg, int FrameIndex,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="">                                    const TargetRegisterClass *RC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="">                                    const TargetRegisterInfo *TRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">                                    Register VReg) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="uncoveredLine">    llvm_unreachable("Target didn't implement "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="">                     "TargetInstrInfo::loadRegFromStackSlot!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="">  /// This function is called for all pseudo instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="">  /// that remain after register allocation. Many pseudo instructions are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="">  /// created to help register allocation. This is the place to convert them</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">  /// into real instructions. The target can edit MI in place, or it can insert</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="">  /// new instructions and erase MI. The function should return true if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="">  /// anything was changed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="uncoveredLine">  virtual bool expandPostRAPseudo(MachineInstr &MI) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">  /// Check whether the target can fold a load that feeds a subreg operand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="">  /// (or a subreg operand that feeds a store).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">  /// For example, X86 may want to return true if it can fold</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">  /// movl (%esp), %eax</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="">  /// subb, %al, ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="">  /// Into:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">  /// subb (%esp), ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">  /// Ideally, we'd like the target implementation of foldMemoryOperand() to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="">  /// reject subregs - but since this behavior used to be enforced in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">  /// target-independent code, moving this responsibility to the targets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="">  /// has the potential of causing nasty silent breakage in out-of-tree targets.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="uncoveredLine">  virtual bool isSubregFoldable() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="">  /// For a patchpoint, stackmap, or statepoint intrinsic, return the range of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">  /// operands which can't be folded into stack references. Operands outside</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">  /// of the range are most likely foldable but it is not guaranteed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="">  /// These instructions are unique in that stack references for some operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="">  /// have the same execution cost (e.g. none) as the unfolded register forms.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="">  /// The ranged return is guaranteed to include all operands which can't be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="">  /// folded at zero cost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">  virtual std::pair<unsigned, unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="">  getPatchpointUnfoldableRange(const MachineInstr &MI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="">  /// Attempt to fold a load or store of the specified stack</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">  /// slot into the specified machine instruction for the specified operand(s).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">  /// If this is possible, a new instruction is returned with the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">  /// operand folded, otherwise NULL is returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">  /// The new instruction is inserted before MI, and the client is responsible</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">  /// for removing the old instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="">  /// If VRM is passed, the assigned physregs can be inspected by target to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="">  /// decide on using an opcode (note that those assignments can still change).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">  MachineInstr *foldMemoryOperand(MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">                                  int FI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">                                  LiveIntervals *LIS = nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">                                  VirtRegMap *VRM = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">  /// Same as the previous version except it allows folding of any load and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="">  /// store from / to any address, not just from a specific stack slot.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="">  MachineInstr *foldMemoryOperand(MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="">                                  MachineInstr &LoadMI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="">                                  LiveIntervals *LIS = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">  /// This function defines the logic to lower COPY instruction to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">  /// target specific instruction(s).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">  void lowerCopy(MachineInstr *MI, const TargetRegisterInfo *TRI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="">  /// Return true when there is potentially a faster code sequence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">  /// for an instruction chain ending in \p Root. All potential patterns are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="">  /// returned in the \p Pattern vector. Pattern should be sorted in priority</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="">  /// order since the pattern evaluator stops checking as soon as it finds a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="">  /// faster sequence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="">  /// \param Root - Instruction that could be combined with one of its operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">  /// \param Patterns - Vector of possible combination patterns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">  getMachineCombinerPatterns(MachineInstr &Root,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="">                             SmallVectorImpl<MachineCombinerPattern> &Patterns,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">                             bool DoRegPressureReduce) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="">  /// Return true if target supports reassociation of instructions in machine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="">  /// combiner pass to reduce register pressure for a given BB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">  shouldReduceRegisterPressure(const MachineBasicBlock *MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="">                               const RegisterClassInfo *RegClassInfo) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">  /// Fix up the placeholder we may add in genAlternativeCodeSequence().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="">  virtual void</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="uncoveredLine">  finalizeInsInstrs(MachineInstr &Root, MachineCombinerPattern &P,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="uncoveredLine">                    SmallVectorImpl<MachineInstr *> &InsInstrs) const {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">  /// Return true when a code sequence can improve throughput. It</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">  /// should be called only for instructions in loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">  /// \param Pattern - combiner pattern</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">  virtual bool isThroughputPattern(MachineCombinerPattern Pattern) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">  /// Return true if the input \P Inst is part of a chain of dependent ops</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="">  /// that are suitable for reassociation, otherwise return false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">  /// If the instruction's operands must be commuted to have a previous</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="">  /// instruction of the same type define the first source operand, \P Commuted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">  /// will be set to true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">  bool isReassociationCandidate(const MachineInstr &Inst, bool &Commuted) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="">  /// Return true when \P Inst is both associative and commutative. If \P Invert</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="">  /// is true, then the inverse of \P Inst operation must be tested.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">  virtual bool isAssociativeAndCommutative(const MachineInstr &Inst,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">                                           bool Invert = false) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">  /// Return the inverse operation opcode if it exists for \P Opcode (e.g. add</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">  /// for sub and vice versa).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="uncoveredLine">  virtual std::optional<unsigned> getInverseOpcode(unsigned Opcode) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">  /// Return true when \P Opcode1 or its inversion is equal to \P Opcode2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="">  bool areOpcodesEqualOrInverse(unsigned Opcode1, unsigned Opcode2) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">  /// Return true when \P Inst has reassociable operands in the same \P MBB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">  virtual bool hasReassociableOperands(const MachineInstr &Inst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="">                                       const MachineBasicBlock *MBB) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">  /// Return true when \P Inst has reassociable sibling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">  virtual bool hasReassociableSibling(const MachineInstr &Inst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">                                      bool &Commuted) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">  /// When getMachineCombinerPatterns() finds patterns, this function generates</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="">  /// the instructions that could replace the original code sequence. The client</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">  /// has to decide whether the actual replacement is beneficial or not.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="">  /// \param Root - Instruction that could be combined with one of its operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="">  /// \param Pattern - Combination pattern for Root</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">  /// \param InsInstrs - Vector of new instructions that implement P</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">  /// \param DelInstrs - Old instructions, including Root, that could be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="">  /// replaced by InsInstr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">  /// \param InstIdxForVirtReg - map of virtual register to instruction in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">  /// InsInstr that defines it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">  virtual void genAlternativeCodeSequence(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="">      MachineInstr &Root, MachineCombinerPattern Pattern,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">      SmallVectorImpl<MachineInstr *> &InsInstrs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="">      SmallVectorImpl<MachineInstr *> &DelInstrs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="">      DenseMap<unsigned, unsigned> &InstIdxForVirtReg) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="">  /// When calculate the latency of the root instruction, accumulate the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">  /// latency of the sequence to the root latency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">  /// \param Root - Instruction that could be combined with one of its operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="uncoveredLine">  virtual bool accumulateInstrSeqToRootLatency(MachineInstr &Root) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">  /// Attempt to reassociate \P Root and \P Prev according to \P Pattern to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="">  /// reduce critical path length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">  void reassociateOps(MachineInstr &Root, MachineInstr &Prev,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">                      MachineCombinerPattern Pattern,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">                      SmallVectorImpl<MachineInstr *> &InsInstrs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">                      SmallVectorImpl<MachineInstr *> &DelInstrs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">                      DenseMap<unsigned, unsigned> &InstrIdxForVirtReg) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">  /// Reassociation of some instructions requires inverse operations (e.g.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">  /// (X + A) - Y => (X - Y) + A). This method returns a pair of new opcodes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">  /// (new root opcode, new prev opcode) that must be used to reassociate \P</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">  /// Root and \P Prev accoring to \P Pattern.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">  std::pair<unsigned, unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">  getReassociationOpcodes(MachineCombinerPattern Pattern,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">                          const MachineInstr &Root,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">                          const MachineInstr &Prev) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">  /// The limit on resource length extension we accept in MachineCombiner Pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="uncoveredLine">  virtual int getExtendResourceLenLimit() const { return 0; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="">  /// This is an architecture-specific helper function of reassociateOps.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="">  /// Set special operand attributes for new instructions after reassociation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="uncoveredLine">  virtual void setSpecialOperandAttr(MachineInstr &OldMI1, MachineInstr &OldMI2,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">                                     MachineInstr &NewMI1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="uncoveredLine">                                     MachineInstr &NewMI2) const {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="">  /// Return true when a target supports MachineCombiner.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">  virtual bool useMachineCombiner() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">  /// Return a strategy that MachineCombiner must use when creating traces.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="">  virtual MachineTraceStrategy getMachineCombinerTraceStrategy() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="">  /// Return true if the given SDNode can be copied during scheduling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">  /// even if it has glue.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="uncoveredLine">  virtual bool canCopyGluedNodeDuringSchedule(SDNode *N) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">  /// Target-dependent implementation for foldMemoryOperand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">  /// Target-independent code in foldMemoryOperand will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">  /// take care of adding a MachineMemOperand to the newly created instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">  /// The instruction and any auxiliary instructions necessary will be inserted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">  /// at InsertPt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">  virtual MachineInstr *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="uncoveredLine">  foldMemoryOperandImpl(MachineFunction &MF, MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="">                        ArrayRef<unsigned> Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">                        MachineBasicBlock::iterator InsertPt, int FrameIndex,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">                        LiveIntervals *LIS = nullptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">                        VirtRegMap *VRM = nullptr) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">  /// Target-dependent implementation for foldMemoryOperand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">  /// Target-independent code in foldMemoryOperand will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">  /// take care of adding a MachineMemOperand to the newly created instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="">  /// The instruction and any auxiliary instructions necessary will be inserted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">  /// at InsertPt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="uncoveredLine">  virtual MachineInstr *foldMemoryOperandImpl(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">      MachineFunction &MF, MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">      MachineBasicBlock::iterator InsertPt, MachineInstr &LoadMI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="">      LiveIntervals *LIS = nullptr) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">  /// Target-dependent implementation of getRegSequenceInputs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">  /// \returns true if it is possible to build the equivalent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">  /// REG_SEQUENCE inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">  /// \pre MI.isRegSequenceLike().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="">  /// \see TargetInstrInfo::getRegSequenceInputs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="uncoveredLine">  virtual bool getRegSequenceLikeInputs(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">      const MachineInstr &MI, unsigned DefIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="">      SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">  /// Target-dependent implementation of getExtractSubregInputs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">  /// \returns true if it is possible to build the equivalent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">  /// EXTRACT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">  /// \pre MI.isExtractSubregLike().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">  /// \see TargetInstrInfo::getExtractSubregInputs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="uncoveredLine">  virtual bool getExtractSubregLikeInputs(const MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">                                          unsigned DefIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">                                          RegSubRegPairAndIdx &InputReg) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">  /// Target-dependent implementation of getInsertSubregInputs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="">  /// \returns true if it is possible to build the equivalent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">  /// INSERT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="">  /// \pre MI.isInsertSubregLike().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="">  /// \see TargetInstrInfo::getInsertSubregInputs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">  getInsertSubregLikeInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">                            RegSubRegPair &BaseReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="">                            RegSubRegPairAndIdx &InsertedReg) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="">  /// unfoldMemoryOperand - Separate a single instruction which folded a load or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="">  /// a store or a load and a store into two or more instruction. If this is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="">  /// possible, returns true as well as the new instructions by reference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="uncoveredLine">  unfoldMemoryOperand(MachineFunction &MF, MachineInstr &MI, unsigned Reg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">                      bool UnfoldLoad, bool UnfoldStore,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="">                      SmallVectorImpl<MachineInstr *> &NewMIs) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="uncoveredLine">  virtual bool unfoldMemoryOperand(SelectionDAG &DAG, SDNode *N,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="">                                   SmallVectorImpl<SDNode *> &NewNodes) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">  /// Returns the opcode of the would be new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">  /// instruction after load / store are unfolded from an instruction of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">  /// specified opcode. It returns zero if the specified unfolding is not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="">  /// possible. If LoadRegIndex is non-null, it is filled in with the operand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="">  /// index of the operand which will hold the register holding the loaded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="">  /// value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="">  virtual unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="uncoveredLine">  getOpcodeAfterMemoryUnfold(unsigned Opc, bool UnfoldLoad, bool UnfoldStore,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="">                             unsigned *LoadRegIndex = nullptr) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="">  /// This is used by the pre-regalloc scheduler to determine if two loads are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="">  /// loading from the same base address. It should only return true if the base</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="">  /// pointers are the same and the only differences between the two addresses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">  /// are the offset. It also returns the offsets by reference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="coveredLine">  virtual bool areLoadsFromSameBasePtr(SDNode *Load1, SDNode *Load2,</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="">                                       int64_t &Offset1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">                                       int64_t &Offset2) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="coveredLine">    return false;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">  /// This is a used by the pre-regalloc scheduler to determine (in conjunction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">  /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">  /// On some targets if two loads are loading from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="">  /// addresses in the same cache line, it's better if they are scheduled</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="">  /// together. This function takes two integers that represent the load offsets</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="">  /// from the common base address. It returns true if it decides it's desirable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">  /// to schedule the two loads together. "NumLoads" is the number of loads that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="">  /// have already been scheduled after Load1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="uncoveredLine">  virtual bool shouldScheduleLoadsNear(SDNode *Load1, SDNode *Load2,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">                                       int64_t Offset1, int64_t Offset2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">                                       unsigned NumLoads) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="">  /// Get the base operand and byte offset of an instruction that reads/writes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">  /// memory. This is a convenience function for callers that are only prepared</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="">  /// to handle a single base operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="">  bool getMemOperandWithOffset(const MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="">                               const MachineOperand *&BaseOp, int64_t &Offset,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="">                               bool &OffsetIsScalable,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="">                               const TargetRegisterInfo *TRI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">  /// Get zero or more base operands and the byte offset of an instruction that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="">  /// reads/writes memory. Note that there may be zero base operands if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="">  /// instruction accesses a constant address.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="">  /// It returns false if MI does not read/write memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="">  /// It returns false if base operands and offset could not be determined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="">  /// It is not guaranteed to always recognize base operands and offsets in all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="">  /// cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="uncoveredLine">  virtual bool getMemOperandsWithOffsetWidth(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="">      const MachineInstr &MI, SmallVectorImpl<const MachineOperand *> &BaseOps,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="">      int64_t &Offset, bool &OffsetIsScalable, unsigned &Width,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="">      const TargetRegisterInfo *TRI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="">  /// Return true if the instruction contains a base register and offset. If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="">  /// true, the function also sets the operand position in the instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="">  /// for the base register and offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="uncoveredLine">  virtual bool getBaseAndOffsetPosition(const MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="">                                        unsigned &BasePos,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">                                        unsigned &OffsetPos) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">  /// Target dependent implementation to get the values constituting the address</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">  /// MachineInstr that is accessing memory. These values are returned as a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="">  /// struct ExtAddrMode which contains all relevant information to make up the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">  /// address.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="">  virtual std::optional<ExtAddrMode></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="uncoveredLine">  getAddrModeFromMemoryOp(const MachineInstr &MemI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="">                          const TargetRegisterInfo *TRI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="">  /// Returns true if MI's Def is NullValueReg, and the MI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">  /// does not change the Zero value. i.e. cases such as rax = shr rax, X where</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">  /// NullValueReg = rax. Note that if the NullValueReg is non-zero, this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="">  /// function can return true even if becomes zero. Specifically cases such as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="">  /// NullValueReg = shl NullValueReg, 63.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="uncoveredLine">  virtual bool preservesZeroValueInReg(const MachineInstr *MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="">                                       const Register NullValueReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="">                                       const TargetRegisterInfo *TRI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="">  /// If the instruction is an increment of a constant value, return the amount.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="uncoveredLine">  virtual bool getIncrementValue(const MachineInstr &MI, int &Value) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="">  /// Returns true if the two given memory operations should be scheduled</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="">  /// adjacent. Note that you have to add:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">  ///   DAG->addMutation(createLoadClusterDAGMutation(DAG->TII, DAG->TRI));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="">  /// or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="">  ///   DAG->addMutation(createStoreClusterDAGMutation(DAG->TII, DAG->TRI));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="">  /// to TargetPassConfig::createMachineScheduler() to have an effect.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">  /// \p BaseOps1 and \p BaseOps2 are memory operands of two memory operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">  /// \p NumLoads is the number of loads that will be in the cluster if this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="">  /// hook returns true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="">  /// \p NumBytes is the number of bytes that will be loaded from all the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">  /// clustered loads if this hook returns true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="uncoveredLine">  virtual bool shouldClusterMemOps(ArrayRef<const MachineOperand *> BaseOps1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="">                                   ArrayRef<const MachineOperand *> BaseOps2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="">                                   unsigned NumLoads, unsigned NumBytes) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">    llvm_unreachable("target did not implement shouldClusterMemOps()");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="">  /// Reverses the branch condition of the specified condition list,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="">  /// returning false on success and true if it cannot be reversed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="uncoveredLine">  reverseBranchCondition(SmallVectorImpl<MachineOperand> &Cond) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="">  /// Insert a noop into the instruction stream at the specified point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="">  virtual void insertNoop(MachineBasicBlock &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="">                          MachineBasicBlock::iterator MI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="">  /// Insert noops into the instruction stream at the specified point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="">  virtual void insertNoops(MachineBasicBlock &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="">                           MachineBasicBlock::iterator MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="">                           unsigned Quantity) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">  /// Return the noop instruction to use for a noop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="">  virtual MCInst getNop() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="">  /// Return true for post-incremented instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">  virtual bool isPostIncrement(const MachineInstr &MI) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="">  /// Returns true if the instruction is already predicated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="uncoveredLine">  virtual bool isPredicated(const MachineInstr &MI) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="">  /// Assumes the instruction is already predicated and returns true if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="">  /// instruction can be predicated again.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="uncoveredLine">  virtual bool canPredicatePredicatedInstr(const MachineInstr &MI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="uncoveredLine">    assert(isPredicated(MI) && "Instruction is not predicated");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">  // Returns a MIRPrinter comment for this machine operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="">  virtual std::string</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="">  createMIROperandComment(const MachineInstr &MI, const MachineOperand &Op,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="">                          unsigned OpIdx, const TargetRegisterInfo *TRI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="">  /// Returns true if the instruction is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="">  /// terminator instruction that has not been predicated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="">  bool isUnpredicatedTerminator(const MachineInstr &MI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">  /// Returns true if MI is an unconditional tail call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="uncoveredLine">  virtual bool isUnconditionalTailCall(const MachineInstr &MI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="">  /// Returns true if the tail call can be made conditional on BranchCond.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="uncoveredLine">  virtual bool canMakeTailCallConditional(SmallVectorImpl<MachineOperand> &Cond,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">                                          const MachineInstr &TailCall) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="">  /// Replace the conditional branch in MBB with a conditional tail call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="uncoveredLine">  virtual void replaceBranchWithTailCall(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">                                         SmallVectorImpl<MachineOperand> &Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="">                                         const MachineInstr &TailCall) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="uncoveredLine">    llvm_unreachable("Target didn't implement replaceBranchWithTailCall!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="">  /// Convert the instruction into a predicated instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="">  /// It returns true if the operation was successful.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="">  virtual bool PredicateInstruction(MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="">                                    ArrayRef<MachineOperand> Pred) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">  /// Returns true if the first specified predicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="">  /// subsumes the second, e.g. GE subsumes GT.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">  virtual bool SubsumesPredicate(ArrayRef<MachineOperand> Pred1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="">                                 ArrayRef<MachineOperand> Pred2) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="">  /// If the specified instruction defines any predicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="">  /// or condition code register(s) used for predication, returns true as well</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="">  /// as the definition predicate(s) by reference.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="">  /// SkipDead should be set to false at any point that dead</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="">  /// predicate instructions should be considered as being defined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="">  /// A dead predicate instruction is one that is guaranteed to be removed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="">  /// after a call to PredicateInstruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="uncoveredLine">  virtual bool ClobbersPredicate(MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="">                                 std::vector<MachineOperand> &Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="">                                 bool SkipDead) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">  /// Return true if the specified instruction can be predicated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="">  /// By default, this returns true for every instruction with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="">  /// PredicateOperand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="uncoveredLine">  virtual bool isPredicable(const MachineInstr &MI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="uncoveredLine">    return MI.getDesc().isPredicable();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="">  /// Return true if it's safe to move a machine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="">  /// instruction that defines the specified register class.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="uncoveredLine">  virtual bool isSafeToMoveRegClassDefs(const TargetRegisterClass *RC) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="">  /// Test if the given instruction should be considered a scheduling boundary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="">  /// This primarily includes labels and terminators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="">  virtual bool isSchedulingBoundary(const MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="">                                    const MachineBasicBlock *MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="">                                    const MachineFunction &MF) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">  /// Measure the specified inline asm to determine an approximation of its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="">  /// length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="">  virtual unsigned getInlineAsmLength(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="">    const char *Str, const MCAsmInfo &MAI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="">    const TargetSubtargetInfo *STI = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="">  /// Allocate and return a hazard recognizer to use for this target when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="">  /// scheduling the machine instructions before register allocation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="">  virtual ScheduleHazardRecognizer *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="">  CreateTargetHazardRecognizer(const TargetSubtargetInfo *STI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="">                               const ScheduleDAG *DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="">  /// Allocate and return a hazard recognizer to use for this target when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="">  /// scheduling the machine instructions before register allocation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="">  virtual ScheduleHazardRecognizer *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="">  CreateTargetMIHazardRecognizer(const InstrItineraryData *,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="">                                 const ScheduleDAGMI *DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="">  /// Allocate and return a hazard recognizer to use for this target when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="">  /// scheduling the machine instructions after register allocation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="">  virtual ScheduleHazardRecognizer *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="">  CreateTargetPostRAHazardRecognizer(const InstrItineraryData *,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="">                                     const ScheduleDAG *DAG) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="">  /// Allocate and return a hazard recognizer to use for by non-scheduling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="">  /// passes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="">  virtual ScheduleHazardRecognizer *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="uncoveredLine">  CreateTargetPostRAHazardRecognizer(const MachineFunction &MF) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="">  /// Provide a global flag for disabling the PreRA hazard recognizer that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="">  /// targets may choose to honor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="">  bool usePreRAHazardRecognizer() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="">  /// For a comparison instruction, return the source registers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="">  /// in SrcReg and SrcReg2 if having two register operands, and the value it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="">  /// compares against in CmpValue. Return true if the comparison instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="">  /// can be analyzed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="uncoveredLine">  virtual bool analyzeCompare(const MachineInstr &MI, Register &SrcReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="">                              Register &SrcReg2, int64_t &Mask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="">                              int64_t &Value) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="">  /// See if the comparison instruction can be converted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="">  /// into something more efficient. E.g., on ARM most instructions can set the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="">  /// flags register, obviating the need for a separate CMP.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="uncoveredLine">  virtual bool optimizeCompareInstr(MachineInstr &CmpInstr, Register SrcReg,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="">                                    Register SrcReg2, int64_t Mask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="">                                    int64_t Value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="">                                    const MachineRegisterInfo *MRI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="uncoveredLine">  virtual bool optimizeCondBranch(MachineInstr &MI) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="">  /// Try to remove the load by folding it to a register operand at the use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="">  /// We fold the load instructions if and only if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="">  /// def and use are in the same BB. We only look at one load and see</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="">  /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="">  /// defined by the load we are trying to fold. DefMI returns the machine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="">  /// instruction that defines FoldAsLoadDefReg, and the function returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="">  /// the machine instruction generated due to folding.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="uncoveredLine">  virtual MachineInstr *optimizeLoadInstr(MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="">                                          const MachineRegisterInfo *MRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="">                                          Register &FoldAsLoadDefReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="">                                          MachineInstr *&DefMI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="">  /// 'Reg' is known to be defined by a move immediate instruction,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="">  /// try to fold the immediate into the use instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="">  /// If MRI->hasOneNonDBGUse(Reg) is true, and this function returns true,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="">  /// then the caller may assume that DefMI has been erased from its parent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="">  /// block. The caller may assume that it will not be erased by this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="">  /// function otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="uncoveredLine">  virtual bool FoldImmediate(MachineInstr &UseMI, MachineInstr &DefMI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="">                             Register Reg, MachineRegisterInfo *MRI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="">  /// Return the number of u-operations the given machine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="">  /// instruction will be decoded to on the target cpu. The itinerary's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="">  /// IssueWidth is the number of microops that can be dispatched each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="">  /// cycle. An instruction with zero microops takes no dispatch resources.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="">  virtual unsigned getNumMicroOps(const InstrItineraryData *ItinData,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="">                                  const MachineInstr &MI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="">  /// Return true for pseudo instructions that don't consume any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="">  /// machine resources in their current form. These are common cases that the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="">  /// scheduler should consider free, rather than conservatively handling them</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="">  /// as instructions with no itinerary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="">  bool isZeroCost(unsigned Opcode) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="">    return Opcode <= TargetOpcode::COPY;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="">  virtual int getOperandLatency(const InstrItineraryData *ItinData,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="">                                SDNode *DefNode, unsigned DefIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="">                                SDNode *UseNode, unsigned UseIdx) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="">  /// Compute and return the use operand latency of a given pair of def and use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="">  /// In most cases, the static scheduling itinerary was enough to determine the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="">  /// operand latency. But it may not be possible for instructions with variable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="">  /// number of defs / uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="">  /// This is a raw interface to the itinerary that may be directly overridden</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="">  /// by a target. Use computeOperandLatency to get the best estimate of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="">  /// latency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="">  virtual int getOperandLatency(const InstrItineraryData *ItinData,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="">                                const MachineInstr &DefMI, unsigned DefIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="">                                const MachineInstr &UseMI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="">                                unsigned UseIdx) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="">  /// Compute the instruction latency of a given instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="">  /// If the instruction has higher cost when predicated, it's returned via</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="">  /// PredCost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="">  virtual unsigned getInstrLatency(const InstrItineraryData *ItinData,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="">                                   const MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">                                   unsigned *PredCost = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="">  virtual unsigned getPredicationCost(const MachineInstr &MI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="">  virtual int getInstrLatency(const InstrItineraryData *ItinData,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="">                              SDNode *Node) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="">  /// Return the default expected latency for a def based on its opcode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="">  unsigned defaultDefLatency(const MCSchedModel &SchedModel,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="">                             const MachineInstr &DefMI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="">  /// Return true if this opcode has high latency to its result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="uncoveredLine">  virtual bool isHighLatencyDef(int opc) const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="">  /// Compute operand latency between a def of 'Reg'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="">  /// and a use in the current loop. Return true if the target considered</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="">  /// it 'high'. This is used by optimization passes such as machine LICM to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="">  /// determine whether it makes sense to hoist an instruction out even in a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="">  /// high register pressure situation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="uncoveredLine">  virtual bool hasHighOperandLatency(const TargetSchedModel &SchedModel,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="">                                     const MachineRegisterInfo *MRI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="">                                     const MachineInstr &DefMI, unsigned DefIdx,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="">                                     const MachineInstr &UseMI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="">                                     unsigned UseIdx) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="">  /// Compute operand latency of a def of 'Reg'. Return true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="">  /// if the target considered it 'low'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="">  virtual bool hasLowDefLatency(const TargetSchedModel &SchedModel,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="">                                const MachineInstr &DefMI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="">                                unsigned DefIdx) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="">  /// Perform target-specific instruction verification.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="uncoveredLine">  virtual bool verifyInstruction(const MachineInstr &MI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="">                                 StringRef &ErrInfo) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="">  /// Return the current execution domain and bit mask of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="">  /// possible domains for instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="">  /// Some micro-architectures have multiple execution domains, and multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="">  /// opcodes that perform the same operation in different domains.  For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="">  /// example, the x86 architecture provides the por, orps, and orpd</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="">  /// instructions that all do the same thing.  There is a latency penalty if a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="">  /// register is written in one domain and read in another.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="">  /// This function returns a pair (domain, mask) containing the execution</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="">  /// domain of MI, and a bit mask of possible domains.  The setExecutionDomain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="">  /// function can be used to change the opcode to one of the domains in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="">  /// bit mask.  Instructions whose execution domain can't be changed should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="">  /// return a 0 mask.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="">  /// The execution domain numbers don't have any special meaning except domain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="">  /// 0 is used for instructions that are not associated with any interesting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="">  /// execution domain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="">  virtual std::pair<uint16_t, uint16_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="uncoveredLine">  getExecutionDomain(const MachineInstr &MI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="uncoveredLine">    return std::make_pair(0, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="">  /// Change the opcode of MI to execute in Domain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="">  /// The bit (1 << Domain) must be set in the mask returned from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="">  /// getExecutionDomain(MI).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="uncoveredLine">  virtual void setExecutionDomain(MachineInstr &MI, unsigned Domain) const {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="">  /// Returns the preferred minimum clearance</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="">  /// before an instruction with an unwanted partial register update.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="">  /// Some instructions only write part of a register, and implicitly need to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="">  /// read the other parts of the register.  This may cause unwanted stalls</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="">  /// preventing otherwise unrelated instructions from executing in parallel in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="">  /// an out-of-order CPU.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="">  /// For example, the x86 instruction cvtsi2ss writes its result to bits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="">  /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="">  /// the instruction needs to wait for the old value of the register to become</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="">  /// available:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="">  ///   addps %xmm1, %xmm0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="">  ///   movaps %xmm0, (%rax)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="">  ///   cvtsi2ss %rbx, %xmm0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="">  /// In the code above, the cvtsi2ss instruction needs to wait for the addps</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">  /// instruction before it can issue, even though the high bits of %xmm0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">  /// probably aren't needed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="">  /// This hook returns the preferred clearance before MI, measured in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="">  /// instructions.  Other defs of MI's operand OpNum are avoided in the last N</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="">  /// instructions before MI.  It should only return a positive value for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="">  /// unwanted dependencies.  If the old bits of the defined register have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="">  /// useful values, or if MI is determined to otherwise read the dependency,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="">  /// the hook should return 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="">  /// The unwanted dependency may be handled by:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="">  /// 1. Allocating the same register for an MI def and use.  That makes the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="">  ///    unwanted dependency identical to a required dependency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="">  /// 2. Allocating a register for the def that has no defs in the previous N</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="">  ///    instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="">  /// 3. Calling breakPartialRegDependency() with the same arguments.  This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="">  ///    allows the target to insert a dependency breaking instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="">  virtual unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="uncoveredLine">  getPartialRegUpdateClearance(const MachineInstr &MI, unsigned OpNum,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="">                               const TargetRegisterInfo *TRI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="">    // The default implementation returns 0 for no partial register dependency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="">  /// Return the minimum clearance before an instruction that reads an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="">  /// unused register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="">  /// For example, AVX instructions may copy part of a register operand into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="">  /// the unused high bits of the destination register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="">  /// vcvtsi2sdq %rax, undef %xmm0, %xmm14</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="">  /// In the code above, vcvtsi2sdq copies %xmm0[127:64] into %xmm14 creating a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="">  /// false dependence on any previous write to %xmm0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="">  /// This hook works similarly to getPartialRegUpdateClearance, except that it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="">  /// does not take an operand index. Instead sets \p OpNum to the index of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="">  /// unused register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="uncoveredLine">  virtual unsigned getUndefRegClearance(const MachineInstr &MI, unsigned OpNum,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="">                                        const TargetRegisterInfo *TRI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="">    // The default implementation returns 0 for no undef register dependency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="">  /// Insert a dependency-breaking instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="">  /// before MI to eliminate an unwanted dependency on OpNum.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="">  /// If it wasn't possible to avoid a def in the last N instructions before MI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="">  /// (see getPartialRegUpdateClearance), this hook will be called to break the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="">  /// unwanted dependency.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="">  /// On x86, an xorps instruction can be used as a dependency breaker:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="">  ///   addps %xmm1, %xmm0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="">  ///   movaps %xmm0, (%rax)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="">  ///   xorps %xmm0, %xmm0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="">  ///   cvtsi2ss %rbx, %xmm0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="">  /// An <imp-kill> operand should be added to MI if an instruction was</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="">  /// inserted.  This ties the instructions together in the post-ra scheduler.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="uncoveredLine">  virtual void breakPartialRegDependency(MachineInstr &MI, unsigned OpNum,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="uncoveredLine">                                         const TargetRegisterInfo *TRI) const {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="">  /// Create machine specific model for scheduling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="">  virtual DFAPacketizer *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="uncoveredLine">  CreateTargetScheduleState(const TargetSubtargetInfo &) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">  /// Sometimes, it is possible for the target</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="">  /// to tell, even without aliasing information, that two MIs access different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="">  /// memory addresses. This function returns true if two MIs access different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="">  /// memory addresses and false otherwise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="">  /// Assumes any physical registers used to compute addresses have the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="">  /// value for both instructions. (This is the most useful assumption for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="">  /// post-RA scheduling.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="">  /// See also MachineInstr::mayAlias, which is implemented on top of this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="">  /// function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="">  virtual bool</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="uncoveredLine">  areMemAccessesTriviallyDisjoint(const MachineInstr &MIa,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="">                                  const MachineInstr &MIb) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="uncoveredLine">    assert(MIa.mayLoadOrStore() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="">           "MIa must load from or modify a memory location");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="uncoveredLine">    assert(MIb.mayLoadOrStore() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="">           "MIb must load from or modify a memory location");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="">  /// Return the value to use for the MachineCSE's LookAheadLimit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="">  /// which is a heuristic used for CSE'ing phys reg defs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="uncoveredLine">  virtual unsigned getMachineCSELookAheadLimit() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="">    // The default lookahead is small to prevent unprofitable quadratic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="">    // behavior.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="uncoveredLine">    return 5;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="">  /// Return the maximal number of alias checks on memory operands. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="">  /// instructions with more than one memory operands, the alias check on a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="">  /// single MachineInstr pair has quadratic overhead and results in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="">  /// unacceptable performance in the worst case. The limit here is to clamp</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="">  /// that maximal checks performed. Usually, that's the product of memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="">  /// operand numbers from that pair of MachineInstr to be checked. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">  /// instance, with two MachineInstrs with 4 and 5 memory operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="">  /// correspondingly, a total of 20 checks are required. With this limit set to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="">  /// 16, their alias check is skipped. We choose to limit the product instead</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="">  /// of the individual instruction as targets may have special MachineInstrs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="">  /// with a considerably high number of memory operands, such as `ldm` in ARM.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="">  /// Setting this limit per MachineInstr would result in either too high</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="">  /// overhead or too rigid restriction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="uncoveredLine">  virtual unsigned getMemOperandAACheckLimit() const { return 16; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="">  /// Return an array that contains the ids of the target indices (used for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="">  /// TargetIndex machine operand) and their names.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="">  /// MIR Serialization is able to serialize only the target indices that are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="">  /// defined by this method.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="">  virtual ArrayRef<std::pair<int, const char *>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="uncoveredLine">  getSerializableTargetIndices() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="">  /// Decompose the machine operand's target flags into two values - the direct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="">  /// target flag value and any of bit flags that are applied.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="">  virtual std::pair<unsigned, unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="uncoveredLine">  decomposeMachineOperandsTargetFlags(unsigned /*TF*/) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="uncoveredLine">    return std::make_pair(0u, 0u);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="">  /// Return an array that contains the direct target flag values and their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="">  /// names.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="">  /// MIR Serialization is able to serialize only the target flags that are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="">  /// defined by this method.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="">  virtual ArrayRef<std::pair<unsigned, const char *>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="uncoveredLine">  getSerializableDirectMachineOperandTargetFlags() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="">  /// Return an array that contains the bitmask target flag values and their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="">  /// names.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="">  /// MIR Serialization is able to serialize only the target flags that are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="">  /// defined by this method.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="">  virtual ArrayRef<std::pair<unsigned, const char *>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="uncoveredLine">  getSerializableBitmaskMachineOperandTargetFlags() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="">  /// Return an array that contains the MMO target flag values and their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="">  /// names.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="">  /// MIR Serialization is able to serialize only the MMO target flags that are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="">  /// defined by this method.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="">  virtual ArrayRef<std::pair<MachineMemOperand::Flags, const char *>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="uncoveredLine">  getSerializableMachineMemOperandTargetFlags() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="uncoveredLine">    return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="">  /// Determines whether \p Inst is a tail call instruction. Override this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="">  /// method on targets that do not properly set MCID::Return and MCID::Call on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="">  /// tail call instructions."</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="uncoveredLine">  virtual bool isTailCall(const MachineInstr &Inst) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="uncoveredLine">    return Inst.isReturn() && Inst.isCall();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">  /// True if the instruction is bound to the top of its basic block and no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">  /// other instructions shall be inserted before it. This can be implemented</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="">  /// to prevent register allocator to insert spills before such instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="uncoveredLine">  virtual bool isBasicBlockPrologue(const MachineInstr &MI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="">  /// During PHI eleimination lets target to make necessary checks and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="">  /// insert the copy to the PHI destination register in a target specific</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="">  /// manner.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="uncoveredLine">  virtual MachineInstr *createPHIDestinationCopy(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="">      MachineBasicBlock &MBB, MachineBasicBlock::iterator InsPt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="">      const DebugLoc &DL, Register Src, Register Dst) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="uncoveredLine">    return BuildMI(MBB, InsPt, DL, get(TargetOpcode::COPY), Dst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="uncoveredLine">        .addReg(Src);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="">  /// During PHI eleimination lets target to make necessary checks and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="">  /// insert the copy to the PHI destination register in a target specific</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="">  /// manner.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="uncoveredLine">  virtual MachineInstr *createPHISourceCopy(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="">                                            MachineBasicBlock::iterator InsPt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="">                                            const DebugLoc &DL, Register Src,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="">                                            unsigned SrcSubReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="">                                            Register Dst) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="uncoveredLine">    return BuildMI(MBB, InsPt, DL, get(TargetOpcode::COPY), Dst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="uncoveredLine">        .addReg(Src, 0, SrcSubReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="">  /// Returns a \p outliner::OutlinedFunction struct containing target-specific</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="">  /// information for a set of outlining candidates. Returns std::nullopt if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">  /// candidates are not suitable for outlining.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="uncoveredLine">  virtual std::optional<outliner::OutlinedFunction> getOutliningCandidateInfo(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="">      std::vector<outliner::Candidate> &RepeatedSequenceLocs) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="uncoveredLine">    llvm_unreachable(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="">        "Target didn't implement TargetInstrInfo::getOutliningCandidateInfo!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="">  /// Optional target hook to create the LLVM IR attributes for the outlined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">  /// function. If overridden, the overriding function must call the default</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="">  /// implementation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="">  virtual void mergeOutliningCandidateAttributes(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="">      Function &F, std::vector<outliner::Candidate> &Candidates) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">  /// Target-dependent implementation for getOutliningTypeImpl.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="">  virtual outliner::InstrType</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="uncoveredLine">  getOutliningTypeImpl(MachineBasicBlock::iterator &MIT, unsigned Flags) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="uncoveredLine">    llvm_unreachable(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="">        "Target didn't implement TargetInstrInfo::getOutliningTypeImpl!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="">  /// Returns how or if \p MIT should be outlined. \p Flags is the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="">  /// target-specific information returned by isMBBSafeToOutlineFrom.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="">  outliner::InstrType</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="">  getOutliningType(MachineBasicBlock::iterator &MIT, unsigned Flags) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="">  /// Optional target hook that returns true if \p MBB is safe to outline from,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="">  /// and returns any target-specific information in \p Flags.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">  virtual bool isMBBSafeToOutlineFrom(MachineBasicBlock &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="">                                      unsigned &Flags) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="">  /// Optional target hook which partitions \p MBB into outlinable ranges for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="">  /// instruction mapping purposes. Each range is defined by two iterators:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="">  /// [start, end).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="">  /// Ranges are expected to be ordered top-down. That is, ranges closer to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="">  /// top of the block should come before ranges closer to the end of the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="">  /// Ranges cannot overlap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="">  /// If an entire block is mappable, then its range is [MBB.begin(), MBB.end())</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="">  /// All instructions not present in an outlinable range are considered</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="">  /// illegal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="">  virtual SmallVector<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="">      std::pair<MachineBasicBlock::iterator, MachineBasicBlock::iterator>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="uncoveredLine">  getOutlinableRanges(MachineBasicBlock &MBB, unsigned &Flags) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="uncoveredLine">    return {std::make_pair(MBB.begin(), MBB.end())};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="">  /// Insert a custom frame for outlined functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="uncoveredLine">  virtual void buildOutlinedFrame(MachineBasicBlock &MBB, MachineFunction &MF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="">                                  const outliner::OutlinedFunction &OF) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="uncoveredLine">    llvm_unreachable(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="">        "Target didn't implement TargetInstrInfo::buildOutlinedFrame!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="">  /// Insert a call to an outlined function into the program.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="">  /// Returns an iterator to the spot where we inserted the call. This must be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="">  /// implemented by the target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="">  virtual MachineBasicBlock::iterator</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="uncoveredLine">  insertOutlinedCall(Module &M, MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="">                     MachineBasicBlock::iterator &It, MachineFunction &MF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="">                     outliner::Candidate &C) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="uncoveredLine">    llvm_unreachable(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">        "Target didn't implement TargetInstrInfo::insertOutlinedCall!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="">  /// Return true if the function can safely be outlined from.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="">  /// A function \p MF is considered safe for outlining if an outlined function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="">  /// produced from instructions in F will produce a program which produces the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="">  /// same output for any set of given inputs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">  virtual bool isFunctionSafeToOutlineFrom(MachineFunction &MF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="">                                           bool OutlineFromLinkOnceODRs) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="uncoveredLine">    llvm_unreachable("Target didn't implement "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="">                     "TargetInstrInfo::isFunctionSafeToOutlineFrom!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="">  /// Return true if the function should be outlined from by default.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="uncoveredLine">  virtual bool shouldOutlineFromFunctionByDefault(MachineFunction &MF) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="">  /// Produce the expression describing the \p MI loading a value into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="">  /// the physical register \p Reg. This hook should only be used with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="">  /// \p MIs belonging to VReg-less functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="">  virtual std::optional<ParamLoadedValue></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="">  describeLoadedValue(const MachineInstr &MI, Register Reg) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="">  /// Given the generic extension instruction \p ExtMI, returns true if this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="">  /// extension is a likely candidate for being folded into an another</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="">  /// instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="uncoveredLine">  virtual bool isExtendLikelyToBeFolded(MachineInstr &ExtMI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="">                                        MachineRegisterInfo &MRI) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="">  /// Return MIR formatter to format/parse MIR operands.  Target can override</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="">  /// this virtual function and return target specific MIR formatter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="uncoveredLine">  virtual const MIRFormatter *getMIRFormatter() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="uncoveredLine">    if (!Formatter.get())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="uncoveredLine">      Formatter = std::make_unique<MIRFormatter>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="uncoveredLine">    return Formatter.get();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="">  /// Returns the target-specific default value for tail duplication.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="">  /// This value will be used if the tail-dup-placement-threshold argument is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="">  /// not provided.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="uncoveredLine">  virtual unsigned getTailDuplicateSize(CodeGenOpt::Level OptLevel) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="uncoveredLine">    return OptLevel >= CodeGenOpt::Aggressive ? 4 : 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="">  /// Returns the callee operand from the given \p MI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="uncoveredLine">  virtual const MachineOperand &getCalleeOperand(const MachineInstr &MI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="uncoveredLine">    return MI.getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="">  /// Return the uniformity behavior of the given instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="">  virtual InstructionUniformity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="uncoveredLine">  getInstructionUniformity(const MachineInstr &MI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="uncoveredLine">    return InstructionUniformity::Default;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="">  /// Returns true if the given \p MI defines a TargetIndex operand that can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="">  /// tracked by their offset, can have values, and can have debug info</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="">  /// associated with it. If so, sets \p Index and \p Offset of the target index</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="">  /// operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="coveredLine">  virtual bool isExplicitTargetIndexDef(const MachineInstr &MI, int &Index,</td>
    <td>23</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="">                                        int64_t &Offset) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="coveredLine">    return false;</td>
    <td>23</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="">  // Get the call frame size just before MI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="">  unsigned getCallFrameSizeAt(MachineInstr &MI) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="">  mutable std::unique_ptr<MIRFormatter> Formatter;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="">  unsigned CallFrameSetupOpcode, CallFrameDestroyOpcode;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="">  unsigned CatchRetOpcode;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="">  unsigned ReturnOpcode;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="">/// Provide DenseMapInfo for TargetInstrInfo::RegSubRegPair.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="">template <> struct DenseMapInfo<TargetInstrInfo::RegSubRegPair> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="">  using RegInfo = DenseMapInfo<unsigned>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="">  static inline TargetInstrInfo::RegSubRegPair getEmptyKey() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="">    return TargetInstrInfo::RegSubRegPair(RegInfo::getEmptyKey(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="">                                          RegInfo::getEmptyKey());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="">  static inline TargetInstrInfo::RegSubRegPair getTombstoneKey() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="">    return TargetInstrInfo::RegSubRegPair(RegInfo::getTombstoneKey(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="">                                          RegInfo::getTombstoneKey());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="">  /// Reuse getHashValue implementation from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="">  /// std::pair<unsigned, unsigned>.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="">  static unsigned getHashValue(const TargetInstrInfo::RegSubRegPair &Val) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="">    std::pair<unsigned, unsigned> PairVal = std::make_pair(Val.Reg, Val.SubReg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="">    return DenseMapInfo<std::pair<unsigned, unsigned>>::getHashValue(PairVal);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="">  static bool isEqual(const TargetInstrInfo::RegSubRegPair &LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="">                      const TargetInstrInfo::RegSubRegPair &RHS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="">    return RegInfo::isEqual(LHS.Reg, RHS.Reg) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="">           RegInfo::isEqual(LHS.SubReg, RHS.SubReg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="">#endif // LLVM_CODEGEN_TARGETINSTRINFO_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo23getCallFrameSetupOpcodeEv</td>
    <td class="numberOfCalls">84</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo25getCallFrameDestroyOpcodeEv</td>
    <td class="numberOfCalls">114</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo12isFrameInstrERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">82</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo12isFrameSetupERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo12getFrameSizeERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo17getFrameTotalSizeERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo23isUnspillableTerminatorEPKNS_12MachineInstrE</td>
    <td class="numberOfCalls">32</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14DestSourcePairC2ERKNS_14MachineOperandES3_</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10RegImmPairC2ENS_8RegisterEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15TargetInstrInfoC2Ejjjj</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo14isIgnorableUseERKNS_14MachineOperandE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo33isReallyTriviallyReMaterializableERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo21isCoalescableExtInstrERKNS_12MachineInstrERNS_8RegisterES5_Rj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo19isLoadFromStackSlotERKNS_12MachineInstrERi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo19isLoadFromStackSlotERKNS_12MachineInstrERiRj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo25isLoadFromStackSlotPostFEERKNS_12MachineInstrERi</td>
    <td class="numberOfCalls">55</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo18isStoreToStackSlotERKNS_12MachineInstrERi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo18isStoreToStackSlotERKNS_12MachineInstrERiRj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo24isStoreToStackSlotPostFEERKNS_12MachineInstrERi</td>
    <td class="numberOfCalls">63</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo15isStackSlotCopyERKNS_12MachineInstrERiS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo18getInstSizeInBytesERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo16isAsCheapAsAMoveERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo10shouldSinkERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo11shouldHoistERKNS_12MachineInstrEPKNS_11MachineLoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo21convertToThreeAddressERNS_12MachineInstrEPNS_13LiveVariablesEPNS_13LiveIntervalsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo20hasCommutePreferenceERNS_12MachineInstrERb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo21isBranchOffsetInRangeEjl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo18getBranchDestBlockERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo20insertIndirectBranchERNS_17MachineBasicBlockES2_S2_RKNS_8DebugLocElPNS_12RegScavengerE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo13analyzeBranchERNS_17MachineBasicBlockERPS1_S4_RNS_15SmallVectorImplINS_14MachineOperandEEEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo22analyzeBranchPredicateERNS_17MachineBasicBlockERNS0_22MachineBranchPredicateEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo12removeBranchERNS_17MachineBasicBlockEPi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo12insertBranchERNS_17MachineBasicBlockEPS1_S3_NS_8ArrayRefINS_14MachineOperandEEERKNS_8DebugLocEPi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo24analyzeLoopForPipeliningEPNS_17MachineBasicBlockE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo11analyzeLoopERNS_11MachineLoopERPNS_12MachineInstrES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo15reduceLoopCountERNS_17MachineBasicBlockES2_PNS_12MachineInstrERS3_RNS_15SmallVectorImplINS_14MachineOperandEEERNS6_IS4_EEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo19isLegalToSplitMBBAtERNS_17MachineBasicBlockENS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo19isProfitableToIfCvtERNS_17MachineBasicBlockEjjNS_17BranchProbabilityE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo19isProfitableToIfCvtERNS_17MachineBasicBlockEjjS2_jjNS_17BranchProbabilityE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo25isProfitableToDupForIfCvtERNS_17MachineBasicBlockEjNS_17BranchProbabilityE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo32extraSizeToPredicateInstructionsERKNS_15MachineFunctionEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo25predictBranchSizeForIfCvtERNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo25isProfitableToUnpredicateERNS_17MachineBasicBlockES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo15canInsertSelectERKNS_17MachineBasicBlockENS_8ArrayRefINS_14MachineOperandEEENS_8RegisterES7_S7_RiS8_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo12insertSelectERNS_17MachineBasicBlockENS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEERKNS_8DebugLocENS_8RegisterENS_8ArrayRefINS_14MachineOperandEEES9_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo13analyzeSelectERKNS_12MachineInstrERNS_15SmallVectorImplINS_14MachineOperandEEERjS8_Rb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo14optimizeSelectERNS_12MachineInstrERNS_15SmallPtrSetImplIPS1_EEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo11copyPhysRegERNS_17MachineBasicBlockENS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEERKNS_8DebugLocENS_10MCRegisterES9_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo27isPCRelRegisterOperandLegalERKNS_14MachineOperandE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo17getJumpTableIndexERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo15isCopyInstrImplERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo27isUnspillableTerminatorImplEPKNS_12MachineInstrE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo11isCopyInstrERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">23</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo14isAddImmediateERKNS_12MachineInstrENS_8RegisterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo23getConstValDefinedInRegERKNS_12MachineInstrENS_8RegisterERl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo19storeRegToStackSlotERNS_17MachineBasicBlockENS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEENS_8RegisterEbiPKNS_19TargetRegisterClassEPKNS_18TargetRegisterInfoES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo20loadRegFromStackSlotERNS_17MachineBasicBlockENS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEENS_8RegisterEiPKNS_19TargetRegisterClassEPKNS_18TargetRegisterInfoES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo18expandPostRAPseudoERNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo16isSubregFoldableEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo28shouldReduceRegisterPressureEPKNS_17MachineBasicBlockEPKNS_17RegisterClassInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo17finalizeInsInstrsERNS_12MachineInstrERNS_22MachineCombinerPatternERNS_15SmallVectorImplIPS1_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo27isAssociativeAndCommutativeERKNS_12MachineInstrEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo16getInverseOpcodeEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo31accumulateInstrSeqToRootLatencyERNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo25getExtendResourceLenLimitEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo21setSpecialOperandAttrERNS_12MachineInstrES2_S2_S2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo18useMachineCombinerEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo30canCopyGluedNodeDuringScheduleEPNS_6SDNodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo21foldMemoryOperandImplERNS_15MachineFunctionERNS_12MachineInstrENS_8ArrayRefIjEENS_26MachineInstrBundleIteratorIS3_Lb0EEEiPNS_13LiveIntervalsEPNS_10VirtRegMapE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo21foldMemoryOperandImplERNS_15MachineFunctionERNS_12MachineInstrENS_8ArrayRefIjEENS_26MachineInstrBundleIteratorIS3_Lb0EEES4_PNS_13LiveIntervalsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo24getRegSequenceLikeInputsERKNS_12MachineInstrEjRNS_15SmallVectorImplINS0_19RegSubRegPairAndIdxEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo26getExtractSubregLikeInputsERKNS_12MachineInstrEjRNS0_19RegSubRegPairAndIdxE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo25getInsertSubregLikeInputsERKNS_12MachineInstrEjRNS0_13RegSubRegPairERNS0_19RegSubRegPairAndIdxE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo19unfoldMemoryOperandERNS_15MachineFunctionERNS_12MachineInstrEjbbRNS_15SmallVectorImplIPS3_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo19unfoldMemoryOperandERNS_12SelectionDAGEPNS_6SDNodeERNS_15SmallVectorImplIS4_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo26getOpcodeAfterMemoryUnfoldEjbbPj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo23areLoadsFromSameBasePtrEPNS_6SDNodeES2_RlS3_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo23shouldScheduleLoadsNearEPNS_6SDNodeES2_llj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo29getMemOperandsWithOffsetWidthERKNS_12MachineInstrERNS_15SmallVectorImplIPKNS_14MachineOperandEEERlRbRjPKNS_18TargetRegisterInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo24getBaseAndOffsetPositionERKNS_12MachineInstrERjS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo23getAddrModeFromMemoryOpERKNS_12MachineInstrEPKNS_18TargetRegisterInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo23preservesZeroValueInRegEPKNS_12MachineInstrENS_8RegisterEPKNS_18TargetRegisterInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo17getIncrementValueERKNS_12MachineInstrERi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo19shouldClusterMemOpsENS_8ArrayRefIPKNS_14MachineOperandEEES5_jj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo22reverseBranchConditionERNS_15SmallVectorImplINS_14MachineOperandEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo15isPostIncrementERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo12isPredicatedERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo27canPredicatePredicatedInstrERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo23isUnconditionalTailCallERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo26canMakeTailCallConditionalERNS_15SmallVectorImplINS_14MachineOperandEEERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo25replaceBranchWithTailCallERNS_17MachineBasicBlockERNS_15SmallVectorImplINS_14MachineOperandEEERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo17SubsumesPredicateENS_8ArrayRefINS_14MachineOperandEEES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo17ClobbersPredicateERNS_12MachineInstrERSt6vectorINS_14MachineOperandESaIS4_EEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo12isPredicableERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo24isSafeToMoveRegClassDefsEPKNS_19TargetRegisterClassE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo34CreateTargetPostRAHazardRecognizerERKNS_15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo14analyzeCompareERKNS_12MachineInstrERNS_8RegisterES5_RlS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo20optimizeCompareInstrERNS_12MachineInstrENS_8RegisterES3_llPKNS_19MachineRegisterInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo18optimizeCondBranchERNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo17optimizeLoadInstrERNS_12MachineInstrEPKNS_19MachineRegisterInfoERNS_8RegisterERPS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo13FoldImmediateERNS_12MachineInstrES2_NS_8RegisterEPNS_19MachineRegisterInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo16isHighLatencyDefEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo21hasHighOperandLatencyERKNS_16TargetSchedModelEPKNS_19MachineRegisterInfoERKNS_12MachineInstrEjS9_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo17verifyInstructionERKNS_12MachineInstrERNS_9StringRefE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo18getExecutionDomainERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo18setExecutionDomainERNS_12MachineInstrEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo28getPartialRegUpdateClearanceERKNS_12MachineInstrEjPKNS_18TargetRegisterInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo20getUndefRegClearanceERKNS_12MachineInstrEjPKNS_18TargetRegisterInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo25breakPartialRegDependencyERNS_12MachineInstrEjPKNS_18TargetRegisterInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo25CreateTargetScheduleStateERKNS_19TargetSubtargetInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo31areMemAccessesTriviallyDisjointERKNS_12MachineInstrES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo27getMachineCSELookAheadLimitEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo25getMemOperandAACheckLimitEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo28getSerializableTargetIndicesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo35decomposeMachineOperandsTargetFlagsEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo46getSerializableDirectMachineOperandTargetFlagsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo47getSerializableBitmaskMachineOperandTargetFlagsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo43getSerializableMachineMemOperandTargetFlagsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo10isTailCallERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo20isBasicBlockPrologueERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo24createPHIDestinationCopyERNS_17MachineBasicBlockENS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEERKNS_8DebugLocENS_8RegisterES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo19createPHISourceCopyERNS_17MachineBasicBlockENS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEERKNS_8DebugLocENS_8RegisterEjS9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo25getOutliningCandidateInfoERSt6vectorINS_8outliner9CandidateESaIS3_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo20getOutliningTypeImplERNS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo19getOutlinableRangesERNS_17MachineBasicBlockERj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo18buildOutlinedFrameERNS_17MachineBasicBlockERNS_15MachineFunctionERKNS_8outliner16OutlinedFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo18insertOutlinedCallERNS_6ModuleERNS_17MachineBasicBlockERNS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEERNS_15MachineFunctionERNS_8outliner9CandidateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo27isFunctionSafeToOutlineFromERNS_15MachineFunctionEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo34shouldOutlineFromFunctionByDefaultERNS_15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo24isExtendLikelyToBeFoldedERNS_12MachineInstrERNS_19MachineRegisterInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo15getMIRFormatterEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo20getTailDuplicateSizeENS_10CodeGenOpt5LevelE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo16getCalleeOperandERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo24getInstructionUniformityERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo24isExplicitTargetIndexDefERKNS_12MachineInstrERiRl</td>
    <td class="numberOfCalls">23</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15TargetInstrInfo27isTriviallyReMaterializableERKNS_12MachineInstrE</td>
    <td class="numberOfCalls">2</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- llvm/CodeGen/TargetInstrInfo.h - Instruction Info --------*- C++ -*-===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- llvm/CodeGen/TargetInstrInfo.h - Instruction Info --------*- C++ -*-===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This file describes the target machine instruction set to the code generator.</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This file describes the target machine instruction set to the code generator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">11</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline"></td>
    <td class="lineNumber">12</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">#ifndef LLVM_CODEGEN_TARGETINSTRINFO_H</td>
    <td class="lineNumber">13</td>
    <td class="codeline">#ifndef LLVM_CODEGEN_TARGETINSTRINFO_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">#define LLVM_CODEGEN_TARGETINSTRINFO_H</td>
    <td class="lineNumber">14</td>
    <td class="codeline">#define LLVM_CODEGEN_TARGETINSTRINFO_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline"></td>
    <td class="lineNumber">15</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/ADT/DenseMapInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/Uniformity.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/Uniformity.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/CodeGen/MIRFormatter.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/CodeGen/MIRFormatter.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstr.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/CodeGen/MachineOperand.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/CodeGen/MachineOutliner.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/CodeGen/MachineOutliner.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/CodeGen/RegisterClassInfo.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/CodeGen/RegisterClassInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/CodeGen/VirtRegMap.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/CodeGen/VirtRegMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/MC/MCInstrInfo.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/MC/MCInstrInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/Support/BranchProbability.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/Support/BranchProbability.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include <cstddef></td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include <cstddef></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include <vector></td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include <vector></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline"></td>
    <td class="lineNumber">37</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">38</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline"></td>
    <td class="lineNumber">39</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">class DFAPacketizer;</td>
    <td class="lineNumber">40</td>
    <td class="codeline">class DFAPacketizer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">class InstrItineraryData;</td>
    <td class="lineNumber">41</td>
    <td class="codeline">class InstrItineraryData;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">class LiveIntervals;</td>
    <td class="lineNumber">42</td>
    <td class="codeline">class LiveIntervals;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">class LiveVariables;</td>
    <td class="lineNumber">43</td>
    <td class="codeline">class LiveVariables;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">class MachineLoop;</td>
    <td class="lineNumber">44</td>
    <td class="codeline">class MachineLoop;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">class MachineMemOperand;</td>
    <td class="lineNumber">45</td>
    <td class="codeline">class MachineMemOperand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">class MachineRegisterInfo;</td>
    <td class="lineNumber">46</td>
    <td class="codeline">class MachineRegisterInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">class MCAsmInfo;</td>
    <td class="lineNumber">47</td>
    <td class="codeline">class MCAsmInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">class MCInst;</td>
    <td class="lineNumber">48</td>
    <td class="codeline">class MCInst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">struct MCSchedModel;</td>
    <td class="lineNumber">49</td>
    <td class="codeline">struct MCSchedModel;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">class Module;</td>
    <td class="lineNumber">50</td>
    <td class="codeline">class Module;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">class ScheduleDAG;</td>
    <td class="lineNumber">51</td>
    <td class="codeline">class ScheduleDAG;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">class ScheduleDAGMI;</td>
    <td class="lineNumber">52</td>
    <td class="codeline">class ScheduleDAGMI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">class ScheduleHazardRecognizer;</td>
    <td class="lineNumber">53</td>
    <td class="codeline">class ScheduleHazardRecognizer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">class SDNode;</td>
    <td class="lineNumber">54</td>
    <td class="codeline">class SDNode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">class SelectionDAG;</td>
    <td class="lineNumber">55</td>
    <td class="codeline">class SelectionDAG;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">class SMSchedule;</td>
    <td class="lineNumber">56</td>
    <td class="codeline">class SMSchedule;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">class SwingSchedulerDAG;</td>
    <td class="lineNumber">57</td>
    <td class="codeline">class SwingSchedulerDAG;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">class RegScavenger;</td>
    <td class="lineNumber">58</td>
    <td class="codeline">class RegScavenger;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">class TargetRegisterClass;</td>
    <td class="lineNumber">59</td>
    <td class="codeline">class TargetRegisterClass;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">class TargetRegisterInfo;</td>
    <td class="lineNumber">60</td>
    <td class="codeline">class TargetRegisterInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">class TargetSchedModel;</td>
    <td class="lineNumber">61</td>
    <td class="codeline">class TargetSchedModel;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">class TargetSubtargetInfo;</td>
    <td class="lineNumber">62</td>
    <td class="codeline">class TargetSubtargetInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">enum class MachineCombinerPattern;</td>
    <td class="lineNumber">63</td>
    <td class="codeline">enum class MachineCombinerPattern;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">enum class MachineTraceStrategy;</td>
    <td class="lineNumber">64</td>
    <td class="codeline">enum class MachineTraceStrategy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline"></td>
    <td class="lineNumber">65</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">template <class T> class SmallVectorImpl;</td>
    <td class="lineNumber">66</td>
    <td class="codeline">template <class T> class SmallVectorImpl;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline"></td>
    <td class="lineNumber">67</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">using ParamLoadedValue = std::pair<MachineOperand, DIExpression*>;</td>
    <td class="lineNumber">68</td>
    <td class="codeline">using ParamLoadedValue = std::pair<MachineOperand, DIExpression*>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline"></td>
    <td class="lineNumber">69</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">struct DestSourcePair {</td>
    <td class="lineNumber">70</td>
    <td class="codeline">struct DestSourcePair {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">  const MachineOperand *Destination;</td>
    <td class="lineNumber">71</td>
    <td class="codeline">  const MachineOperand *Destination;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">  const MachineOperand *Source;</td>
    <td class="lineNumber">72</td>
    <td class="codeline">  const MachineOperand *Source;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline"></td>
    <td class="lineNumber">73</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine diffFirst">  DestSourcePair(const MachineOperand &Dest, const MachineOperand &Src)</td>
    <td class="lineNumber">74</td>
    <td class="codeline">  DestSourcePair(const MachineOperand &Dest, const MachineOperand &Src)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine diffFirst">      : Destination(&Dest), Source(&Src) {}</td>
    <td class="lineNumber">75</td>
    <td class="codeline">      : Destination(&Dest), Source(&Src) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">};</td>
    <td class="lineNumber">76</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">/// Used to describe a register and immediate addition.</td>
    <td class="lineNumber">78</td>
    <td class="codeline">/// Used to describe a register and immediate addition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">struct RegImmPair {</td>
    <td class="lineNumber">79</td>
    <td class="codeline">struct RegImmPair {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">  Register Reg;</td>
    <td class="lineNumber">80</td>
    <td class="codeline">  Register Reg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">  int64_t Imm;</td>
    <td class="lineNumber">81</td>
    <td class="codeline">  int64_t Imm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">  RegImmPair(Register Reg, int64_t Imm) : Reg(Reg), Imm(Imm) {}</td>
    <td class="lineNumber">83</td>
    <td class="codeline">  RegImmPair(Register Reg, int64_t Imm) : Reg(Reg), Imm(Imm) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">};</td>
    <td class="lineNumber">84</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline"></td>
    <td class="lineNumber">85</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">/// Used to describe addressing mode similar to ExtAddrMode in CodeGenPrepare.</td>
    <td class="lineNumber">86</td>
    <td class="codeline">/// Used to describe addressing mode similar to ExtAddrMode in CodeGenPrepare.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">/// It holds the register values, the scale value and the displacement.</td>
    <td class="lineNumber">87</td>
    <td class="codeline">/// It holds the register values, the scale value and the displacement.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">struct ExtAddrMode {</td>
    <td class="lineNumber">88</td>
    <td class="codeline">struct ExtAddrMode {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">  Register BaseReg;</td>
    <td class="lineNumber">89</td>
    <td class="codeline">  Register BaseReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">  Register ScaledReg;</td>
    <td class="lineNumber">90</td>
    <td class="codeline">  Register ScaledReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">  int64_t Scale;</td>
    <td class="lineNumber">91</td>
    <td class="codeline">  int64_t Scale;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">  int64_t Displacement;</td>
    <td class="lineNumber">92</td>
    <td class="codeline">  int64_t Displacement;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">};</td>
    <td class="lineNumber">93</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline"></td>
    <td class="lineNumber">94</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">//---------------------------------------------------------------------------</td>
    <td class="lineNumber">95</td>
    <td class="codeline">//---------------------------------------------------------------------------</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">///</td>
    <td class="lineNumber">96</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">/// TargetInstrInfo - Interface to description of machine instruction set</td>
    <td class="lineNumber">97</td>
    <td class="codeline">/// TargetInstrInfo - Interface to description of machine instruction set</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">///</td>
    <td class="lineNumber">98</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">class TargetInstrInfo : public MCInstrInfo {</td>
    <td class="lineNumber">99</td>
    <td class="codeline">class TargetInstrInfo : public MCInstrInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">100</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">  TargetInstrInfo(unsigned CFSetupOpcode = ~0u, unsigned CFDestroyOpcode = ~0u,</td>
    <td class="lineNumber">101</td>
    <td class="codeline">  TargetInstrInfo(unsigned CFSetupOpcode = ~0u, unsigned CFDestroyOpcode = ~0u,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">                  unsigned CatchRetOpcode = ~0u, unsigned ReturnOpcode = ~0u)</td>
    <td class="lineNumber">102</td>
    <td class="codeline">                  unsigned CatchRetOpcode = ~0u, unsigned ReturnOpcode = ~0u)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">      : CallFrameSetupOpcode(CFSetupOpcode),</td>
    <td class="lineNumber">103</td>
    <td class="codeline">      : CallFrameSetupOpcode(CFSetupOpcode),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">        CallFrameDestroyOpcode(CFDestroyOpcode), CatchRetOpcode(CatchRetOpcode),</td>
    <td class="lineNumber">104</td>
    <td class="codeline">        CallFrameDestroyOpcode(CFDestroyOpcode), CatchRetOpcode(CatchRetOpcode),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">        ReturnOpcode(ReturnOpcode) {}</td>
    <td class="lineNumber">105</td>
    <td class="codeline">        ReturnOpcode(ReturnOpcode) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">  TargetInstrInfo(const TargetInstrInfo &) = delete;</td>
    <td class="lineNumber">106</td>
    <td class="codeline">  TargetInstrInfo(const TargetInstrInfo &) = delete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">  TargetInstrInfo &operator=(const TargetInstrInfo &) = delete;</td>
    <td class="lineNumber">107</td>
    <td class="codeline">  TargetInstrInfo &operator=(const TargetInstrInfo &) = delete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">  virtual ~TargetInstrInfo();</td>
    <td class="lineNumber">108</td>
    <td class="codeline">  virtual ~TargetInstrInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline"></td>
    <td class="lineNumber">109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  static bool isGenericOpcode(unsigned Opc) {</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  static bool isGenericOpcode(unsigned Opc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">    return Opc <= TargetOpcode::GENERIC_OP_END;</td>
    <td class="lineNumber">111</td>
    <td class="codeline">    return Opc <= TargetOpcode::GENERIC_OP_END;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline"></td>
    <td class="lineNumber">113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  static bool isGenericAtomicRMWOpcode(unsigned Opc) {</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  static bool isGenericAtomicRMWOpcode(unsigned Opc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">    return Opc >= TargetOpcode::GENERIC_ATOMICRMW_OP_START &&</td>
    <td class="lineNumber">115</td>
    <td class="codeline">    return Opc >= TargetOpcode::GENERIC_ATOMICRMW_OP_START &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">           Opc <= TargetOpcode::GENERIC_ATOMICRMW_OP_END;</td>
    <td class="lineNumber">116</td>
    <td class="codeline">           Opc <= TargetOpcode::GENERIC_ATOMICRMW_OP_END;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline"></td>
    <td class="lineNumber">118</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">  /// Given a machine instruction descriptor, returns the register</td>
    <td class="lineNumber">119</td>
    <td class="codeline">  /// Given a machine instruction descriptor, returns the register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">  /// class constraint for OpNum, or NULL.</td>
    <td class="lineNumber">120</td>
    <td class="codeline">  /// class constraint for OpNum, or NULL.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  virtual</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  virtual</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">  const TargetRegisterClass *getRegClass(const MCInstrDesc &MCID, unsigned OpNum,</td>
    <td class="lineNumber">122</td>
    <td class="codeline">  const TargetRegisterClass *getRegClass(const MCInstrDesc &MCID, unsigned OpNum,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">                                         const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">123</td>
    <td class="codeline">                                         const TargetRegisterInfo *TRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">                                         const MachineFunction &MF) const;</td>
    <td class="lineNumber">124</td>
    <td class="codeline">                                         const MachineFunction &MF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  /// Return true if the instruction is trivially rematerializable, meaning it</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  /// Return true if the instruction is trivially rematerializable, meaning it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  /// has no side effects and requires no operands that aren't always available.</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  /// has no side effects and requires no operands that aren't always available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  /// This means the only allowed uses are constants and unallocatable physical</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  /// This means the only allowed uses are constants and unallocatable physical</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">  /// registers so that the instructions result is independent of the place</td>
    <td class="lineNumber">129</td>
    <td class="codeline">  /// registers so that the instructions result is independent of the place</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  /// in the function.</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  /// in the function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">  bool isTriviallyReMaterializable(const MachineInstr &MI) const {</td>
    <td class="lineNumber">131</td>
    <td class="codeline">  bool isTriviallyReMaterializable(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">    return MI.getOpcode() == TargetOpcode::IMPLICIT_DEF ||</td>
    <td class="lineNumber">132</td>
    <td class="codeline">    return MI.getOpcode() == TargetOpcode::IMPLICIT_DEF ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">           (MI.getDesc().isRematerializable() &&</td>
    <td class="lineNumber">133</td>
    <td class="codeline">           (MI.getDesc().isRematerializable() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">            (isReallyTriviallyReMaterializable(MI) ||</td>
    <td class="lineNumber">134</td>
    <td class="codeline">            (isReallyTriviallyReMaterializable(MI) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">             isReallyTriviallyReMaterializableGeneric(MI)));</td>
    <td class="lineNumber">135</td>
    <td class="codeline">             isReallyTriviallyReMaterializableGeneric(MI)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">136</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">  /// Given \p MO is a PhysReg use return if it can be ignored for the purpose</td>
    <td class="lineNumber">138</td>
    <td class="codeline">  /// Given \p MO is a PhysReg use return if it can be ignored for the purpose</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">  /// of instruction rematerialization or sinking.</td>
    <td class="lineNumber">139</td>
    <td class="codeline">  /// of instruction rematerialization or sinking.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">  virtual bool isIgnorableUse(const MachineOperand &MO) const {</td>
    <td class="lineNumber">140</td>
    <td class="codeline">  virtual bool isIgnorableUse(const MachineOperand &MO) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">141</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">142</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline"></td>
    <td class="lineNumber">143</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">144</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">  /// For instructions with opcodes for which the M_REMATERIALIZABLE flag is</td>
    <td class="lineNumber">145</td>
    <td class="codeline">  /// For instructions with opcodes for which the M_REMATERIALIZABLE flag is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">  /// set, this hook lets the target specify whether the instruction is actually</td>
    <td class="lineNumber">146</td>
    <td class="codeline">  /// set, this hook lets the target specify whether the instruction is actually</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  /// trivially rematerializable, taking into consideration its operands. This</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  /// trivially rematerializable, taking into consideration its operands. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">  /// predicate must return false if the instruction has any side effects other</td>
    <td class="lineNumber">148</td>
    <td class="codeline">  /// predicate must return false if the instruction has any side effects other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">  /// than producing a value, or if it requres any address registers that are</td>
    <td class="lineNumber">149</td>
    <td class="codeline">  /// than producing a value, or if it requres any address registers that are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">  /// not always available.</td>
    <td class="lineNumber">150</td>
    <td class="codeline">  /// not always available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">  /// Requirements must be check as stated in isTriviallyReMaterializable() .</td>
    <td class="lineNumber">151</td>
    <td class="codeline">  /// Requirements must be check as stated in isTriviallyReMaterializable() .</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">  virtual bool isReallyTriviallyReMaterializable(const MachineInstr &MI) const {</td>
    <td class="lineNumber">152</td>
    <td class="codeline">  virtual bool isReallyTriviallyReMaterializable(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">153</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">154</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline"></td>
    <td class="lineNumber">155</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">  /// This method commutes the operands of the given machine instruction MI.</td>
    <td class="lineNumber">156</td>
    <td class="codeline">  /// This method commutes the operands of the given machine instruction MI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  /// The operands to be commuted are specified by their indices OpIdx1 and</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  /// The operands to be commuted are specified by their indices OpIdx1 and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">  /// OpIdx2.</td>
    <td class="lineNumber">158</td>
    <td class="codeline">  /// OpIdx2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">  /// If a target has any instructions that are commutable but require</td>
    <td class="lineNumber">160</td>
    <td class="codeline">  /// If a target has any instructions that are commutable but require</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">  /// converting to different instructions or making non-trivial changes</td>
    <td class="lineNumber">161</td>
    <td class="codeline">  /// converting to different instructions or making non-trivial changes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">  /// to commute them, this method can be overloaded to do that.</td>
    <td class="lineNumber">162</td>
    <td class="codeline">  /// to commute them, this method can be overloaded to do that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">  /// The default implementation simply swaps the commutable operands.</td>
    <td class="lineNumber">163</td>
    <td class="codeline">  /// The default implementation simply swaps the commutable operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">  /// If NewMI is false, MI is modified in place and returned; otherwise, a</td>
    <td class="lineNumber">165</td>
    <td class="codeline">  /// If NewMI is false, MI is modified in place and returned; otherwise, a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">  /// new machine instruction is created and returned.</td>
    <td class="lineNumber">166</td>
    <td class="codeline">  /// new machine instruction is created and returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">167</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  /// Do not call this method for a non-commutable instruction.</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  /// Do not call this method for a non-commutable instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  /// Even though the instruction is commutable, the method may still</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  /// Even though the instruction is commutable, the method may still</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  /// fail to commute the operands, null pointer is returned in such cases.</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  /// fail to commute the operands, null pointer is returned in such cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  virtual MachineInstr *commuteInstructionImpl(MachineInstr &MI, bool NewMI,</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  virtual MachineInstr *commuteInstructionImpl(MachineInstr &MI, bool NewMI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">                                               unsigned OpIdx1,</td>
    <td class="lineNumber">172</td>
    <td class="codeline">                                               unsigned OpIdx1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">                                               unsigned OpIdx2) const;</td>
    <td class="lineNumber">173</td>
    <td class="codeline">                                               unsigned OpIdx2) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline"></td>
    <td class="lineNumber">174</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  /// Assigns the (CommutableOpIdx1, CommutableOpIdx2) pair of commutable</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  /// Assigns the (CommutableOpIdx1, CommutableOpIdx2) pair of commutable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">  /// operand indices to (ResultIdx1, ResultIdx2).</td>
    <td class="lineNumber">176</td>
    <td class="codeline">  /// operand indices to (ResultIdx1, ResultIdx2).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">  /// One or both input values of the pair: (ResultIdx1, ResultIdx2) may be</td>
    <td class="lineNumber">177</td>
    <td class="codeline">  /// One or both input values of the pair: (ResultIdx1, ResultIdx2) may be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  /// predefined to some indices or be undefined (designated by the special</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  /// predefined to some indices or be undefined (designated by the special</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  /// value 'CommuteAnyOperandIndex').</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  /// value 'CommuteAnyOperandIndex').</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">  /// The predefined result indices cannot be re-defined.</td>
    <td class="lineNumber">180</td>
    <td class="codeline">  /// The predefined result indices cannot be re-defined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">  /// The function returns true iff after the result pair redefinition</td>
    <td class="lineNumber">181</td>
    <td class="codeline">  /// The function returns true iff after the result pair redefinition</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">  /// the fixed result pair is equal to or equivalent to the source pair of</td>
    <td class="lineNumber">182</td>
    <td class="codeline">  /// the fixed result pair is equal to or equivalent to the source pair of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  /// indices: (CommutableOpIdx1, CommutableOpIdx2). It is assumed here that</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  /// indices: (CommutableOpIdx1, CommutableOpIdx2). It is assumed here that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">  /// the pairs (x,y) and (y,x) are equivalent.</td>
    <td class="lineNumber">184</td>
    <td class="codeline">  /// the pairs (x,y) and (y,x) are equivalent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  static bool fixCommutedOpIndices(unsigned &ResultIdx1, unsigned &ResultIdx2,</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  static bool fixCommutedOpIndices(unsigned &ResultIdx1, unsigned &ResultIdx2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">                                   unsigned CommutableOpIdx1,</td>
    <td class="lineNumber">186</td>
    <td class="codeline">                                   unsigned CommutableOpIdx1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">                                   unsigned CommutableOpIdx2);</td>
    <td class="lineNumber">187</td>
    <td class="codeline">                                   unsigned CommutableOpIdx2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline"></td>
    <td class="lineNumber">188</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">189</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  /// For instructions with opcodes for which the M_REMATERIALIZABLE flag is</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  /// For instructions with opcodes for which the M_REMATERIALIZABLE flag is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  /// set and the target hook isReallyTriviallyReMaterializable returns false,</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  /// set and the target hook isReallyTriviallyReMaterializable returns false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">  /// this function does target-independent tests to determine if the</td>
    <td class="lineNumber">192</td>
    <td class="codeline">  /// this function does target-independent tests to determine if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  /// instruction is really trivially rematerializable.</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  /// instruction is really trivially rematerializable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">  bool isReallyTriviallyReMaterializableGeneric(const MachineInstr &MI) const;</td>
    <td class="lineNumber">194</td>
    <td class="codeline">  bool isReallyTriviallyReMaterializableGeneric(const MachineInstr &MI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline"></td>
    <td class="lineNumber">195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">196</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  /// These methods return the opcode of the frame setup/destroy instructions</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  /// These methods return the opcode of the frame setup/destroy instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">  /// if they exist (-1 otherwise).  Some targets use pseudo instructions in</td>
    <td class="lineNumber">198</td>
    <td class="codeline">  /// if they exist (-1 otherwise).  Some targets use pseudo instructions in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">  /// order to abstract away the difference between operating with a frame</td>
    <td class="lineNumber">199</td>
    <td class="codeline">  /// order to abstract away the difference between operating with a frame</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">  /// pointer and operating without, through the use of these two instructions.</td>
    <td class="lineNumber">200</td>
    <td class="codeline">  /// pointer and operating without, through the use of these two instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">  unsigned getCallFrameSetupOpcode() const { return CallFrameSetupOpcode; }</td>
    <td class="lineNumber">202</td>
    <td class="codeline">  unsigned getCallFrameSetupOpcode() const { return CallFrameSetupOpcode; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">  unsigned getCallFrameDestroyOpcode() const { return CallFrameDestroyOpcode; }</td>
    <td class="lineNumber">203</td>
    <td class="codeline">  unsigned getCallFrameDestroyOpcode() const { return CallFrameDestroyOpcode; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  /// Returns true if the argument is a frame pseudo instruction.</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  /// Returns true if the argument is a frame pseudo instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  bool isFrameInstr(const MachineInstr &I) const {</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  bool isFrameInstr(const MachineInstr &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">    return I.getOpcode() == getCallFrameSetupOpcode() ||</td>
    <td class="lineNumber">207</td>
    <td class="codeline">    return I.getOpcode() == getCallFrameSetupOpcode() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">           I.getOpcode() == getCallFrameDestroyOpcode();</td>
    <td class="lineNumber">208</td>
    <td class="codeline">           I.getOpcode() == getCallFrameDestroyOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">209</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  /// Returns true if the argument is a frame setup pseudo instruction.</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  /// Returns true if the argument is a frame setup pseudo instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  bool isFrameSetup(const MachineInstr &I) const {</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  bool isFrameSetup(const MachineInstr &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">    return I.getOpcode() == getCallFrameSetupOpcode();</td>
    <td class="lineNumber">213</td>
    <td class="codeline">    return I.getOpcode() == getCallFrameSetupOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">214</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">  /// Returns size of the frame associated with the given frame instruction.</td>
    <td class="lineNumber">216</td>
    <td class="codeline">  /// Returns size of the frame associated with the given frame instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  /// For frame setup instruction this is frame that is set up space set up</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  /// For frame setup instruction this is frame that is set up space set up</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  /// after the instruction. For frame destroy instruction this is the frame</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  /// after the instruction. For frame destroy instruction this is the frame</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  /// freed by the caller.</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  /// freed by the caller.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">  /// Note, in some cases a call frame (or a part of it) may be prepared prior</td>
    <td class="lineNumber">220</td>
    <td class="codeline">  /// Note, in some cases a call frame (or a part of it) may be prepared prior</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  /// to the frame setup instruction. It occurs in the calls that involve</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  /// to the frame setup instruction. It occurs in the calls that involve</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">  /// inalloca arguments. This function reports only the size of the frame part</td>
    <td class="lineNumber">222</td>
    <td class="codeline">  /// inalloca arguments. This function reports only the size of the frame part</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  /// that is set up between the frame setup and destroy pseudo instructions.</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  /// that is set up between the frame setup and destroy pseudo instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">  int64_t getFrameSize(const MachineInstr &I) const {</td>
    <td class="lineNumber">224</td>
    <td class="codeline">  int64_t getFrameSize(const MachineInstr &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">    assert(isFrameInstr(I) && "Not a frame instruction");</td>
    <td class="lineNumber">225</td>
    <td class="codeline">    assert(isFrameInstr(I) && "Not a frame instruction");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">    assert(I.getOperand(0).getImm() >= 0);</td>
    <td class="lineNumber">226</td>
    <td class="codeline">    assert(I.getOperand(0).getImm() >= 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">    return I.getOperand(0).getImm();</td>
    <td class="lineNumber">227</td>
    <td class="codeline">    return I.getOperand(0).getImm();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">228</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  /// Returns the total frame size, which is made up of the space set up inside</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  /// Returns the total frame size, which is made up of the space set up inside</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  /// the pair of frame start-stop instructions and the space that is set up</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  /// the pair of frame start-stop instructions and the space that is set up</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  /// prior to the pair.</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  /// prior to the pair.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  int64_t getFrameTotalSize(const MachineInstr &I) const {</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  int64_t getFrameTotalSize(const MachineInstr &I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">    if (isFrameSetup(I)) {</td>
    <td class="lineNumber">234</td>
    <td class="codeline">    if (isFrameSetup(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">      assert(I.getOperand(1).getImm() >= 0 &&</td>
    <td class="lineNumber">235</td>
    <td class="codeline">      assert(I.getOperand(1).getImm() >= 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">             "Frame size must not be negative");</td>
    <td class="lineNumber">236</td>
    <td class="codeline">             "Frame size must not be negative");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">      return getFrameSize(I) + I.getOperand(1).getImm();</td>
    <td class="lineNumber">237</td>
    <td class="codeline">      return getFrameSize(I) + I.getOperand(1).getImm();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">238</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    return getFrameSize(I);</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    return getFrameSize(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline"></td>
    <td class="lineNumber">241</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  unsigned getCatchReturnOpcode() const { return CatchRetOpcode; }</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  unsigned getCatchReturnOpcode() const { return CatchRetOpcode; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  unsigned getReturnOpcode() const { return ReturnOpcode; }</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  unsigned getReturnOpcode() const { return ReturnOpcode; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline"></td>
    <td class="lineNumber">244</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">  /// Returns the actual stack pointer adjustment made by an instruction</td>
    <td class="lineNumber">245</td>
    <td class="codeline">  /// Returns the actual stack pointer adjustment made by an instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  /// as part of a call sequence. By default, only call frame setup/destroy</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  /// as part of a call sequence. By default, only call frame setup/destroy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  /// instructions adjust the stack, but targets may want to override this</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  /// instructions adjust the stack, but targets may want to override this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">  /// to enable more fine-grained adjustment, or adjust by a different value.</td>
    <td class="lineNumber">248</td>
    <td class="codeline">  /// to enable more fine-grained adjustment, or adjust by a different value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  virtual int getSPAdjust(const MachineInstr &MI) const;</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  virtual int getSPAdjust(const MachineInstr &MI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline"></td>
    <td class="lineNumber">250</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  /// Return true if the instruction is a "coalescable" extension instruction.</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  /// Return true if the instruction is a "coalescable" extension instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  /// That is, it's like a copy where it's legal for the source to overlap the</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  /// That is, it's like a copy where it's legal for the source to overlap the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  /// destination. e.g. X86::MOVSX64rr32. If this returns true, then it's</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  /// destination. e.g. X86::MOVSX64rr32. If this returns true, then it's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  /// expected the pre-extension value is available as a subreg of the result</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  /// expected the pre-extension value is available as a subreg of the result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  /// register. This also returns the sub-register index in SubIdx.</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  /// register. This also returns the sub-register index in SubIdx.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">  virtual bool isCoalescableExtInstr(const MachineInstr &MI, Register &SrcReg,</td>
    <td class="lineNumber">256</td>
    <td class="codeline">  virtual bool isCoalescableExtInstr(const MachineInstr &MI, Register &SrcReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">                                     Register &DstReg, unsigned &SubIdx) const {</td>
    <td class="lineNumber">257</td>
    <td class="codeline">                                     Register &DstReg, unsigned &SubIdx) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">258</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline"></td>
    <td class="lineNumber">260</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">  /// If the specified machine instruction is a direct</td>
    <td class="lineNumber">261</td>
    <td class="codeline">  /// If the specified machine instruction is a direct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  /// load from a stack slot, return the virtual or physical register number of</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  /// load from a stack slot, return the virtual or physical register number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">  /// the destination along with the FrameIndex of the loaded stack slot.  If</td>
    <td class="lineNumber">263</td>
    <td class="codeline">  /// the destination along with the FrameIndex of the loaded stack slot.  If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  /// not, return 0.  This predicate must return 0 if the instruction has</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  /// not, return 0.  This predicate must return 0 if the instruction has</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  /// any side effects other than loading from the stack slot.</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  /// any side effects other than loading from the stack slot.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  virtual unsigned isLoadFromStackSlot(const MachineInstr &MI,</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  virtual unsigned isLoadFromStackSlot(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">                                       int &FrameIndex) const {</td>
    <td class="lineNumber">267</td>
    <td class="codeline">                                       int &FrameIndex) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">268</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline"></td>
    <td class="lineNumber">270</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  /// Optional extension of isLoadFromStackSlot that returns the number of</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  /// Optional extension of isLoadFromStackSlot that returns the number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  /// bytes loaded from the stack. This must be implemented if a backend</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  /// bytes loaded from the stack. This must be implemented if a backend</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  /// supports partial stack slot spills/loads to further disambiguate</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  /// supports partial stack slot spills/loads to further disambiguate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  /// what the load does.</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  /// what the load does.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  virtual unsigned isLoadFromStackSlot(const MachineInstr &MI,</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  virtual unsigned isLoadFromStackSlot(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">                                       int &FrameIndex,</td>
    <td class="lineNumber">276</td>
    <td class="codeline">                                       int &FrameIndex,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">                                       unsigned &MemBytes) const {</td>
    <td class="lineNumber">277</td>
    <td class="codeline">                                       unsigned &MemBytes) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">    MemBytes = 0;</td>
    <td class="lineNumber">278</td>
    <td class="codeline">    MemBytes = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">    return isLoadFromStackSlot(MI, FrameIndex);</td>
    <td class="lineNumber">279</td>
    <td class="codeline">    return isLoadFromStackSlot(MI, FrameIndex);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline"></td>
    <td class="lineNumber">281</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">  /// Check for post-frame ptr elimination stack locations as well.</td>
    <td class="lineNumber">282</td>
    <td class="codeline">  /// Check for post-frame ptr elimination stack locations as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  /// This uses a heuristic so it isn't reliable for correctness.</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  /// This uses a heuristic so it isn't reliable for correctness.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  virtual unsigned isLoadFromStackSlotPostFE(const MachineInstr &MI,</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  virtual unsigned isLoadFromStackSlotPostFE(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">                                             int &FrameIndex) const {</td>
    <td class="lineNumber">285</td>
    <td class="codeline">                                             int &FrameIndex) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">286</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  /// If the specified machine instruction has a load from a stack slot,</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  /// If the specified machine instruction has a load from a stack slot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">  /// return true along with the FrameIndices of the loaded stack slot and the</td>
    <td class="lineNumber">290</td>
    <td class="codeline">  /// return true along with the FrameIndices of the loaded stack slot and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  /// machine mem operands containing the reference.</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  /// machine mem operands containing the reference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">  /// If not, return false.  Unlike isLoadFromStackSlot, this returns true for</td>
    <td class="lineNumber">292</td>
    <td class="codeline">  /// If not, return false.  Unlike isLoadFromStackSlot, this returns true for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  /// any instructions that loads from the stack.  This is just a hint, as some</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  /// any instructions that loads from the stack.  This is just a hint, as some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  /// cases may be missed.</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  /// cases may be missed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  virtual bool hasLoadFromStackSlot(</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  virtual bool hasLoadFromStackSlot(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">      const MachineInstr &MI,</td>
    <td class="lineNumber">296</td>
    <td class="codeline">      const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">      SmallVectorImpl<const MachineMemOperand *> &Accesses) const;</td>
    <td class="lineNumber">297</td>
    <td class="codeline">      SmallVectorImpl<const MachineMemOperand *> &Accesses) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline"></td>
    <td class="lineNumber">298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  /// If the specified machine instruction is a direct</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  /// If the specified machine instruction is a direct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">  /// store to a stack slot, return the virtual or physical register number of</td>
    <td class="lineNumber">300</td>
    <td class="codeline">  /// store to a stack slot, return the virtual or physical register number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  /// the source reg along with the FrameIndex of the loaded stack slot.  If</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  /// the source reg along with the FrameIndex of the loaded stack slot.  If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  /// not, return 0.  This predicate must return 0 if the instruction has</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  /// not, return 0.  This predicate must return 0 if the instruction has</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">  /// any side effects other than storing to the stack slot.</td>
    <td class="lineNumber">303</td>
    <td class="codeline">  /// any side effects other than storing to the stack slot.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">  virtual unsigned isStoreToStackSlot(const MachineInstr &MI,</td>
    <td class="lineNumber">304</td>
    <td class="codeline">  virtual unsigned isStoreToStackSlot(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">                                      int &FrameIndex) const {</td>
    <td class="lineNumber">305</td>
    <td class="codeline">                                      int &FrameIndex) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">306</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  /// Optional extension of isStoreToStackSlot that returns the number of</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  /// Optional extension of isStoreToStackSlot that returns the number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">  /// bytes stored to the stack. This must be implemented if a backend</td>
    <td class="lineNumber">310</td>
    <td class="codeline">  /// bytes stored to the stack. This must be implemented if a backend</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">  /// supports partial stack slot spills/loads to further disambiguate</td>
    <td class="lineNumber">311</td>
    <td class="codeline">  /// supports partial stack slot spills/loads to further disambiguate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">  /// what the store does.</td>
    <td class="lineNumber">312</td>
    <td class="codeline">  /// what the store does.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">  virtual unsigned isStoreToStackSlot(const MachineInstr &MI,</td>
    <td class="lineNumber">313</td>
    <td class="codeline">  virtual unsigned isStoreToStackSlot(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">                                      int &FrameIndex,</td>
    <td class="lineNumber">314</td>
    <td class="codeline">                                      int &FrameIndex,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">                                      unsigned &MemBytes) const {</td>
    <td class="lineNumber">315</td>
    <td class="codeline">                                      unsigned &MemBytes) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">    MemBytes = 0;</td>
    <td class="lineNumber">316</td>
    <td class="codeline">    MemBytes = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">    return isStoreToStackSlot(MI, FrameIndex);</td>
    <td class="lineNumber">317</td>
    <td class="codeline">    return isStoreToStackSlot(MI, FrameIndex);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">318</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
    <td class="lineNumber">319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">  /// Check for post-frame ptr elimination stack locations as well.</td>
    <td class="lineNumber">320</td>
    <td class="codeline">  /// Check for post-frame ptr elimination stack locations as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">  /// This uses a heuristic, so it isn't reliable for correctness.</td>
    <td class="lineNumber">321</td>
    <td class="codeline">  /// This uses a heuristic, so it isn't reliable for correctness.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">  virtual unsigned isStoreToStackSlotPostFE(const MachineInstr &MI,</td>
    <td class="lineNumber">322</td>
    <td class="codeline">  virtual unsigned isStoreToStackSlotPostFE(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">                                            int &FrameIndex) const {</td>
    <td class="lineNumber">323</td>
    <td class="codeline">                                            int &FrameIndex) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">324</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">325</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline"></td>
    <td class="lineNumber">326</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">  /// If the specified machine instruction has a store to a stack slot,</td>
    <td class="lineNumber">327</td>
    <td class="codeline">  /// If the specified machine instruction has a store to a stack slot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">  /// return true along with the FrameIndices of the loaded stack slot and the</td>
    <td class="lineNumber">328</td>
    <td class="codeline">  /// return true along with the FrameIndices of the loaded stack slot and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">  /// machine mem operands containing the reference.</td>
    <td class="lineNumber">329</td>
    <td class="codeline">  /// machine mem operands containing the reference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  /// If not, return false.  Unlike isStoreToStackSlot,</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  /// If not, return false.  Unlike isStoreToStackSlot,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">  /// this returns true for any instructions that stores to the</td>
    <td class="lineNumber">331</td>
    <td class="codeline">  /// this returns true for any instructions that stores to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">  /// stack.  This is just a hint, as some cases may be missed.</td>
    <td class="lineNumber">332</td>
    <td class="codeline">  /// stack.  This is just a hint, as some cases may be missed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">  virtual bool hasStoreToStackSlot(</td>
    <td class="lineNumber">333</td>
    <td class="codeline">  virtual bool hasStoreToStackSlot(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">      const MachineInstr &MI,</td>
    <td class="lineNumber">334</td>
    <td class="codeline">      const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">      SmallVectorImpl<const MachineMemOperand *> &Accesses) const;</td>
    <td class="lineNumber">335</td>
    <td class="codeline">      SmallVectorImpl<const MachineMemOperand *> &Accesses) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  /// Return true if the specified machine instruction</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  /// Return true if the specified machine instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">  /// is a copy of one stack slot to another and has no other effect.</td>
    <td class="lineNumber">338</td>
    <td class="codeline">  /// is a copy of one stack slot to another and has no other effect.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">  /// Provide the identity of the two frame indices.</td>
    <td class="lineNumber">339</td>
    <td class="codeline">  /// Provide the identity of the two frame indices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">  virtual bool isStackSlotCopy(const MachineInstr &MI, int &DestFrameIndex,</td>
    <td class="lineNumber">340</td>
    <td class="codeline">  virtual bool isStackSlotCopy(const MachineInstr &MI, int &DestFrameIndex,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">                               int &SrcFrameIndex) const {</td>
    <td class="lineNumber">341</td>
    <td class="codeline">                               int &SrcFrameIndex) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">342</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">343</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  /// Compute the size in bytes and offset within a stack slot of a spilled</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  /// Compute the size in bytes and offset within a stack slot of a spilled</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">  /// register or subregister.</td>
    <td class="lineNumber">346</td>
    <td class="codeline">  /// register or subregister.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">347</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">  /// \param [out] Size in bytes of the spilled value.</td>
    <td class="lineNumber">348</td>
    <td class="codeline">  /// \param [out] Size in bytes of the spilled value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">  /// \param [out] Offset in bytes within the stack slot.</td>
    <td class="lineNumber">349</td>
    <td class="codeline">  /// \param [out] Offset in bytes within the stack slot.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">  /// \returns true if both Size and Offset are successfully computed.</td>
    <td class="lineNumber">350</td>
    <td class="codeline">  /// \returns true if both Size and Offset are successfully computed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">351</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">  /// Not all subregisters have computable spill slots. For example,</td>
    <td class="lineNumber">352</td>
    <td class="codeline">  /// Not all subregisters have computable spill slots. For example,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">  /// subregisters registers may not be byte-sized, and a pair of discontiguous</td>
    <td class="lineNumber">353</td>
    <td class="codeline">  /// subregisters registers may not be byte-sized, and a pair of discontiguous</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">  /// subregisters has no single offset.</td>
    <td class="lineNumber">354</td>
    <td class="codeline">  /// subregisters has no single offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">355</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  /// Targets with nontrivial bigendian implementations may need to override</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  /// Targets with nontrivial bigendian implementations may need to override</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">  /// this, particularly to support spilled vector registers.</td>
    <td class="lineNumber">357</td>
    <td class="codeline">  /// this, particularly to support spilled vector registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">  virtual bool getStackSlotRange(const TargetRegisterClass *RC, unsigned SubIdx,</td>
    <td class="lineNumber">358</td>
    <td class="codeline">  virtual bool getStackSlotRange(const TargetRegisterClass *RC, unsigned SubIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">                                 unsigned &Size, unsigned &Offset,</td>
    <td class="lineNumber">359</td>
    <td class="codeline">                                 unsigned &Size, unsigned &Offset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">                                 const MachineFunction &MF) const;</td>
    <td class="lineNumber">360</td>
    <td class="codeline">                                 const MachineFunction &MF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline"></td>
    <td class="lineNumber">361</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">  /// Return true if the given instruction is terminator that is unspillable,</td>
    <td class="lineNumber">362</td>
    <td class="codeline">  /// Return true if the given instruction is terminator that is unspillable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">  /// according to isUnspillableTerminatorImpl.</td>
    <td class="lineNumber">363</td>
    <td class="codeline">  /// according to isUnspillableTerminatorImpl.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">  bool isUnspillableTerminator(const MachineInstr *MI) const {</td>
    <td class="lineNumber">364</td>
    <td class="codeline">  bool isUnspillableTerminator(const MachineInstr *MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">    return MI->isTerminator() && isUnspillableTerminatorImpl(MI);</td>
    <td class="lineNumber">365</td>
    <td class="codeline">    return MI->isTerminator() && isUnspillableTerminatorImpl(MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">366</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">  /// Returns the size in bytes of the specified MachineInstr, or ~0U</td>
    <td class="lineNumber">368</td>
    <td class="codeline">  /// Returns the size in bytes of the specified MachineInstr, or ~0U</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  /// when this function is not implemented by a target.</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  /// when this function is not implemented by a target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  virtual unsigned getInstSizeInBytes(const MachineInstr &MI) const {</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  virtual unsigned getInstSizeInBytes(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">    return ~0U;</td>
    <td class="lineNumber">371</td>
    <td class="codeline">    return ~0U;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">372</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline"></td>
    <td class="lineNumber">373</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">  /// Return true if the instruction is as cheap as a move instruction.</td>
    <td class="lineNumber">374</td>
    <td class="codeline">  /// Return true if the instruction is as cheap as a move instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">375</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">  /// Targets for different archs need to override this, and different</td>
    <td class="lineNumber">376</td>
    <td class="codeline">  /// Targets for different archs need to override this, and different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">  /// micro-architectures can also be finely tuned inside.</td>
    <td class="lineNumber">377</td>
    <td class="codeline">  /// micro-architectures can also be finely tuned inside.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">  virtual bool isAsCheapAsAMove(const MachineInstr &MI) const {</td>
    <td class="lineNumber">378</td>
    <td class="codeline">  virtual bool isAsCheapAsAMove(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">    return MI.isAsCheapAsAMove();</td>
    <td class="lineNumber">379</td>
    <td class="codeline">    return MI.isAsCheapAsAMove();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">380</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline"></td>
    <td class="lineNumber">381</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">  /// Return true if the instruction should be sunk by MachineSink.</td>
    <td class="lineNumber">382</td>
    <td class="codeline">  /// Return true if the instruction should be sunk by MachineSink.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">  /// MachineSink determines on its own whether the instruction is safe to sink;</td>
    <td class="lineNumber">384</td>
    <td class="codeline">  /// MachineSink determines on its own whether the instruction is safe to sink;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  /// this gives the target a hook to override the default behavior with regards</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  /// this gives the target a hook to override the default behavior with regards</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">  /// to which instructions should be sunk.</td>
    <td class="lineNumber">386</td>
    <td class="codeline">  /// to which instructions should be sunk.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">  virtual bool shouldSink(const MachineInstr &MI) const { return true; }</td>
    <td class="lineNumber">387</td>
    <td class="codeline">  virtual bool shouldSink(const MachineInstr &MI) const { return true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">  /// Return false if the instruction should not be hoisted by MachineLICM.</td>
    <td class="lineNumber">389</td>
    <td class="codeline">  /// Return false if the instruction should not be hoisted by MachineLICM.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">390</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">  /// MachineLICM determines on its own whether the instruction is safe to</td>
    <td class="lineNumber">391</td>
    <td class="codeline">  /// MachineLICM determines on its own whether the instruction is safe to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">  /// hoist; this gives the target a hook to extend this assessment and prevent</td>
    <td class="lineNumber">392</td>
    <td class="codeline">  /// hoist; this gives the target a hook to extend this assessment and prevent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  /// an instruction being hoisted from a given loop for target specific</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  /// an instruction being hoisted from a given loop for target specific</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  /// reasons.</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  /// reasons.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">  virtual bool shouldHoist(const MachineInstr &MI,</td>
    <td class="lineNumber">395</td>
    <td class="codeline">  virtual bool shouldHoist(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">                           const MachineLoop *FromLoop) const {</td>
    <td class="lineNumber">396</td>
    <td class="codeline">                           const MachineLoop *FromLoop) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">397</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">398</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline"></td>
    <td class="lineNumber">399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  /// Re-issue the specified 'original' instruction at the</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  /// Re-issue the specified 'original' instruction at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">  /// specific location targeting a new destination register.</td>
    <td class="lineNumber">401</td>
    <td class="codeline">  /// specific location targeting a new destination register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  /// The register in Orig->getOperand(0).getReg() will be substituted by</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  /// The register in Orig->getOperand(0).getReg() will be substituted by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  /// DestReg:SubIdx. Any existing subreg index is preserved or composed with</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  /// DestReg:SubIdx. Any existing subreg index is preserved or composed with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  /// SubIdx.</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  /// SubIdx.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  virtual void reMaterialize(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  virtual void reMaterialize(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">                             MachineBasicBlock::iterator MI, Register DestReg,</td>
    <td class="lineNumber">406</td>
    <td class="codeline">                             MachineBasicBlock::iterator MI, Register DestReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">                             unsigned SubIdx, const MachineInstr &Orig,</td>
    <td class="lineNumber">407</td>
    <td class="codeline">                             unsigned SubIdx, const MachineInstr &Orig,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">                             const TargetRegisterInfo &TRI) const;</td>
    <td class="lineNumber">408</td>
    <td class="codeline">                             const TargetRegisterInfo &TRI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">  /// Clones instruction or the whole instruction bundle \p Orig and</td>
    <td class="lineNumber">410</td>
    <td class="codeline">  /// Clones instruction or the whole instruction bundle \p Orig and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  /// insert into \p MBB before \p InsertBefore. The target may update operands</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  /// insert into \p MBB before \p InsertBefore. The target may update operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  /// that are required to be unique.</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  /// that are required to be unique.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">413</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">  /// \p Orig must not return true for MachineInstr::isNotDuplicable().</td>
    <td class="lineNumber">414</td>
    <td class="codeline">  /// \p Orig must not return true for MachineInstr::isNotDuplicable().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  virtual MachineInstr &duplicate(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  virtual MachineInstr &duplicate(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">                                  MachineBasicBlock::iterator InsertBefore,</td>
    <td class="lineNumber">416</td>
    <td class="codeline">                                  MachineBasicBlock::iterator InsertBefore,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">                                  const MachineInstr &Orig) const;</td>
    <td class="lineNumber">417</td>
    <td class="codeline">                                  const MachineInstr &Orig) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline"></td>
    <td class="lineNumber">418</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">  /// This method must be implemented by targets that</td>
    <td class="lineNumber">419</td>
    <td class="codeline">  /// This method must be implemented by targets that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">  /// set the M_CONVERTIBLE_TO_3_ADDR flag.  When this flag is set, the target</td>
    <td class="lineNumber">420</td>
    <td class="codeline">  /// set the M_CONVERTIBLE_TO_3_ADDR flag.  When this flag is set, the target</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">  /// may be able to convert a two-address instruction into one or more true</td>
    <td class="lineNumber">421</td>
    <td class="codeline">  /// may be able to convert a two-address instruction into one or more true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  /// three-address instructions on demand.  This allows the X86 target (for</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  /// three-address instructions on demand.  This allows the X86 target (for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">  /// example) to convert ADD and SHL instructions into LEA instructions if they</td>
    <td class="lineNumber">423</td>
    <td class="codeline">  /// example) to convert ADD and SHL instructions into LEA instructions if they</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  /// would require register copies due to two-addressness.</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  /// would require register copies due to two-addressness.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  /// This method returns a null pointer if the transformation cannot be</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  /// This method returns a null pointer if the transformation cannot be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  /// performed, otherwise it returns the last new instruction.</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  /// performed, otherwise it returns the last new instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">  /// If \p LIS is not nullptr, the LiveIntervals info should be updated for</td>
    <td class="lineNumber">429</td>
    <td class="codeline">  /// If \p LIS is not nullptr, the LiveIntervals info should be updated for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  /// replacing \p MI with new instructions, even though this function does not</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  /// replacing \p MI with new instructions, even though this function does not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  /// remove MI.</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  /// remove MI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  virtual MachineInstr *convertToThreeAddress(MachineInstr &MI,</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  virtual MachineInstr *convertToThreeAddress(MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">                                              LiveVariables *LV,</td>
    <td class="lineNumber">433</td>
    <td class="codeline">                                              LiveVariables *LV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">                                              LiveIntervals *LIS) const {</td>
    <td class="lineNumber">434</td>
    <td class="codeline">                                              LiveIntervals *LIS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">435</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">436</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline"></td>
    <td class="lineNumber">437</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">  // This constant can be used as an input value of operand index passed to</td>
    <td class="lineNumber">438</td>
    <td class="codeline">  // This constant can be used as an input value of operand index passed to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  // the method findCommutedOpIndices() to tell the method that the</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  // the method findCommutedOpIndices() to tell the method that the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">  // corresponding operand index is not pre-defined and that the method</td>
    <td class="lineNumber">440</td>
    <td class="codeline">  // corresponding operand index is not pre-defined and that the method</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">  // can pick any commutable operand.</td>
    <td class="lineNumber">441</td>
    <td class="codeline">  // can pick any commutable operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">  static const unsigned CommuteAnyOperandIndex = ~0U;</td>
    <td class="lineNumber">442</td>
    <td class="codeline">  static const unsigned CommuteAnyOperandIndex = ~0U;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline"></td>
    <td class="lineNumber">443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">  /// This method commutes the operands of the given machine instruction MI.</td>
    <td class="lineNumber">444</td>
    <td class="codeline">  /// This method commutes the operands of the given machine instruction MI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">445</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">  /// The operands to be commuted are specified by their indices OpIdx1 and</td>
    <td class="lineNumber">446</td>
    <td class="codeline">  /// The operands to be commuted are specified by their indices OpIdx1 and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">  /// OpIdx2. OpIdx1 and OpIdx2 arguments may be set to a special value</td>
    <td class="lineNumber">447</td>
    <td class="codeline">  /// OpIdx2. OpIdx1 and OpIdx2 arguments may be set to a special value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">  /// 'CommuteAnyOperandIndex', which means that the method is free to choose</td>
    <td class="lineNumber">448</td>
    <td class="codeline">  /// 'CommuteAnyOperandIndex', which means that the method is free to choose</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">  /// any arbitrarily chosen commutable operand. If both arguments are set to</td>
    <td class="lineNumber">449</td>
    <td class="codeline">  /// any arbitrarily chosen commutable operand. If both arguments are set to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">  /// 'CommuteAnyOperandIndex' then the method looks for 2 different commutable</td>
    <td class="lineNumber">450</td>
    <td class="codeline">  /// 'CommuteAnyOperandIndex' then the method looks for 2 different commutable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">  /// operands; then commutes them if such operands could be found.</td>
    <td class="lineNumber">451</td>
    <td class="codeline">  /// operands; then commutes them if such operands could be found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">452</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  /// If NewMI is false, MI is modified in place and returned; otherwise, a</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  /// If NewMI is false, MI is modified in place and returned; otherwise, a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">  /// new machine instruction is created and returned.</td>
    <td class="lineNumber">454</td>
    <td class="codeline">  /// new machine instruction is created and returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">  /// Do not call this method for a non-commutable instruction or</td>
    <td class="lineNumber">456</td>
    <td class="codeline">  /// Do not call this method for a non-commutable instruction or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">  /// for non-commuable operands.</td>
    <td class="lineNumber">457</td>
    <td class="codeline">  /// for non-commuable operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">  /// Even though the instruction is commutable, the method may still</td>
    <td class="lineNumber">458</td>
    <td class="codeline">  /// Even though the instruction is commutable, the method may still</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">  /// fail to commute the operands, null pointer is returned in such cases.</td>
    <td class="lineNumber">459</td>
    <td class="codeline">  /// fail to commute the operands, null pointer is returned in such cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">  MachineInstr *</td>
    <td class="lineNumber">460</td>
    <td class="codeline">  MachineInstr *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">  commuteInstruction(MachineInstr &MI, bool NewMI = false,</td>
    <td class="lineNumber">461</td>
    <td class="codeline">  commuteInstruction(MachineInstr &MI, bool NewMI = false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">                     unsigned OpIdx1 = CommuteAnyOperandIndex,</td>
    <td class="lineNumber">462</td>
    <td class="codeline">                     unsigned OpIdx1 = CommuteAnyOperandIndex,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">                     unsigned OpIdx2 = CommuteAnyOperandIndex) const;</td>
    <td class="lineNumber">463</td>
    <td class="codeline">                     unsigned OpIdx2 = CommuteAnyOperandIndex) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline"></td>
    <td class="lineNumber">464</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  /// Returns true iff the routine could find two commutable operands in the</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  /// Returns true iff the routine could find two commutable operands in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">  /// given machine instruction.</td>
    <td class="lineNumber">466</td>
    <td class="codeline">  /// given machine instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  /// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments.</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  /// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">  /// If any of the INPUT values is set to the special value</td>
    <td class="lineNumber">468</td>
    <td class="codeline">  /// If any of the INPUT values is set to the special value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">  /// 'CommuteAnyOperandIndex' then the method arbitrarily picks a commutable</td>
    <td class="lineNumber">469</td>
    <td class="codeline">  /// 'CommuteAnyOperandIndex' then the method arbitrarily picks a commutable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">  /// operand, then returns its index in the corresponding argument.</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  /// operand, then returns its index in the corresponding argument.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">  /// If both of INPUT values are set to 'CommuteAnyOperandIndex' then method</td>
    <td class="lineNumber">471</td>
    <td class="codeline">  /// If both of INPUT values are set to 'CommuteAnyOperandIndex' then method</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  /// looks for 2 commutable operands.</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  /// looks for 2 commutable operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  /// If INPUT values refer to some operands of MI, then the method simply</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  /// If INPUT values refer to some operands of MI, then the method simply</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  /// returns true if the corresponding operands are commutable and returns</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  /// returns true if the corresponding operands are commutable and returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  /// false otherwise.</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  /// false otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  /// For example, calling this method this way:</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  /// For example, calling this method this way:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  ///     unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  ///     unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  ///     findCommutedOpIndices(MI, Op1, Op2);</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  ///     findCommutedOpIndices(MI, Op1, Op2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">  /// can be interpreted as a query asking to find an operand that would be</td>
    <td class="lineNumber">480</td>
    <td class="codeline">  /// can be interpreted as a query asking to find an operand that would be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">  /// commutable with the operand#1.</td>
    <td class="lineNumber">481</td>
    <td class="codeline">  /// commutable with the operand#1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">  virtual bool findCommutedOpIndices(const MachineInstr &MI,</td>
    <td class="lineNumber">482</td>
    <td class="codeline">  virtual bool findCommutedOpIndices(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">                                     unsigned &SrcOpIdx1,</td>
    <td class="lineNumber">483</td>
    <td class="codeline">                                     unsigned &SrcOpIdx1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">                                     unsigned &SrcOpIdx2) const;</td>
    <td class="lineNumber">484</td>
    <td class="codeline">                                     unsigned &SrcOpIdx2) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline"></td>
    <td class="lineNumber">485</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  /// Returns true if the target has a preference on the operands order of</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  /// Returns true if the target has a preference on the operands order of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  /// the given machine instruction. And specify if \p Commute is required to</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  /// the given machine instruction. And specify if \p Commute is required to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">  /// get the desired operands order.</td>
    <td class="lineNumber">488</td>
    <td class="codeline">  /// get the desired operands order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">  virtual bool hasCommutePreference(MachineInstr &MI, bool &Commute) const {</td>
    <td class="lineNumber">489</td>
    <td class="codeline">  virtual bool hasCommutePreference(MachineInstr &MI, bool &Commute) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">490</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline"></td>
    <td class="lineNumber">492</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  /// A pair composed of a register and a sub-register index.</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  /// A pair composed of a register and a sub-register index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  /// Used to give some type checking when modeling Reg:SubReg.</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  /// Used to give some type checking when modeling Reg:SubReg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">  struct RegSubRegPair {</td>
    <td class="lineNumber">495</td>
    <td class="codeline">  struct RegSubRegPair {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">    Register Reg;</td>
    <td class="lineNumber">496</td>
    <td class="codeline">    Register Reg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">    unsigned SubReg;</td>
    <td class="lineNumber">497</td>
    <td class="codeline">    unsigned SubReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline"></td>
    <td class="lineNumber">498</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">    RegSubRegPair(Register Reg = Register(), unsigned SubReg = 0)</td>
    <td class="lineNumber">499</td>
    <td class="codeline">    RegSubRegPair(Register Reg = Register(), unsigned SubReg = 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">        : Reg(Reg), SubReg(SubReg) {}</td>
    <td class="lineNumber">500</td>
    <td class="codeline">        : Reg(Reg), SubReg(SubReg) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline"></td>
    <td class="lineNumber">501</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">    bool operator==(const RegSubRegPair& P) const {</td>
    <td class="lineNumber">502</td>
    <td class="codeline">    bool operator==(const RegSubRegPair& P) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">      return Reg == P.Reg && SubReg == P.SubReg;</td>
    <td class="lineNumber">503</td>
    <td class="codeline">      return Reg == P.Reg && SubReg == P.SubReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">504</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">    bool operator!=(const RegSubRegPair& P) const {</td>
    <td class="lineNumber">505</td>
    <td class="codeline">    bool operator!=(const RegSubRegPair& P) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">      return !(*this == P);</td>
    <td class="lineNumber">506</td>
    <td class="codeline">      return !(*this == P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">507</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline"></td>
    <td class="lineNumber">509</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">  /// A pair composed of a pair of a register and a sub-register index,</td>
    <td class="lineNumber">510</td>
    <td class="codeline">  /// A pair composed of a pair of a register and a sub-register index,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">  /// and another sub-register index.</td>
    <td class="lineNumber">511</td>
    <td class="codeline">  /// and another sub-register index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  /// Used to give some type checking when modeling Reg:SubReg1, SubReg2.</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  /// Used to give some type checking when modeling Reg:SubReg1, SubReg2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">  struct RegSubRegPairAndIdx : RegSubRegPair {</td>
    <td class="lineNumber">513</td>
    <td class="codeline">  struct RegSubRegPairAndIdx : RegSubRegPair {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">    unsigned SubIdx;</td>
    <td class="lineNumber">514</td>
    <td class="codeline">    unsigned SubIdx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline"></td>
    <td class="lineNumber">515</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">    RegSubRegPairAndIdx(Register Reg = Register(), unsigned SubReg = 0,</td>
    <td class="lineNumber">516</td>
    <td class="codeline">    RegSubRegPairAndIdx(Register Reg = Register(), unsigned SubReg = 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">                        unsigned SubIdx = 0)</td>
    <td class="lineNumber">517</td>
    <td class="codeline">                        unsigned SubIdx = 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">        : RegSubRegPair(Reg, SubReg), SubIdx(SubIdx) {}</td>
    <td class="lineNumber">518</td>
    <td class="codeline">        : RegSubRegPair(Reg, SubReg), SubIdx(SubIdx) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
    <td class="lineNumber">520</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">  /// Build the equivalent inputs of a REG_SEQUENCE for the given \p MI</td>
    <td class="lineNumber">521</td>
    <td class="codeline">  /// Build the equivalent inputs of a REG_SEQUENCE for the given \p MI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">  /// and \p DefIdx.</td>
    <td class="lineNumber">522</td>
    <td class="codeline">  /// and \p DefIdx.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  /// \p [out] InputRegs of the equivalent REG_SEQUENCE. Each element of</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  /// \p [out] InputRegs of the equivalent REG_SEQUENCE. Each element of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">  /// the list is modeled as <Reg:SubReg, SubIdx>. Operands with the undef</td>
    <td class="lineNumber">524</td>
    <td class="codeline">  /// the list is modeled as <Reg:SubReg, SubIdx>. Operands with the undef</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  /// flag are not added to this list.</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  /// flag are not added to this list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">  /// E.g., REG_SEQUENCE %1:sub1, sub0, %2, sub1 would produce</td>
    <td class="lineNumber">526</td>
    <td class="codeline">  /// E.g., REG_SEQUENCE %1:sub1, sub0, %2, sub1 would produce</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  /// two elements:</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  /// two elements:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">  /// - %1:sub1, sub0</td>
    <td class="lineNumber">528</td>
    <td class="codeline">  /// - %1:sub1, sub0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">  /// - %2<:0>, sub1</td>
    <td class="lineNumber">529</td>
    <td class="codeline">  /// - %2<:0>, sub1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">  /// \returns true if it is possible to build such an input sequence</td>
    <td class="lineNumber">531</td>
    <td class="codeline">  /// \returns true if it is possible to build such an input sequence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">  /// with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td class="lineNumber">532</td>
    <td class="codeline">  /// with the pair \p MI, \p DefIdx. False otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">533</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">  /// \pre MI.isRegSequence() or MI.isRegSequenceLike().</td>
    <td class="lineNumber">534</td>
    <td class="codeline">  /// \pre MI.isRegSequence() or MI.isRegSequenceLike().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">535</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  /// \note The generic implementation does not provide any support for</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  /// \note The generic implementation does not provide any support for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  /// MI.isRegSequenceLike(). In other words, one has to override</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  /// MI.isRegSequenceLike(). In other words, one has to override</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">  /// getRegSequenceLikeInputs for target specific instructions.</td>
    <td class="lineNumber">538</td>
    <td class="codeline">  /// getRegSequenceLikeInputs for target specific instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  bool</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">  getRegSequenceInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">540</td>
    <td class="codeline">  getRegSequenceInputs(const MachineInstr &MI, unsigned DefIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">                       SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs) const;</td>
    <td class="lineNumber">541</td>
    <td class="codeline">                       SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline"></td>
    <td class="lineNumber">542</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">  /// Build the equivalent inputs of a EXTRACT_SUBREG for the given \p MI</td>
    <td class="lineNumber">543</td>
    <td class="codeline">  /// Build the equivalent inputs of a EXTRACT_SUBREG for the given \p MI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">  /// and \p DefIdx.</td>
    <td class="lineNumber">544</td>
    <td class="codeline">  /// and \p DefIdx.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">  /// \p [out] InputReg of the equivalent EXTRACT_SUBREG.</td>
    <td class="lineNumber">545</td>
    <td class="codeline">  /// \p [out] InputReg of the equivalent EXTRACT_SUBREG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">  /// E.g., EXTRACT_SUBREG %1:sub1, sub0, sub1 would produce:</td>
    <td class="lineNumber">546</td>
    <td class="codeline">  /// E.g., EXTRACT_SUBREG %1:sub1, sub0, sub1 would produce:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  /// - %1:sub1, sub0</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  /// - %1:sub1, sub0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">  /// \returns true if it is possible to build such an input sequence</td>
    <td class="lineNumber">549</td>
    <td class="codeline">  /// \returns true if it is possible to build such an input sequence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">  /// with the pair \p MI, \p DefIdx and the operand has no undef flag set.</td>
    <td class="lineNumber">550</td>
    <td class="codeline">  /// with the pair \p MI, \p DefIdx and the operand has no undef flag set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">  /// False otherwise.</td>
    <td class="lineNumber">551</td>
    <td class="codeline">  /// False otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">552</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">  /// \pre MI.isExtractSubreg() or MI.isExtractSubregLike().</td>
    <td class="lineNumber">553</td>
    <td class="codeline">  /// \pre MI.isExtractSubreg() or MI.isExtractSubregLike().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">554</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">  /// \note The generic implementation does not provide any support for</td>
    <td class="lineNumber">555</td>
    <td class="codeline">  /// \note The generic implementation does not provide any support for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">  /// MI.isExtractSubregLike(). In other words, one has to override</td>
    <td class="lineNumber">556</td>
    <td class="codeline">  /// MI.isExtractSubregLike(). In other words, one has to override</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">  /// getExtractSubregLikeInputs for target specific instructions.</td>
    <td class="lineNumber">557</td>
    <td class="codeline">  /// getExtractSubregLikeInputs for target specific instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">  bool getExtractSubregInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">558</td>
    <td class="codeline">  bool getExtractSubregInputs(const MachineInstr &MI, unsigned DefIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">                              RegSubRegPairAndIdx &InputReg) const;</td>
    <td class="lineNumber">559</td>
    <td class="codeline">                              RegSubRegPairAndIdx &InputReg) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline"></td>
    <td class="lineNumber">560</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">  /// Build the equivalent inputs of a INSERT_SUBREG for the given \p MI</td>
    <td class="lineNumber">561</td>
    <td class="codeline">  /// Build the equivalent inputs of a INSERT_SUBREG for the given \p MI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">  /// and \p DefIdx.</td>
    <td class="lineNumber">562</td>
    <td class="codeline">  /// and \p DefIdx.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  /// \p [out] BaseReg and \p [out] InsertedReg contain</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  /// \p [out] BaseReg and \p [out] InsertedReg contain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">  /// the equivalent inputs of INSERT_SUBREG.</td>
    <td class="lineNumber">564</td>
    <td class="codeline">  /// the equivalent inputs of INSERT_SUBREG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">  /// E.g., INSERT_SUBREG %0:sub0, %1:sub1, sub3 would produce:</td>
    <td class="lineNumber">565</td>
    <td class="codeline">  /// E.g., INSERT_SUBREG %0:sub0, %1:sub1, sub3 would produce:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">  /// - BaseReg: %0:sub0</td>
    <td class="lineNumber">566</td>
    <td class="codeline">  /// - BaseReg: %0:sub0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">  /// - InsertedReg: %1:sub1, sub3</td>
    <td class="lineNumber">567</td>
    <td class="codeline">  /// - InsertedReg: %1:sub1, sub3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">568</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">  /// \returns true if it is possible to build such an input sequence</td>
    <td class="lineNumber">569</td>
    <td class="codeline">  /// \returns true if it is possible to build such an input sequence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">  /// with the pair \p MI, \p DefIdx and the operand has no undef flag set.</td>
    <td class="lineNumber">570</td>
    <td class="codeline">  /// with the pair \p MI, \p DefIdx and the operand has no undef flag set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">  /// False otherwise.</td>
    <td class="lineNumber">571</td>
    <td class="codeline">  /// False otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">572</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">  /// \pre MI.isInsertSubreg() or MI.isInsertSubregLike().</td>
    <td class="lineNumber">573</td>
    <td class="codeline">  /// \pre MI.isInsertSubreg() or MI.isInsertSubregLike().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">574</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">  /// \note The generic implementation does not provide any support for</td>
    <td class="lineNumber">575</td>
    <td class="codeline">  /// \note The generic implementation does not provide any support for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  /// MI.isInsertSubregLike(). In other words, one has to override</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  /// MI.isInsertSubregLike(). In other words, one has to override</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  /// getInsertSubregLikeInputs for target specific instructions.</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  /// getInsertSubregLikeInputs for target specific instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">  bool getInsertSubregInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">578</td>
    <td class="codeline">  bool getInsertSubregInputs(const MachineInstr &MI, unsigned DefIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">                             RegSubRegPair &BaseReg,</td>
    <td class="lineNumber">579</td>
    <td class="codeline">                             RegSubRegPair &BaseReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">                             RegSubRegPairAndIdx &InsertedReg) const;</td>
    <td class="lineNumber">580</td>
    <td class="codeline">                             RegSubRegPairAndIdx &InsertedReg) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline"></td>
    <td class="lineNumber">581</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">  /// Return true if two machine instructions would produce identical values.</td>
    <td class="lineNumber">582</td>
    <td class="codeline">  /// Return true if two machine instructions would produce identical values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">  /// By default, this is only true when the two instructions</td>
    <td class="lineNumber">583</td>
    <td class="codeline">  /// By default, this is only true when the two instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">  /// are deemed identical except for defs. If this function is called when the</td>
    <td class="lineNumber">584</td>
    <td class="codeline">  /// are deemed identical except for defs. If this function is called when the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  /// IR is still in SSA form, the caller can pass the MachineRegisterInfo for</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  /// IR is still in SSA form, the caller can pass the MachineRegisterInfo for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">  /// aggressive checks.</td>
    <td class="lineNumber">586</td>
    <td class="codeline">  /// aggressive checks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">  virtual bool produceSameValue(const MachineInstr &MI0,</td>
    <td class="lineNumber">587</td>
    <td class="codeline">  virtual bool produceSameValue(const MachineInstr &MI0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">                                const MachineInstr &MI1,</td>
    <td class="lineNumber">588</td>
    <td class="codeline">                                const MachineInstr &MI1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">                                const MachineRegisterInfo *MRI = nullptr) const;</td>
    <td class="lineNumber">589</td>
    <td class="codeline">                                const MachineRegisterInfo *MRI = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">  /// \returns true if a branch from an instruction with opcode \p BranchOpc</td>
    <td class="lineNumber">591</td>
    <td class="codeline">  /// \returns true if a branch from an instruction with opcode \p BranchOpc</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">  ///  bytes is capable of jumping to a position \p BrOffset bytes away.</td>
    <td class="lineNumber">592</td>
    <td class="codeline">  ///  bytes is capable of jumping to a position \p BrOffset bytes away.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">  virtual bool isBranchOffsetInRange(unsigned BranchOpc,</td>
    <td class="lineNumber">593</td>
    <td class="codeline">  virtual bool isBranchOffsetInRange(unsigned BranchOpc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">                                     int64_t BrOffset) const {</td>
    <td class="lineNumber">594</td>
    <td class="codeline">                                     int64_t BrOffset) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">    llvm_unreachable("target did not implement");</td>
    <td class="lineNumber">595</td>
    <td class="codeline">    llvm_unreachable("target did not implement");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">  /// \returns The block that branch instruction \p MI jumps to.</td>
    <td class="lineNumber">598</td>
    <td class="codeline">  /// \returns The block that branch instruction \p MI jumps to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  virtual MachineBasicBlock *getBranchDestBlock(const MachineInstr &MI) const {</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  virtual MachineBasicBlock *getBranchDestBlock(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">    llvm_unreachable("target did not implement");</td>
    <td class="lineNumber">600</td>
    <td class="codeline">    llvm_unreachable("target did not implement");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">601</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline"></td>
    <td class="lineNumber">602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">  /// Insert an unconditional indirect branch at the end of \p MBB to \p</td>
    <td class="lineNumber">603</td>
    <td class="codeline">  /// Insert an unconditional indirect branch at the end of \p MBB to \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  /// NewDestBB. Optionally, insert the clobbered register restoring in \p</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  /// NewDestBB. Optionally, insert the clobbered register restoring in \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">  /// RestoreBB. \p BrOffset indicates the offset of \p NewDestBB relative to</td>
    <td class="lineNumber">605</td>
    <td class="codeline">  /// RestoreBB. \p BrOffset indicates the offset of \p NewDestBB relative to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">  /// the offset of the position to insert the new branch.</td>
    <td class="lineNumber">606</td>
    <td class="codeline">  /// the offset of the position to insert the new branch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">  virtual void insertIndirectBranch(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">607</td>
    <td class="codeline">  virtual void insertIndirectBranch(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">                                    MachineBasicBlock &NewDestBB,</td>
    <td class="lineNumber">608</td>
    <td class="codeline">                                    MachineBasicBlock &NewDestBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">                                    MachineBasicBlock &RestoreBB,</td>
    <td class="lineNumber">609</td>
    <td class="codeline">                                    MachineBasicBlock &RestoreBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">                                    const DebugLoc &DL, int64_t BrOffset = 0,</td>
    <td class="lineNumber">610</td>
    <td class="codeline">                                    const DebugLoc &DL, int64_t BrOffset = 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">                                    RegScavenger *RS = nullptr) const {</td>
    <td class="lineNumber">611</td>
    <td class="codeline">                                    RegScavenger *RS = nullptr) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">    llvm_unreachable("target did not implement");</td>
    <td class="lineNumber">612</td>
    <td class="codeline">    llvm_unreachable("target did not implement");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">613</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  /// Analyze the branching code at the end of MBB, returning</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  /// Analyze the branching code at the end of MBB, returning</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  /// true if it cannot be understood (e.g. it's a switch dispatch or isn't</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  /// true if it cannot be understood (e.g. it's a switch dispatch or isn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">  /// implemented for a target).  Upon success, this returns false and returns</td>
    <td class="lineNumber">617</td>
    <td class="codeline">  /// implemented for a target).  Upon success, this returns false and returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">  /// with the following information in various cases:</td>
    <td class="lineNumber">618</td>
    <td class="codeline">  /// with the following information in various cases:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">  /// 1. If this block ends with no branches (it just falls through to its succ)</td>
    <td class="lineNumber">620</td>
    <td class="codeline">  /// 1. If this block ends with no branches (it just falls through to its succ)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">  ///    just return false, leaving TBB/FBB null.</td>
    <td class="lineNumber">621</td>
    <td class="codeline">  ///    just return false, leaving TBB/FBB null.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">  /// 2. If this block ends with only an unconditional branch, it sets TBB to be</td>
    <td class="lineNumber">622</td>
    <td class="codeline">  /// 2. If this block ends with only an unconditional branch, it sets TBB to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  ///    the destination block.</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  ///    the destination block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  /// 3. If this block ends with a conditional branch and it falls through to a</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  /// 3. If this block ends with a conditional branch and it falls through to a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  ///    successor block, it sets TBB to be the branch destination block and a</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  ///    successor block, it sets TBB to be the branch destination block and a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  ///    list of operands that evaluate the condition. These operands can be</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  ///    list of operands that evaluate the condition. These operands can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">  ///    passed to other TargetInstrInfo methods to create new branches.</td>
    <td class="lineNumber">627</td>
    <td class="codeline">  ///    passed to other TargetInstrInfo methods to create new branches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">  /// 4. If this block ends with a conditional branch followed by an</td>
    <td class="lineNumber">628</td>
    <td class="codeline">  /// 4. If this block ends with a conditional branch followed by an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  ///    unconditional branch, it returns the 'true' destination in TBB, the</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  ///    unconditional branch, it returns the 'true' destination in TBB, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">  ///    'false' destination in FBB, and a list of operands that evaluate the</td>
    <td class="lineNumber">630</td>
    <td class="codeline">  ///    'false' destination in FBB, and a list of operands that evaluate the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">  ///    condition.  These operands can be passed to other TargetInstrInfo</td>
    <td class="lineNumber">631</td>
    <td class="codeline">  ///    condition.  These operands can be passed to other TargetInstrInfo</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  ///    methods to create new branches.</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  ///    methods to create new branches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  /// Note that removeBranch and insertBranch must be implemented to support</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  /// Note that removeBranch and insertBranch must be implemented to support</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">  /// cases where this method returns success.</td>
    <td class="lineNumber">635</td>
    <td class="codeline">  /// cases where this method returns success.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">636</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">  /// If AllowModify is true, then this routine is allowed to modify the basic</td>
    <td class="lineNumber">637</td>
    <td class="codeline">  /// If AllowModify is true, then this routine is allowed to modify the basic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">  /// block (e.g. delete instructions after the unconditional branch).</td>
    <td class="lineNumber">638</td>
    <td class="codeline">  /// block (e.g. delete instructions after the unconditional branch).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">639</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid</td>
    <td class="lineNumber">640</td>
    <td class="codeline">  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">  /// before calling this function.</td>
    <td class="lineNumber">641</td>
    <td class="codeline">  /// before calling this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">  virtual bool analyzeBranch(MachineBasicBlock &MBB, MachineBasicBlock *&TBB,</td>
    <td class="lineNumber">642</td>
    <td class="codeline">  virtual bool analyzeBranch(MachineBasicBlock &MBB, MachineBasicBlock *&TBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">                             MachineBasicBlock *&FBB,</td>
    <td class="lineNumber">643</td>
    <td class="codeline">                             MachineBasicBlock *&FBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">                             SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">644</td>
    <td class="codeline">                             SmallVectorImpl<MachineOperand> &Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">                             bool AllowModify = false) const {</td>
    <td class="lineNumber">645</td>
    <td class="codeline">                             bool AllowModify = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">646</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline"></td>
    <td class="lineNumber">648</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  /// Represents a predicate at the MachineFunction level.  The control flow a</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  /// Represents a predicate at the MachineFunction level.  The control flow a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">  /// MachineBranchPredicate represents is:</td>
    <td class="lineNumber">650</td>
    <td class="codeline">  /// MachineBranchPredicate represents is:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">  ///  Reg = LHS `Predicate` RHS         == ConditionDef</td>
    <td class="lineNumber">652</td>
    <td class="codeline">  ///  Reg = LHS `Predicate` RHS         == ConditionDef</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">  ///  if Reg then goto TrueDest else goto FalseDest</td>
    <td class="lineNumber">653</td>
    <td class="codeline">  ///  if Reg then goto TrueDest else goto FalseDest</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  struct MachineBranchPredicate {</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  struct MachineBranchPredicate {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">    enum ComparePredicate {</td>
    <td class="lineNumber">656</td>
    <td class="codeline">    enum ComparePredicate {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">      PRED_EQ,     // True if two values are equal</td>
    <td class="lineNumber">657</td>
    <td class="codeline">      PRED_EQ,     // True if two values are equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">      PRED_NE,     // True if two values are not equal</td>
    <td class="lineNumber">658</td>
    <td class="codeline">      PRED_NE,     // True if two values are not equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">      PRED_INVALID // Sentinel value</td>
    <td class="lineNumber">659</td>
    <td class="codeline">      PRED_INVALID // Sentinel value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">660</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline"></td>
    <td class="lineNumber">661</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">    ComparePredicate Predicate = PRED_INVALID;</td>
    <td class="lineNumber">662</td>
    <td class="codeline">    ComparePredicate Predicate = PRED_INVALID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">    MachineOperand LHS = MachineOperand::CreateImm(0);</td>
    <td class="lineNumber">663</td>
    <td class="codeline">    MachineOperand LHS = MachineOperand::CreateImm(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">    MachineOperand RHS = MachineOperand::CreateImm(0);</td>
    <td class="lineNumber">664</td>
    <td class="codeline">    MachineOperand RHS = MachineOperand::CreateImm(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">    MachineBasicBlock *TrueDest = nullptr;</td>
    <td class="lineNumber">665</td>
    <td class="codeline">    MachineBasicBlock *TrueDest = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">    MachineBasicBlock *FalseDest = nullptr;</td>
    <td class="lineNumber">666</td>
    <td class="codeline">    MachineBasicBlock *FalseDest = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">    MachineInstr *ConditionDef = nullptr;</td>
    <td class="lineNumber">667</td>
    <td class="codeline">    MachineInstr *ConditionDef = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline"></td>
    <td class="lineNumber">668</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">    /// SingleUseCondition is true if ConditionDef is dead except for the</td>
    <td class="lineNumber">669</td>
    <td class="codeline">    /// SingleUseCondition is true if ConditionDef is dead except for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">    /// branch(es) at the end of the basic block.</td>
    <td class="lineNumber">670</td>
    <td class="codeline">    /// branch(es) at the end of the basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">    ///</td>
    <td class="lineNumber">671</td>
    <td class="codeline">    ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">    bool SingleUseCondition = false;</td>
    <td class="lineNumber">672</td>
    <td class="codeline">    bool SingleUseCondition = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline"></td>
    <td class="lineNumber">673</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">    explicit MachineBranchPredicate() = default;</td>
    <td class="lineNumber">674</td>
    <td class="codeline">    explicit MachineBranchPredicate() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">675</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">  /// Analyze the branching code at the end of MBB and parse it into the</td>
    <td class="lineNumber">677</td>
    <td class="codeline">  /// Analyze the branching code at the end of MBB and parse it into the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">  /// MachineBranchPredicate structure if possible.  Returns false on success</td>
    <td class="lineNumber">678</td>
    <td class="codeline">  /// MachineBranchPredicate structure if possible.  Returns false on success</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  /// and true on failure.</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  /// and true on failure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">680</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">  /// If AllowModify is true, then this routine is allowed to modify the basic</td>
    <td class="lineNumber">681</td>
    <td class="codeline">  /// If AllowModify is true, then this routine is allowed to modify the basic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">  /// block (e.g. delete instructions after the unconditional branch).</td>
    <td class="lineNumber">682</td>
    <td class="codeline">  /// block (e.g. delete instructions after the unconditional branch).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">683</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  virtual bool analyzeBranchPredicate(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  virtual bool analyzeBranchPredicate(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">                                      MachineBranchPredicate &MBP,</td>
    <td class="lineNumber">685</td>
    <td class="codeline">                                      MachineBranchPredicate &MBP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">                                      bool AllowModify = false) const {</td>
    <td class="lineNumber">686</td>
    <td class="codeline">                                      bool AllowModify = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">687</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline"></td>
    <td class="lineNumber">689</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  /// Remove the branching code at the end of the specific MBB.</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  /// Remove the branching code at the end of the specific MBB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">  /// This is only invoked in cases where analyzeBranch returns success. It</td>
    <td class="lineNumber">691</td>
    <td class="codeline">  /// This is only invoked in cases where analyzeBranch returns success. It</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  /// returns the number of instructions that were removed.</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  /// returns the number of instructions that were removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  /// If \p BytesRemoved is non-null, report the change in code size from the</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  /// If \p BytesRemoved is non-null, report the change in code size from the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  /// removed instructions.</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  /// removed instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">  virtual unsigned removeBranch(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">695</td>
    <td class="codeline">  virtual unsigned removeBranch(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">                                int *BytesRemoved = nullptr) const {</td>
    <td class="lineNumber">696</td>
    <td class="codeline">                                int *BytesRemoved = nullptr) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement TargetInstrInfo::removeBranch!");</td>
    <td class="lineNumber">697</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement TargetInstrInfo::removeBranch!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline"></td>
    <td class="lineNumber">699</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  /// Insert branch code into the end of the specified MachineBasicBlock. The</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  /// Insert branch code into the end of the specified MachineBasicBlock. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">  /// operands to this method are the same as those returned by analyzeBranch.</td>
    <td class="lineNumber">701</td>
    <td class="codeline">  /// operands to this method are the same as those returned by analyzeBranch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">  /// This is only invoked in cases where analyzeBranch returns success. It</td>
    <td class="lineNumber">702</td>
    <td class="codeline">  /// This is only invoked in cases where analyzeBranch returns success. It</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">  /// returns the number of instructions inserted. If \p BytesAdded is non-null,</td>
    <td class="lineNumber">703</td>
    <td class="codeline">  /// returns the number of instructions inserted. If \p BytesAdded is non-null,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">  /// report the change in code size from the added instructions.</td>
    <td class="lineNumber">704</td>
    <td class="codeline">  /// report the change in code size from the added instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">705</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">  /// It is also invoked by tail merging to add unconditional branches in</td>
    <td class="lineNumber">706</td>
    <td class="codeline">  /// It is also invoked by tail merging to add unconditional branches in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">  /// cases where analyzeBranch doesn't apply because there was no original</td>
    <td class="lineNumber">707</td>
    <td class="codeline">  /// cases where analyzeBranch doesn't apply because there was no original</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">  /// branch to analyze.  At least this much must be implemented, else tail</td>
    <td class="lineNumber">708</td>
    <td class="codeline">  /// branch to analyze.  At least this much must be implemented, else tail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">  /// merging needs to be disabled.</td>
    <td class="lineNumber">709</td>
    <td class="codeline">  /// merging needs to be disabled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">710</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid</td>
    <td class="lineNumber">711</td>
    <td class="codeline">  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">  /// before calling this function.</td>
    <td class="lineNumber">712</td>
    <td class="codeline">  /// before calling this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">  virtual unsigned insertBranch(MachineBasicBlock &MBB, MachineBasicBlock *TBB,</td>
    <td class="lineNumber">713</td>
    <td class="codeline">  virtual unsigned insertBranch(MachineBasicBlock &MBB, MachineBasicBlock *TBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">                                MachineBasicBlock *FBB,</td>
    <td class="lineNumber">714</td>
    <td class="codeline">                                MachineBasicBlock *FBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">                                ArrayRef<MachineOperand> Cond,</td>
    <td class="lineNumber">715</td>
    <td class="codeline">                                ArrayRef<MachineOperand> Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">                                const DebugLoc &DL,</td>
    <td class="lineNumber">716</td>
    <td class="codeline">                                const DebugLoc &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">                                int *BytesAdded = nullptr) const {</td>
    <td class="lineNumber">717</td>
    <td class="codeline">                                int *BytesAdded = nullptr) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement TargetInstrInfo::insertBranch!");</td>
    <td class="lineNumber">718</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement TargetInstrInfo::insertBranch!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">719</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline"></td>
    <td class="lineNumber">720</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">  unsigned insertUnconditionalBranch(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">721</td>
    <td class="codeline">  unsigned insertUnconditionalBranch(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">                                     MachineBasicBlock *DestBB,</td>
    <td class="lineNumber">722</td>
    <td class="codeline">                                     MachineBasicBlock *DestBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">                                     const DebugLoc &DL,</td>
    <td class="lineNumber">723</td>
    <td class="codeline">                                     const DebugLoc &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">                                     int *BytesAdded = nullptr) const {</td>
    <td class="lineNumber">724</td>
    <td class="codeline">                                     int *BytesAdded = nullptr) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">    return insertBranch(MBB, DestBB, nullptr, ArrayRef<MachineOperand>(), DL,</td>
    <td class="lineNumber">725</td>
    <td class="codeline">    return insertBranch(MBB, DestBB, nullptr, ArrayRef<MachineOperand>(), DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">                        BytesAdded);</td>
    <td class="lineNumber">726</td>
    <td class="codeline">                        BytesAdded);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">727</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline"></td>
    <td class="lineNumber">728</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">  /// Object returned by analyzeLoopForPipelining. Allows software pipelining</td>
    <td class="lineNumber">729</td>
    <td class="codeline">  /// Object returned by analyzeLoopForPipelining. Allows software pipelining</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">  /// implementations to query attributes of the loop being pipelined and to</td>
    <td class="lineNumber">730</td>
    <td class="codeline">  /// implementations to query attributes of the loop being pipelined and to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">  /// apply target-specific updates to the loop once pipelining is complete.</td>
    <td class="lineNumber">731</td>
    <td class="codeline">  /// apply target-specific updates to the loop once pipelining is complete.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">  class PipelinerLoopInfo {</td>
    <td class="lineNumber">732</td>
    <td class="codeline">  class PipelinerLoopInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">733</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">    virtual ~PipelinerLoopInfo();</td>
    <td class="lineNumber">734</td>
    <td class="codeline">    virtual ~PipelinerLoopInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">    /// Return true if the given instruction should not be pipelined and should</td>
    <td class="lineNumber">735</td>
    <td class="codeline">    /// Return true if the given instruction should not be pipelined and should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">    /// be ignored. An example could be a loop comparison, or induction variable</td>
    <td class="lineNumber">736</td>
    <td class="codeline">    /// be ignored. An example could be a loop comparison, or induction variable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">    /// update with no users being pipelined.</td>
    <td class="lineNumber">737</td>
    <td class="codeline">    /// update with no users being pipelined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">    virtual bool shouldIgnoreForPipelining(const MachineInstr *MI) const = 0;</td>
    <td class="lineNumber">738</td>
    <td class="codeline">    virtual bool shouldIgnoreForPipelining(const MachineInstr *MI) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline"></td>
    <td class="lineNumber">739</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">    /// Return true if the proposed schedule should used.  Otherwise return</td>
    <td class="lineNumber">740</td>
    <td class="codeline">    /// Return true if the proposed schedule should used.  Otherwise return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">    /// false to not pipeline the loop. This function should be used to ensure</td>
    <td class="lineNumber">741</td>
    <td class="codeline">    /// false to not pipeline the loop. This function should be used to ensure</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">    /// that pipelined loops meet target-specific quality heuristics.</td>
    <td class="lineNumber">742</td>
    <td class="codeline">    /// that pipelined loops meet target-specific quality heuristics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">    virtual bool shouldUseSchedule(SwingSchedulerDAG &SSD, SMSchedule &SMS) {</td>
    <td class="lineNumber">743</td>
    <td class="codeline">    virtual bool shouldUseSchedule(SwingSchedulerDAG &SSD, SMSchedule &SMS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">744</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">745</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">    /// Create a condition to determine if the trip count of the loop is greater</td>
    <td class="lineNumber">747</td>
    <td class="codeline">    /// Create a condition to determine if the trip count of the loop is greater</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">    /// than TC, where TC is always one more than for the previous prologue or</td>
    <td class="lineNumber">748</td>
    <td class="codeline">    /// than TC, where TC is always one more than for the previous prologue or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">    /// 0 if this is being called for the outermost prologue.</td>
    <td class="lineNumber">749</td>
    <td class="codeline">    /// 0 if this is being called for the outermost prologue.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">    ///</td>
    <td class="lineNumber">750</td>
    <td class="codeline">    ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">    /// If the trip count is statically known to be greater than TC, return</td>
    <td class="lineNumber">751</td>
    <td class="codeline">    /// If the trip count is statically known to be greater than TC, return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">    /// true. If the trip count is statically known to be not greater than TC,</td>
    <td class="lineNumber">752</td>
    <td class="codeline">    /// true. If the trip count is statically known to be not greater than TC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">    /// return false. Otherwise return nullopt and fill out Cond with the test</td>
    <td class="lineNumber">753</td>
    <td class="codeline">    /// return false. Otherwise return nullopt and fill out Cond with the test</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">    /// condition.</td>
    <td class="lineNumber">754</td>
    <td class="codeline">    /// condition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">    ///</td>
    <td class="lineNumber">755</td>
    <td class="codeline">    ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">    /// Note: This hook is guaranteed to be called from the innermost to the</td>
    <td class="lineNumber">756</td>
    <td class="codeline">    /// Note: This hook is guaranteed to be called from the innermost to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">    /// outermost prologue of the loop being software pipelined.</td>
    <td class="lineNumber">757</td>
    <td class="codeline">    /// outermost prologue of the loop being software pipelined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">    virtual std::optional<bool></td>
    <td class="lineNumber">758</td>
    <td class="codeline">    virtual std::optional<bool></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">    createTripCountGreaterCondition(int TC, MachineBasicBlock &MBB,</td>
    <td class="lineNumber">759</td>
    <td class="codeline">    createTripCountGreaterCondition(int TC, MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">                                    SmallVectorImpl<MachineOperand> &Cond) = 0;</td>
    <td class="lineNumber">760</td>
    <td class="codeline">                                    SmallVectorImpl<MachineOperand> &Cond) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline"></td>
    <td class="lineNumber">761</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">    /// Modify the loop such that the trip count is</td>
    <td class="lineNumber">762</td>
    <td class="codeline">    /// Modify the loop such that the trip count is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">    /// OriginalTC + TripCountAdjust.</td>
    <td class="lineNumber">763</td>
    <td class="codeline">    /// OriginalTC + TripCountAdjust.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">    virtual void adjustTripCount(int TripCountAdjust) = 0;</td>
    <td class="lineNumber">764</td>
    <td class="codeline">    virtual void adjustTripCount(int TripCountAdjust) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline"></td>
    <td class="lineNumber">765</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">    /// Called when the loop's preheader has been modified to NewPreheader.</td>
    <td class="lineNumber">766</td>
    <td class="codeline">    /// Called when the loop's preheader has been modified to NewPreheader.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">    virtual void setPreheader(MachineBasicBlock *NewPreheader) = 0;</td>
    <td class="lineNumber">767</td>
    <td class="codeline">    virtual void setPreheader(MachineBasicBlock *NewPreheader) = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline"></td>
    <td class="lineNumber">768</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">    /// Called when the loop is being removed. Any instructions in the preheader</td>
    <td class="lineNumber">769</td>
    <td class="codeline">    /// Called when the loop is being removed. Any instructions in the preheader</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">    /// should be removed.</td>
    <td class="lineNumber">770</td>
    <td class="codeline">    /// should be removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">    ///</td>
    <td class="lineNumber">771</td>
    <td class="codeline">    ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">    /// Once this function is called, no other functions on this object are</td>
    <td class="lineNumber">772</td>
    <td class="codeline">    /// Once this function is called, no other functions on this object are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">    /// valid; the loop has been removed.</td>
    <td class="lineNumber">773</td>
    <td class="codeline">    /// valid; the loop has been removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">    virtual void disposed() = 0;</td>
    <td class="lineNumber">774</td>
    <td class="codeline">    virtual void disposed() = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">775</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline"></td>
    <td class="lineNumber">776</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">  /// Analyze loop L, which must be a single-basic-block loop, and if the</td>
    <td class="lineNumber">777</td>
    <td class="codeline">  /// Analyze loop L, which must be a single-basic-block loop, and if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">  /// conditions can be understood enough produce a PipelinerLoopInfo object.</td>
    <td class="lineNumber">778</td>
    <td class="codeline">  /// conditions can be understood enough produce a PipelinerLoopInfo object.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">  virtual std::unique_ptr<PipelinerLoopInfo></td>
    <td class="lineNumber">779</td>
    <td class="codeline">  virtual std::unique_ptr<PipelinerLoopInfo></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">  analyzeLoopForPipelining(MachineBasicBlock *LoopBB) const {</td>
    <td class="lineNumber">780</td>
    <td class="codeline">  analyzeLoopForPipelining(MachineBasicBlock *LoopBB) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">781</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">782</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline"></td>
    <td class="lineNumber">783</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">  /// Analyze the loop code, return true if it cannot be understood. Upon</td>
    <td class="lineNumber">784</td>
    <td class="codeline">  /// Analyze the loop code, return true if it cannot be understood. Upon</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">  /// success, this function returns false and returns information about the</td>
    <td class="lineNumber">785</td>
    <td class="codeline">  /// success, this function returns false and returns information about the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">  /// induction variable and compare instruction used at the end.</td>
    <td class="lineNumber">786</td>
    <td class="codeline">  /// induction variable and compare instruction used at the end.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">  virtual bool analyzeLoop(MachineLoop &L, MachineInstr *&IndVarInst,</td>
    <td class="lineNumber">787</td>
    <td class="codeline">  virtual bool analyzeLoop(MachineLoop &L, MachineInstr *&IndVarInst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">                           MachineInstr *&CmpInst) const {</td>
    <td class="lineNumber">788</td>
    <td class="codeline">                           MachineInstr *&CmpInst) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">789</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">790</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">  /// Generate code to reduce the loop iteration by one and check if the loop</td>
    <td class="lineNumber">792</td>
    <td class="codeline">  /// Generate code to reduce the loop iteration by one and check if the loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">  /// is finished.  Return the value/register of the new loop count.  We need</td>
    <td class="lineNumber">793</td>
    <td class="codeline">  /// is finished.  Return the value/register of the new loop count.  We need</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">  /// this function when peeling off one or more iterations of a loop. This</td>
    <td class="lineNumber">794</td>
    <td class="codeline">  /// this function when peeling off one or more iterations of a loop. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">  /// function assumes the nth iteration is peeled first.</td>
    <td class="lineNumber">795</td>
    <td class="codeline">  /// function assumes the nth iteration is peeled first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">  virtual unsigned reduceLoopCount(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">796</td>
    <td class="codeline">  virtual unsigned reduceLoopCount(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">                                   MachineBasicBlock &PreHeader,</td>
    <td class="lineNumber">797</td>
    <td class="codeline">                                   MachineBasicBlock &PreHeader,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">                                   MachineInstr *IndVar, MachineInstr &Cmp,</td>
    <td class="lineNumber">798</td>
    <td class="codeline">                                   MachineInstr *IndVar, MachineInstr &Cmp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">                                   SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">799</td>
    <td class="codeline">                                   SmallVectorImpl<MachineOperand> &Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">                                   SmallVectorImpl<MachineInstr *> &PrevInsts,</td>
    <td class="lineNumber">800</td>
    <td class="codeline">                                   SmallVectorImpl<MachineInstr *> &PrevInsts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">                                   unsigned Iter, unsigned MaxIter) const {</td>
    <td class="lineNumber">801</td>
    <td class="codeline">                                   unsigned Iter, unsigned MaxIter) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement ReduceLoopCount");</td>
    <td class="lineNumber">802</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement ReduceLoopCount");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">803</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline"></td>
    <td class="lineNumber">804</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">  /// Delete the instruction OldInst and everything after it, replacing it with</td>
    <td class="lineNumber">805</td>
    <td class="codeline">  /// Delete the instruction OldInst and everything after it, replacing it with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">  /// an unconditional branch to NewDest. This is used by the tail merging pass.</td>
    <td class="lineNumber">806</td>
    <td class="codeline">  /// an unconditional branch to NewDest. This is used by the tail merging pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">  virtual void ReplaceTailWithBranchTo(MachineBasicBlock::iterator Tail,</td>
    <td class="lineNumber">807</td>
    <td class="codeline">  virtual void ReplaceTailWithBranchTo(MachineBasicBlock::iterator Tail,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">                                       MachineBasicBlock *NewDest) const;</td>
    <td class="lineNumber">808</td>
    <td class="codeline">                                       MachineBasicBlock *NewDest) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline"></td>
    <td class="lineNumber">809</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">  /// Return true if it's legal to split the given basic</td>
    <td class="lineNumber">810</td>
    <td class="codeline">  /// Return true if it's legal to split the given basic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  /// block at the specified instruction (i.e. instruction would be the start</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  /// block at the specified instruction (i.e. instruction would be the start</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">  /// of a new basic block).</td>
    <td class="lineNumber">812</td>
    <td class="codeline">  /// of a new basic block).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  virtual bool isLegalToSplitMBBAt(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  virtual bool isLegalToSplitMBBAt(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">                                   MachineBasicBlock::iterator MBBI) const {</td>
    <td class="lineNumber">814</td>
    <td class="codeline">                                   MachineBasicBlock::iterator MBBI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">815</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">816</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline"></td>
    <td class="lineNumber">817</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">  /// Return true if it's profitable to predicate</td>
    <td class="lineNumber">818</td>
    <td class="codeline">  /// Return true if it's profitable to predicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">  /// instructions with accumulated instruction latency of "NumCycles"</td>
    <td class="lineNumber">819</td>
    <td class="codeline">  /// instructions with accumulated instruction latency of "NumCycles"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  /// of the specified basic block, where the probability of the instructions</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  /// of the specified basic block, where the probability of the instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  /// being executed is given by Probability, and Confidence is a measure</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  /// being executed is given by Probability, and Confidence is a measure</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">  /// of our confidence that it will be properly predicted.</td>
    <td class="lineNumber">822</td>
    <td class="codeline">  /// of our confidence that it will be properly predicted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">  virtual bool isProfitableToIfCvt(MachineBasicBlock &MBB, unsigned NumCycles,</td>
    <td class="lineNumber">823</td>
    <td class="codeline">  virtual bool isProfitableToIfCvt(MachineBasicBlock &MBB, unsigned NumCycles,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">                                   unsigned ExtraPredCycles,</td>
    <td class="lineNumber">824</td>
    <td class="codeline">                                   unsigned ExtraPredCycles,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">                                   BranchProbability Probability) const {</td>
    <td class="lineNumber">825</td>
    <td class="codeline">                                   BranchProbability Probability) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">826</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">827</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline"></td>
    <td class="lineNumber">828</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">  /// Second variant of isProfitableToIfCvt. This one</td>
    <td class="lineNumber">829</td>
    <td class="codeline">  /// Second variant of isProfitableToIfCvt. This one</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">  /// checks for the case where two basic blocks from true and false path</td>
    <td class="lineNumber">830</td>
    <td class="codeline">  /// checks for the case where two basic blocks from true and false path</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  /// of a if-then-else (diamond) are predicated on mutually exclusive</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  /// of a if-then-else (diamond) are predicated on mutually exclusive</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">  /// predicates, where the probability of the true path being taken is given</td>
    <td class="lineNumber">832</td>
    <td class="codeline">  /// predicates, where the probability of the true path being taken is given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">  /// by Probability, and Confidence is a measure of our confidence that it</td>
    <td class="lineNumber">833</td>
    <td class="codeline">  /// by Probability, and Confidence is a measure of our confidence that it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  /// will be properly predicted.</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  /// will be properly predicted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">  virtual bool isProfitableToIfCvt(MachineBasicBlock &TMBB, unsigned NumTCycles,</td>
    <td class="lineNumber">835</td>
    <td class="codeline">  virtual bool isProfitableToIfCvt(MachineBasicBlock &TMBB, unsigned NumTCycles,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">                                   unsigned ExtraTCycles,</td>
    <td class="lineNumber">836</td>
    <td class="codeline">                                   unsigned ExtraTCycles,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">                                   MachineBasicBlock &FMBB, unsigned NumFCycles,</td>
    <td class="lineNumber">837</td>
    <td class="codeline">                                   MachineBasicBlock &FMBB, unsigned NumFCycles,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">                                   unsigned ExtraFCycles,</td>
    <td class="lineNumber">838</td>
    <td class="codeline">                                   unsigned ExtraFCycles,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">                                   BranchProbability Probability) const {</td>
    <td class="lineNumber">839</td>
    <td class="codeline">                                   BranchProbability Probability) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">840</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">841</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline"></td>
    <td class="lineNumber">842</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">  /// Return true if it's profitable for if-converter to duplicate instructions</td>
    <td class="lineNumber">843</td>
    <td class="codeline">  /// Return true if it's profitable for if-converter to duplicate instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">  /// of specified accumulated instruction latencies in the specified MBB to</td>
    <td class="lineNumber">844</td>
    <td class="codeline">  /// of specified accumulated instruction latencies in the specified MBB to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">  /// enable if-conversion.</td>
    <td class="lineNumber">845</td>
    <td class="codeline">  /// enable if-conversion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">  /// The probability of the instructions being executed is given by</td>
    <td class="lineNumber">846</td>
    <td class="codeline">  /// The probability of the instructions being executed is given by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  /// Probability, and Confidence is a measure of our confidence that it</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  /// Probability, and Confidence is a measure of our confidence that it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  /// will be properly predicted.</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  /// will be properly predicted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">  virtual bool isProfitableToDupForIfCvt(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">849</td>
    <td class="codeline">  virtual bool isProfitableToDupForIfCvt(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">                                         unsigned NumCycles,</td>
    <td class="lineNumber">850</td>
    <td class="codeline">                                         unsigned NumCycles,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">                                         BranchProbability Probability) const {</td>
    <td class="lineNumber">851</td>
    <td class="codeline">                                         BranchProbability Probability) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">852</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline"></td>
    <td class="lineNumber">854</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">  /// Return the increase in code size needed to predicate a contiguous run of</td>
    <td class="lineNumber">855</td>
    <td class="codeline">  /// Return the increase in code size needed to predicate a contiguous run of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">  /// NumInsts instructions.</td>
    <td class="lineNumber">856</td>
    <td class="codeline">  /// NumInsts instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">  virtual unsigned extraSizeToPredicateInstructions(const MachineFunction &MF,</td>
    <td class="lineNumber">857</td>
    <td class="codeline">  virtual unsigned extraSizeToPredicateInstructions(const MachineFunction &MF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">                                                    unsigned NumInsts) const {</td>
    <td class="lineNumber">858</td>
    <td class="codeline">                                                    unsigned NumInsts) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">859</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">860</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline"></td>
    <td class="lineNumber">861</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">  /// Return an estimate for the code size reduction (in bytes) which will be</td>
    <td class="lineNumber">862</td>
    <td class="codeline">  /// Return an estimate for the code size reduction (in bytes) which will be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">  /// caused by removing the given branch instruction during if-conversion.</td>
    <td class="lineNumber">863</td>
    <td class="codeline">  /// caused by removing the given branch instruction during if-conversion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">  virtual unsigned predictBranchSizeForIfCvt(MachineInstr &MI) const {</td>
    <td class="lineNumber">864</td>
    <td class="codeline">  virtual unsigned predictBranchSizeForIfCvt(MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">    return getInstSizeInBytes(MI);</td>
    <td class="lineNumber">865</td>
    <td class="codeline">    return getInstSizeInBytes(MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">866</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline"></td>
    <td class="lineNumber">867</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">  /// Return true if it's profitable to unpredicate</td>
    <td class="lineNumber">868</td>
    <td class="codeline">  /// Return true if it's profitable to unpredicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">  /// one side of a 'diamond', i.e. two sides of if-else predicated on mutually</td>
    <td class="lineNumber">869</td>
    <td class="codeline">  /// one side of a 'diamond', i.e. two sides of if-else predicated on mutually</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  /// exclusive predicates.</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  /// exclusive predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">  /// e.g.</td>
    <td class="lineNumber">871</td>
    <td class="codeline">  /// e.g.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">  ///   subeq  r0, r1, #1</td>
    <td class="lineNumber">872</td>
    <td class="codeline">  ///   subeq  r0, r1, #1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">  ///   addne  r0, r1, #1</td>
    <td class="lineNumber">873</td>
    <td class="codeline">  ///   addne  r0, r1, #1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">  /// =></td>
    <td class="lineNumber">874</td>
    <td class="codeline">  /// =></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  ///   sub    r0, r1, #1</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  ///   sub    r0, r1, #1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  ///   addne  r0, r1, #1</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  ///   addne  r0, r1, #1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">877</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">  /// This may be profitable is conditional instructions are always executed.</td>
    <td class="lineNumber">878</td>
    <td class="codeline">  /// This may be profitable is conditional instructions are always executed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">  virtual bool isProfitableToUnpredicate(MachineBasicBlock &TMBB,</td>
    <td class="lineNumber">879</td>
    <td class="codeline">  virtual bool isProfitableToUnpredicate(MachineBasicBlock &TMBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">                                         MachineBasicBlock &FMBB) const {</td>
    <td class="lineNumber">880</td>
    <td class="codeline">                                         MachineBasicBlock &FMBB) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">881</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">882</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline"></td>
    <td class="lineNumber">883</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">  /// Return true if it is possible to insert a select</td>
    <td class="lineNumber">884</td>
    <td class="codeline">  /// Return true if it is possible to insert a select</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">  /// instruction that chooses between TrueReg and FalseReg based on the</td>
    <td class="lineNumber">885</td>
    <td class="codeline">  /// instruction that chooses between TrueReg and FalseReg based on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">  /// condition code in Cond.</td>
    <td class="lineNumber">886</td>
    <td class="codeline">  /// condition code in Cond.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">887</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">  /// When successful, also return the latency in cycles from TrueReg,</td>
    <td class="lineNumber">888</td>
    <td class="codeline">  /// When successful, also return the latency in cycles from TrueReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">  /// FalseReg, and Cond to the destination register. In most cases, a select</td>
    <td class="lineNumber">889</td>
    <td class="codeline">  /// FalseReg, and Cond to the destination register. In most cases, a select</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">  /// instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1</td>
    <td class="lineNumber">890</td>
    <td class="codeline">  /// instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">891</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">  /// Some x86 implementations have 2-cycle cmov instructions.</td>
    <td class="lineNumber">892</td>
    <td class="codeline">  /// Some x86 implementations have 2-cycle cmov instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">893</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">  /// @param MBB         Block where select instruction would be inserted.</td>
    <td class="lineNumber">894</td>
    <td class="codeline">  /// @param MBB         Block where select instruction would be inserted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">  /// @param Cond        Condition returned by analyzeBranch.</td>
    <td class="lineNumber">895</td>
    <td class="codeline">  /// @param Cond        Condition returned by analyzeBranch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">  /// @param DstReg      Virtual dest register that the result should write to.</td>
    <td class="lineNumber">896</td>
    <td class="codeline">  /// @param DstReg      Virtual dest register that the result should write to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">  /// @param TrueReg     Virtual register to select when Cond is true.</td>
    <td class="lineNumber">897</td>
    <td class="codeline">  /// @param TrueReg     Virtual register to select when Cond is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">  /// @param FalseReg    Virtual register to select when Cond is false.</td>
    <td class="lineNumber">898</td>
    <td class="codeline">  /// @param FalseReg    Virtual register to select when Cond is false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">  /// @param CondCycles  Latency from Cond+Branch to select output.</td>
    <td class="lineNumber">899</td>
    <td class="codeline">  /// @param CondCycles  Latency from Cond+Branch to select output.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">  /// @param TrueCycles  Latency from TrueReg to select output.</td>
    <td class="lineNumber">900</td>
    <td class="codeline">  /// @param TrueCycles  Latency from TrueReg to select output.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">  /// @param FalseCycles Latency from FalseReg to select output.</td>
    <td class="lineNumber">901</td>
    <td class="codeline">  /// @param FalseCycles Latency from FalseReg to select output.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">  virtual bool canInsertSelect(const MachineBasicBlock &MBB,</td>
    <td class="lineNumber">902</td>
    <td class="codeline">  virtual bool canInsertSelect(const MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">                               ArrayRef<MachineOperand> Cond, Register DstReg,</td>
    <td class="lineNumber">903</td>
    <td class="codeline">                               ArrayRef<MachineOperand> Cond, Register DstReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">                               Register TrueReg, Register FalseReg,</td>
    <td class="lineNumber">904</td>
    <td class="codeline">                               Register TrueReg, Register FalseReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">                               int &CondCycles, int &TrueCycles,</td>
    <td class="lineNumber">905</td>
    <td class="codeline">                               int &CondCycles, int &TrueCycles,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">                               int &FalseCycles) const {</td>
    <td class="lineNumber">906</td>
    <td class="codeline">                               int &FalseCycles) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">907</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">908</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline"></td>
    <td class="lineNumber">909</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">  /// Insert a select instruction into MBB before I that will copy TrueReg to</td>
    <td class="lineNumber">910</td>
    <td class="codeline">  /// Insert a select instruction into MBB before I that will copy TrueReg to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">  /// DstReg when Cond is true, and FalseReg to DstReg when Cond is false.</td>
    <td class="lineNumber">911</td>
    <td class="codeline">  /// DstReg when Cond is true, and FalseReg to DstReg when Cond is false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">912</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">  /// This function can only be called after canInsertSelect() returned true.</td>
    <td class="lineNumber">913</td>
    <td class="codeline">  /// This function can only be called after canInsertSelect() returned true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">  /// The condition in Cond comes from analyzeBranch, and it can be assumed</td>
    <td class="lineNumber">914</td>
    <td class="codeline">  /// The condition in Cond comes from analyzeBranch, and it can be assumed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">  /// that the same flags or registers required by Cond are available at the</td>
    <td class="lineNumber">915</td>
    <td class="codeline">  /// that the same flags or registers required by Cond are available at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">  /// insertion point.</td>
    <td class="lineNumber">916</td>
    <td class="codeline">  /// insertion point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">917</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">  /// @param MBB      Block where select instruction should be inserted.</td>
    <td class="lineNumber">918</td>
    <td class="codeline">  /// @param MBB      Block where select instruction should be inserted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">  /// @param I        Insertion point.</td>
    <td class="lineNumber">919</td>
    <td class="codeline">  /// @param I        Insertion point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">  /// @param DL       Source location for debugging.</td>
    <td class="lineNumber">920</td>
    <td class="codeline">  /// @param DL       Source location for debugging.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">  /// @param DstReg   Virtual register to be defined by select instruction.</td>
    <td class="lineNumber">921</td>
    <td class="codeline">  /// @param DstReg   Virtual register to be defined by select instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">  /// @param Cond     Condition as computed by analyzeBranch.</td>
    <td class="lineNumber">922</td>
    <td class="codeline">  /// @param Cond     Condition as computed by analyzeBranch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">  /// @param TrueReg  Virtual register to copy when Cond is true.</td>
    <td class="lineNumber">923</td>
    <td class="codeline">  /// @param TrueReg  Virtual register to copy when Cond is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">  /// @param FalseReg Virtual register to copy when Cons is false.</td>
    <td class="lineNumber">924</td>
    <td class="codeline">  /// @param FalseReg Virtual register to copy when Cons is false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">  virtual void insertSelect(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">925</td>
    <td class="codeline">  virtual void insertSelect(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">                            MachineBasicBlock::iterator I, const DebugLoc &DL,</td>
    <td class="lineNumber">926</td>
    <td class="codeline">                            MachineBasicBlock::iterator I, const DebugLoc &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">                            Register DstReg, ArrayRef<MachineOperand> Cond,</td>
    <td class="lineNumber">927</td>
    <td class="codeline">                            Register DstReg, ArrayRef<MachineOperand> Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">                            Register TrueReg, Register FalseReg) const {</td>
    <td class="lineNumber">928</td>
    <td class="codeline">                            Register TrueReg, Register FalseReg) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement TargetInstrInfo::insertSelect!");</td>
    <td class="lineNumber">929</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement TargetInstrInfo::insertSelect!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">930</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline"></td>
    <td class="lineNumber">931</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">  /// Analyze the given select instruction, returning true if</td>
    <td class="lineNumber">932</td>
    <td class="codeline">  /// Analyze the given select instruction, returning true if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">  /// it cannot be understood. It is assumed that MI->isSelect() is true.</td>
    <td class="lineNumber">933</td>
    <td class="codeline">  /// it cannot be understood. It is assumed that MI->isSelect() is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">934</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">  /// When successful, return the controlling condition and the operands that</td>
    <td class="lineNumber">935</td>
    <td class="codeline">  /// When successful, return the controlling condition and the operands that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">  /// determine the true and false result values.</td>
    <td class="lineNumber">936</td>
    <td class="codeline">  /// determine the true and false result values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">937</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">  ///   Result = SELECT Cond, TrueOp, FalseOp</td>
    <td class="lineNumber">938</td>
    <td class="codeline">  ///   Result = SELECT Cond, TrueOp, FalseOp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">939</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">  /// Some targets can optimize select instructions, for example by predicating</td>
    <td class="lineNumber">940</td>
    <td class="codeline">  /// Some targets can optimize select instructions, for example by predicating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">  /// the instruction defining one of the operands. Such targets should set</td>
    <td class="lineNumber">941</td>
    <td class="codeline">  /// the instruction defining one of the operands. Such targets should set</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">  /// Optimizable.</td>
    <td class="lineNumber">942</td>
    <td class="codeline">  /// Optimizable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">943</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">  /// @param         MI Select instruction to analyze.</td>
    <td class="lineNumber">944</td>
    <td class="codeline">  /// @param         MI Select instruction to analyze.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">  /// @param Cond    Condition controlling the select.</td>
    <td class="lineNumber">945</td>
    <td class="codeline">  /// @param Cond    Condition controlling the select.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">  /// @param TrueOp  Operand number of the value selected when Cond is true.</td>
    <td class="lineNumber">946</td>
    <td class="codeline">  /// @param TrueOp  Operand number of the value selected when Cond is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">  /// @param FalseOp Operand number of the value selected when Cond is false.</td>
    <td class="lineNumber">947</td>
    <td class="codeline">  /// @param FalseOp Operand number of the value selected when Cond is false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">  /// @param Optimizable Returned as true if MI is optimizable.</td>
    <td class="lineNumber">948</td>
    <td class="codeline">  /// @param Optimizable Returned as true if MI is optimizable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">  /// @returns False on success.</td>
    <td class="lineNumber">949</td>
    <td class="codeline">  /// @returns False on success.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">  virtual bool analyzeSelect(const MachineInstr &MI,</td>
    <td class="lineNumber">950</td>
    <td class="codeline">  virtual bool analyzeSelect(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">                             SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">951</td>
    <td class="codeline">                             SmallVectorImpl<MachineOperand> &Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">                             unsigned &TrueOp, unsigned &FalseOp,</td>
    <td class="lineNumber">952</td>
    <td class="codeline">                             unsigned &TrueOp, unsigned &FalseOp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">                             bool &Optimizable) const {</td>
    <td class="lineNumber">953</td>
    <td class="codeline">                             bool &Optimizable) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">    assert(MI.getDesc().isSelect() && "MI must be a select instruction");</td>
    <td class="lineNumber">954</td>
    <td class="codeline">    assert(MI.getDesc().isSelect() && "MI must be a select instruction");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">955</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">956</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline"></td>
    <td class="lineNumber">957</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">  /// Given a select instruction that was understood by</td>
    <td class="lineNumber">958</td>
    <td class="codeline">  /// Given a select instruction that was understood by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">  /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by</td>
    <td class="lineNumber">959</td>
    <td class="codeline">  /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">  /// merging it with one of its operands. Returns NULL on failure.</td>
    <td class="lineNumber">960</td>
    <td class="codeline">  /// merging it with one of its operands. Returns NULL on failure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">961</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">  /// When successful, returns the new select instruction. The client is</td>
    <td class="lineNumber">962</td>
    <td class="codeline">  /// When successful, returns the new select instruction. The client is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">  /// responsible for deleting MI.</td>
    <td class="lineNumber">963</td>
    <td class="codeline">  /// responsible for deleting MI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">964</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">  /// If both sides of the select can be optimized, PreferFalse is used to pick</td>
    <td class="lineNumber">965</td>
    <td class="codeline">  /// If both sides of the select can be optimized, PreferFalse is used to pick</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  /// a side.</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  /// a side.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  /// @param MI          Optimizable select instruction.</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  /// @param MI          Optimizable select instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">  /// @param NewMIs     Set that record all MIs in the basic block up to \p</td>
    <td class="lineNumber">969</td>
    <td class="codeline">  /// @param NewMIs     Set that record all MIs in the basic block up to \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">  /// MI. Has to be updated with any newly created MI or deleted ones.</td>
    <td class="lineNumber">970</td>
    <td class="codeline">  /// MI. Has to be updated with any newly created MI or deleted ones.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">  /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.</td>
    <td class="lineNumber">971</td>
    <td class="codeline">  /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">  /// @returns Optimized instruction or NULL.</td>
    <td class="lineNumber">972</td>
    <td class="codeline">  /// @returns Optimized instruction or NULL.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">  virtual MachineInstr *optimizeSelect(MachineInstr &MI,</td>
    <td class="lineNumber">973</td>
    <td class="codeline">  virtual MachineInstr *optimizeSelect(MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">                                       SmallPtrSetImpl<MachineInstr *> &NewMIs,</td>
    <td class="lineNumber">974</td>
    <td class="codeline">                                       SmallPtrSetImpl<MachineInstr *> &NewMIs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">                                       bool PreferFalse = false) const {</td>
    <td class="lineNumber">975</td>
    <td class="codeline">                                       bool PreferFalse = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">    // This function must be implemented if Optimizable is ever set.</td>
    <td class="lineNumber">976</td>
    <td class="codeline">    // This function must be implemented if Optimizable is ever set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">    llvm_unreachable("Target must implement TargetInstrInfo::optimizeSelect!");</td>
    <td class="lineNumber">977</td>
    <td class="codeline">    llvm_unreachable("Target must implement TargetInstrInfo::optimizeSelect!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">978</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline"></td>
    <td class="lineNumber">979</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">  /// Emit instructions to copy a pair of physical registers.</td>
    <td class="lineNumber">980</td>
    <td class="codeline">  /// Emit instructions to copy a pair of physical registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">981</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">  /// This function should support copies within any legal register class as</td>
    <td class="lineNumber">982</td>
    <td class="codeline">  /// This function should support copies within any legal register class as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">  /// well as any cross-class copies created during instruction selection.</td>
    <td class="lineNumber">983</td>
    <td class="codeline">  /// well as any cross-class copies created during instruction selection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">984</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">  /// The source and destination registers may overlap, which may require a</td>
    <td class="lineNumber">985</td>
    <td class="codeline">  /// The source and destination registers may overlap, which may require a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">  /// careful implementation when multiple copy instructions are required for</td>
    <td class="lineNumber">986</td>
    <td class="codeline">  /// careful implementation when multiple copy instructions are required for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">  /// large registers. See for example the ARM target.</td>
    <td class="lineNumber">987</td>
    <td class="codeline">  /// large registers. See for example the ARM target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">  virtual void copyPhysReg(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">988</td>
    <td class="codeline">  virtual void copyPhysReg(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">                           MachineBasicBlock::iterator MI, const DebugLoc &DL,</td>
    <td class="lineNumber">989</td>
    <td class="codeline">                           MachineBasicBlock::iterator MI, const DebugLoc &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">                           MCRegister DestReg, MCRegister SrcReg,</td>
    <td class="lineNumber">990</td>
    <td class="codeline">                           MCRegister DestReg, MCRegister SrcReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">                           bool KillSrc) const {</td>
    <td class="lineNumber">991</td>
    <td class="codeline">                           bool KillSrc) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement TargetInstrInfo::copyPhysReg!");</td>
    <td class="lineNumber">992</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement TargetInstrInfo::copyPhysReg!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">993</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline"></td>
    <td class="lineNumber">994</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">  /// Allow targets to tell MachineVerifier whether a specific register</td>
    <td class="lineNumber">995</td>
    <td class="codeline">  /// Allow targets to tell MachineVerifier whether a specific register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">  /// MachineOperand can be used as part of PC-relative addressing.</td>
    <td class="lineNumber">996</td>
    <td class="codeline">  /// MachineOperand can be used as part of PC-relative addressing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">  /// PC-relative addressing modes in many CISC architectures contain</td>
    <td class="lineNumber">997</td>
    <td class="codeline">  /// PC-relative addressing modes in many CISC architectures contain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  /// (non-PC) registers as offsets or scaling values, which inherently</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  /// (non-PC) registers as offsets or scaling values, which inherently</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">  /// tags the corresponding MachineOperand with OPERAND_PCREL.</td>
    <td class="lineNumber">999</td>
    <td class="codeline">  /// tags the corresponding MachineOperand with OPERAND_PCREL.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">  /// @param MO The MachineOperand in question. MO.isReg() should always</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">  /// @param MO The MachineOperand in question. MO.isReg() should always</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">  /// be true.</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">  /// be true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">  /// @return Whether this operand is allowed to be used PC-relatively.</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">  /// @return Whether this operand is allowed to be used PC-relatively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">  virtual bool isPCRelRegisterOperandLegal(const MachineOperand &MO) const {</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">  virtual bool isPCRelRegisterOperandLegal(const MachineOperand &MO) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline"></td>
    <td class="lineNumber">1007</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">  /// Return an index for MachineJumpTableInfo if \p insn is an indirect jump</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">  /// Return an index for MachineJumpTableInfo if \p insn is an indirect jump</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">  /// using a jump table, otherwise -1.</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">  /// using a jump table, otherwise -1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">  virtual int getJumpTableIndex(const MachineInstr &MI) const { return -1; }</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">  virtual int getJumpTableIndex(const MachineInstr &MI) const { return -1; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline"></td>
    <td class="lineNumber">1011</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">  /// Target-dependent implementation for IsCopyInstr.</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">  /// Target-dependent implementation for IsCopyInstr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">  /// If the specific machine instruction is a instruction that moves/copies</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">  /// If the specific machine instruction is a instruction that moves/copies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">  /// value from one register to another register return destination and source</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">  /// value from one register to another register return destination and source</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">  /// registers as machine operands.</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">  /// registers as machine operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">  virtual std::optional<DestSourcePair></td>
    <td class="lineNumber">1017</td>
    <td class="codeline">  virtual std::optional<DestSourcePair></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">  isCopyInstrImpl(const MachineInstr &MI) const {</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">  isCopyInstrImpl(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline"></td>
    <td class="lineNumber">1021</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">  /// Return true if the given terminator MI is not expected to spill. This</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">  /// Return true if the given terminator MI is not expected to spill. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">  /// sets the live interval as not spillable and adjusts phi node lowering to</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">  /// sets the live interval as not spillable and adjusts phi node lowering to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">  /// not introduce copies after the terminator. Use with care, these are</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">  /// not introduce copies after the terminator. Use with care, these are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">  /// currently used for hardware loop intrinsics in very controlled situations,</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">  /// currently used for hardware loop intrinsics in very controlled situations,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">  /// created prior to registry allocation in loops that only have single phi</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">  /// created prior to registry allocation in loops that only have single phi</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">  /// users for the terminators value. They may run out of registers if not used</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">  /// users for the terminators value. They may run out of registers if not used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">  /// carefully.</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">  /// carefully.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">  virtual bool isUnspillableTerminatorImpl(const MachineInstr *MI) const {</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">  virtual bool isUnspillableTerminatorImpl(const MachineInstr *MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline"></td>
    <td class="lineNumber">1032</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">  /// If the specific machine instruction is a instruction that moves/copies</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">  /// If the specific machine instruction is a instruction that moves/copies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">  /// value from one register to another register return destination and source</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">  /// value from one register to another register return destination and source</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">  /// registers as machine operands.</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">  /// registers as machine operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">  /// For COPY-instruction the method naturally returns destination and source</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">  /// For COPY-instruction the method naturally returns destination and source</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">  /// registers as machine operands, for all other instructions the method calls</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">  /// registers as machine operands, for all other instructions the method calls</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  /// target-dependent implementation.</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  /// target-dependent implementation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine diffFirst">  std::optional<DestSourcePair> isCopyInstr(const MachineInstr &MI) const {</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">  std::optional<DestSourcePair> isCopyInstr(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine diffFirst">    if (MI.isCopy()) {</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">    if (MI.isCopy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">      return DestSourcePair{MI.getOperand(0), MI.getOperand(1)};</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">      return DestSourcePair{MI.getOperand(0), MI.getOperand(1)};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine diffFirst">    return isCopyInstrImpl(MI);</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">    return isCopyInstrImpl(MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline"></td>
    <td class="lineNumber">1046</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">  /// If the specific machine instruction is an instruction that adds an</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">  /// If the specific machine instruction is an instruction that adds an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">  /// immediate value and a physical register, and stores the result in</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">  /// immediate value and a physical register, and stores the result in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  /// the given physical register \c Reg, return a pair of the source</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  /// the given physical register \c Reg, return a pair of the source</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">  /// register and the offset which has been added.</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">  /// register and the offset which has been added.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">  virtual std::optional<RegImmPair> isAddImmediate(const MachineInstr &MI,</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">  virtual std::optional<RegImmPair> isAddImmediate(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">                                                   Register Reg) const {</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">                                                   Register Reg) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline"></td>
    <td class="lineNumber">1055</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">  /// Returns true if MI is an instruction that defines Reg to have a constant</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">  /// Returns true if MI is an instruction that defines Reg to have a constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">  /// value and the value is recorded in ImmVal. The ImmVal is a result that</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">  /// value and the value is recorded in ImmVal. The ImmVal is a result that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">  /// should be interpreted as modulo size of Reg.</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">  /// should be interpreted as modulo size of Reg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  virtual bool getConstValDefinedInReg(const MachineInstr &MI,</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  virtual bool getConstValDefinedInReg(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">                                       const Register Reg,</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">                                       const Register Reg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">                                       int64_t &ImmVal) const {</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">                                       int64_t &ImmVal) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline"></td>
    <td class="lineNumber">1064</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">  /// Store the specified register of the given register class to the specified</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">  /// Store the specified register of the given register class to the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">  /// stack frame index. The store instruction is to be added to the given</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">  /// stack frame index. The store instruction is to be added to the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">  /// machine basic block before the specified machine instruction. If isKill</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">  /// machine basic block before the specified machine instruction. If isKill</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">  /// is true, the register operand is the last use and must be marked kill. If</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">  /// is true, the register operand is the last use and must be marked kill. If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">  /// \p SrcReg is being directly spilled as part of assigning a virtual</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">  /// \p SrcReg is being directly spilled as part of assigning a virtual</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">  /// register, \p VReg is the register being assigned. This additional register</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">  /// register, \p VReg is the register being assigned. This additional register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">  /// argument is needed for certain targets when invoked from RegAllocFast to</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">  /// argument is needed for certain targets when invoked from RegAllocFast to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">  /// map the spilled physical register to its virtual register. A null register</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">  /// map the spilled physical register to its virtual register. A null register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">  /// can be passed elsewhere.</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">  /// can be passed elsewhere.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">  virtual void storeRegToStackSlot(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">  virtual void storeRegToStackSlot(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">                                   MachineBasicBlock::iterator MI,</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">                                   MachineBasicBlock::iterator MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">                                   Register SrcReg, bool isKill, int FrameIndex,</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">                                   Register SrcReg, bool isKill, int FrameIndex,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">                                   const TargetRegisterClass *RC,</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">                                   const TargetRegisterClass *RC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">                                   const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">                                   const TargetRegisterInfo *TRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">                                   Register VReg) const {</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">                                   Register VReg) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement "</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">                     "TargetInstrInfo::storeRegToStackSlot!");</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">                     "TargetInstrInfo::storeRegToStackSlot!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline"></td>
    <td class="lineNumber">1083</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">  /// Load the specified register of the given register class from the specified</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">  /// Load the specified register of the given register class from the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">  /// stack frame index. The load instruction is to be added to the given</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">  /// stack frame index. The load instruction is to be added to the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">  /// machine basic block before the specified machine instruction. If \p</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">  /// machine basic block before the specified machine instruction. If \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">  /// DestReg is being directly reloaded as part of assigning a virtual</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">  /// DestReg is being directly reloaded as part of assigning a virtual</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">  /// register, \p VReg is the register being assigned. This additional register</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">  /// register, \p VReg is the register being assigned. This additional register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">  /// argument is needed for certain targets when invoked from RegAllocFast to</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">  /// argument is needed for certain targets when invoked from RegAllocFast to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">  /// map the loaded physical register to its virtual register. A null register</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">  /// map the loaded physical register to its virtual register. A null register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">  /// can be passed elsewhere.</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">  /// can be passed elsewhere.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">  virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">  virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">                                    MachineBasicBlock::iterator MI,</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">                                    MachineBasicBlock::iterator MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">                                    Register DestReg, int FrameIndex,</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">                                    Register DestReg, int FrameIndex,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">                                    const TargetRegisterClass *RC,</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">                                    const TargetRegisterClass *RC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">                                    const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">                                    const TargetRegisterInfo *TRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">                                    Register VReg) const {</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">                                    Register VReg) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement "</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">                     "TargetInstrInfo::loadRegFromStackSlot!");</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">                     "TargetInstrInfo::loadRegFromStackSlot!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline"></td>
    <td class="lineNumber">1101</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">  /// This function is called for all pseudo instructions</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">  /// This function is called for all pseudo instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">  /// that remain after register allocation. Many pseudo instructions are</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">  /// that remain after register allocation. Many pseudo instructions are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">  /// created to help register allocation. This is the place to convert them</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">  /// created to help register allocation. This is the place to convert them</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">  /// into real instructions. The target can edit MI in place, or it can insert</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">  /// into real instructions. The target can edit MI in place, or it can insert</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">  /// new instructions and erase MI. The function should return true if</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">  /// new instructions and erase MI. The function should return true if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">  /// anything was changed.</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">  /// anything was changed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">  virtual bool expandPostRAPseudo(MachineInstr &MI) const { return false; }</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">  virtual bool expandPostRAPseudo(MachineInstr &MI) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline"></td>
    <td class="lineNumber">1109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">  /// Check whether the target can fold a load that feeds a subreg operand</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">  /// Check whether the target can fold a load that feeds a subreg operand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">  /// (or a subreg operand that feeds a store).</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">  /// (or a subreg operand that feeds a store).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">  /// For example, X86 may want to return true if it can fold</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">  /// For example, X86 may want to return true if it can fold</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">  /// movl (%esp), %eax</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">  /// movl (%esp), %eax</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">  /// subb, %al, ...</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">  /// subb, %al, ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">  /// Into:</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">  /// Into:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">  /// subb (%esp), ...</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">  /// subb (%esp), ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">  /// Ideally, we'd like the target implementation of foldMemoryOperand() to</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">  /// Ideally, we'd like the target implementation of foldMemoryOperand() to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">  /// reject subregs - but since this behavior used to be enforced in the</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">  /// reject subregs - but since this behavior used to be enforced in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">  /// target-independent code, moving this responsibility to the targets</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">  /// target-independent code, moving this responsibility to the targets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">  /// has the potential of causing nasty silent breakage in out-of-tree targets.</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">  /// has the potential of causing nasty silent breakage in out-of-tree targets.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">  virtual bool isSubregFoldable() const { return false; }</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">  virtual bool isSubregFoldable() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">  /// For a patchpoint, stackmap, or statepoint intrinsic, return the range of</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">  /// For a patchpoint, stackmap, or statepoint intrinsic, return the range of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">  /// operands which can't be folded into stack references. Operands outside</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">  /// operands which can't be folded into stack references. Operands outside</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">  /// of the range are most likely foldable but it is not guaranteed.</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">  /// of the range are most likely foldable but it is not guaranteed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">  /// These instructions are unique in that stack references for some operands</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">  /// These instructions are unique in that stack references for some operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">  /// have the same execution cost (e.g. none) as the unfolded register forms.</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">  /// have the same execution cost (e.g. none) as the unfolded register forms.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">  /// The ranged return is guaranteed to include all operands which can't be</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">  /// The ranged return is guaranteed to include all operands which can't be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">  /// folded at zero cost.</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">  /// folded at zero cost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">  virtual std::pair<unsigned, unsigned></td>
    <td class="lineNumber">1131</td>
    <td class="codeline">  virtual std::pair<unsigned, unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">  getPatchpointUnfoldableRange(const MachineInstr &MI) const;</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">  getPatchpointUnfoldableRange(const MachineInstr &MI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline"></td>
    <td class="lineNumber">1133</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">  /// Attempt to fold a load or store of the specified stack</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">  /// Attempt to fold a load or store of the specified stack</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">  /// slot into the specified machine instruction for the specified operand(s).</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">  /// slot into the specified machine instruction for the specified operand(s).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">  /// If this is possible, a new instruction is returned with the specified</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">  /// If this is possible, a new instruction is returned with the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">  /// operand folded, otherwise NULL is returned.</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">  /// operand folded, otherwise NULL is returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">  /// The new instruction is inserted before MI, and the client is responsible</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">  /// The new instruction is inserted before MI, and the client is responsible</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">  /// for removing the old instruction.</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">  /// for removing the old instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">  /// If VRM is passed, the assigned physregs can be inspected by target to</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">  /// If VRM is passed, the assigned physregs can be inspected by target to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">  /// decide on using an opcode (note that those assignments can still change).</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">  /// decide on using an opcode (note that those assignments can still change).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">  MachineInstr *foldMemoryOperand(MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">  MachineInstr *foldMemoryOperand(MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">                                  int FI,</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">                                  int FI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">                                  LiveIntervals *LIS = nullptr,</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">                                  LiveIntervals *LIS = nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">                                  VirtRegMap *VRM = nullptr) const;</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">                                  VirtRegMap *VRM = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline"></td>
    <td class="lineNumber">1146</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">  /// Same as the previous version except it allows folding of any load and</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">  /// Same as the previous version except it allows folding of any load and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">  /// store from / to any address, not just from a specific stack slot.</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">  /// store from / to any address, not just from a specific stack slot.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">  MachineInstr *foldMemoryOperand(MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">  MachineInstr *foldMemoryOperand(MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">                                  MachineInstr &LoadMI,</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">                                  MachineInstr &LoadMI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">                                  LiveIntervals *LIS = nullptr) const;</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">                                  LiveIntervals *LIS = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline"></td>
    <td class="lineNumber">1152</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">  /// This function defines the logic to lower COPY instruction to</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">  /// This function defines the logic to lower COPY instruction to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">  /// target specific instruction(s).</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">  /// target specific instruction(s).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">  void lowerCopy(MachineInstr *MI, const TargetRegisterInfo *TRI) const;</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">  void lowerCopy(MachineInstr *MI, const TargetRegisterInfo *TRI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline"></td>
    <td class="lineNumber">1156</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">  /// Return true when there is potentially a faster code sequence</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">  /// Return true when there is potentially a faster code sequence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">  /// for an instruction chain ending in \p Root. All potential patterns are</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">  /// for an instruction chain ending in \p Root. All potential patterns are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">  /// returned in the \p Pattern vector. Pattern should be sorted in priority</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">  /// returned in the \p Pattern vector. Pattern should be sorted in priority</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">  /// order since the pattern evaluator stops checking as soon as it finds a</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">  /// order since the pattern evaluator stops checking as soon as it finds a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">  /// faster sequence.</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">  /// faster sequence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">  /// \param Root - Instruction that could be combined with one of its operands</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">  /// \param Root - Instruction that could be combined with one of its operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">  /// \param Patterns - Vector of possible combination patterns</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">  /// \param Patterns - Vector of possible combination patterns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">  getMachineCombinerPatterns(MachineInstr &Root,</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">  getMachineCombinerPatterns(MachineInstr &Root,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">                             SmallVectorImpl<MachineCombinerPattern> &Patterns,</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">                             SmallVectorImpl<MachineCombinerPattern> &Patterns,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">                             bool DoRegPressureReduce) const;</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">                             bool DoRegPressureReduce) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline"></td>
    <td class="lineNumber">1168</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">  /// Return true if target supports reassociation of instructions in machine</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">  /// Return true if target supports reassociation of instructions in machine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">  /// combiner pass to reduce register pressure for a given BB.</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">  /// combiner pass to reduce register pressure for a given BB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">  shouldReduceRegisterPressure(const MachineBasicBlock *MBB,</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">  shouldReduceRegisterPressure(const MachineBasicBlock *MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">                               const RegisterClassInfo *RegClassInfo) const {</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">                               const RegisterClassInfo *RegClassInfo) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline"></td>
    <td class="lineNumber">1176</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">  /// Fix up the placeholder we may add in genAlternativeCodeSequence().</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">  /// Fix up the placeholder we may add in genAlternativeCodeSequence().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">  virtual void</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">  virtual void</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">  finalizeInsInstrs(MachineInstr &Root, MachineCombinerPattern &P,</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">  finalizeInsInstrs(MachineInstr &Root, MachineCombinerPattern &P,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">                    SmallVectorImpl<MachineInstr *> &InsInstrs) const {}</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">                    SmallVectorImpl<MachineInstr *> &InsInstrs) const {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">  /// Return true when a code sequence can improve throughput. It</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">  /// Return true when a code sequence can improve throughput. It</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">  /// should be called only for instructions in loops.</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">  /// should be called only for instructions in loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">  /// \param Pattern - combiner pattern</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">  /// \param Pattern - combiner pattern</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">  virtual bool isThroughputPattern(MachineCombinerPattern Pattern) const;</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">  virtual bool isThroughputPattern(MachineCombinerPattern Pattern) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline"></td>
    <td class="lineNumber">1186</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">  /// Return true if the input \P Inst is part of a chain of dependent ops</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">  /// Return true if the input \P Inst is part of a chain of dependent ops</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">  /// that are suitable for reassociation, otherwise return false.</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">  /// that are suitable for reassociation, otherwise return false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">  /// If the instruction's operands must be commuted to have a previous</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">  /// If the instruction's operands must be commuted to have a previous</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">  /// instruction of the same type define the first source operand, \P Commuted</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">  /// instruction of the same type define the first source operand, \P Commuted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">  /// will be set to true.</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">  /// will be set to true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">  bool isReassociationCandidate(const MachineInstr &Inst, bool &Commuted) const;</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">  bool isReassociationCandidate(const MachineInstr &Inst, bool &Commuted) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline"></td>
    <td class="lineNumber">1193</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">  /// Return true when \P Inst is both associative and commutative. If \P Invert</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">  /// Return true when \P Inst is both associative and commutative. If \P Invert</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">  /// is true, then the inverse of \P Inst operation must be tested.</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">  /// is true, then the inverse of \P Inst operation must be tested.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">  virtual bool isAssociativeAndCommutative(const MachineInstr &Inst,</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">  virtual bool isAssociativeAndCommutative(const MachineInstr &Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">                                           bool Invert = false) const {</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">                                           bool Invert = false) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline"></td>
    <td class="lineNumber">1200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">  /// Return the inverse operation opcode if it exists for \P Opcode (e.g. add</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">  /// Return the inverse operation opcode if it exists for \P Opcode (e.g. add</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">  /// for sub and vice versa).</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">  /// for sub and vice versa).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">  virtual std::optional<unsigned> getInverseOpcode(unsigned Opcode) const {</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">  virtual std::optional<unsigned> getInverseOpcode(unsigned Opcode) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline"></td>
    <td class="lineNumber">1206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">  /// Return true when \P Opcode1 or its inversion is equal to \P Opcode2.</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">  /// Return true when \P Opcode1 or its inversion is equal to \P Opcode2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">  bool areOpcodesEqualOrInverse(unsigned Opcode1, unsigned Opcode2) const;</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">  bool areOpcodesEqualOrInverse(unsigned Opcode1, unsigned Opcode2) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline"></td>
    <td class="lineNumber">1209</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">  /// Return true when \P Inst has reassociable operands in the same \P MBB.</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">  /// Return true when \P Inst has reassociable operands in the same \P MBB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">  virtual bool hasReassociableOperands(const MachineInstr &Inst,</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">  virtual bool hasReassociableOperands(const MachineInstr &Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">                                       const MachineBasicBlock *MBB) const;</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">                                       const MachineBasicBlock *MBB) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline"></td>
    <td class="lineNumber">1213</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  /// Return true when \P Inst has reassociable sibling.</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  /// Return true when \P Inst has reassociable sibling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">  virtual bool hasReassociableSibling(const MachineInstr &Inst,</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">  virtual bool hasReassociableSibling(const MachineInstr &Inst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">                                      bool &Commuted) const;</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">                                      bool &Commuted) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline"></td>
    <td class="lineNumber">1217</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  /// When getMachineCombinerPatterns() finds patterns, this function generates</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  /// When getMachineCombinerPatterns() finds patterns, this function generates</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">  /// the instructions that could replace the original code sequence. The client</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">  /// the instructions that could replace the original code sequence. The client</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">  /// has to decide whether the actual replacement is beneficial or not.</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">  /// has to decide whether the actual replacement is beneficial or not.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">  /// \param Root - Instruction that could be combined with one of its operands</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">  /// \param Root - Instruction that could be combined with one of its operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  /// \param Pattern - Combination pattern for Root</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  /// \param Pattern - Combination pattern for Root</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">  /// \param InsInstrs - Vector of new instructions that implement P</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">  /// \param InsInstrs - Vector of new instructions that implement P</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">  /// \param DelInstrs - Old instructions, including Root, that could be</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">  /// \param DelInstrs - Old instructions, including Root, that could be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">  /// replaced by InsInstr</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">  /// replaced by InsInstr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">  /// \param InstIdxForVirtReg - map of virtual register to instruction in</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">  /// \param InstIdxForVirtReg - map of virtual register to instruction in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  /// InsInstr that defines it</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  /// InsInstr that defines it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">  virtual void genAlternativeCodeSequence(</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">  virtual void genAlternativeCodeSequence(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">      MachineInstr &Root, MachineCombinerPattern Pattern,</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">      MachineInstr &Root, MachineCombinerPattern Pattern,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">      SmallVectorImpl<MachineInstr *> &InsInstrs,</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">      SmallVectorImpl<MachineInstr *> &InsInstrs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">      SmallVectorImpl<MachineInstr *> &DelInstrs,</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">      SmallVectorImpl<MachineInstr *> &DelInstrs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">      DenseMap<unsigned, unsigned> &InstIdxForVirtReg) const;</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">      DenseMap<unsigned, unsigned> &InstIdxForVirtReg) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline"></td>
    <td class="lineNumber">1233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">  /// When calculate the latency of the root instruction, accumulate the</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">  /// When calculate the latency of the root instruction, accumulate the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  /// latency of the sequence to the root latency.</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  /// latency of the sequence to the root latency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">  /// \param Root - Instruction that could be combined with one of its operands</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">  /// \param Root - Instruction that could be combined with one of its operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  virtual bool accumulateInstrSeqToRootLatency(MachineInstr &Root) const {</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  virtual bool accumulateInstrSeqToRootLatency(MachineInstr &Root) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline"></td>
    <td class="lineNumber">1240</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">  /// Attempt to reassociate \P Root and \P Prev according to \P Pattern to</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">  /// Attempt to reassociate \P Root and \P Prev according to \P Pattern to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">  /// reduce critical path length.</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">  /// reduce critical path length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">  void reassociateOps(MachineInstr &Root, MachineInstr &Prev,</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">  void reassociateOps(MachineInstr &Root, MachineInstr &Prev,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">                      MachineCombinerPattern Pattern,</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">                      MachineCombinerPattern Pattern,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">                      SmallVectorImpl<MachineInstr *> &InsInstrs,</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">                      SmallVectorImpl<MachineInstr *> &InsInstrs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">                      SmallVectorImpl<MachineInstr *> &DelInstrs,</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">                      SmallVectorImpl<MachineInstr *> &DelInstrs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">                      DenseMap<unsigned, unsigned> &InstrIdxForVirtReg) const;</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">                      DenseMap<unsigned, unsigned> &InstrIdxForVirtReg) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline"></td>
    <td class="lineNumber">1248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">  /// Reassociation of some instructions requires inverse operations (e.g.</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">  /// Reassociation of some instructions requires inverse operations (e.g.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">  /// (X + A) - Y => (X - Y) + A). This method returns a pair of new opcodes</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">  /// (X + A) - Y => (X - Y) + A). This method returns a pair of new opcodes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">  /// (new root opcode, new prev opcode) that must be used to reassociate \P</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">  /// (new root opcode, new prev opcode) that must be used to reassociate \P</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">  /// Root and \P Prev accoring to \P Pattern.</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">  /// Root and \P Prev accoring to \P Pattern.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">  std::pair<unsigned, unsigned></td>
    <td class="lineNumber">1253</td>
    <td class="codeline">  std::pair<unsigned, unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">  getReassociationOpcodes(MachineCombinerPattern Pattern,</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">  getReassociationOpcodes(MachineCombinerPattern Pattern,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">                          const MachineInstr &Root,</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">                          const MachineInstr &Root,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">                          const MachineInstr &Prev) const;</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">                          const MachineInstr &Prev) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline"></td>
    <td class="lineNumber">1257</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  /// The limit on resource length extension we accept in MachineCombiner Pass.</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  /// The limit on resource length extension we accept in MachineCombiner Pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">  virtual int getExtendResourceLenLimit() const { return 0; }</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">  virtual int getExtendResourceLenLimit() const { return 0; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline"></td>
    <td class="lineNumber">1260</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">  /// This is an architecture-specific helper function of reassociateOps.</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">  /// This is an architecture-specific helper function of reassociateOps.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">  /// Set special operand attributes for new instructions after reassociation.</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">  /// Set special operand attributes for new instructions after reassociation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">  virtual void setSpecialOperandAttr(MachineInstr &OldMI1, MachineInstr &OldMI2,</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">  virtual void setSpecialOperandAttr(MachineInstr &OldMI1, MachineInstr &OldMI2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">                                     MachineInstr &NewMI1,</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">                                     MachineInstr &NewMI1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">                                     MachineInstr &NewMI2) const {}</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">                                     MachineInstr &NewMI2) const {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline"></td>
    <td class="lineNumber">1266</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">  /// Return true when a target supports MachineCombiner.</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">  /// Return true when a target supports MachineCombiner.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">  virtual bool useMachineCombiner() const { return false; }</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">  virtual bool useMachineCombiner() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">  /// Return a strategy that MachineCombiner must use when creating traces.</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">  /// Return a strategy that MachineCombiner must use when creating traces.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">  virtual MachineTraceStrategy getMachineCombinerTraceStrategy() const;</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">  virtual MachineTraceStrategy getMachineCombinerTraceStrategy() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline"></td>
    <td class="lineNumber">1272</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">  /// Return true if the given SDNode can be copied during scheduling</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">  /// Return true if the given SDNode can be copied during scheduling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  /// even if it has glue.</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  /// even if it has glue.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">  virtual bool canCopyGluedNodeDuringSchedule(SDNode *N) const { return false; }</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">  virtual bool canCopyGluedNodeDuringSchedule(SDNode *N) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">  /// Target-dependent implementation for foldMemoryOperand.</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">  /// Target-dependent implementation for foldMemoryOperand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">  /// Target-independent code in foldMemoryOperand will</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">  /// Target-independent code in foldMemoryOperand will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">  /// take care of adding a MachineMemOperand to the newly created instruction.</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">  /// take care of adding a MachineMemOperand to the newly created instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">  /// The instruction and any auxiliary instructions necessary will be inserted</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">  /// The instruction and any auxiliary instructions necessary will be inserted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">  /// at InsertPt.</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">  /// at InsertPt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">  virtual MachineInstr *</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">  virtual MachineInstr *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">  foldMemoryOperandImpl(MachineFunction &MF, MachineInstr &MI,</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">  foldMemoryOperandImpl(MachineFunction &MF, MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">                        ArrayRef<unsigned> Ops,</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">                        ArrayRef<unsigned> Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">                        MachineBasicBlock::iterator InsertPt, int FrameIndex,</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">                        MachineBasicBlock::iterator InsertPt, int FrameIndex,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">                        LiveIntervals *LIS = nullptr,</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">                        LiveIntervals *LIS = nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">                        VirtRegMap *VRM = nullptr) const {</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">                        VirtRegMap *VRM = nullptr) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline"></td>
    <td class="lineNumber">1291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">  /// Target-dependent implementation for foldMemoryOperand.</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">  /// Target-dependent implementation for foldMemoryOperand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">  /// Target-independent code in foldMemoryOperand will</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">  /// Target-independent code in foldMemoryOperand will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">  /// take care of adding a MachineMemOperand to the newly created instruction.</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">  /// take care of adding a MachineMemOperand to the newly created instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">  /// The instruction and any auxiliary instructions necessary will be inserted</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">  /// The instruction and any auxiliary instructions necessary will be inserted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">  /// at InsertPt.</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">  /// at InsertPt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">  virtual MachineInstr *foldMemoryOperandImpl(</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">  virtual MachineInstr *foldMemoryOperandImpl(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">      MachineFunction &MF, MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">      MachineFunction &MF, MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">      MachineBasicBlock::iterator InsertPt, MachineInstr &LoadMI,</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">      MachineBasicBlock::iterator InsertPt, MachineInstr &LoadMI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">      LiveIntervals *LIS = nullptr) const {</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">      LiveIntervals *LIS = nullptr) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline"></td>
    <td class="lineNumber">1303</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">  /// Target-dependent implementation of getRegSequenceInputs.</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">  /// Target-dependent implementation of getRegSequenceInputs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">  /// \returns true if it is possible to build the equivalent</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">  /// \returns true if it is possible to build the equivalent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">  /// REG_SEQUENCE inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">  /// REG_SEQUENCE inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">  /// \pre MI.isRegSequenceLike().</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">  /// \pre MI.isRegSequenceLike().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">  /// \see TargetInstrInfo::getRegSequenceInputs.</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">  /// \see TargetInstrInfo::getRegSequenceInputs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">  virtual bool getRegSequenceLikeInputs(</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">  virtual bool getRegSequenceLikeInputs(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">      const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">      const MachineInstr &MI, unsigned DefIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">      SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs) const {</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">      SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">  /// Target-dependent implementation of getExtractSubregInputs.</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">  /// Target-dependent implementation of getExtractSubregInputs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">  /// \returns true if it is possible to build the equivalent</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">  /// \returns true if it is possible to build the equivalent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">  /// EXTRACT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">  /// EXTRACT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">  /// \pre MI.isExtractSubregLike().</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">  /// \pre MI.isExtractSubregLike().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">  /// \see TargetInstrInfo::getExtractSubregInputs.</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">  /// \see TargetInstrInfo::getExtractSubregInputs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">  virtual bool getExtractSubregLikeInputs(const MachineInstr &MI,</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">  virtual bool getExtractSubregLikeInputs(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">                                          unsigned DefIdx,</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">                                          unsigned DefIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">                                          RegSubRegPairAndIdx &InputReg) const {</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">                                          RegSubRegPairAndIdx &InputReg) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline"></td>
    <td class="lineNumber">1331</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">  /// Target-dependent implementation of getInsertSubregInputs.</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">  /// Target-dependent implementation of getInsertSubregInputs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">  /// \returns true if it is possible to build the equivalent</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">  /// \returns true if it is possible to build the equivalent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">  /// INSERT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">  /// INSERT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">  /// \pre MI.isInsertSubregLike().</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">  /// \pre MI.isInsertSubregLike().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">  /// \see TargetInstrInfo::getInsertSubregInputs.</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">  /// \see TargetInstrInfo::getInsertSubregInputs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">  getInsertSubregLikeInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">  getInsertSubregLikeInputs(const MachineInstr &MI, unsigned DefIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">                            RegSubRegPair &BaseReg,</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">                            RegSubRegPair &BaseReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">                            RegSubRegPairAndIdx &InsertedReg) const {</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">                            RegSubRegPairAndIdx &InsertedReg) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline"></td>
    <td class="lineNumber">1346</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">  /// unfoldMemoryOperand - Separate a single instruction which folded a load or</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">  /// unfoldMemoryOperand - Separate a single instruction which folded a load or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">  /// a store or a load and a store into two or more instruction. If this is</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">  /// a store or a load and a store into two or more instruction. If this is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">  /// possible, returns true as well as the new instructions by reference.</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">  /// possible, returns true as well as the new instructions by reference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">  unfoldMemoryOperand(MachineFunction &MF, MachineInstr &MI, unsigned Reg,</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">  unfoldMemoryOperand(MachineFunction &MF, MachineInstr &MI, unsigned Reg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">                      bool UnfoldLoad, bool UnfoldStore,</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">                      bool UnfoldLoad, bool UnfoldStore,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">                      SmallVectorImpl<MachineInstr *> &NewMIs) const {</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">                      SmallVectorImpl<MachineInstr *> &NewMIs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline"></td>
    <td class="lineNumber">1357</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">  virtual bool unfoldMemoryOperand(SelectionDAG &DAG, SDNode *N,</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">  virtual bool unfoldMemoryOperand(SelectionDAG &DAG, SDNode *N,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">                                   SmallVectorImpl<SDNode *> &NewNodes) const {</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">                                   SmallVectorImpl<SDNode *> &NewNodes) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline"></td>
    <td class="lineNumber">1362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">  /// Returns the opcode of the would be new</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">  /// Returns the opcode of the would be new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">  /// instruction after load / store are unfolded from an instruction of the</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">  /// instruction after load / store are unfolded from an instruction of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">  /// specified opcode. It returns zero if the specified unfolding is not</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">  /// specified opcode. It returns zero if the specified unfolding is not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">  /// possible. If LoadRegIndex is non-null, it is filled in with the operand</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">  /// possible. If LoadRegIndex is non-null, it is filled in with the operand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">  /// index of the operand which will hold the register holding the loaded</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">  /// index of the operand which will hold the register holding the loaded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">  /// value.</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">  /// value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">  virtual unsigned</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">  virtual unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">  getOpcodeAfterMemoryUnfold(unsigned Opc, bool UnfoldLoad, bool UnfoldStore,</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">  getOpcodeAfterMemoryUnfold(unsigned Opc, bool UnfoldLoad, bool UnfoldStore,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">                             unsigned *LoadRegIndex = nullptr) const {</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">                             unsigned *LoadRegIndex = nullptr) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline"></td>
    <td class="lineNumber">1374</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">  /// This is used by the pre-regalloc scheduler to determine if two loads are</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">  /// This is used by the pre-regalloc scheduler to determine if two loads are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">  /// loading from the same base address. It should only return true if the base</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">  /// loading from the same base address. It should only return true if the base</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">  /// pointers are the same and the only differences between the two addresses</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">  /// pointers are the same and the only differences between the two addresses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">  /// are the offset. It also returns the offsets by reference.</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">  /// are the offset. It also returns the offsets by reference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">  virtual bool areLoadsFromSameBasePtr(SDNode *Load1, SDNode *Load2,</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">  virtual bool areLoadsFromSameBasePtr(SDNode *Load1, SDNode *Load2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">                                       int64_t &Offset1,</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">                                       int64_t &Offset1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">                                       int64_t &Offset2) const {</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">                                       int64_t &Offset2) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline"></td>
    <td class="lineNumber">1384</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">  /// This is a used by the pre-regalloc scheduler to determine (in conjunction</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">  /// This is a used by the pre-regalloc scheduler to determine (in conjunction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">  /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">  /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">  /// On some targets if two loads are loading from</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">  /// On some targets if two loads are loading from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">  /// addresses in the same cache line, it's better if they are scheduled</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">  /// addresses in the same cache line, it's better if they are scheduled</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">  /// together. This function takes two integers that represent the load offsets</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">  /// together. This function takes two integers that represent the load offsets</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">  /// from the common base address. It returns true if it decides it's desirable</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">  /// from the common base address. It returns true if it decides it's desirable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">  /// to schedule the two loads together. "NumLoads" is the number of loads that</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">  /// to schedule the two loads together. "NumLoads" is the number of loads that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">  /// have already been scheduled after Load1.</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">  /// have already been scheduled after Load1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">  virtual bool shouldScheduleLoadsNear(SDNode *Load1, SDNode *Load2,</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">  virtual bool shouldScheduleLoadsNear(SDNode *Load1, SDNode *Load2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">                                       int64_t Offset1, int64_t Offset2,</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">                                       int64_t Offset1, int64_t Offset2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">                                       unsigned NumLoads) const {</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">                                       unsigned NumLoads) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline"></td>
    <td class="lineNumber">1398</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">  /// Get the base operand and byte offset of an instruction that reads/writes</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">  /// Get the base operand and byte offset of an instruction that reads/writes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">  /// memory. This is a convenience function for callers that are only prepared</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">  /// memory. This is a convenience function for callers that are only prepared</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">  /// to handle a single base operand.</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">  /// to handle a single base operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">  bool getMemOperandWithOffset(const MachineInstr &MI,</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">  bool getMemOperandWithOffset(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">                               const MachineOperand *&BaseOp, int64_t &Offset,</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">                               const MachineOperand *&BaseOp, int64_t &Offset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">                               bool &OffsetIsScalable,</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">                               bool &OffsetIsScalable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">                               const TargetRegisterInfo *TRI) const;</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">                               const TargetRegisterInfo *TRI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline"></td>
    <td class="lineNumber">1406</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">  /// Get zero or more base operands and the byte offset of an instruction that</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">  /// Get zero or more base operands and the byte offset of an instruction that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">  /// reads/writes memory. Note that there may be zero base operands if the</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">  /// reads/writes memory. Note that there may be zero base operands if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">  /// instruction accesses a constant address.</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">  /// instruction accesses a constant address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">  /// It returns false if MI does not read/write memory.</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">  /// It returns false if MI does not read/write memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">  /// It returns false if base operands and offset could not be determined.</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">  /// It returns false if base operands and offset could not be determined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">  /// It is not guaranteed to always recognize base operands and offsets in all</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">  /// It is not guaranteed to always recognize base operands and offsets in all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">  /// cases.</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">  /// cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">  virtual bool getMemOperandsWithOffsetWidth(</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">  virtual bool getMemOperandsWithOffsetWidth(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">      const MachineInstr &MI, SmallVectorImpl<const MachineOperand *> &BaseOps,</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">      const MachineInstr &MI, SmallVectorImpl<const MachineOperand *> &BaseOps,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">      int64_t &Offset, bool &OffsetIsScalable, unsigned &Width,</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">      int64_t &Offset, bool &OffsetIsScalable, unsigned &Width,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">      const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">      const TargetRegisterInfo *TRI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline"></td>
    <td class="lineNumber">1420</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">  /// Return true if the instruction contains a base register and offset. If</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">  /// Return true if the instruction contains a base register and offset. If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">  /// true, the function also sets the operand position in the instruction</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">  /// true, the function also sets the operand position in the instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">  /// for the base register and offset.</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">  /// for the base register and offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">  virtual bool getBaseAndOffsetPosition(const MachineInstr &MI,</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">  virtual bool getBaseAndOffsetPosition(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">                                        unsigned &BasePos,</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">                                        unsigned &BasePos,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">                                        unsigned &OffsetPos) const {</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">                                        unsigned &OffsetPos) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline"></td>
    <td class="lineNumber">1429</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">  /// Target dependent implementation to get the values constituting the address</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">  /// Target dependent implementation to get the values constituting the address</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">  /// MachineInstr that is accessing memory. These values are returned as a</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">  /// MachineInstr that is accessing memory. These values are returned as a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">  /// struct ExtAddrMode which contains all relevant information to make up the</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">  /// struct ExtAddrMode which contains all relevant information to make up the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">  /// address.</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">  /// address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">  virtual std::optional<ExtAddrMode></td>
    <td class="lineNumber">1434</td>
    <td class="codeline">  virtual std::optional<ExtAddrMode></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">  getAddrModeFromMemoryOp(const MachineInstr &MemI,</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">  getAddrModeFromMemoryOp(const MachineInstr &MemI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">                          const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">                          const TargetRegisterInfo *TRI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline"></td>
    <td class="lineNumber">1439</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">  /// Returns true if MI's Def is NullValueReg, and the MI</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">  /// Returns true if MI's Def is NullValueReg, and the MI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">  /// does not change the Zero value. i.e. cases such as rax = shr rax, X where</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">  /// does not change the Zero value. i.e. cases such as rax = shr rax, X where</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">  /// NullValueReg = rax. Note that if the NullValueReg is non-zero, this</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">  /// NullValueReg = rax. Note that if the NullValueReg is non-zero, this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">  /// function can return true even if becomes zero. Specifically cases such as</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">  /// function can return true even if becomes zero. Specifically cases such as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">  /// NullValueReg = shl NullValueReg, 63.</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">  /// NullValueReg = shl NullValueReg, 63.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">  virtual bool preservesZeroValueInReg(const MachineInstr *MI,</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">  virtual bool preservesZeroValueInReg(const MachineInstr *MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">                                       const Register NullValueReg,</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">                                       const Register NullValueReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">                                       const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">                                       const TargetRegisterInfo *TRI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline"></td>
    <td class="lineNumber">1450</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">  /// If the instruction is an increment of a constant value, return the amount.</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">  /// If the instruction is an increment of a constant value, return the amount.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">  virtual bool getIncrementValue(const MachineInstr &MI, int &Value) const {</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">  virtual bool getIncrementValue(const MachineInstr &MI, int &Value) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline"></td>
    <td class="lineNumber">1455</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">  /// Returns true if the two given memory operations should be scheduled</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">  /// Returns true if the two given memory operations should be scheduled</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">  /// adjacent. Note that you have to add:</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">  /// adjacent. Note that you have to add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">  ///   DAG->addMutation(createLoadClusterDAGMutation(DAG->TII, DAG->TRI));</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">  ///   DAG->addMutation(createLoadClusterDAGMutation(DAG->TII, DAG->TRI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">  /// or</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">  /// or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">  ///   DAG->addMutation(createStoreClusterDAGMutation(DAG->TII, DAG->TRI));</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">  ///   DAG->addMutation(createStoreClusterDAGMutation(DAG->TII, DAG->TRI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">  /// to TargetPassConfig::createMachineScheduler() to have an effect.</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">  /// to TargetPassConfig::createMachineScheduler() to have an effect.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">  /// \p BaseOps1 and \p BaseOps2 are memory operands of two memory operations.</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">  /// \p BaseOps1 and \p BaseOps2 are memory operands of two memory operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">  /// \p NumLoads is the number of loads that will be in the cluster if this</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">  /// \p NumLoads is the number of loads that will be in the cluster if this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">  /// hook returns true.</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">  /// hook returns true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">  /// \p NumBytes is the number of bytes that will be loaded from all the</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">  /// \p NumBytes is the number of bytes that will be loaded from all the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">  /// clustered loads if this hook returns true.</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">  /// clustered loads if this hook returns true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">  virtual bool shouldClusterMemOps(ArrayRef<const MachineOperand *> BaseOps1,</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">  virtual bool shouldClusterMemOps(ArrayRef<const MachineOperand *> BaseOps1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">                                   ArrayRef<const MachineOperand *> BaseOps2,</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">                                   ArrayRef<const MachineOperand *> BaseOps2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">                                   unsigned NumLoads, unsigned NumBytes) const {</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">                                   unsigned NumLoads, unsigned NumBytes) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">    llvm_unreachable("target did not implement shouldClusterMemOps()");</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">    llvm_unreachable("target did not implement shouldClusterMemOps()");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline"></td>
    <td class="lineNumber">1473</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">  /// Reverses the branch condition of the specified condition list,</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">  /// Reverses the branch condition of the specified condition list,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">  /// returning false on success and true if it cannot be reversed.</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">  /// returning false on success and true if it cannot be reversed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">  reverseBranchCondition(SmallVectorImpl<MachineOperand> &Cond) const {</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">  reverseBranchCondition(SmallVectorImpl<MachineOperand> &Cond) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline"></td>
    <td class="lineNumber">1480</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">  /// Insert a noop into the instruction stream at the specified point.</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">  /// Insert a noop into the instruction stream at the specified point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">  virtual void insertNoop(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">  virtual void insertNoop(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">                          MachineBasicBlock::iterator MI) const;</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">                          MachineBasicBlock::iterator MI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline"></td>
    <td class="lineNumber">1484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">  /// Insert noops into the instruction stream at the specified point.</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">  /// Insert noops into the instruction stream at the specified point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">  virtual void insertNoops(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">  virtual void insertNoops(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">                           MachineBasicBlock::iterator MI,</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">                           MachineBasicBlock::iterator MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">                           unsigned Quantity) const;</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">                           unsigned Quantity) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline"></td>
    <td class="lineNumber">1489</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">  /// Return the noop instruction to use for a noop.</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">  /// Return the noop instruction to use for a noop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">  virtual MCInst getNop() const;</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">  virtual MCInst getNop() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline"></td>
    <td class="lineNumber">1492</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">  /// Return true for post-incremented instructions.</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">  /// Return true for post-incremented instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">  virtual bool isPostIncrement(const MachineInstr &MI) const { return false; }</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">  virtual bool isPostIncrement(const MachineInstr &MI) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline"></td>
    <td class="lineNumber">1495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">  /// Returns true if the instruction is already predicated.</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">  /// Returns true if the instruction is already predicated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  virtual bool isPredicated(const MachineInstr &MI) const { return false; }</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  virtual bool isPredicated(const MachineInstr &MI) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline"></td>
    <td class="lineNumber">1498</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">  /// Assumes the instruction is already predicated and returns true if the</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">  /// Assumes the instruction is already predicated and returns true if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">  /// instruction can be predicated again.</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">  /// instruction can be predicated again.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">  virtual bool canPredicatePredicatedInstr(const MachineInstr &MI) const {</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">  virtual bool canPredicatePredicatedInstr(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">    assert(isPredicated(MI) && "Instruction is not predicated");</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">    assert(isPredicated(MI) && "Instruction is not predicated");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline"></td>
    <td class="lineNumber">1505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">  // Returns a MIRPrinter comment for this machine operand.</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">  // Returns a MIRPrinter comment for this machine operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">  virtual std::string</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">  virtual std::string</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">  createMIROperandComment(const MachineInstr &MI, const MachineOperand &Op,</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">  createMIROperandComment(const MachineInstr &MI, const MachineOperand &Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">                          unsigned OpIdx, const TargetRegisterInfo *TRI) const;</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">                          unsigned OpIdx, const TargetRegisterInfo *TRI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline"></td>
    <td class="lineNumber">1510</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">  /// Returns true if the instruction is a</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">  /// Returns true if the instruction is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">  /// terminator instruction that has not been predicated.</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">  /// terminator instruction that has not been predicated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">  bool isUnpredicatedTerminator(const MachineInstr &MI) const;</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">  bool isUnpredicatedTerminator(const MachineInstr &MI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline"></td>
    <td class="lineNumber">1514</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">  /// Returns true if MI is an unconditional tail call.</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">  /// Returns true if MI is an unconditional tail call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">  virtual bool isUnconditionalTailCall(const MachineInstr &MI) const {</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">  virtual bool isUnconditionalTailCall(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline"></td>
    <td class="lineNumber">1519</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">  /// Returns true if the tail call can be made conditional on BranchCond.</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">  /// Returns true if the tail call can be made conditional on BranchCond.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">  virtual bool canMakeTailCallConditional(SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">  virtual bool canMakeTailCallConditional(SmallVectorImpl<MachineOperand> &Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">                                          const MachineInstr &TailCall) const {</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">                                          const MachineInstr &TailCall) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline"></td>
    <td class="lineNumber">1525</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">  /// Replace the conditional branch in MBB with a conditional tail call.</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">  /// Replace the conditional branch in MBB with a conditional tail call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">  virtual void replaceBranchWithTailCall(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">  virtual void replaceBranchWithTailCall(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">                                         SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">                                         SmallVectorImpl<MachineOperand> &Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">                                         const MachineInstr &TailCall) const {</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">                                         const MachineInstr &TailCall) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement replaceBranchWithTailCall!");</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement replaceBranchWithTailCall!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline"></td>
    <td class="lineNumber">1532</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">  /// Convert the instruction into a predicated instruction.</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">  /// Convert the instruction into a predicated instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">  /// It returns true if the operation was successful.</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">  /// It returns true if the operation was successful.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">  virtual bool PredicateInstruction(MachineInstr &MI,</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">  virtual bool PredicateInstruction(MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">                                    ArrayRef<MachineOperand> Pred) const;</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">                                    ArrayRef<MachineOperand> Pred) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline"></td>
    <td class="lineNumber">1537</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">  /// Returns true if the first specified predicate</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">  /// Returns true if the first specified predicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">  /// subsumes the second, e.g. GE subsumes GT.</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">  /// subsumes the second, e.g. GE subsumes GT.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">  virtual bool SubsumesPredicate(ArrayRef<MachineOperand> Pred1,</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">  virtual bool SubsumesPredicate(ArrayRef<MachineOperand> Pred1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">                                 ArrayRef<MachineOperand> Pred2) const {</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">                                 ArrayRef<MachineOperand> Pred2) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline"></td>
    <td class="lineNumber">1544</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">  /// If the specified instruction defines any predicate</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">  /// If the specified instruction defines any predicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">  /// or condition code register(s) used for predication, returns true as well</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">  /// or condition code register(s) used for predication, returns true as well</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">  /// as the definition predicate(s) by reference.</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">  /// as the definition predicate(s) by reference.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">  /// SkipDead should be set to false at any point that dead</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">  /// SkipDead should be set to false at any point that dead</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">  /// predicate instructions should be considered as being defined.</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">  /// predicate instructions should be considered as being defined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">  /// A dead predicate instruction is one that is guaranteed to be removed</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">  /// A dead predicate instruction is one that is guaranteed to be removed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">  /// after a call to PredicateInstruction.</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">  /// after a call to PredicateInstruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline">  virtual bool ClobbersPredicate(MachineInstr &MI,</td>
    <td class="lineNumber">1552</td>
    <td class="codeline">  virtual bool ClobbersPredicate(MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">                                 std::vector<MachineOperand> &Pred,</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">                                 std::vector<MachineOperand> &Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">                                 bool SkipDead) const {</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">                                 bool SkipDead) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline"></td>
    <td class="lineNumber">1557</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">  /// Return true if the specified instruction can be predicated.</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">  /// Return true if the specified instruction can be predicated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">  /// By default, this returns true for every instruction with a</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">  /// By default, this returns true for every instruction with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">  /// PredicateOperand.</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">  /// PredicateOperand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">  virtual bool isPredicable(const MachineInstr &MI) const {</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">  virtual bool isPredicable(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">    return MI.getDesc().isPredicable();</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">    return MI.getDesc().isPredicable();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline"></td>
    <td class="lineNumber">1564</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">  /// Return true if it's safe to move a machine</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">  /// Return true if it's safe to move a machine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">  /// instruction that defines the specified register class.</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">  /// instruction that defines the specified register class.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">  virtual bool isSafeToMoveRegClassDefs(const TargetRegisterClass *RC) const {</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">  virtual bool isSafeToMoveRegClassDefs(const TargetRegisterClass *RC) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline"></td>
    <td class="lineNumber">1570</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">  /// Test if the given instruction should be considered a scheduling boundary.</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">  /// Test if the given instruction should be considered a scheduling boundary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">  /// This primarily includes labels and terminators.</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">  /// This primarily includes labels and terminators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">  virtual bool isSchedulingBoundary(const MachineInstr &MI,</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">  virtual bool isSchedulingBoundary(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">                                    const MachineBasicBlock *MBB,</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">                                    const MachineBasicBlock *MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">                                    const MachineFunction &MF) const;</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">                                    const MachineFunction &MF) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline"></td>
    <td class="lineNumber">1576</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">  /// Measure the specified inline asm to determine an approximation of its</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">  /// Measure the specified inline asm to determine an approximation of its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">  /// length.</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">  /// length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">  virtual unsigned getInlineAsmLength(</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">  virtual unsigned getInlineAsmLength(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">    const char *Str, const MCAsmInfo &MAI,</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">    const char *Str, const MCAsmInfo &MAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">    const TargetSubtargetInfo *STI = nullptr) const;</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">    const TargetSubtargetInfo *STI = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline"></td>
    <td class="lineNumber">1582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">  /// Allocate and return a hazard recognizer to use for this target when</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">  /// Allocate and return a hazard recognizer to use for this target when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">  /// scheduling the machine instructions before register allocation.</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">  /// scheduling the machine instructions before register allocation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">  virtual ScheduleHazardRecognizer *</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">  virtual ScheduleHazardRecognizer *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">  CreateTargetHazardRecognizer(const TargetSubtargetInfo *STI,</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">  CreateTargetHazardRecognizer(const TargetSubtargetInfo *STI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">                               const ScheduleDAG *DAG) const;</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">                               const ScheduleDAG *DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline"></td>
    <td class="lineNumber">1588</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">  /// Allocate and return a hazard recognizer to use for this target when</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">  /// Allocate and return a hazard recognizer to use for this target when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">  /// scheduling the machine instructions before register allocation.</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">  /// scheduling the machine instructions before register allocation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">  virtual ScheduleHazardRecognizer *</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">  virtual ScheduleHazardRecognizer *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">  CreateTargetMIHazardRecognizer(const InstrItineraryData *,</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">  CreateTargetMIHazardRecognizer(const InstrItineraryData *,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">                                 const ScheduleDAGMI *DAG) const;</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">                                 const ScheduleDAGMI *DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline"></td>
    <td class="lineNumber">1594</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">  /// Allocate and return a hazard recognizer to use for this target when</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">  /// Allocate and return a hazard recognizer to use for this target when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">  /// scheduling the machine instructions after register allocation.</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">  /// scheduling the machine instructions after register allocation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">  virtual ScheduleHazardRecognizer *</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">  virtual ScheduleHazardRecognizer *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">  CreateTargetPostRAHazardRecognizer(const InstrItineraryData *,</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">  CreateTargetPostRAHazardRecognizer(const InstrItineraryData *,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">                                     const ScheduleDAG *DAG) const;</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">                                     const ScheduleDAG *DAG) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline"></td>
    <td class="lineNumber">1600</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">  /// Allocate and return a hazard recognizer to use for by non-scheduling</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">  /// Allocate and return a hazard recognizer to use for by non-scheduling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">  /// passes.</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">  /// passes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">  virtual ScheduleHazardRecognizer *</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">  virtual ScheduleHazardRecognizer *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">  CreateTargetPostRAHazardRecognizer(const MachineFunction &MF) const {</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">  CreateTargetPostRAHazardRecognizer(const MachineFunction &MF) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline"></td>
    <td class="lineNumber">1607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">  /// Provide a global flag for disabling the PreRA hazard recognizer that</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">  /// Provide a global flag for disabling the PreRA hazard recognizer that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">  /// targets may choose to honor.</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">  /// targets may choose to honor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">  bool usePreRAHazardRecognizer() const;</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">  bool usePreRAHazardRecognizer() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline"></td>
    <td class="lineNumber">1611</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">  /// For a comparison instruction, return the source registers</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">  /// For a comparison instruction, return the source registers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">  /// in SrcReg and SrcReg2 if having two register operands, and the value it</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">  /// in SrcReg and SrcReg2 if having two register operands, and the value it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">  /// compares against in CmpValue. Return true if the comparison instruction</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">  /// compares against in CmpValue. Return true if the comparison instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">  /// can be analyzed.</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">  /// can be analyzed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">  virtual bool analyzeCompare(const MachineInstr &MI, Register &SrcReg,</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">  virtual bool analyzeCompare(const MachineInstr &MI, Register &SrcReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">                              Register &SrcReg2, int64_t &Mask,</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">                              Register &SrcReg2, int64_t &Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">                              int64_t &Value) const {</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">                              int64_t &Value) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline"></td>
    <td class="lineNumber">1621</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">  /// See if the comparison instruction can be converted</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">  /// See if the comparison instruction can be converted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">  /// into something more efficient. E.g., on ARM most instructions can set the</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">  /// into something more efficient. E.g., on ARM most instructions can set the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">  /// flags register, obviating the need for a separate CMP.</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">  /// flags register, obviating the need for a separate CMP.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">  virtual bool optimizeCompareInstr(MachineInstr &CmpInstr, Register SrcReg,</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">  virtual bool optimizeCompareInstr(MachineInstr &CmpInstr, Register SrcReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">                                    Register SrcReg2, int64_t Mask,</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">                                    Register SrcReg2, int64_t Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">                                    int64_t Value,</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">                                    int64_t Value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">                                    const MachineRegisterInfo *MRI) const {</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">                                    const MachineRegisterInfo *MRI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">  virtual bool optimizeCondBranch(MachineInstr &MI) const { return false; }</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">  virtual bool optimizeCondBranch(MachineInstr &MI) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline"></td>
    <td class="lineNumber">1632</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">  /// Try to remove the load by folding it to a register operand at the use.</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">  /// Try to remove the load by folding it to a register operand at the use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">  /// We fold the load instructions if and only if the</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">  /// We fold the load instructions if and only if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">  /// def and use are in the same BB. We only look at one load and see</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">  /// def and use are in the same BB. We only look at one load and see</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">  /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">  /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">  /// defined by the load we are trying to fold. DefMI returns the machine</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">  /// defined by the load we are trying to fold. DefMI returns the machine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">  /// instruction that defines FoldAsLoadDefReg, and the function returns</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">  /// instruction that defines FoldAsLoadDefReg, and the function returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">  /// the machine instruction generated due to folding.</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">  /// the machine instruction generated due to folding.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">  virtual MachineInstr *optimizeLoadInstr(MachineInstr &MI,</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">  virtual MachineInstr *optimizeLoadInstr(MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">                                          const MachineRegisterInfo *MRI,</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">                                          const MachineRegisterInfo *MRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">                                          Register &FoldAsLoadDefReg,</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">                                          Register &FoldAsLoadDefReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">                                          MachineInstr *&DefMI) const {</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">                                          MachineInstr *&DefMI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline"></td>
    <td class="lineNumber">1646</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">  /// 'Reg' is known to be defined by a move immediate instruction,</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">  /// 'Reg' is known to be defined by a move immediate instruction,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">  /// try to fold the immediate into the use instruction.</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">  /// try to fold the immediate into the use instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">  /// If MRI->hasOneNonDBGUse(Reg) is true, and this function returns true,</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">  /// If MRI->hasOneNonDBGUse(Reg) is true, and this function returns true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">  /// then the caller may assume that DefMI has been erased from its parent</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">  /// then the caller may assume that DefMI has been erased from its parent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">  /// block. The caller may assume that it will not be erased by this</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">  /// block. The caller may assume that it will not be erased by this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">  /// function otherwise.</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">  /// function otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">  virtual bool FoldImmediate(MachineInstr &UseMI, MachineInstr &DefMI,</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">  virtual bool FoldImmediate(MachineInstr &UseMI, MachineInstr &DefMI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">                             Register Reg, MachineRegisterInfo *MRI) const {</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">                             Register Reg, MachineRegisterInfo *MRI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline"></td>
    <td class="lineNumber">1657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">  /// Return the number of u-operations the given machine</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">  /// Return the number of u-operations the given machine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">  /// instruction will be decoded to on the target cpu. The itinerary's</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">  /// instruction will be decoded to on the target cpu. The itinerary's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">  /// IssueWidth is the number of microops that can be dispatched each</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">  /// IssueWidth is the number of microops that can be dispatched each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">  /// cycle. An instruction with zero microops takes no dispatch resources.</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">  /// cycle. An instruction with zero microops takes no dispatch resources.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">  virtual unsigned getNumMicroOps(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">  virtual unsigned getNumMicroOps(const InstrItineraryData *ItinData,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">                                  const MachineInstr &MI) const;</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">                                  const MachineInstr &MI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline"></td>
    <td class="lineNumber">1664</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">  /// Return true for pseudo instructions that don't consume any</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">  /// Return true for pseudo instructions that don't consume any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">  /// machine resources in their current form. These are common cases that the</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">  /// machine resources in their current form. These are common cases that the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">  /// scheduler should consider free, rather than conservatively handling them</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">  /// scheduler should consider free, rather than conservatively handling them</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">  /// as instructions with no itinerary.</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">  /// as instructions with no itinerary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">  bool isZeroCost(unsigned Opcode) const {</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">  bool isZeroCost(unsigned Opcode) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">    return Opcode <= TargetOpcode::COPY;</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">    return Opcode <= TargetOpcode::COPY;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline"></td>
    <td class="lineNumber">1672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">  virtual int getOperandLatency(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">  virtual int getOperandLatency(const InstrItineraryData *ItinData,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">                                SDNode *DefNode, unsigned DefIdx,</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">                                SDNode *DefNode, unsigned DefIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">                                SDNode *UseNode, unsigned UseIdx) const;</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">                                SDNode *UseNode, unsigned UseIdx) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline"></td>
    <td class="lineNumber">1676</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">  /// Compute and return the use operand latency of a given pair of def and use.</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">  /// Compute and return the use operand latency of a given pair of def and use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">  /// In most cases, the static scheduling itinerary was enough to determine the</td>
    <td class="lineNumber">1678</td>
    <td class="codeline">  /// In most cases, the static scheduling itinerary was enough to determine the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">  /// operand latency. But it may not be possible for instructions with variable</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">  /// operand latency. But it may not be possible for instructions with variable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">  /// number of defs / uses.</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">  /// number of defs / uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">  /// This is a raw interface to the itinerary that may be directly overridden</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">  /// This is a raw interface to the itinerary that may be directly overridden</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">  /// by a target. Use computeOperandLatency to get the best estimate of</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">  /// by a target. Use computeOperandLatency to get the best estimate of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">  /// latency.</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">  /// latency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">  virtual int getOperandLatency(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">  virtual int getOperandLatency(const InstrItineraryData *ItinData,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">                                const MachineInstr &DefMI, unsigned DefIdx,</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">                                const MachineInstr &DefMI, unsigned DefIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">                                const MachineInstr &UseMI,</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">                                const MachineInstr &UseMI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">                                unsigned UseIdx) const;</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">                                unsigned UseIdx) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline"></td>
    <td class="lineNumber">1689</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">  /// Compute the instruction latency of a given instruction.</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">  /// Compute the instruction latency of a given instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">  /// If the instruction has higher cost when predicated, it's returned via</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">  /// If the instruction has higher cost when predicated, it's returned via</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">  /// PredCost.</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">  /// PredCost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">  virtual unsigned getInstrLatency(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">  virtual unsigned getInstrLatency(const InstrItineraryData *ItinData,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">                                   const MachineInstr &MI,</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">                                   const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">                                   unsigned *PredCost = nullptr) const;</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">                                   unsigned *PredCost = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">  virtual unsigned getPredicationCost(const MachineInstr &MI) const;</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">  virtual unsigned getPredicationCost(const MachineInstr &MI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline"></td>
    <td class="lineNumber">1698</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">  virtual int getInstrLatency(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">  virtual int getInstrLatency(const InstrItineraryData *ItinData,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">                              SDNode *Node) const;</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">                              SDNode *Node) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline"></td>
    <td class="lineNumber">1701</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">  /// Return the default expected latency for a def based on its opcode.</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">  /// Return the default expected latency for a def based on its opcode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">  unsigned defaultDefLatency(const MCSchedModel &SchedModel,</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">  unsigned defaultDefLatency(const MCSchedModel &SchedModel,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">                             const MachineInstr &DefMI) const;</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">                             const MachineInstr &DefMI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline"></td>
    <td class="lineNumber">1705</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">  /// Return true if this opcode has high latency to its result.</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">  /// Return true if this opcode has high latency to its result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">  virtual bool isHighLatencyDef(int opc) const { return false; }</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">  virtual bool isHighLatencyDef(int opc) const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline"></td>
    <td class="lineNumber">1708</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">  /// Compute operand latency between a def of 'Reg'</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">  /// Compute operand latency between a def of 'Reg'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">  /// and a use in the current loop. Return true if the target considered</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">  /// and a use in the current loop. Return true if the target considered</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">  /// it 'high'. This is used by optimization passes such as machine LICM to</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">  /// it 'high'. This is used by optimization passes such as machine LICM to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">  /// determine whether it makes sense to hoist an instruction out even in a</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">  /// determine whether it makes sense to hoist an instruction out even in a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">  /// high register pressure situation.</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">  /// high register pressure situation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">  virtual bool hasHighOperandLatency(const TargetSchedModel &SchedModel,</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">  virtual bool hasHighOperandLatency(const TargetSchedModel &SchedModel,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">                                     const MachineRegisterInfo *MRI,</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">                                     const MachineRegisterInfo *MRI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">                                     const MachineInstr &DefMI, unsigned DefIdx,</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">                                     const MachineInstr &DefMI, unsigned DefIdx,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">                                     const MachineInstr &UseMI,</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">                                     const MachineInstr &UseMI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">                                     unsigned UseIdx) const {</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">                                     unsigned UseIdx) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline"></td>
    <td class="lineNumber">1721</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">  /// Compute operand latency of a def of 'Reg'. Return true</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">  /// Compute operand latency of a def of 'Reg'. Return true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">  /// if the target considered it 'low'.</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">  /// if the target considered it 'low'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">  virtual bool hasLowDefLatency(const TargetSchedModel &SchedModel,</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">  virtual bool hasLowDefLatency(const TargetSchedModel &SchedModel,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">                                const MachineInstr &DefMI,</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">                                const MachineInstr &DefMI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">                                unsigned DefIdx) const;</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">                                unsigned DefIdx) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline"></td>
    <td class="lineNumber">1727</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">  /// Perform target-specific instruction verification.</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">  /// Perform target-specific instruction verification.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">  virtual bool verifyInstruction(const MachineInstr &MI,</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">  virtual bool verifyInstruction(const MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">                                 StringRef &ErrInfo) const {</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">                                 StringRef &ErrInfo) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline"></td>
    <td class="lineNumber">1733</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">  /// Return the current execution domain and bit mask of</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">  /// Return the current execution domain and bit mask of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">  /// possible domains for instruction.</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">  /// possible domains for instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">  /// Some micro-architectures have multiple execution domains, and multiple</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">  /// Some micro-architectures have multiple execution domains, and multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">  /// opcodes that perform the same operation in different domains.  For</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">  /// opcodes that perform the same operation in different domains.  For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">  /// example, the x86 architecture provides the por, orps, and orpd</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">  /// example, the x86 architecture provides the por, orps, and orpd</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">  /// instructions that all do the same thing.  There is a latency penalty if a</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">  /// instructions that all do the same thing.  There is a latency penalty if a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">  /// register is written in one domain and read in another.</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">  /// register is written in one domain and read in another.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">  /// This function returns a pair (domain, mask) containing the execution</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">  /// This function returns a pair (domain, mask) containing the execution</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">  /// domain of MI, and a bit mask of possible domains.  The setExecutionDomain</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">  /// domain of MI, and a bit mask of possible domains.  The setExecutionDomain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">  /// function can be used to change the opcode to one of the domains in the</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">  /// function can be used to change the opcode to one of the domains in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">  /// bit mask.  Instructions whose execution domain can't be changed should</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">  /// bit mask.  Instructions whose execution domain can't be changed should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">  /// return a 0 mask.</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">  /// return a 0 mask.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">  /// The execution domain numbers don't have any special meaning except domain</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">  /// The execution domain numbers don't have any special meaning except domain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">  /// 0 is used for instructions that are not associated with any interesting</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">  /// 0 is used for instructions that are not associated with any interesting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">  /// execution domain.</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">  /// execution domain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">  virtual std::pair<uint16_t, uint16_t></td>
    <td class="lineNumber">1753</td>
    <td class="codeline">  virtual std::pair<uint16_t, uint16_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">  getExecutionDomain(const MachineInstr &MI) const {</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">  getExecutionDomain(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">    return std::make_pair(0, 0);</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">    return std::make_pair(0, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline"></td>
    <td class="lineNumber">1757</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">  /// Change the opcode of MI to execute in Domain.</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">  /// Change the opcode of MI to execute in Domain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">  /// The bit (1 << Domain) must be set in the mask returned from</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">  /// The bit (1 << Domain) must be set in the mask returned from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">  /// getExecutionDomain(MI).</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">  /// getExecutionDomain(MI).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">  virtual void setExecutionDomain(MachineInstr &MI, unsigned Domain) const {}</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">  virtual void setExecutionDomain(MachineInstr &MI, unsigned Domain) const {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline"></td>
    <td class="lineNumber">1763</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">  /// Returns the preferred minimum clearance</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">  /// Returns the preferred minimum clearance</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">  /// before an instruction with an unwanted partial register update.</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">  /// before an instruction with an unwanted partial register update.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">  /// Some instructions only write part of a register, and implicitly need to</td>
    <td class="lineNumber">1767</td>
    <td class="codeline">  /// Some instructions only write part of a register, and implicitly need to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">  /// read the other parts of the register.  This may cause unwanted stalls</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">  /// read the other parts of the register.  This may cause unwanted stalls</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">  /// preventing otherwise unrelated instructions from executing in parallel in</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">  /// preventing otherwise unrelated instructions from executing in parallel in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">  /// an out-of-order CPU.</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">  /// an out-of-order CPU.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">  /// For example, the x86 instruction cvtsi2ss writes its result to bits</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">  /// For example, the x86 instruction cvtsi2ss writes its result to bits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">  /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">  /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">  /// the instruction needs to wait for the old value of the register to become</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">  /// the instruction needs to wait for the old value of the register to become</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">  /// available:</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">  /// available:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">  ///   addps %xmm1, %xmm0</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">  ///   addps %xmm1, %xmm0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">  ///   movaps %xmm0, (%rax)</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">  ///   movaps %xmm0, (%rax)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">  ///   cvtsi2ss %rbx, %xmm0</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">  ///   cvtsi2ss %rbx, %xmm0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">  /// In the code above, the cvtsi2ss instruction needs to wait for the addps</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">  /// In the code above, the cvtsi2ss instruction needs to wait for the addps</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">  /// instruction before it can issue, even though the high bits of %xmm0</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">  /// instruction before it can issue, even though the high bits of %xmm0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">  /// probably aren't needed.</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">  /// probably aren't needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">  /// This hook returns the preferred clearance before MI, measured in</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">  /// This hook returns the preferred clearance before MI, measured in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">  /// instructions.  Other defs of MI's operand OpNum are avoided in the last N</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">  /// instructions.  Other defs of MI's operand OpNum are avoided in the last N</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">  /// instructions before MI.  It should only return a positive value for</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">  /// instructions before MI.  It should only return a positive value for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">  /// unwanted dependencies.  If the old bits of the defined register have</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">  /// unwanted dependencies.  If the old bits of the defined register have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">  /// useful values, or if MI is determined to otherwise read the dependency,</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">  /// useful values, or if MI is determined to otherwise read the dependency,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">  /// the hook should return 0.</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">  /// the hook should return 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">  /// The unwanted dependency may be handled by:</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">  /// The unwanted dependency may be handled by:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">  /// 1. Allocating the same register for an MI def and use.  That makes the</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">  /// 1. Allocating the same register for an MI def and use.  That makes the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">  ///    unwanted dependency identical to a required dependency.</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">  ///    unwanted dependency identical to a required dependency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">  /// 2. Allocating a register for the def that has no defs in the previous N</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">  /// 2. Allocating a register for the def that has no defs in the previous N</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">  ///    instructions.</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">  ///    instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">  /// 3. Calling breakPartialRegDependency() with the same arguments.  This</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">  /// 3. Calling breakPartialRegDependency() with the same arguments.  This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">  ///    allows the target to insert a dependency breaking instruction.</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">  ///    allows the target to insert a dependency breaking instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">  virtual unsigned</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">  virtual unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">  getPartialRegUpdateClearance(const MachineInstr &MI, unsigned OpNum,</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">  getPartialRegUpdateClearance(const MachineInstr &MI, unsigned OpNum,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">                               const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">                               const TargetRegisterInfo *TRI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">    // The default implementation returns 0 for no partial register dependency.</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">    // The default implementation returns 0 for no partial register dependency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline"></td>
    <td class="lineNumber">1809</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">  /// Return the minimum clearance before an instruction that reads an</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">  /// Return the minimum clearance before an instruction that reads an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">  /// unused register.</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">  /// unused register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">  /// For example, AVX instructions may copy part of a register operand into</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">  /// For example, AVX instructions may copy part of a register operand into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">  /// the unused high bits of the destination register.</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">  /// the unused high bits of the destination register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">  /// vcvtsi2sdq %rax, undef %xmm0, %xmm14</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">  /// vcvtsi2sdq %rax, undef %xmm0, %xmm14</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">  /// In the code above, vcvtsi2sdq copies %xmm0[127:64] into %xmm14 creating a</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">  /// In the code above, vcvtsi2sdq copies %xmm0[127:64] into %xmm14 creating a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">  /// false dependence on any previous write to %xmm0.</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">  /// false dependence on any previous write to %xmm0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">  /// This hook works similarly to getPartialRegUpdateClearance, except that it</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">  /// This hook works similarly to getPartialRegUpdateClearance, except that it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">  /// does not take an operand index. Instead sets \p OpNum to the index of the</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">  /// does not take an operand index. Instead sets \p OpNum to the index of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">  /// unused register.</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">  /// unused register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">  virtual unsigned getUndefRegClearance(const MachineInstr &MI, unsigned OpNum,</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">  virtual unsigned getUndefRegClearance(const MachineInstr &MI, unsigned OpNum,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">                                        const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">                                        const TargetRegisterInfo *TRI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">    // The default implementation returns 0 for no undef register dependency.</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">    // The default implementation returns 0 for no undef register dependency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline"></td>
    <td class="lineNumber">1829</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">  /// Insert a dependency-breaking instruction</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">  /// Insert a dependency-breaking instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">  /// before MI to eliminate an unwanted dependency on OpNum.</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">  /// before MI to eliminate an unwanted dependency on OpNum.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">  /// If it wasn't possible to avoid a def in the last N instructions before MI</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">  /// If it wasn't possible to avoid a def in the last N instructions before MI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">  /// (see getPartialRegUpdateClearance), this hook will be called to break the</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">  /// (see getPartialRegUpdateClearance), this hook will be called to break the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">  /// unwanted dependency.</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">  /// unwanted dependency.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">  /// On x86, an xorps instruction can be used as a dependency breaker:</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">  /// On x86, an xorps instruction can be used as a dependency breaker:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">  ///   addps %xmm1, %xmm0</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">  ///   addps %xmm1, %xmm0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">  ///   movaps %xmm0, (%rax)</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">  ///   movaps %xmm0, (%rax)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">  ///   xorps %xmm0, %xmm0</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">  ///   xorps %xmm0, %xmm0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">  ///   cvtsi2ss %rbx, %xmm0</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">  ///   cvtsi2ss %rbx, %xmm0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">  /// An <imp-kill> operand should be added to MI if an instruction was</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">  /// An <imp-kill> operand should be added to MI if an instruction was</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">  /// inserted.  This ties the instructions together in the post-ra scheduler.</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">  /// inserted.  This ties the instructions together in the post-ra scheduler.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">  virtual void breakPartialRegDependency(MachineInstr &MI, unsigned OpNum,</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">  virtual void breakPartialRegDependency(MachineInstr &MI, unsigned OpNum,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">                                         const TargetRegisterInfo *TRI) const {}</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">                                         const TargetRegisterInfo *TRI) const {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline"></td>
    <td class="lineNumber">1849</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">  /// Create machine specific model for scheduling.</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">  /// Create machine specific model for scheduling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">  virtual DFAPacketizer *</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">  virtual DFAPacketizer *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">  CreateTargetScheduleState(const TargetSubtargetInfo &) const {</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">  CreateTargetScheduleState(const TargetSubtargetInfo &) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline"></td>
    <td class="lineNumber">1855</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">  /// Sometimes, it is possible for the target</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">  /// Sometimes, it is possible for the target</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">  /// to tell, even without aliasing information, that two MIs access different</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">  /// to tell, even without aliasing information, that two MIs access different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">  /// memory addresses. This function returns true if two MIs access different</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">  /// memory addresses. This function returns true if two MIs access different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">  /// memory addresses and false otherwise.</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">  /// memory addresses and false otherwise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">  /// Assumes any physical registers used to compute addresses have the same</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">  /// Assumes any physical registers used to compute addresses have the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">  /// value for both instructions. (This is the most useful assumption for</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">  /// value for both instructions. (This is the most useful assumption for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">  /// post-RA scheduling.)</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">  /// post-RA scheduling.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">  /// See also MachineInstr::mayAlias, which is implemented on top of this</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">  /// See also MachineInstr::mayAlias, which is implemented on top of this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">  /// function.</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">  /// function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">  virtual bool</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">  virtual bool</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">  areMemAccessesTriviallyDisjoint(const MachineInstr &MIa,</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">  areMemAccessesTriviallyDisjoint(const MachineInstr &MIa,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">                                  const MachineInstr &MIb) const {</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">                                  const MachineInstr &MIb) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">    assert(MIa.mayLoadOrStore() &&</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">    assert(MIa.mayLoadOrStore() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">           "MIa must load from or modify a memory location");</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">           "MIa must load from or modify a memory location");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">    assert(MIb.mayLoadOrStore() &&</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">    assert(MIb.mayLoadOrStore() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">           "MIb must load from or modify a memory location");</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">           "MIb must load from or modify a memory location");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline"></td>
    <td class="lineNumber">1876</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">  /// Return the value to use for the MachineCSE's LookAheadLimit,</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">  /// Return the value to use for the MachineCSE's LookAheadLimit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">  /// which is a heuristic used for CSE'ing phys reg defs.</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">  /// which is a heuristic used for CSE'ing phys reg defs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">  virtual unsigned getMachineCSELookAheadLimit() const {</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">  virtual unsigned getMachineCSELookAheadLimit() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">    // The default lookahead is small to prevent unprofitable quadratic</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">    // The default lookahead is small to prevent unprofitable quadratic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">    // behavior.</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">    // behavior.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">    return 5;</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">    return 5;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline"></td>
    <td class="lineNumber">1884</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">  /// Return the maximal number of alias checks on memory operands. For</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">  /// Return the maximal number of alias checks on memory operands. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">  /// instructions with more than one memory operands, the alias check on a</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">  /// instructions with more than one memory operands, the alias check on a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">  /// single MachineInstr pair has quadratic overhead and results in</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">  /// single MachineInstr pair has quadratic overhead and results in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">  /// unacceptable performance in the worst case. The limit here is to clamp</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">  /// unacceptable performance in the worst case. The limit here is to clamp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">  /// that maximal checks performed. Usually, that's the product of memory</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">  /// that maximal checks performed. Usually, that's the product of memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">  /// operand numbers from that pair of MachineInstr to be checked. For</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">  /// operand numbers from that pair of MachineInstr to be checked. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">  /// instance, with two MachineInstrs with 4 and 5 memory operands</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">  /// instance, with two MachineInstrs with 4 and 5 memory operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">  /// correspondingly, a total of 20 checks are required. With this limit set to</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">  /// correspondingly, a total of 20 checks are required. With this limit set to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">  /// 16, their alias check is skipped. We choose to limit the product instead</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">  /// 16, their alias check is skipped. We choose to limit the product instead</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">  /// of the individual instruction as targets may have special MachineInstrs</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">  /// of the individual instruction as targets may have special MachineInstrs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">  /// with a considerably high number of memory operands, such as `ldm` in ARM.</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">  /// with a considerably high number of memory operands, such as `ldm` in ARM.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">  /// Setting this limit per MachineInstr would result in either too high</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">  /// Setting this limit per MachineInstr would result in either too high</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">  /// overhead or too rigid restriction.</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">  /// overhead or too rigid restriction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">  virtual unsigned getMemOperandAACheckLimit() const { return 16; }</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">  virtual unsigned getMemOperandAACheckLimit() const { return 16; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline"></td>
    <td class="lineNumber">1899</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">  /// Return an array that contains the ids of the target indices (used for the</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">  /// Return an array that contains the ids of the target indices (used for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">  /// TargetIndex machine operand) and their names.</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">  /// TargetIndex machine operand) and their names.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">  /// MIR Serialization is able to serialize only the target indices that are</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">  /// MIR Serialization is able to serialize only the target indices that are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">  /// defined by this method.</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">  /// defined by this method.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">  virtual ArrayRef<std::pair<int, const char *>></td>
    <td class="lineNumber">1905</td>
    <td class="codeline">  virtual ArrayRef<std::pair<int, const char *>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">  getSerializableTargetIndices() const {</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">  getSerializableTargetIndices() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline"></td>
    <td class="lineNumber">1909</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">  /// Decompose the machine operand's target flags into two values - the direct</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">  /// Decompose the machine operand's target flags into two values - the direct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">  /// target flag value and any of bit flags that are applied.</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">  /// target flag value and any of bit flags that are applied.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">  virtual std::pair<unsigned, unsigned></td>
    <td class="lineNumber">1912</td>
    <td class="codeline">  virtual std::pair<unsigned, unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">  decomposeMachineOperandsTargetFlags(unsigned /*TF*/) const {</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">  decomposeMachineOperandsTargetFlags(unsigned /*TF*/) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">    return std::make_pair(0u, 0u);</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">    return std::make_pair(0u, 0u);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline"></td>
    <td class="lineNumber">1916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">  /// Return an array that contains the direct target flag values and their</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">  /// Return an array that contains the direct target flag values and their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">  /// names.</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">  /// names.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">  /// MIR Serialization is able to serialize only the target flags that are</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">  /// MIR Serialization is able to serialize only the target flags that are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">  /// defined by this method.</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">  /// defined by this method.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">  virtual ArrayRef<std::pair<unsigned, const char *>></td>
    <td class="lineNumber">1922</td>
    <td class="codeline">  virtual ArrayRef<std::pair<unsigned, const char *>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">  getSerializableDirectMachineOperandTargetFlags() const {</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">  getSerializableDirectMachineOperandTargetFlags() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline"></td>
    <td class="lineNumber">1926</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">  /// Return an array that contains the bitmask target flag values and their</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">  /// Return an array that contains the bitmask target flag values and their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">  /// names.</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">  /// names.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">  /// MIR Serialization is able to serialize only the target flags that are</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">  /// MIR Serialization is able to serialize only the target flags that are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">  /// defined by this method.</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">  /// defined by this method.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline">  virtual ArrayRef<std::pair<unsigned, const char *>></td>
    <td class="lineNumber">1932</td>
    <td class="codeline">  virtual ArrayRef<std::pair<unsigned, const char *>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">  getSerializableBitmaskMachineOperandTargetFlags() const {</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">  getSerializableBitmaskMachineOperandTargetFlags() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline"></td>
    <td class="lineNumber">1936</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">  /// Return an array that contains the MMO target flag values and their</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">  /// Return an array that contains the MMO target flag values and their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">  /// names.</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">  /// names.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">  /// MIR Serialization is able to serialize only the MMO target flags that are</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">  /// MIR Serialization is able to serialize only the MMO target flags that are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">  /// defined by this method.</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">  /// defined by this method.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">  virtual ArrayRef<std::pair<MachineMemOperand::Flags, const char *>></td>
    <td class="lineNumber">1942</td>
    <td class="codeline">  virtual ArrayRef<std::pair<MachineMemOperand::Flags, const char *>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">  getSerializableMachineMemOperandTargetFlags() const {</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">  getSerializableMachineMemOperandTargetFlags() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">    return std::nullopt;</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">    return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline"></td>
    <td class="lineNumber">1946</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">  /// Determines whether \p Inst is a tail call instruction. Override this</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">  /// Determines whether \p Inst is a tail call instruction. Override this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">  /// method on targets that do not properly set MCID::Return and MCID::Call on</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">  /// method on targets that do not properly set MCID::Return and MCID::Call on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">  /// tail call instructions."</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">  /// tail call instructions."</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">  virtual bool isTailCall(const MachineInstr &Inst) const {</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">  virtual bool isTailCall(const MachineInstr &Inst) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">    return Inst.isReturn() && Inst.isCall();</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">    return Inst.isReturn() && Inst.isCall();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline"></td>
    <td class="lineNumber">1953</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">  /// True if the instruction is bound to the top of its basic block and no</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">  /// True if the instruction is bound to the top of its basic block and no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">  /// other instructions shall be inserted before it. This can be implemented</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">  /// other instructions shall be inserted before it. This can be implemented</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">  /// to prevent register allocator to insert spills before such instructions.</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">  /// to prevent register allocator to insert spills before such instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">  virtual bool isBasicBlockPrologue(const MachineInstr &MI) const {</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">  virtual bool isBasicBlockPrologue(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline"></td>
    <td class="lineNumber">1960</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">  /// During PHI eleimination lets target to make necessary checks and</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">  /// During PHI eleimination lets target to make necessary checks and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">  /// insert the copy to the PHI destination register in a target specific</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">  /// insert the copy to the PHI destination register in a target specific</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">  /// manner.</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">  /// manner.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">  virtual MachineInstr *createPHIDestinationCopy(</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">  virtual MachineInstr *createPHIDestinationCopy(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">      MachineBasicBlock &MBB, MachineBasicBlock::iterator InsPt,</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">      MachineBasicBlock &MBB, MachineBasicBlock::iterator InsPt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">      const DebugLoc &DL, Register Src, Register Dst) const {</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">      const DebugLoc &DL, Register Src, Register Dst) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">    return BuildMI(MBB, InsPt, DL, get(TargetOpcode::COPY), Dst)</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">    return BuildMI(MBB, InsPt, DL, get(TargetOpcode::COPY), Dst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">        .addReg(Src);</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">        .addReg(Src);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline"></td>
    <td class="lineNumber">1970</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">  /// During PHI eleimination lets target to make necessary checks and</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">  /// During PHI eleimination lets target to make necessary checks and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">  /// insert the copy to the PHI destination register in a target specific</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">  /// insert the copy to the PHI destination register in a target specific</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">  /// manner.</td>
    <td class="lineNumber">1973</td>
    <td class="codeline">  /// manner.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">  virtual MachineInstr *createPHISourceCopy(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">  virtual MachineInstr *createPHISourceCopy(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">                                            MachineBasicBlock::iterator InsPt,</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">                                            MachineBasicBlock::iterator InsPt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">                                            const DebugLoc &DL, Register Src,</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">                                            const DebugLoc &DL, Register Src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">                                            unsigned SrcSubReg,</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">                                            unsigned SrcSubReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">                                            Register Dst) const {</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">                                            Register Dst) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">    return BuildMI(MBB, InsPt, DL, get(TargetOpcode::COPY), Dst)</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">    return BuildMI(MBB, InsPt, DL, get(TargetOpcode::COPY), Dst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">        .addReg(Src, 0, SrcSubReg);</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">        .addReg(Src, 0, SrcSubReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline"></td>
    <td class="lineNumber">1982</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">  /// Returns a \p outliner::OutlinedFunction struct containing target-specific</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">  /// Returns a \p outliner::OutlinedFunction struct containing target-specific</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">  /// information for a set of outlining candidates. Returns std::nullopt if the</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">  /// information for a set of outlining candidates. Returns std::nullopt if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">  /// candidates are not suitable for outlining.</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">  /// candidates are not suitable for outlining.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">  virtual std::optional<outliner::OutlinedFunction> getOutliningCandidateInfo(</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">  virtual std::optional<outliner::OutlinedFunction> getOutliningCandidateInfo(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">      std::vector<outliner::Candidate> &RepeatedSequenceLocs) const {</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">      std::vector<outliner::Candidate> &RepeatedSequenceLocs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">    llvm_unreachable(</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">    llvm_unreachable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">        "Target didn't implement TargetInstrInfo::getOutliningCandidateInfo!");</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">        "Target didn't implement TargetInstrInfo::getOutliningCandidateInfo!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline"></td>
    <td class="lineNumber">1991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">  /// Optional target hook to create the LLVM IR attributes for the outlined</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">  /// Optional target hook to create the LLVM IR attributes for the outlined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">  /// function. If overridden, the overriding function must call the default</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">  /// function. If overridden, the overriding function must call the default</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">  /// implementation.</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">  /// implementation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">  virtual void mergeOutliningCandidateAttributes(</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">  virtual void mergeOutliningCandidateAttributes(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">      Function &F, std::vector<outliner::Candidate> &Candidates) const;</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">      Function &F, std::vector<outliner::Candidate> &Candidates) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline"></td>
    <td class="lineNumber">1997</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">  /// Target-dependent implementation for getOutliningTypeImpl.</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">  /// Target-dependent implementation for getOutliningTypeImpl.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">  virtual outliner::InstrType</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">  virtual outliner::InstrType</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">  getOutliningTypeImpl(MachineBasicBlock::iterator &MIT, unsigned Flags) const {</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">  getOutliningTypeImpl(MachineBasicBlock::iterator &MIT, unsigned Flags) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">    llvm_unreachable(</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">    llvm_unreachable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">        "Target didn't implement TargetInstrInfo::getOutliningTypeImpl!");</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">        "Target didn't implement TargetInstrInfo::getOutliningTypeImpl!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline"></td>
    <td class="lineNumber">2005</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">  /// Returns how or if \p MIT should be outlined. \p Flags is the</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">  /// Returns how or if \p MIT should be outlined. \p Flags is the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">  /// target-specific information returned by isMBBSafeToOutlineFrom.</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">  /// target-specific information returned by isMBBSafeToOutlineFrom.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">  outliner::InstrType</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">  outliner::InstrType</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">  getOutliningType(MachineBasicBlock::iterator &MIT, unsigned Flags) const;</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">  getOutliningType(MachineBasicBlock::iterator &MIT, unsigned Flags) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline"></td>
    <td class="lineNumber">2011</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">  /// Optional target hook that returns true if \p MBB is safe to outline from,</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">  /// Optional target hook that returns true if \p MBB is safe to outline from,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">  /// and returns any target-specific information in \p Flags.</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">  /// and returns any target-specific information in \p Flags.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">  virtual bool isMBBSafeToOutlineFrom(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">  virtual bool isMBBSafeToOutlineFrom(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">                                      unsigned &Flags) const;</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">                                      unsigned &Flags) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline"></td>
    <td class="lineNumber">2016</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">  /// Optional target hook which partitions \p MBB into outlinable ranges for</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">  /// Optional target hook which partitions \p MBB into outlinable ranges for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">  /// instruction mapping purposes. Each range is defined by two iterators:</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">  /// instruction mapping purposes. Each range is defined by two iterators:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">  /// [start, end).</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">  /// [start, end).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">  /// Ranges are expected to be ordered top-down. That is, ranges closer to the</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">  /// Ranges are expected to be ordered top-down. That is, ranges closer to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">  /// top of the block should come before ranges closer to the end of the block.</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">  /// top of the block should come before ranges closer to the end of the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">  /// Ranges cannot overlap.</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">  /// Ranges cannot overlap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">  /// If an entire block is mappable, then its range is [MBB.begin(), MBB.end())</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">  /// If an entire block is mappable, then its range is [MBB.begin(), MBB.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">  /// All instructions not present in an outlinable range are considered</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">  /// All instructions not present in an outlinable range are considered</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">  /// illegal.</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">  /// illegal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">  virtual SmallVector<</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">  virtual SmallVector<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">      std::pair<MachineBasicBlock::iterator, MachineBasicBlock::iterator>></td>
    <td class="lineNumber">2031</td>
    <td class="codeline">      std::pair<MachineBasicBlock::iterator, MachineBasicBlock::iterator>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">  getOutlinableRanges(MachineBasicBlock &MBB, unsigned &Flags) const {</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">  getOutlinableRanges(MachineBasicBlock &MBB, unsigned &Flags) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">    return {std::make_pair(MBB.begin(), MBB.end())};</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">    return {std::make_pair(MBB.begin(), MBB.end())};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline"></td>
    <td class="lineNumber">2035</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">  /// Insert a custom frame for outlined functions.</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">  /// Insert a custom frame for outlined functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">  virtual void buildOutlinedFrame(MachineBasicBlock &MBB, MachineFunction &MF,</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">  virtual void buildOutlinedFrame(MachineBasicBlock &MBB, MachineFunction &MF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">                                  const outliner::OutlinedFunction &OF) const {</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">                                  const outliner::OutlinedFunction &OF) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">    llvm_unreachable(</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">    llvm_unreachable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">        "Target didn't implement TargetInstrInfo::buildOutlinedFrame!");</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">        "Target didn't implement TargetInstrInfo::buildOutlinedFrame!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline"></td>
    <td class="lineNumber">2042</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">  /// Insert a call to an outlined function into the program.</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">  /// Insert a call to an outlined function into the program.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">  /// Returns an iterator to the spot where we inserted the call. This must be</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">  /// Returns an iterator to the spot where we inserted the call. This must be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">  /// implemented by the target.</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">  /// implemented by the target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">  virtual MachineBasicBlock::iterator</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">  virtual MachineBasicBlock::iterator</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">  insertOutlinedCall(Module &M, MachineBasicBlock &MBB,</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">  insertOutlinedCall(Module &M, MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">                     MachineBasicBlock::iterator &It, MachineFunction &MF,</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">                     MachineBasicBlock::iterator &It, MachineFunction &MF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">                     outliner::Candidate &C) const {</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">                     outliner::Candidate &C) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">    llvm_unreachable(</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">    llvm_unreachable(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">        "Target didn't implement TargetInstrInfo::insertOutlinedCall!");</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">        "Target didn't implement TargetInstrInfo::insertOutlinedCall!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline"></td>
    <td class="lineNumber">2053</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">  /// Return true if the function can safely be outlined from.</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">  /// Return true if the function can safely be outlined from.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">  /// A function \p MF is considered safe for outlining if an outlined function</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">  /// A function \p MF is considered safe for outlining if an outlined function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">  /// produced from instructions in F will produce a program which produces the</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">  /// produced from instructions in F will produce a program which produces the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">  /// same output for any set of given inputs.</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">  /// same output for any set of given inputs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">  virtual bool isFunctionSafeToOutlineFrom(MachineFunction &MF,</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">  virtual bool isFunctionSafeToOutlineFrom(MachineFunction &MF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline">                                           bool OutlineFromLinkOnceODRs) const {</td>
    <td class="lineNumber">2059</td>
    <td class="codeline">                                           bool OutlineFromLinkOnceODRs) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement "</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">    llvm_unreachable("Target didn't implement "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">                     "TargetInstrInfo::isFunctionSafeToOutlineFrom!");</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">                     "TargetInstrInfo::isFunctionSafeToOutlineFrom!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline"></td>
    <td class="lineNumber">2063</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">  /// Return true if the function should be outlined from by default.</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">  /// Return true if the function should be outlined from by default.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">  virtual bool shouldOutlineFromFunctionByDefault(MachineFunction &MF) const {</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">  virtual bool shouldOutlineFromFunctionByDefault(MachineFunction &MF) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline"></td>
    <td class="lineNumber">2068</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">  /// Produce the expression describing the \p MI loading a value into</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">  /// Produce the expression describing the \p MI loading a value into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">  /// the physical register \p Reg. This hook should only be used with</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">  /// the physical register \p Reg. This hook should only be used with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">  /// \p MIs belonging to VReg-less functions.</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">  /// \p MIs belonging to VReg-less functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">  virtual std::optional<ParamLoadedValue></td>
    <td class="lineNumber">2072</td>
    <td class="codeline">  virtual std::optional<ParamLoadedValue></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">  describeLoadedValue(const MachineInstr &MI, Register Reg) const;</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">  describeLoadedValue(const MachineInstr &MI, Register Reg) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline"></td>
    <td class="lineNumber">2074</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">  /// Given the generic extension instruction \p ExtMI, returns true if this</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">  /// Given the generic extension instruction \p ExtMI, returns true if this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">  /// extension is a likely candidate for being folded into an another</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">  /// extension is a likely candidate for being folded into an another</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">  /// instruction.</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">  /// instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">  virtual bool isExtendLikelyToBeFolded(MachineInstr &ExtMI,</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">  virtual bool isExtendLikelyToBeFolded(MachineInstr &ExtMI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">                                        MachineRegisterInfo &MRI) const {</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">                                        MachineRegisterInfo &MRI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline"></td>
    <td class="lineNumber">2082</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">  /// Return MIR formatter to format/parse MIR operands.  Target can override</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">  /// Return MIR formatter to format/parse MIR operands.  Target can override</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">  /// this virtual function and return target specific MIR formatter.</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">  /// this virtual function and return target specific MIR formatter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">  virtual const MIRFormatter *getMIRFormatter() const {</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">  virtual const MIRFormatter *getMIRFormatter() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">    if (!Formatter.get())</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">    if (!Formatter.get())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">      Formatter = std::make_unique<MIRFormatter>();</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">      Formatter = std::make_unique<MIRFormatter>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">    return Formatter.get();</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">    return Formatter.get();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline"></td>
    <td class="lineNumber">2090</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">  /// Returns the target-specific default value for tail duplication.</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">  /// Returns the target-specific default value for tail duplication.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">  /// This value will be used if the tail-dup-placement-threshold argument is</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">  /// This value will be used if the tail-dup-placement-threshold argument is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">  /// not provided.</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">  /// not provided.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">  virtual unsigned getTailDuplicateSize(CodeGenOpt::Level OptLevel) const {</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">  virtual unsigned getTailDuplicateSize(CodeGenOpt::Level OptLevel) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">    return OptLevel >= CodeGenOpt::Aggressive ? 4 : 2;</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">    return OptLevel >= CodeGenOpt::Aggressive ? 4 : 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline"></td>
    <td class="lineNumber">2097</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">  /// Returns the callee operand from the given \p MI.</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">  /// Returns the callee operand from the given \p MI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">  virtual const MachineOperand &getCalleeOperand(const MachineInstr &MI) const {</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">  virtual const MachineOperand &getCalleeOperand(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">    return MI.getOperand(0);</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">    return MI.getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline"></td>
    <td class="lineNumber">2102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">  /// Return the uniformity behavior of the given instruction.</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">  /// Return the uniformity behavior of the given instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">  virtual InstructionUniformity</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">  virtual InstructionUniformity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">  getInstructionUniformity(const MachineInstr &MI) const {</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">  getInstructionUniformity(const MachineInstr &MI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">    return InstructionUniformity::Default;</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">    return InstructionUniformity::Default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline"></td>
    <td class="lineNumber">2108</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">  /// Returns true if the given \p MI defines a TargetIndex operand that can be</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">  /// Returns true if the given \p MI defines a TargetIndex operand that can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">  /// tracked by their offset, can have values, and can have debug info</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">  /// tracked by their offset, can have values, and can have debug info</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">  /// associated with it. If so, sets \p Index and \p Offset of the target index</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">  /// associated with it. If so, sets \p Index and \p Offset of the target index</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">  /// operand.</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">  /// operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine diffFirst">  virtual bool isExplicitTargetIndexDef(const MachineInstr &MI, int &Index,</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">  virtual bool isExplicitTargetIndexDef(const MachineInstr &MI, int &Index,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">                                        int64_t &Offset) const {</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">                                        int64_t &Offset) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine diffFirst">    return false;</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline"></td>
    <td class="lineNumber">2117</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">  // Get the call frame size just before MI.</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">  // Get the call frame size just before MI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">  unsigned getCallFrameSizeAt(MachineInstr &MI) const;</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">  unsigned getCallFrameSizeAt(MachineInstr &MI) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline"></td>
    <td class="lineNumber">2120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">  mutable std::unique_ptr<MIRFormatter> Formatter;</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">  mutable std::unique_ptr<MIRFormatter> Formatter;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">  unsigned CallFrameSetupOpcode, CallFrameDestroyOpcode;</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">  unsigned CallFrameSetupOpcode, CallFrameDestroyOpcode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">  unsigned CatchRetOpcode;</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">  unsigned CatchRetOpcode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">  unsigned ReturnOpcode;</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">  unsigned ReturnOpcode;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline"></td>
    <td class="lineNumber">2127</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">/// Provide DenseMapInfo for TargetInstrInfo::RegSubRegPair.</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">/// Provide DenseMapInfo for TargetInstrInfo::RegSubRegPair.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">template <> struct DenseMapInfo<TargetInstrInfo::RegSubRegPair> {</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">template <> struct DenseMapInfo<TargetInstrInfo::RegSubRegPair> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">  using RegInfo = DenseMapInfo<unsigned>;</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">  using RegInfo = DenseMapInfo<unsigned>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline"></td>
    <td class="lineNumber">2131</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">  static inline TargetInstrInfo::RegSubRegPair getEmptyKey() {</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">  static inline TargetInstrInfo::RegSubRegPair getEmptyKey() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">    return TargetInstrInfo::RegSubRegPair(RegInfo::getEmptyKey(),</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">    return TargetInstrInfo::RegSubRegPair(RegInfo::getEmptyKey(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">                                          RegInfo::getEmptyKey());</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">                                          RegInfo::getEmptyKey());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline"></td>
    <td class="lineNumber">2136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">  static inline TargetInstrInfo::RegSubRegPair getTombstoneKey() {</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">  static inline TargetInstrInfo::RegSubRegPair getTombstoneKey() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">    return TargetInstrInfo::RegSubRegPair(RegInfo::getTombstoneKey(),</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">    return TargetInstrInfo::RegSubRegPair(RegInfo::getTombstoneKey(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">                                          RegInfo::getTombstoneKey());</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">                                          RegInfo::getTombstoneKey());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline"></td>
    <td class="lineNumber">2141</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">  /// Reuse getHashValue implementation from</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">  /// Reuse getHashValue implementation from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">  /// std::pair<unsigned, unsigned>.</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">  /// std::pair<unsigned, unsigned>.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">  static unsigned getHashValue(const TargetInstrInfo::RegSubRegPair &Val) {</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">  static unsigned getHashValue(const TargetInstrInfo::RegSubRegPair &Val) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">    std::pair<unsigned, unsigned> PairVal = std::make_pair(Val.Reg, Val.SubReg);</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">    std::pair<unsigned, unsigned> PairVal = std::make_pair(Val.Reg, Val.SubReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">    return DenseMapInfo<std::pair<unsigned, unsigned>>::getHashValue(PairVal);</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">    return DenseMapInfo<std::pair<unsigned, unsigned>>::getHashValue(PairVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline"></td>
    <td class="lineNumber">2148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">  static bool isEqual(const TargetInstrInfo::RegSubRegPair &LHS,</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">  static bool isEqual(const TargetInstrInfo::RegSubRegPair &LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">                      const TargetInstrInfo::RegSubRegPair &RHS) {</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">                      const TargetInstrInfo::RegSubRegPair &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">    return RegInfo::isEqual(LHS.Reg, RHS.Reg) &&</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">    return RegInfo::isEqual(LHS.Reg, RHS.Reg) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">           RegInfo::isEqual(LHS.SubReg, RHS.SubReg);</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">           RegInfo::isEqual(LHS.SubReg, RHS.SubReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline"></td>
    <td class="lineNumber">2155</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline"></td>
    <td class="lineNumber">2157</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">#endif // LLVM_CODEGEN_TARGETINSTRINFO_H</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">#endif // LLVM_CODEGEN_TARGETINSTRINFO_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline"></td>
    <td class="lineNumber">2159</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- llvm/CodeGen/TargetInstrInfo.h - Instruction Info --------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- llvm/CodeGen/TargetInstrInfo.h - Instruction Info --------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file describes the target machine instruction set to the code generator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file describes the target machine instruction set to the code generator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">#ifndef LLVM_CODEGEN_TARGETINSTRINFO_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">#ifndef LLVM_CODEGEN_TARGETINSTRINFO_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">#define LLVM_CODEGEN_TARGETINSTRINFO_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">#define LLVM_CODEGEN_TARGETINSTRINFO_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/Uniformity.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/Uniformity.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/CodeGen/MIRFormatter.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/CodeGen/MIRFormatter.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineOutliner.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineOutliner.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/CodeGen/RegisterClassInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/CodeGen/RegisterClassInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/CodeGen/VirtRegMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/CodeGen/VirtRegMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/MC/MCInstrInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/MC/MCInstrInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/Support/BranchProbability.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/Support/BranchProbability.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include <cstddef></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include <cstddef></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">class DFAPacketizer;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">class DFAPacketizer;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">class InstrItineraryData;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">class InstrItineraryData;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">class LiveIntervals;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">class LiveIntervals;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">class LiveVariables;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">class LiveVariables;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">class MachineLoop;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">class MachineLoop;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">class MachineMemOperand;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">class MachineMemOperand;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">class MachineRegisterInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">class MachineRegisterInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">class MCAsmInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">class MCAsmInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">class MCInst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">class MCInst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">struct MCSchedModel;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">struct MCSchedModel;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">class Module;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">class Module;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">class ScheduleDAG;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">class ScheduleDAG;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">class ScheduleDAGMI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">class ScheduleDAGMI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">class ScheduleHazardRecognizer;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">class ScheduleHazardRecognizer;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">class SDNode;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">class SDNode;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">class SelectionDAG;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">class SelectionDAG;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">class SMSchedule;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">class SMSchedule;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">class SwingSchedulerDAG;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">class SwingSchedulerDAG;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">class RegScavenger;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">class RegScavenger;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">class TargetRegisterClass;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">class TargetRegisterClass;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">class TargetRegisterInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">class TargetRegisterInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">class TargetSchedModel;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">class TargetSchedModel;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">class TargetSubtargetInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">class TargetSubtargetInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">enum class MachineCombinerPattern;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">enum class MachineCombinerPattern;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">enum class MachineTraceStrategy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">enum class MachineTraceStrategy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">template <class T> class SmallVectorImpl;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">template <class T> class SmallVectorImpl;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">using ParamLoadedValue = std::pair<MachineOperand, DIExpression*>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">using ParamLoadedValue = std::pair<MachineOperand, DIExpression*>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">struct DestSourcePair {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">struct DestSourcePair {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">  const MachineOperand *Destination;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">  const MachineOperand *Destination;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">  const MachineOperand *Source;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">  const MachineOperand *Source;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine coveredLine">  DestSourcePair(const MachineOperand &Dest, const MachineOperand &Src)</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">  DestSourcePair(const MachineOperand &Dest, const MachineOperand &Src)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine coveredLine">      : Destination(&Dest), Source(&Src) {}</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">      : Destination(&Dest), Source(&Src) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">/// Used to describe a register and immediate addition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">/// Used to describe a register and immediate addition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">struct RegImmPair {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">struct RegImmPair {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">  Register Reg;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">  Register Reg;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">  int64_t Imm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">  int64_t Imm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">  RegImmPair(Register Reg, int64_t Imm) : Reg(Reg), Imm(Imm) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">  RegImmPair(Register Reg, int64_t Imm) : Reg(Reg), Imm(Imm) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">/// Used to describe addressing mode similar to ExtAddrMode in CodeGenPrepare.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">/// Used to describe addressing mode similar to ExtAddrMode in CodeGenPrepare.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">/// It holds the register values, the scale value and the displacement.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">/// It holds the register values, the scale value and the displacement.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">struct ExtAddrMode {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">struct ExtAddrMode {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">  Register BaseReg;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">  Register BaseReg;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">  Register ScaledReg;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">  Register ScaledReg;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">  int64_t Scale;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">  int64_t Scale;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">  int64_t Displacement;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">  int64_t Displacement;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">//---------------------------------------------------------------------------</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">//---------------------------------------------------------------------------</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">/// TargetInstrInfo - Interface to description of machine instruction set</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">/// TargetInstrInfo - Interface to description of machine instruction set</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">class TargetInstrInfo : public MCInstrInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">class TargetInstrInfo : public MCInstrInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine coveredLine">  TargetInstrInfo(unsigned CFSetupOpcode = ~0u, unsigned CFDestroyOpcode = ~0u,</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">101</td>
    <td class="codeLine coveredLine">  TargetInstrInfo(unsigned CFSetupOpcode = ~0u, unsigned CFDestroyOpcode = ~0u,</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">                  unsigned CatchRetOpcode = ~0u, unsigned ReturnOpcode = ~0u)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">                  unsigned CatchRetOpcode = ~0u, unsigned ReturnOpcode = ~0u)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine coveredLine">      : CallFrameSetupOpcode(CFSetupOpcode),</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">103</td>
    <td class="codeLine coveredLine">      : CallFrameSetupOpcode(CFSetupOpcode),</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine coveredLine">        CallFrameDestroyOpcode(CFDestroyOpcode), CatchRetOpcode(CatchRetOpcode),</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">104</td>
    <td class="codeLine coveredLine">        CallFrameDestroyOpcode(CFDestroyOpcode), CatchRetOpcode(CatchRetOpcode),</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine coveredLine">        ReturnOpcode(ReturnOpcode) {}</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">105</td>
    <td class="codeLine coveredLine">        ReturnOpcode(ReturnOpcode) {}</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">  TargetInstrInfo(const TargetInstrInfo &) = delete;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">  TargetInstrInfo(const TargetInstrInfo &) = delete;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">  TargetInstrInfo &operator=(const TargetInstrInfo &) = delete;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">  TargetInstrInfo &operator=(const TargetInstrInfo &) = delete;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">  virtual ~TargetInstrInfo();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">  virtual ~TargetInstrInfo();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  static bool isGenericOpcode(unsigned Opc) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  static bool isGenericOpcode(unsigned Opc) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">    return Opc <= TargetOpcode::GENERIC_OP_END;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">    return Opc <= TargetOpcode::GENERIC_OP_END;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">  static bool isGenericAtomicRMWOpcode(unsigned Opc) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">  static bool isGenericAtomicRMWOpcode(unsigned Opc) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">    return Opc >= TargetOpcode::GENERIC_ATOMICRMW_OP_START &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">    return Opc >= TargetOpcode::GENERIC_ATOMICRMW_OP_START &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">           Opc <= TargetOpcode::GENERIC_ATOMICRMW_OP_END;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">           Opc <= TargetOpcode::GENERIC_ATOMICRMW_OP_END;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">  /// Given a machine instruction descriptor, returns the register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">  /// Given a machine instruction descriptor, returns the register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">  /// class constraint for OpNum, or NULL.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">  /// class constraint for OpNum, or NULL.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  virtual</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  virtual</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">  const TargetRegisterClass *getRegClass(const MCInstrDesc &MCID, unsigned OpNum,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">  const TargetRegisterClass *getRegClass(const MCInstrDesc &MCID, unsigned OpNum,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">                                         const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">                                         const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">                                         const MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">                                         const MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">  /// Return true if the instruction is trivially rematerializable, meaning it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">  /// Return true if the instruction is trivially rematerializable, meaning it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  /// has no side effects and requires no operands that aren't always available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  /// has no side effects and requires no operands that aren't always available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  /// This means the only allowed uses are constants and unallocatable physical</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  /// This means the only allowed uses are constants and unallocatable physical</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">  /// registers so that the instructions result is independent of the place</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">  /// registers so that the instructions result is independent of the place</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">  /// in the function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">  /// in the function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine coveredLine">  bool isTriviallyReMaterializable(const MachineInstr &MI) const {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">131</td>
    <td class="codeLine coveredLine">  bool isTriviallyReMaterializable(const MachineInstr &MI) const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine coveredLine">    return MI.getOpcode() == TargetOpcode::IMPLICIT_DEF ||</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">132</td>
    <td class="codeLine coveredLine">    return MI.getOpcode() == TargetOpcode::IMPLICIT_DEF ||</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine coveredLine">           (MI.getDesc().isRematerializable() &&</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">133</td>
    <td class="codeLine coveredLine">           (MI.getDesc().isRematerializable() &&</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">            (isReallyTriviallyReMaterializable(MI) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">            (isReallyTriviallyReMaterializable(MI) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine coveredLine">             isReallyTriviallyReMaterializableGeneric(MI)));</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">135</td>
    <td class="codeLine coveredLine">             isReallyTriviallyReMaterializableGeneric(MI)));</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">  /// Given \p MO is a PhysReg use return if it can be ignored for the purpose</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">  /// Given \p MO is a PhysReg use return if it can be ignored for the purpose</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">  /// of instruction rematerialization or sinking.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">  /// of instruction rematerialization or sinking.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">  virtual bool isIgnorableUse(const MachineOperand &MO) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">  virtual bool isIgnorableUse(const MachineOperand &MO) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">  /// For instructions with opcodes for which the M_REMATERIALIZABLE flag is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">  /// For instructions with opcodes for which the M_REMATERIALIZABLE flag is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">  /// set, this hook lets the target specify whether the instruction is actually</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">  /// set, this hook lets the target specify whether the instruction is actually</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  /// trivially rematerializable, taking into consideration its operands. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  /// trivially rematerializable, taking into consideration its operands. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">  /// predicate must return false if the instruction has any side effects other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">  /// predicate must return false if the instruction has any side effects other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">  /// than producing a value, or if it requres any address registers that are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">  /// than producing a value, or if it requres any address registers that are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">  /// not always available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">  /// not always available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">  /// Requirements must be check as stated in isTriviallyReMaterializable() .</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">  /// Requirements must be check as stated in isTriviallyReMaterializable() .</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">  virtual bool isReallyTriviallyReMaterializable(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">  virtual bool isReallyTriviallyReMaterializable(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">  /// This method commutes the operands of the given machine instruction MI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">  /// This method commutes the operands of the given machine instruction MI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  /// The operands to be commuted are specified by their indices OpIdx1 and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  /// The operands to be commuted are specified by their indices OpIdx1 and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">  /// OpIdx2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">  /// OpIdx2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">  /// If a target has any instructions that are commutable but require</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">  /// If a target has any instructions that are commutable but require</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">  /// converting to different instructions or making non-trivial changes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">  /// converting to different instructions or making non-trivial changes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">  /// to commute them, this method can be overloaded to do that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">  /// to commute them, this method can be overloaded to do that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">  /// The default implementation simply swaps the commutable operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">  /// The default implementation simply swaps the commutable operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">  /// If NewMI is false, MI is modified in place and returned; otherwise, a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">  /// If NewMI is false, MI is modified in place and returned; otherwise, a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">  /// new machine instruction is created and returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">  /// new machine instruction is created and returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">  /// Do not call this method for a non-commutable instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">  /// Do not call this method for a non-commutable instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  /// Even though the instruction is commutable, the method may still</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  /// Even though the instruction is commutable, the method may still</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">  /// fail to commute the operands, null pointer is returned in such cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">  /// fail to commute the operands, null pointer is returned in such cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  virtual MachineInstr *commuteInstructionImpl(MachineInstr &MI, bool NewMI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  virtual MachineInstr *commuteInstructionImpl(MachineInstr &MI, bool NewMI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">                                               unsigned OpIdx1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">                                               unsigned OpIdx1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">                                               unsigned OpIdx2) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">                                               unsigned OpIdx2) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">  /// Assigns the (CommutableOpIdx1, CommutableOpIdx2) pair of commutable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">  /// Assigns the (CommutableOpIdx1, CommutableOpIdx2) pair of commutable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">  /// operand indices to (ResultIdx1, ResultIdx2).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">  /// operand indices to (ResultIdx1, ResultIdx2).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">  /// One or both input values of the pair: (ResultIdx1, ResultIdx2) may be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">  /// One or both input values of the pair: (ResultIdx1, ResultIdx2) may be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  /// predefined to some indices or be undefined (designated by the special</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  /// predefined to some indices or be undefined (designated by the special</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  /// value 'CommuteAnyOperandIndex').</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  /// value 'CommuteAnyOperandIndex').</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">  /// The predefined result indices cannot be re-defined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">  /// The predefined result indices cannot be re-defined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">  /// The function returns true iff after the result pair redefinition</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">  /// The function returns true iff after the result pair redefinition</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">  /// the fixed result pair is equal to or equivalent to the source pair of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">  /// the fixed result pair is equal to or equivalent to the source pair of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  /// indices: (CommutableOpIdx1, CommutableOpIdx2). It is assumed here that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  /// indices: (CommutableOpIdx1, CommutableOpIdx2). It is assumed here that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">  /// the pairs (x,y) and (y,x) are equivalent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">  /// the pairs (x,y) and (y,x) are equivalent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  static bool fixCommutedOpIndices(unsigned &ResultIdx1, unsigned &ResultIdx2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  static bool fixCommutedOpIndices(unsigned &ResultIdx1, unsigned &ResultIdx2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">                                   unsigned CommutableOpIdx1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">                                   unsigned CommutableOpIdx1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">                                   unsigned CommutableOpIdx2);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">                                   unsigned CommutableOpIdx2);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  /// For instructions with opcodes for which the M_REMATERIALIZABLE flag is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  /// For instructions with opcodes for which the M_REMATERIALIZABLE flag is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  /// set and the target hook isReallyTriviallyReMaterializable returns false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  /// set and the target hook isReallyTriviallyReMaterializable returns false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">  /// this function does target-independent tests to determine if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">  /// this function does target-independent tests to determine if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  /// instruction is really trivially rematerializable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  /// instruction is really trivially rematerializable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">  bool isReallyTriviallyReMaterializableGeneric(const MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">  bool isReallyTriviallyReMaterializableGeneric(const MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  /// These methods return the opcode of the frame setup/destroy instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  /// These methods return the opcode of the frame setup/destroy instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">  /// if they exist (-1 otherwise).  Some targets use pseudo instructions in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">  /// if they exist (-1 otherwise).  Some targets use pseudo instructions in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">  /// order to abstract away the difference between operating with a frame</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">  /// order to abstract away the difference between operating with a frame</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">  /// pointer and operating without, through the use of these two instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">  /// pointer and operating without, through the use of these two instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine coveredLine">  unsigned getCallFrameSetupOpcode() const { return CallFrameSetupOpcode; }</td>
    <td class="lineNumber">41</td>
    <td class="lineNumber">202</td>
    <td class="codeLine coveredLine">  unsigned getCallFrameSetupOpcode() const { return CallFrameSetupOpcode; }</td>
    <td class="lineNumber">43</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine coveredLine">  unsigned getCallFrameDestroyOpcode() const { return CallFrameDestroyOpcode; }</td>
    <td class="lineNumber">56</td>
    <td class="lineNumber">203</td>
    <td class="codeLine coveredLine">  unsigned getCallFrameDestroyOpcode() const { return CallFrameDestroyOpcode; }</td>
    <td class="lineNumber">58</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  /// Returns true if the argument is a frame pseudo instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  /// Returns true if the argument is a frame pseudo instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine coveredLine">  bool isFrameInstr(const MachineInstr &I) const {</td>
    <td class="lineNumber">40</td>
    <td class="lineNumber">206</td>
    <td class="codeLine coveredLine">  bool isFrameInstr(const MachineInstr &I) const {</td>
    <td class="lineNumber">42</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine coveredLine">    return I.getOpcode() == getCallFrameSetupOpcode() ||</td>
    <td class="lineNumber">80</td>
    <td class="lineNumber">207</td>
    <td class="codeLine coveredLine">    return I.getOpcode() == getCallFrameSetupOpcode() ||</td>
    <td class="lineNumber">84</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine coveredLine">           I.getOpcode() == getCallFrameDestroyOpcode();</td>
    <td class="lineNumber">80</td>
    <td class="lineNumber">208</td>
    <td class="codeLine coveredLine">           I.getOpcode() == getCallFrameDestroyOpcode();</td>
    <td class="lineNumber">84</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  /// Returns true if the argument is a frame setup pseudo instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  /// Returns true if the argument is a frame setup pseudo instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  bool isFrameSetup(const MachineInstr &I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  bool isFrameSetup(const MachineInstr &I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">    return I.getOpcode() == getCallFrameSetupOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">    return I.getOpcode() == getCallFrameSetupOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">  /// Returns size of the frame associated with the given frame instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">  /// Returns size of the frame associated with the given frame instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">  /// For frame setup instruction this is frame that is set up space set up</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">  /// For frame setup instruction this is frame that is set up space set up</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">  /// after the instruction. For frame destroy instruction this is the frame</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">  /// after the instruction. For frame destroy instruction this is the frame</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  /// freed by the caller.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  /// freed by the caller.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">  /// Note, in some cases a call frame (or a part of it) may be prepared prior</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">  /// Note, in some cases a call frame (or a part of it) may be prepared prior</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">  /// to the frame setup instruction. It occurs in the calls that involve</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">  /// to the frame setup instruction. It occurs in the calls that involve</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">  /// inalloca arguments. This function reports only the size of the frame part</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">  /// inalloca arguments. This function reports only the size of the frame part</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  /// that is set up between the frame setup and destroy pseudo instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  /// that is set up between the frame setup and destroy pseudo instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">  int64_t getFrameSize(const MachineInstr &I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">  int64_t getFrameSize(const MachineInstr &I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">    assert(isFrameInstr(I) && "Not a frame instruction");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">    assert(isFrameInstr(I) && "Not a frame instruction");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">    assert(I.getOperand(0).getImm() >= 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">    assert(I.getOperand(0).getImm() >= 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">    return I.getOperand(0).getImm();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">    return I.getOperand(0).getImm();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  /// Returns the total frame size, which is made up of the space set up inside</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  /// Returns the total frame size, which is made up of the space set up inside</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  /// the pair of frame start-stop instructions and the space that is set up</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  /// the pair of frame start-stop instructions and the space that is set up</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">  /// prior to the pair.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">  /// prior to the pair.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  int64_t getFrameTotalSize(const MachineInstr &I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  int64_t getFrameTotalSize(const MachineInstr &I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">    if (isFrameSetup(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">    if (isFrameSetup(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">      assert(I.getOperand(1).getImm() >= 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">      assert(I.getOperand(1).getImm() >= 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">             "Frame size must not be negative");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">             "Frame size must not be negative");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">      return getFrameSize(I) + I.getOperand(1).getImm();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">      return getFrameSize(I) + I.getOperand(1).getImm();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">    return getFrameSize(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">    return getFrameSize(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  unsigned getCatchReturnOpcode() const { return CatchRetOpcode; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  unsigned getCatchReturnOpcode() const { return CatchRetOpcode; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  unsigned getReturnOpcode() const { return ReturnOpcode; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  unsigned getReturnOpcode() const { return ReturnOpcode; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">  /// Returns the actual stack pointer adjustment made by an instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">  /// Returns the actual stack pointer adjustment made by an instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">  /// as part of a call sequence. By default, only call frame setup/destroy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">  /// as part of a call sequence. By default, only call frame setup/destroy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">  /// instructions adjust the stack, but targets may want to override this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">  /// instructions adjust the stack, but targets may want to override this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">  /// to enable more fine-grained adjustment, or adjust by a different value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">  /// to enable more fine-grained adjustment, or adjust by a different value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  virtual int getSPAdjust(const MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  virtual int getSPAdjust(const MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">  /// Return true if the instruction is a "coalescable" extension instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">  /// Return true if the instruction is a "coalescable" extension instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  /// That is, it's like a copy where it's legal for the source to overlap the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  /// That is, it's like a copy where it's legal for the source to overlap the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  /// destination. e.g. X86::MOVSX64rr32. If this returns true, then it's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  /// destination. e.g. X86::MOVSX64rr32. If this returns true, then it's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  /// expected the pre-extension value is available as a subreg of the result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  /// expected the pre-extension value is available as a subreg of the result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  /// register. This also returns the sub-register index in SubIdx.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  /// register. This also returns the sub-register index in SubIdx.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">  virtual bool isCoalescableExtInstr(const MachineInstr &MI, Register &SrcReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">  virtual bool isCoalescableExtInstr(const MachineInstr &MI, Register &SrcReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">                                     Register &DstReg, unsigned &SubIdx) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">                                     Register &DstReg, unsigned &SubIdx) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">  /// If the specified machine instruction is a direct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">  /// If the specified machine instruction is a direct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  /// load from a stack slot, return the virtual or physical register number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  /// load from a stack slot, return the virtual or physical register number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">  /// the destination along with the FrameIndex of the loaded stack slot.  If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">  /// the destination along with the FrameIndex of the loaded stack slot.  If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  /// not, return 0.  This predicate must return 0 if the instruction has</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  /// not, return 0.  This predicate must return 0 if the instruction has</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  /// any side effects other than loading from the stack slot.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  /// any side effects other than loading from the stack slot.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  virtual unsigned isLoadFromStackSlot(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  virtual unsigned isLoadFromStackSlot(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">                                       int &FrameIndex) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">                                       int &FrameIndex) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  /// Optional extension of isLoadFromStackSlot that returns the number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  /// Optional extension of isLoadFromStackSlot that returns the number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  /// bytes loaded from the stack. This must be implemented if a backend</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  /// bytes loaded from the stack. This must be implemented if a backend</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">  /// supports partial stack slot spills/loads to further disambiguate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">  /// supports partial stack slot spills/loads to further disambiguate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  /// what the load does.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  /// what the load does.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">  virtual unsigned isLoadFromStackSlot(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  virtual unsigned isLoadFromStackSlot(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">                                       int &FrameIndex,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">                                       int &FrameIndex,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">                                       unsigned &MemBytes) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">                                       unsigned &MemBytes) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">    MemBytes = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">    MemBytes = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">    return isLoadFromStackSlot(MI, FrameIndex);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">    return isLoadFromStackSlot(MI, FrameIndex);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">  /// Check for post-frame ptr elimination stack locations as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">  /// Check for post-frame ptr elimination stack locations as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">  /// This uses a heuristic so it isn't reliable for correctness.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">  /// This uses a heuristic so it isn't reliable for correctness.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine coveredLine">  virtual unsigned isLoadFromStackSlotPostFE(const MachineInstr &MI,</td>
    <td class="lineNumber">31</td>
    <td class="lineNumber">284</td>
    <td class="codeLine coveredLine">  virtual unsigned isLoadFromStackSlotPostFE(const MachineInstr &MI,</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">                                             int &FrameIndex) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">                                             int &FrameIndex) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine coveredLine">    return 0;</td>
    <td class="lineNumber">31</td>
    <td class="lineNumber">286</td>
    <td class="codeLine coveredLine">    return 0;</td>
    <td class="lineNumber">24</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">  /// If the specified machine instruction has a load from a stack slot,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">  /// If the specified machine instruction has a load from a stack slot,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">  /// return true along with the FrameIndices of the loaded stack slot and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">  /// return true along with the FrameIndices of the loaded stack slot and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  /// machine mem operands containing the reference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  /// machine mem operands containing the reference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">  /// If not, return false.  Unlike isLoadFromStackSlot, this returns true for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">  /// If not, return false.  Unlike isLoadFromStackSlot, this returns true for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  /// any instructions that loads from the stack.  This is just a hint, as some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  /// any instructions that loads from the stack.  This is just a hint, as some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  /// cases may be missed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  /// cases may be missed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  virtual bool hasLoadFromStackSlot(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  virtual bool hasLoadFromStackSlot(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">      const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">      const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">      SmallVectorImpl<const MachineMemOperand *> &Accesses) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">      SmallVectorImpl<const MachineMemOperand *> &Accesses) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  /// If the specified machine instruction is a direct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  /// If the specified machine instruction is a direct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">  /// store to a stack slot, return the virtual or physical register number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">  /// store to a stack slot, return the virtual or physical register number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  /// the source reg along with the FrameIndex of the loaded stack slot.  If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  /// the source reg along with the FrameIndex of the loaded stack slot.  If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  /// not, return 0.  This predicate must return 0 if the instruction has</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  /// not, return 0.  This predicate must return 0 if the instruction has</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">  /// any side effects other than storing to the stack slot.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">  /// any side effects other than storing to the stack slot.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">  virtual unsigned isStoreToStackSlot(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">  virtual unsigned isStoreToStackSlot(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">                                      int &FrameIndex) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">                                      int &FrameIndex) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  /// Optional extension of isStoreToStackSlot that returns the number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  /// Optional extension of isStoreToStackSlot that returns the number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">  /// bytes stored to the stack. This must be implemented if a backend</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">  /// bytes stored to the stack. This must be implemented if a backend</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">  /// supports partial stack slot spills/loads to further disambiguate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">  /// supports partial stack slot spills/loads to further disambiguate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">  /// what the store does.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">  /// what the store does.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">  virtual unsigned isStoreToStackSlot(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">  virtual unsigned isStoreToStackSlot(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">                                      int &FrameIndex,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">                                      int &FrameIndex,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">                                      unsigned &MemBytes) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">                                      unsigned &MemBytes) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">    MemBytes = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">    MemBytes = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">    return isStoreToStackSlot(MI, FrameIndex);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">    return isStoreToStackSlot(MI, FrameIndex);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">  /// Check for post-frame ptr elimination stack locations as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">  /// Check for post-frame ptr elimination stack locations as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">  /// This uses a heuristic, so it isn't reliable for correctness.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">  /// This uses a heuristic, so it isn't reliable for correctness.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine coveredLine">  virtual unsigned isStoreToStackSlotPostFE(const MachineInstr &MI,</td>
    <td class="lineNumber">41</td>
    <td class="lineNumber">322</td>
    <td class="codeLine coveredLine">  virtual unsigned isStoreToStackSlotPostFE(const MachineInstr &MI,</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">                                            int &FrameIndex) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">                                            int &FrameIndex) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine coveredLine">    return 0;</td>
    <td class="lineNumber">41</td>
    <td class="lineNumber">324</td>
    <td class="codeLine coveredLine">    return 0;</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">  /// If the specified machine instruction has a store to a stack slot,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">  /// If the specified machine instruction has a store to a stack slot,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">  /// return true along with the FrameIndices of the loaded stack slot and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">  /// return true along with the FrameIndices of the loaded stack slot and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">  /// machine mem operands containing the reference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">  /// machine mem operands containing the reference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  /// If not, return false.  Unlike isStoreToStackSlot,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  /// If not, return false.  Unlike isStoreToStackSlot,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">  /// this returns true for any instructions that stores to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">  /// this returns true for any instructions that stores to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">  /// stack.  This is just a hint, as some cases may be missed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">  /// stack.  This is just a hint, as some cases may be missed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">  virtual bool hasStoreToStackSlot(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">  virtual bool hasStoreToStackSlot(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">      const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">      const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">      SmallVectorImpl<const MachineMemOperand *> &Accesses) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">      SmallVectorImpl<const MachineMemOperand *> &Accesses) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">  /// Return true if the specified machine instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">  /// Return true if the specified machine instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">  /// is a copy of one stack slot to another and has no other effect.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">  /// is a copy of one stack slot to another and has no other effect.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">  /// Provide the identity of the two frame indices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">  /// Provide the identity of the two frame indices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">  virtual bool isStackSlotCopy(const MachineInstr &MI, int &DestFrameIndex,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">  virtual bool isStackSlotCopy(const MachineInstr &MI, int &DestFrameIndex,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">                               int &SrcFrameIndex) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">                               int &SrcFrameIndex) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  /// Compute the size in bytes and offset within a stack slot of a spilled</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  /// Compute the size in bytes and offset within a stack slot of a spilled</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">  /// register or subregister.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">  /// register or subregister.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">  /// \param [out] Size in bytes of the spilled value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">  /// \param [out] Size in bytes of the spilled value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">  /// \param [out] Offset in bytes within the stack slot.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">  /// \param [out] Offset in bytes within the stack slot.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">  /// \returns true if both Size and Offset are successfully computed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">  /// \returns true if both Size and Offset are successfully computed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">  /// Not all subregisters have computable spill slots. For example,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">  /// Not all subregisters have computable spill slots. For example,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">  /// subregisters registers may not be byte-sized, and a pair of discontiguous</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">  /// subregisters registers may not be byte-sized, and a pair of discontiguous</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">  /// subregisters has no single offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">  /// subregisters has no single offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  /// Targets with nontrivial bigendian implementations may need to override</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  /// Targets with nontrivial bigendian implementations may need to override</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">  /// this, particularly to support spilled vector registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">  /// this, particularly to support spilled vector registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">  virtual bool getStackSlotRange(const TargetRegisterClass *RC, unsigned SubIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">  virtual bool getStackSlotRange(const TargetRegisterClass *RC, unsigned SubIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">                                 unsigned &Size, unsigned &Offset,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">                                 unsigned &Size, unsigned &Offset,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">                                 const MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">                                 const MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">  /// Return true if the given instruction is terminator that is unspillable,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">  /// Return true if the given instruction is terminator that is unspillable,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">  /// according to isUnspillableTerminatorImpl.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">  /// according to isUnspillableTerminatorImpl.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine coveredLine">  bool isUnspillableTerminator(const MachineInstr *MI) const {</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">364</td>
    <td class="codeLine coveredLine">  bool isUnspillableTerminator(const MachineInstr *MI) const {</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine coveredLine">    return MI->isTerminator() && isUnspillableTerminatorImpl(MI);</td>
    <td class="lineNumber">16</td>
    <td class="lineNumber">365</td>
    <td class="codeLine coveredLine">    return MI->isTerminator() && isUnspillableTerminatorImpl(MI);</td>
    <td class="lineNumber">16</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">  /// Returns the size in bytes of the specified MachineInstr, or ~0U</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">  /// Returns the size in bytes of the specified MachineInstr, or ~0U</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">  /// when this function is not implemented by a target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">  /// when this function is not implemented by a target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">  virtual unsigned getInstSizeInBytes(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">  virtual unsigned getInstSizeInBytes(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">    return ~0U;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">    return ~0U;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">  /// Return true if the instruction is as cheap as a move instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">  /// Return true if the instruction is as cheap as a move instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">  /// Targets for different archs need to override this, and different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">  /// Targets for different archs need to override this, and different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">  /// micro-architectures can also be finely tuned inside.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">  /// micro-architectures can also be finely tuned inside.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine coveredLine">  virtual bool isAsCheapAsAMove(const MachineInstr &MI) const {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">378</td>
    <td class="codeLine coveredLine">  virtual bool isAsCheapAsAMove(const MachineInstr &MI) const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine coveredLine">    return MI.isAsCheapAsAMove();</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">379</td>
    <td class="codeLine coveredLine">    return MI.isAsCheapAsAMove();</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">  /// Return true if the instruction should be sunk by MachineSink.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">  /// Return true if the instruction should be sunk by MachineSink.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">  /// MachineSink determines on its own whether the instruction is safe to sink;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">  /// MachineSink determines on its own whether the instruction is safe to sink;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  /// this gives the target a hook to override the default behavior with regards</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  /// this gives the target a hook to override the default behavior with regards</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">  /// to which instructions should be sunk.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">  /// to which instructions should be sunk.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">  virtual bool shouldSink(const MachineInstr &MI) const { return true; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">  virtual bool shouldSink(const MachineInstr &MI) const { return true; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">  /// Return false if the instruction should not be hoisted by MachineLICM.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">  /// Return false if the instruction should not be hoisted by MachineLICM.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">  /// MachineLICM determines on its own whether the instruction is safe to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">  /// MachineLICM determines on its own whether the instruction is safe to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">  /// hoist; this gives the target a hook to extend this assessment and prevent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">  /// hoist; this gives the target a hook to extend this assessment and prevent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  /// an instruction being hoisted from a given loop for target specific</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  /// an instruction being hoisted from a given loop for target specific</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  /// reasons.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  /// reasons.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">  virtual bool shouldHoist(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">  virtual bool shouldHoist(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">                           const MachineLoop *FromLoop) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">                           const MachineLoop *FromLoop) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">  /// Re-issue the specified 'original' instruction at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">  /// Re-issue the specified 'original' instruction at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">  /// specific location targeting a new destination register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">  /// specific location targeting a new destination register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  /// The register in Orig->getOperand(0).getReg() will be substituted by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  /// The register in Orig->getOperand(0).getReg() will be substituted by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  /// DestReg:SubIdx. Any existing subreg index is preserved or composed with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  /// DestReg:SubIdx. Any existing subreg index is preserved or composed with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  /// SubIdx.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  /// SubIdx.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">  virtual void reMaterialize(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">  virtual void reMaterialize(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">                             MachineBasicBlock::iterator MI, Register DestReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">                             MachineBasicBlock::iterator MI, Register DestReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">                             unsigned SubIdx, const MachineInstr &Orig,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">                             unsigned SubIdx, const MachineInstr &Orig,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">                             const TargetRegisterInfo &TRI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">                             const TargetRegisterInfo &TRI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">  /// Clones instruction or the whole instruction bundle \p Orig and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">  /// Clones instruction or the whole instruction bundle \p Orig and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  /// insert into \p MBB before \p InsertBefore. The target may update operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  /// insert into \p MBB before \p InsertBefore. The target may update operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  /// that are required to be unique.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  /// that are required to be unique.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">  /// \p Orig must not return true for MachineInstr::isNotDuplicable().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">  /// \p Orig must not return true for MachineInstr::isNotDuplicable().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">  virtual MachineInstr &duplicate(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">  virtual MachineInstr &duplicate(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">                                  MachineBasicBlock::iterator InsertBefore,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">                                  MachineBasicBlock::iterator InsertBefore,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">                                  const MachineInstr &Orig) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">                                  const MachineInstr &Orig) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">  /// This method must be implemented by targets that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">  /// This method must be implemented by targets that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">  /// set the M_CONVERTIBLE_TO_3_ADDR flag.  When this flag is set, the target</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">  /// set the M_CONVERTIBLE_TO_3_ADDR flag.  When this flag is set, the target</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">  /// may be able to convert a two-address instruction into one or more true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">  /// may be able to convert a two-address instruction into one or more true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  /// three-address instructions on demand.  This allows the X86 target (for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  /// three-address instructions on demand.  This allows the X86 target (for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">  /// example) to convert ADD and SHL instructions into LEA instructions if they</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">  /// example) to convert ADD and SHL instructions into LEA instructions if they</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  /// would require register copies due to two-addressness.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  /// would require register copies due to two-addressness.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  /// This method returns a null pointer if the transformation cannot be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  /// This method returns a null pointer if the transformation cannot be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  /// performed, otherwise it returns the last new instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  /// performed, otherwise it returns the last new instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">  /// If \p LIS is not nullptr, the LiveIntervals info should be updated for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">  /// If \p LIS is not nullptr, the LiveIntervals info should be updated for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  /// replacing \p MI with new instructions, even though this function does not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  /// replacing \p MI with new instructions, even though this function does not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">  /// remove MI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">  /// remove MI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  virtual MachineInstr *convertToThreeAddress(MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  virtual MachineInstr *convertToThreeAddress(MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">                                              LiveVariables *LV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">                                              LiveVariables *LV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">                                              LiveIntervals *LIS) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">                                              LiveIntervals *LIS) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">  // This constant can be used as an input value of operand index passed to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">  // This constant can be used as an input value of operand index passed to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">  // the method findCommutedOpIndices() to tell the method that the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">  // the method findCommutedOpIndices() to tell the method that the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">  // corresponding operand index is not pre-defined and that the method</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">  // corresponding operand index is not pre-defined and that the method</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">  // can pick any commutable operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">  // can pick any commutable operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">  static const unsigned CommuteAnyOperandIndex = ~0U;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">  static const unsigned CommuteAnyOperandIndex = ~0U;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">  /// This method commutes the operands of the given machine instruction MI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">  /// This method commutes the operands of the given machine instruction MI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">  /// The operands to be commuted are specified by their indices OpIdx1 and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">  /// The operands to be commuted are specified by their indices OpIdx1 and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">  /// OpIdx2. OpIdx1 and OpIdx2 arguments may be set to a special value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">  /// OpIdx2. OpIdx1 and OpIdx2 arguments may be set to a special value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">  /// 'CommuteAnyOperandIndex', which means that the method is free to choose</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">  /// 'CommuteAnyOperandIndex', which means that the method is free to choose</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">  /// any arbitrarily chosen commutable operand. If both arguments are set to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">  /// any arbitrarily chosen commutable operand. If both arguments are set to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">  /// 'CommuteAnyOperandIndex' then the method looks for 2 different commutable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">  /// 'CommuteAnyOperandIndex' then the method looks for 2 different commutable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">  /// operands; then commutes them if such operands could be found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">  /// operands; then commutes them if such operands could be found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  /// If NewMI is false, MI is modified in place and returned; otherwise, a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  /// If NewMI is false, MI is modified in place and returned; otherwise, a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">  /// new machine instruction is created and returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">  /// new machine instruction is created and returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">  /// Do not call this method for a non-commutable instruction or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">  /// Do not call this method for a non-commutable instruction or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">  /// for non-commuable operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">  /// for non-commuable operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">  /// Even though the instruction is commutable, the method may still</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">  /// Even though the instruction is commutable, the method may still</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">  /// fail to commute the operands, null pointer is returned in such cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">  /// fail to commute the operands, null pointer is returned in such cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">  MachineInstr *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">  MachineInstr *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">  commuteInstruction(MachineInstr &MI, bool NewMI = false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">  commuteInstruction(MachineInstr &MI, bool NewMI = false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">                     unsigned OpIdx1 = CommuteAnyOperandIndex,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">                     unsigned OpIdx1 = CommuteAnyOperandIndex,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">                     unsigned OpIdx2 = CommuteAnyOperandIndex) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">                     unsigned OpIdx2 = CommuteAnyOperandIndex) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  /// Returns true iff the routine could find two commutable operands in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  /// Returns true iff the routine could find two commutable operands in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">  /// given machine instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">  /// given machine instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  /// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  /// The 'SrcOpIdx1' and 'SrcOpIdx2' are INPUT and OUTPUT arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">  /// If any of the INPUT values is set to the special value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">  /// If any of the INPUT values is set to the special value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">  /// 'CommuteAnyOperandIndex' then the method arbitrarily picks a commutable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">  /// 'CommuteAnyOperandIndex' then the method arbitrarily picks a commutable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">  /// operand, then returns its index in the corresponding argument.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">  /// operand, then returns its index in the corresponding argument.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">  /// If both of INPUT values are set to 'CommuteAnyOperandIndex' then method</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">  /// If both of INPUT values are set to 'CommuteAnyOperandIndex' then method</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  /// looks for 2 commutable operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  /// looks for 2 commutable operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  /// If INPUT values refer to some operands of MI, then the method simply</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  /// If INPUT values refer to some operands of MI, then the method simply</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  /// returns true if the corresponding operands are commutable and returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  /// returns true if the corresponding operands are commutable and returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  /// false otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  /// false otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  /// For example, calling this method this way:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  /// For example, calling this method this way:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  ///     unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  ///     unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  ///     findCommutedOpIndices(MI, Op1, Op2);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  ///     findCommutedOpIndices(MI, Op1, Op2);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">  /// can be interpreted as a query asking to find an operand that would be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">  /// can be interpreted as a query asking to find an operand that would be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">  /// commutable with the operand#1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">  /// commutable with the operand#1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">  virtual bool findCommutedOpIndices(const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">  virtual bool findCommutedOpIndices(const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">                                     unsigned &SrcOpIdx1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">                                     unsigned &SrcOpIdx1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">                                     unsigned &SrcOpIdx2) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">                                     unsigned &SrcOpIdx2) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  /// Returns true if the target has a preference on the operands order of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  /// Returns true if the target has a preference on the operands order of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  /// the given machine instruction. And specify if \p Commute is required to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  /// the given machine instruction. And specify if \p Commute is required to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">  /// get the desired operands order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">  /// get the desired operands order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">  virtual bool hasCommutePreference(MachineInstr &MI, bool &Commute) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">  virtual bool hasCommutePreference(MachineInstr &MI, bool &Commute) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  /// A pair composed of a register and a sub-register index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  /// A pair composed of a register and a sub-register index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  /// Used to give some type checking when modeling Reg:SubReg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  /// Used to give some type checking when modeling Reg:SubReg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">  struct RegSubRegPair {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">  struct RegSubRegPair {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">    Register Reg;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">    Register Reg;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">    unsigned SubReg;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">    unsigned SubReg;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">    RegSubRegPair(Register Reg = Register(), unsigned SubReg = 0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">    RegSubRegPair(Register Reg = Register(), unsigned SubReg = 0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">        : Reg(Reg), SubReg(SubReg) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">        : Reg(Reg), SubReg(SubReg) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">    bool operator==(const RegSubRegPair& P) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">    bool operator==(const RegSubRegPair& P) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">      return Reg == P.Reg && SubReg == P.SubReg;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">      return Reg == P.Reg && SubReg == P.SubReg;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">    bool operator!=(const RegSubRegPair& P) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">    bool operator!=(const RegSubRegPair& P) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">      return !(*this == P);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">      return !(*this == P);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">  /// A pair composed of a pair of a register and a sub-register index,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">  /// A pair composed of a pair of a register and a sub-register index,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">  /// and another sub-register index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">  /// and another sub-register index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  /// Used to give some type checking when modeling Reg:SubReg1, SubReg2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  /// Used to give some type checking when modeling Reg:SubReg1, SubReg2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">  struct RegSubRegPairAndIdx : RegSubRegPair {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">  struct RegSubRegPairAndIdx : RegSubRegPair {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">    unsigned SubIdx;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">    unsigned SubIdx;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">    RegSubRegPairAndIdx(Register Reg = Register(), unsigned SubReg = 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">    RegSubRegPairAndIdx(Register Reg = Register(), unsigned SubReg = 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">                        unsigned SubIdx = 0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">                        unsigned SubIdx = 0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">        : RegSubRegPair(Reg, SubReg), SubIdx(SubIdx) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">        : RegSubRegPair(Reg, SubReg), SubIdx(SubIdx) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">  /// Build the equivalent inputs of a REG_SEQUENCE for the given \p MI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">  /// Build the equivalent inputs of a REG_SEQUENCE for the given \p MI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">  /// and \p DefIdx.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">  /// and \p DefIdx.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  /// \p [out] InputRegs of the equivalent REG_SEQUENCE. Each element of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  /// \p [out] InputRegs of the equivalent REG_SEQUENCE. Each element of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">  /// the list is modeled as <Reg:SubReg, SubIdx>. Operands with the undef</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">  /// the list is modeled as <Reg:SubReg, SubIdx>. Operands with the undef</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  /// flag are not added to this list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  /// flag are not added to this list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">  /// E.g., REG_SEQUENCE %1:sub1, sub0, %2, sub1 would produce</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">  /// E.g., REG_SEQUENCE %1:sub1, sub0, %2, sub1 would produce</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  /// two elements:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  /// two elements:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">  /// - %1:sub1, sub0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">  /// - %1:sub1, sub0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">  /// - %2<:0>, sub1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">  /// - %2<:0>, sub1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">  /// \returns true if it is possible to build such an input sequence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">  /// \returns true if it is possible to build such an input sequence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">  /// with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">  /// with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">  /// \pre MI.isRegSequence() or MI.isRegSequenceLike().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">  /// \pre MI.isRegSequence() or MI.isRegSequenceLike().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  /// \note The generic implementation does not provide any support for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  /// \note The generic implementation does not provide any support for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  /// MI.isRegSequenceLike(). In other words, one has to override</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  /// MI.isRegSequenceLike(). In other words, one has to override</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">  /// getRegSequenceLikeInputs for target specific instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">  /// getRegSequenceLikeInputs for target specific instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">  getRegSequenceInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">  getRegSequenceInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">                       SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">                       SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">  /// Build the equivalent inputs of a EXTRACT_SUBREG for the given \p MI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">  /// Build the equivalent inputs of a EXTRACT_SUBREG for the given \p MI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">  /// and \p DefIdx.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">  /// and \p DefIdx.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">  /// \p [out] InputReg of the equivalent EXTRACT_SUBREG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">  /// \p [out] InputReg of the equivalent EXTRACT_SUBREG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">  /// E.g., EXTRACT_SUBREG %1:sub1, sub0, sub1 would produce:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">  /// E.g., EXTRACT_SUBREG %1:sub1, sub0, sub1 would produce:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  /// - %1:sub1, sub0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  /// - %1:sub1, sub0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">  /// \returns true if it is possible to build such an input sequence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">  /// \returns true if it is possible to build such an input sequence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">  /// with the pair \p MI, \p DefIdx and the operand has no undef flag set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">  /// with the pair \p MI, \p DefIdx and the operand has no undef flag set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">  /// False otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">  /// False otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">  /// \pre MI.isExtractSubreg() or MI.isExtractSubregLike().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">  /// \pre MI.isExtractSubreg() or MI.isExtractSubregLike().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">  /// \note The generic implementation does not provide any support for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">  /// \note The generic implementation does not provide any support for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">  /// MI.isExtractSubregLike(). In other words, one has to override</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">  /// MI.isExtractSubregLike(). In other words, one has to override</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">  /// getExtractSubregLikeInputs for target specific instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">  /// getExtractSubregLikeInputs for target specific instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">  bool getExtractSubregInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">  bool getExtractSubregInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">                              RegSubRegPairAndIdx &InputReg) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">                              RegSubRegPairAndIdx &InputReg) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">  /// Build the equivalent inputs of a INSERT_SUBREG for the given \p MI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">  /// Build the equivalent inputs of a INSERT_SUBREG for the given \p MI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">  /// and \p DefIdx.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">  /// and \p DefIdx.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">  /// \p [out] BaseReg and \p [out] InsertedReg contain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">  /// \p [out] BaseReg and \p [out] InsertedReg contain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">  /// the equivalent inputs of INSERT_SUBREG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">  /// the equivalent inputs of INSERT_SUBREG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">  /// E.g., INSERT_SUBREG %0:sub0, %1:sub1, sub3 would produce:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">  /// E.g., INSERT_SUBREG %0:sub0, %1:sub1, sub3 would produce:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">  /// - BaseReg: %0:sub0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">  /// - BaseReg: %0:sub0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">  /// - InsertedReg: %1:sub1, sub3</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">  /// - InsertedReg: %1:sub1, sub3</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">  /// \returns true if it is possible to build such an input sequence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">  /// \returns true if it is possible to build such an input sequence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">  /// with the pair \p MI, \p DefIdx and the operand has no undef flag set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">  /// with the pair \p MI, \p DefIdx and the operand has no undef flag set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">  /// False otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">  /// False otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">  /// \pre MI.isInsertSubreg() or MI.isInsertSubregLike().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">  /// \pre MI.isInsertSubreg() or MI.isInsertSubregLike().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">  /// \note The generic implementation does not provide any support for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">  /// \note The generic implementation does not provide any support for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  /// MI.isInsertSubregLike(). In other words, one has to override</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  /// MI.isInsertSubregLike(). In other words, one has to override</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  /// getInsertSubregLikeInputs for target specific instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  /// getInsertSubregLikeInputs for target specific instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">  bool getInsertSubregInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">  bool getInsertSubregInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">                             RegSubRegPair &BaseReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">                             RegSubRegPair &BaseReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">                             RegSubRegPairAndIdx &InsertedReg) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">                             RegSubRegPairAndIdx &InsertedReg) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">  /// Return true if two machine instructions would produce identical values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">  /// Return true if two machine instructions would produce identical values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">  /// By default, this is only true when the two instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">  /// By default, this is only true when the two instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">  /// are deemed identical except for defs. If this function is called when the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">  /// are deemed identical except for defs. If this function is called when the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  /// IR is still in SSA form, the caller can pass the MachineRegisterInfo for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  /// IR is still in SSA form, the caller can pass the MachineRegisterInfo for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">  /// aggressive checks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">  /// aggressive checks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">  virtual bool produceSameValue(const MachineInstr &MI0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">  virtual bool produceSameValue(const MachineInstr &MI0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">                                const MachineInstr &MI1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">                                const MachineInstr &MI1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">                                const MachineRegisterInfo *MRI = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">                                const MachineRegisterInfo *MRI = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">  /// \returns true if a branch from an instruction with opcode \p BranchOpc</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">  /// \returns true if a branch from an instruction with opcode \p BranchOpc</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">  ///  bytes is capable of jumping to a position \p BrOffset bytes away.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">  ///  bytes is capable of jumping to a position \p BrOffset bytes away.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">  virtual bool isBranchOffsetInRange(unsigned BranchOpc,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">  virtual bool isBranchOffsetInRange(unsigned BranchOpc,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">                                     int64_t BrOffset) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">                                     int64_t BrOffset) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">    llvm_unreachable("target did not implement");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">    llvm_unreachable("target did not implement");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">  /// \returns The block that branch instruction \p MI jumps to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">  /// \returns The block that branch instruction \p MI jumps to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  virtual MachineBasicBlock *getBranchDestBlock(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  virtual MachineBasicBlock *getBranchDestBlock(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">    llvm_unreachable("target did not implement");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">    llvm_unreachable("target did not implement");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">  /// Insert an unconditional indirect branch at the end of \p MBB to \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">  /// Insert an unconditional indirect branch at the end of \p MBB to \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  /// NewDestBB. Optionally, insert the clobbered register restoring in \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  /// NewDestBB. Optionally, insert the clobbered register restoring in \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">  /// RestoreBB. \p BrOffset indicates the offset of \p NewDestBB relative to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">  /// RestoreBB. \p BrOffset indicates the offset of \p NewDestBB relative to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">  /// the offset of the position to insert the new branch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">  /// the offset of the position to insert the new branch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">  virtual void insertIndirectBranch(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">  virtual void insertIndirectBranch(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">                                    MachineBasicBlock &NewDestBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">                                    MachineBasicBlock &NewDestBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">                                    MachineBasicBlock &RestoreBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">                                    MachineBasicBlock &RestoreBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">                                    const DebugLoc &DL, int64_t BrOffset = 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">                                    const DebugLoc &DL, int64_t BrOffset = 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">                                    RegScavenger *RS = nullptr) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">                                    RegScavenger *RS = nullptr) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">    llvm_unreachable("target did not implement");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">    llvm_unreachable("target did not implement");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  /// Analyze the branching code at the end of MBB, returning</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  /// Analyze the branching code at the end of MBB, returning</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  /// true if it cannot be understood (e.g. it's a switch dispatch or isn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  /// true if it cannot be understood (e.g. it's a switch dispatch or isn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">  /// implemented for a target).  Upon success, this returns false and returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">  /// implemented for a target).  Upon success, this returns false and returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">  /// with the following information in various cases:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">  /// with the following information in various cases:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">  /// 1. If this block ends with no branches (it just falls through to its succ)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">  /// 1. If this block ends with no branches (it just falls through to its succ)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">  ///    just return false, leaving TBB/FBB null.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">  ///    just return false, leaving TBB/FBB null.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">  /// 2. If this block ends with only an unconditional branch, it sets TBB to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">  /// 2. If this block ends with only an unconditional branch, it sets TBB to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  ///    the destination block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  ///    the destination block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  /// 3. If this block ends with a conditional branch and it falls through to a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  /// 3. If this block ends with a conditional branch and it falls through to a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  ///    successor block, it sets TBB to be the branch destination block and a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  ///    successor block, it sets TBB to be the branch destination block and a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  ///    list of operands that evaluate the condition. These operands can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  ///    list of operands that evaluate the condition. These operands can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">  ///    passed to other TargetInstrInfo methods to create new branches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">  ///    passed to other TargetInstrInfo methods to create new branches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">  /// 4. If this block ends with a conditional branch followed by an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">  /// 4. If this block ends with a conditional branch followed by an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">  ///    unconditional branch, it returns the 'true' destination in TBB, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">  ///    unconditional branch, it returns the 'true' destination in TBB, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">  ///    'false' destination in FBB, and a list of operands that evaluate the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">  ///    'false' destination in FBB, and a list of operands that evaluate the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">  ///    condition.  These operands can be passed to other TargetInstrInfo</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">  ///    condition.  These operands can be passed to other TargetInstrInfo</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  ///    methods to create new branches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  ///    methods to create new branches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  /// Note that removeBranch and insertBranch must be implemented to support</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  /// Note that removeBranch and insertBranch must be implemented to support</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">  /// cases where this method returns success.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">  /// cases where this method returns success.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">  /// If AllowModify is true, then this routine is allowed to modify the basic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">  /// If AllowModify is true, then this routine is allowed to modify the basic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">  /// block (e.g. delete instructions after the unconditional branch).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">  /// block (e.g. delete instructions after the unconditional branch).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">  /// before calling this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">  /// before calling this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">  virtual bool analyzeBranch(MachineBasicBlock &MBB, MachineBasicBlock *&TBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">  virtual bool analyzeBranch(MachineBasicBlock &MBB, MachineBasicBlock *&TBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">                             MachineBasicBlock *&FBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">                             MachineBasicBlock *&FBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">                             SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">                             SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">                             bool AllowModify = false) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">                             bool AllowModify = false) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  /// Represents a predicate at the MachineFunction level.  The control flow a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  /// Represents a predicate at the MachineFunction level.  The control flow a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">  /// MachineBranchPredicate represents is:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">  /// MachineBranchPredicate represents is:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">  ///  Reg = LHS `Predicate` RHS         == ConditionDef</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">  ///  Reg = LHS `Predicate` RHS         == ConditionDef</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">  ///  if Reg then goto TrueDest else goto FalseDest</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">  ///  if Reg then goto TrueDest else goto FalseDest</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  struct MachineBranchPredicate {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  struct MachineBranchPredicate {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">    enum ComparePredicate {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">    enum ComparePredicate {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">      PRED_EQ,     // True if two values are equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">      PRED_EQ,     // True if two values are equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">      PRED_NE,     // True if two values are not equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">      PRED_NE,     // True if two values are not equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">      PRED_INVALID // Sentinel value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">      PRED_INVALID // Sentinel value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">    ComparePredicate Predicate = PRED_INVALID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">    ComparePredicate Predicate = PRED_INVALID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">    MachineOperand LHS = MachineOperand::CreateImm(0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">    MachineOperand LHS = MachineOperand::CreateImm(0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">    MachineOperand RHS = MachineOperand::CreateImm(0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">    MachineOperand RHS = MachineOperand::CreateImm(0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">    MachineBasicBlock *TrueDest = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">    MachineBasicBlock *TrueDest = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">    MachineBasicBlock *FalseDest = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">    MachineBasicBlock *FalseDest = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">    MachineInstr *ConditionDef = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">    MachineInstr *ConditionDef = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">    /// SingleUseCondition is true if ConditionDef is dead except for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">    /// SingleUseCondition is true if ConditionDef is dead except for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">    /// branch(es) at the end of the basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">    /// branch(es) at the end of the basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">    bool SingleUseCondition = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">    bool SingleUseCondition = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">    explicit MachineBranchPredicate() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">    explicit MachineBranchPredicate() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">  /// Analyze the branching code at the end of MBB and parse it into the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">  /// Analyze the branching code at the end of MBB and parse it into the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">  /// MachineBranchPredicate structure if possible.  Returns false on success</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">  /// MachineBranchPredicate structure if possible.  Returns false on success</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  /// and true on failure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  /// and true on failure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">  /// If AllowModify is true, then this routine is allowed to modify the basic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">  /// If AllowModify is true, then this routine is allowed to modify the basic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">  /// block (e.g. delete instructions after the unconditional branch).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">  /// block (e.g. delete instructions after the unconditional branch).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  virtual bool analyzeBranchPredicate(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  virtual bool analyzeBranchPredicate(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">                                      MachineBranchPredicate &MBP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">                                      MachineBranchPredicate &MBP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">                                      bool AllowModify = false) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">                                      bool AllowModify = false) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  /// Remove the branching code at the end of the specific MBB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  /// Remove the branching code at the end of the specific MBB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">  /// This is only invoked in cases where analyzeBranch returns success. It</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">  /// This is only invoked in cases where analyzeBranch returns success. It</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  /// returns the number of instructions that were removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  /// returns the number of instructions that were removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  /// If \p BytesRemoved is non-null, report the change in code size from the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  /// If \p BytesRemoved is non-null, report the change in code size from the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  /// removed instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  /// removed instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">  virtual unsigned removeBranch(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">  virtual unsigned removeBranch(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">                                int *BytesRemoved = nullptr) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">                                int *BytesRemoved = nullptr) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement TargetInstrInfo::removeBranch!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement TargetInstrInfo::removeBranch!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  /// Insert branch code into the end of the specified MachineBasicBlock. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  /// Insert branch code into the end of the specified MachineBasicBlock. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">  /// operands to this method are the same as those returned by analyzeBranch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">  /// operands to this method are the same as those returned by analyzeBranch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">  /// This is only invoked in cases where analyzeBranch returns success. It</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">  /// This is only invoked in cases where analyzeBranch returns success. It</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">  /// returns the number of instructions inserted. If \p BytesAdded is non-null,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">  /// returns the number of instructions inserted. If \p BytesAdded is non-null,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">  /// report the change in code size from the added instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">  /// report the change in code size from the added instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">  /// It is also invoked by tail merging to add unconditional branches in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">  /// It is also invoked by tail merging to add unconditional branches in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">  /// cases where analyzeBranch doesn't apply because there was no original</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">  /// cases where analyzeBranch doesn't apply because there was no original</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">  /// branch to analyze.  At least this much must be implemented, else tail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">  /// branch to analyze.  At least this much must be implemented, else tail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">  /// merging needs to be disabled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">  /// merging needs to be disabled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">  /// The CFG information in MBB.Predecessors and MBB.Successors must be valid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">  /// before calling this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">  /// before calling this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">  virtual unsigned insertBranch(MachineBasicBlock &MBB, MachineBasicBlock *TBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">  virtual unsigned insertBranch(MachineBasicBlock &MBB, MachineBasicBlock *TBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">                                MachineBasicBlock *FBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">                                MachineBasicBlock *FBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">                                ArrayRef<MachineOperand> Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">                                ArrayRef<MachineOperand> Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">                                const DebugLoc &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">                                const DebugLoc &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">                                int *BytesAdded = nullptr) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">                                int *BytesAdded = nullptr) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement TargetInstrInfo::insertBranch!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement TargetInstrInfo::insertBranch!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">  unsigned insertUnconditionalBranch(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">  unsigned insertUnconditionalBranch(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">                                     MachineBasicBlock *DestBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">                                     MachineBasicBlock *DestBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">                                     const DebugLoc &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">                                     const DebugLoc &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">                                     int *BytesAdded = nullptr) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">                                     int *BytesAdded = nullptr) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">    return insertBranch(MBB, DestBB, nullptr, ArrayRef<MachineOperand>(), DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">    return insertBranch(MBB, DestBB, nullptr, ArrayRef<MachineOperand>(), DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">                        BytesAdded);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">                        BytesAdded);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">  /// Object returned by analyzeLoopForPipelining. Allows software pipelining</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">  /// Object returned by analyzeLoopForPipelining. Allows software pipelining</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">  /// implementations to query attributes of the loop being pipelined and to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">  /// implementations to query attributes of the loop being pipelined and to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">  /// apply target-specific updates to the loop once pipelining is complete.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">  /// apply target-specific updates to the loop once pipelining is complete.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">  class PipelinerLoopInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">  class PipelinerLoopInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">    virtual ~PipelinerLoopInfo();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">    virtual ~PipelinerLoopInfo();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">    /// Return true if the given instruction should not be pipelined and should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">    /// Return true if the given instruction should not be pipelined and should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">    /// be ignored. An example could be a loop comparison, or induction variable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">    /// be ignored. An example could be a loop comparison, or induction variable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">    /// update with no users being pipelined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">    /// update with no users being pipelined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">    virtual bool shouldIgnoreForPipelining(const MachineInstr *MI) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">    virtual bool shouldIgnoreForPipelining(const MachineInstr *MI) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">    /// Return true if the proposed schedule should used.  Otherwise return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">    /// Return true if the proposed schedule should used.  Otherwise return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">    /// false to not pipeline the loop. This function should be used to ensure</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">    /// false to not pipeline the loop. This function should be used to ensure</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">    /// that pipelined loops meet target-specific quality heuristics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">    /// that pipelined loops meet target-specific quality heuristics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">    virtual bool shouldUseSchedule(SwingSchedulerDAG &SSD, SMSchedule &SMS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">    virtual bool shouldUseSchedule(SwingSchedulerDAG &SSD, SMSchedule &SMS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">    /// Create a condition to determine if the trip count of the loop is greater</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">    /// Create a condition to determine if the trip count of the loop is greater</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">    /// than TC, where TC is always one more than for the previous prologue or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">    /// than TC, where TC is always one more than for the previous prologue or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">    /// 0 if this is being called for the outermost prologue.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">    /// 0 if this is being called for the outermost prologue.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">    /// If the trip count is statically known to be greater than TC, return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">    /// If the trip count is statically known to be greater than TC, return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">    /// true. If the trip count is statically known to be not greater than TC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">    /// true. If the trip count is statically known to be not greater than TC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">    /// return false. Otherwise return nullopt and fill out Cond with the test</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">    /// return false. Otherwise return nullopt and fill out Cond with the test</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">    /// condition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">    /// condition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">    /// Note: This hook is guaranteed to be called from the innermost to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">    /// Note: This hook is guaranteed to be called from the innermost to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">    /// outermost prologue of the loop being software pipelined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">    /// outermost prologue of the loop being software pipelined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">    virtual std::optional<bool></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">    virtual std::optional<bool></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">    createTripCountGreaterCondition(int TC, MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">    createTripCountGreaterCondition(int TC, MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">                                    SmallVectorImpl<MachineOperand> &Cond) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">                                    SmallVectorImpl<MachineOperand> &Cond) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">    /// Modify the loop such that the trip count is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">    /// Modify the loop such that the trip count is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">    /// OriginalTC + TripCountAdjust.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">    /// OriginalTC + TripCountAdjust.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">    virtual void adjustTripCount(int TripCountAdjust) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">    virtual void adjustTripCount(int TripCountAdjust) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">    /// Called when the loop's preheader has been modified to NewPreheader.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">    /// Called when the loop's preheader has been modified to NewPreheader.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">    virtual void setPreheader(MachineBasicBlock *NewPreheader) = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">    virtual void setPreheader(MachineBasicBlock *NewPreheader) = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">    /// Called when the loop is being removed. Any instructions in the preheader</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">    /// Called when the loop is being removed. Any instructions in the preheader</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">    /// should be removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">    /// should be removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">    /// Once this function is called, no other functions on this object are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">    /// Once this function is called, no other functions on this object are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">    /// valid; the loop has been removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">    /// valid; the loop has been removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">    virtual void disposed() = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">    virtual void disposed() = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">  /// Analyze loop L, which must be a single-basic-block loop, and if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">  /// Analyze loop L, which must be a single-basic-block loop, and if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">  /// conditions can be understood enough produce a PipelinerLoopInfo object.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">  /// conditions can be understood enough produce a PipelinerLoopInfo object.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">  virtual std::unique_ptr<PipelinerLoopInfo></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">  virtual std::unique_ptr<PipelinerLoopInfo></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">  analyzeLoopForPipelining(MachineBasicBlock *LoopBB) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">  analyzeLoopForPipelining(MachineBasicBlock *LoopBB) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">  /// Analyze the loop code, return true if it cannot be understood. Upon</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">  /// Analyze the loop code, return true if it cannot be understood. Upon</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">  /// success, this function returns false and returns information about the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">  /// success, this function returns false and returns information about the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">  /// induction variable and compare instruction used at the end.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">  /// induction variable and compare instruction used at the end.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">  virtual bool analyzeLoop(MachineLoop &L, MachineInstr *&IndVarInst,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">  virtual bool analyzeLoop(MachineLoop &L, MachineInstr *&IndVarInst,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">                           MachineInstr *&CmpInst) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">                           MachineInstr *&CmpInst) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">  /// Generate code to reduce the loop iteration by one and check if the loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">  /// Generate code to reduce the loop iteration by one and check if the loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">  /// is finished.  Return the value/register of the new loop count.  We need</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">  /// is finished.  Return the value/register of the new loop count.  We need</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">  /// this function when peeling off one or more iterations of a loop. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">  /// this function when peeling off one or more iterations of a loop. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">  /// function assumes the nth iteration is peeled first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">  /// function assumes the nth iteration is peeled first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">  virtual unsigned reduceLoopCount(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">  virtual unsigned reduceLoopCount(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">                                   MachineBasicBlock &PreHeader,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">                                   MachineBasicBlock &PreHeader,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">                                   MachineInstr *IndVar, MachineInstr &Cmp,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">                                   MachineInstr *IndVar, MachineInstr &Cmp,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">                                   SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">                                   SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">                                   SmallVectorImpl<MachineInstr *> &PrevInsts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">                                   SmallVectorImpl<MachineInstr *> &PrevInsts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">                                   unsigned Iter, unsigned MaxIter) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">                                   unsigned Iter, unsigned MaxIter) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement ReduceLoopCount");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement ReduceLoopCount");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">  /// Delete the instruction OldInst and everything after it, replacing it with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">  /// Delete the instruction OldInst and everything after it, replacing it with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">  /// an unconditional branch to NewDest. This is used by the tail merging pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">  /// an unconditional branch to NewDest. This is used by the tail merging pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">  virtual void ReplaceTailWithBranchTo(MachineBasicBlock::iterator Tail,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">  virtual void ReplaceTailWithBranchTo(MachineBasicBlock::iterator Tail,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">                                       MachineBasicBlock *NewDest) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">                                       MachineBasicBlock *NewDest) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">  /// Return true if it's legal to split the given basic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">  /// Return true if it's legal to split the given basic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  /// block at the specified instruction (i.e. instruction would be the start</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  /// block at the specified instruction (i.e. instruction would be the start</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">  /// of a new basic block).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">  /// of a new basic block).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">  virtual bool isLegalToSplitMBBAt(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">  virtual bool isLegalToSplitMBBAt(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">                                   MachineBasicBlock::iterator MBBI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">                                   MachineBasicBlock::iterator MBBI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">  /// Return true if it's profitable to predicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">  /// Return true if it's profitable to predicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">  /// instructions with accumulated instruction latency of "NumCycles"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">  /// instructions with accumulated instruction latency of "NumCycles"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  /// of the specified basic block, where the probability of the instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  /// of the specified basic block, where the probability of the instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  /// being executed is given by Probability, and Confidence is a measure</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  /// being executed is given by Probability, and Confidence is a measure</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">  /// of our confidence that it will be properly predicted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">  /// of our confidence that it will be properly predicted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">  virtual bool isProfitableToIfCvt(MachineBasicBlock &MBB, unsigned NumCycles,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">  virtual bool isProfitableToIfCvt(MachineBasicBlock &MBB, unsigned NumCycles,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">                                   unsigned ExtraPredCycles,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">                                   unsigned ExtraPredCycles,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">                                   BranchProbability Probability) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">                                   BranchProbability Probability) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">  /// Second variant of isProfitableToIfCvt. This one</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">  /// Second variant of isProfitableToIfCvt. This one</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">  /// checks for the case where two basic blocks from true and false path</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">  /// checks for the case where two basic blocks from true and false path</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  /// of a if-then-else (diamond) are predicated on mutually exclusive</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  /// of a if-then-else (diamond) are predicated on mutually exclusive</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">  /// predicates, where the probability of the true path being taken is given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">  /// predicates, where the probability of the true path being taken is given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">  /// by Probability, and Confidence is a measure of our confidence that it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">  /// by Probability, and Confidence is a measure of our confidence that it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">  /// will be properly predicted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">  /// will be properly predicted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">  virtual bool isProfitableToIfCvt(MachineBasicBlock &TMBB, unsigned NumTCycles,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">  virtual bool isProfitableToIfCvt(MachineBasicBlock &TMBB, unsigned NumTCycles,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">                                   unsigned ExtraTCycles,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">                                   unsigned ExtraTCycles,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">                                   MachineBasicBlock &FMBB, unsigned NumFCycles,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">                                   MachineBasicBlock &FMBB, unsigned NumFCycles,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">                                   unsigned ExtraFCycles,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">                                   unsigned ExtraFCycles,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">                                   BranchProbability Probability) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">                                   BranchProbability Probability) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">  /// Return true if it's profitable for if-converter to duplicate instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">  /// Return true if it's profitable for if-converter to duplicate instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">  /// of specified accumulated instruction latencies in the specified MBB to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">  /// of specified accumulated instruction latencies in the specified MBB to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">  /// enable if-conversion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">  /// enable if-conversion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">  /// The probability of the instructions being executed is given by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">  /// The probability of the instructions being executed is given by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  /// Probability, and Confidence is a measure of our confidence that it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  /// Probability, and Confidence is a measure of our confidence that it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  /// will be properly predicted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  /// will be properly predicted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">  virtual bool isProfitableToDupForIfCvt(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">  virtual bool isProfitableToDupForIfCvt(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">                                         unsigned NumCycles,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">                                         unsigned NumCycles,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">                                         BranchProbability Probability) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">                                         BranchProbability Probability) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">  /// Return the increase in code size needed to predicate a contiguous run of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">  /// Return the increase in code size needed to predicate a contiguous run of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">  /// NumInsts instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">  /// NumInsts instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">  virtual unsigned extraSizeToPredicateInstructions(const MachineFunction &MF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">  virtual unsigned extraSizeToPredicateInstructions(const MachineFunction &MF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">                                                    unsigned NumInsts) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">                                                    unsigned NumInsts) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">  /// Return an estimate for the code size reduction (in bytes) which will be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">  /// Return an estimate for the code size reduction (in bytes) which will be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">  /// caused by removing the given branch instruction during if-conversion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">  /// caused by removing the given branch instruction during if-conversion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">  virtual unsigned predictBranchSizeForIfCvt(MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">  virtual unsigned predictBranchSizeForIfCvt(MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">    return getInstSizeInBytes(MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">    return getInstSizeInBytes(MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">  /// Return true if it's profitable to unpredicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">  /// Return true if it's profitable to unpredicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">  /// one side of a 'diamond', i.e. two sides of if-else predicated on mutually</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">  /// one side of a 'diamond', i.e. two sides of if-else predicated on mutually</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  /// exclusive predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  /// exclusive predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">  /// e.g.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">  /// e.g.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">  ///   subeq  r0, r1, #1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">  ///   subeq  r0, r1, #1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">  ///   addne  r0, r1, #1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">  ///   addne  r0, r1, #1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">  /// =></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">  /// =></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  ///   sub    r0, r1, #1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  ///   sub    r0, r1, #1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  ///   addne  r0, r1, #1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  ///   addne  r0, r1, #1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">  /// This may be profitable is conditional instructions are always executed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">  /// This may be profitable is conditional instructions are always executed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">  virtual bool isProfitableToUnpredicate(MachineBasicBlock &TMBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">  virtual bool isProfitableToUnpredicate(MachineBasicBlock &TMBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">                                         MachineBasicBlock &FMBB) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">                                         MachineBasicBlock &FMBB) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">  /// Return true if it is possible to insert a select</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">  /// Return true if it is possible to insert a select</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">  /// instruction that chooses between TrueReg and FalseReg based on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">  /// instruction that chooses between TrueReg and FalseReg based on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">  /// condition code in Cond.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">  /// condition code in Cond.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">  /// When successful, also return the latency in cycles from TrueReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">  /// When successful, also return the latency in cycles from TrueReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">  /// FalseReg, and Cond to the destination register. In most cases, a select</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">  /// FalseReg, and Cond to the destination register. In most cases, a select</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">  /// instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">  /// instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">  /// Some x86 implementations have 2-cycle cmov instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">  /// Some x86 implementations have 2-cycle cmov instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">  /// @param MBB         Block where select instruction would be inserted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">  /// @param MBB         Block where select instruction would be inserted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">  /// @param Cond        Condition returned by analyzeBranch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">  /// @param Cond        Condition returned by analyzeBranch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">  /// @param DstReg      Virtual dest register that the result should write to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">  /// @param DstReg      Virtual dest register that the result should write to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">  /// @param TrueReg     Virtual register to select when Cond is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">  /// @param TrueReg     Virtual register to select when Cond is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">  /// @param FalseReg    Virtual register to select when Cond is false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">  /// @param FalseReg    Virtual register to select when Cond is false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">  /// @param CondCycles  Latency from Cond+Branch to select output.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">  /// @param CondCycles  Latency from Cond+Branch to select output.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">  /// @param TrueCycles  Latency from TrueReg to select output.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">  /// @param TrueCycles  Latency from TrueReg to select output.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">  /// @param FalseCycles Latency from FalseReg to select output.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">  /// @param FalseCycles Latency from FalseReg to select output.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">  virtual bool canInsertSelect(const MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">  virtual bool canInsertSelect(const MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">                               ArrayRef<MachineOperand> Cond, Register DstReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">                               ArrayRef<MachineOperand> Cond, Register DstReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">                               Register TrueReg, Register FalseReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">                               Register TrueReg, Register FalseReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">                               int &CondCycles, int &TrueCycles,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">                               int &CondCycles, int &TrueCycles,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">                               int &FalseCycles) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">                               int &FalseCycles) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">  /// Insert a select instruction into MBB before I that will copy TrueReg to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">  /// Insert a select instruction into MBB before I that will copy TrueReg to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">  /// DstReg when Cond is true, and FalseReg to DstReg when Cond is false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">  /// DstReg when Cond is true, and FalseReg to DstReg when Cond is false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">  /// This function can only be called after canInsertSelect() returned true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">  /// This function can only be called after canInsertSelect() returned true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">  /// The condition in Cond comes from analyzeBranch, and it can be assumed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">  /// The condition in Cond comes from analyzeBranch, and it can be assumed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">  /// that the same flags or registers required by Cond are available at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">  /// that the same flags or registers required by Cond are available at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">  /// insertion point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">  /// insertion point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">  /// @param MBB      Block where select instruction should be inserted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">  /// @param MBB      Block where select instruction should be inserted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">  /// @param I        Insertion point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">  /// @param I        Insertion point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">  /// @param DL       Source location for debugging.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">  /// @param DL       Source location for debugging.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">  /// @param DstReg   Virtual register to be defined by select instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">  /// @param DstReg   Virtual register to be defined by select instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">  /// @param Cond     Condition as computed by analyzeBranch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">  /// @param Cond     Condition as computed by analyzeBranch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">  /// @param TrueReg  Virtual register to copy when Cond is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">  /// @param TrueReg  Virtual register to copy when Cond is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">  /// @param FalseReg Virtual register to copy when Cons is false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">  /// @param FalseReg Virtual register to copy when Cons is false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">  virtual void insertSelect(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">  virtual void insertSelect(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">                            MachineBasicBlock::iterator I, const DebugLoc &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">                            MachineBasicBlock::iterator I, const DebugLoc &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">                            Register DstReg, ArrayRef<MachineOperand> Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">                            Register DstReg, ArrayRef<MachineOperand> Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">                            Register TrueReg, Register FalseReg) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">                            Register TrueReg, Register FalseReg) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement TargetInstrInfo::insertSelect!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement TargetInstrInfo::insertSelect!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">  /// Analyze the given select instruction, returning true if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">  /// Analyze the given select instruction, returning true if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">  /// it cannot be understood. It is assumed that MI->isSelect() is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">  /// it cannot be understood. It is assumed that MI->isSelect() is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">  /// When successful, return the controlling condition and the operands that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">  /// When successful, return the controlling condition and the operands that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">  /// determine the true and false result values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">  /// determine the true and false result values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">  ///   Result = SELECT Cond, TrueOp, FalseOp</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">  ///   Result = SELECT Cond, TrueOp, FalseOp</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">  /// Some targets can optimize select instructions, for example by predicating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">  /// Some targets can optimize select instructions, for example by predicating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">  /// the instruction defining one of the operands. Such targets should set</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">  /// the instruction defining one of the operands. Such targets should set</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">  /// Optimizable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">  /// Optimizable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">  /// @param         MI Select instruction to analyze.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">  /// @param         MI Select instruction to analyze.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">  /// @param Cond    Condition controlling the select.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">  /// @param Cond    Condition controlling the select.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">  /// @param TrueOp  Operand number of the value selected when Cond is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">  /// @param TrueOp  Operand number of the value selected when Cond is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">  /// @param FalseOp Operand number of the value selected when Cond is false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">  /// @param FalseOp Operand number of the value selected when Cond is false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">  /// @param Optimizable Returned as true if MI is optimizable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">  /// @param Optimizable Returned as true if MI is optimizable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">  /// @returns False on success.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">  /// @returns False on success.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">  virtual bool analyzeSelect(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">  virtual bool analyzeSelect(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">                             SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">                             SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">                             unsigned &TrueOp, unsigned &FalseOp,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">                             unsigned &TrueOp, unsigned &FalseOp,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">                             bool &Optimizable) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">                             bool &Optimizable) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">    assert(MI.getDesc().isSelect() && "MI must be a select instruction");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">    assert(MI.getDesc().isSelect() && "MI must be a select instruction");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">  /// Given a select instruction that was understood by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">  /// Given a select instruction that was understood by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">  /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">  /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">  /// merging it with one of its operands. Returns NULL on failure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">  /// merging it with one of its operands. Returns NULL on failure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">  /// When successful, returns the new select instruction. The client is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">  /// When successful, returns the new select instruction. The client is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">  /// responsible for deleting MI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">  /// responsible for deleting MI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">  /// If both sides of the select can be optimized, PreferFalse is used to pick</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">  /// If both sides of the select can be optimized, PreferFalse is used to pick</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  /// a side.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  /// a side.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">  /// @param MI          Optimizable select instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">  /// @param MI          Optimizable select instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">  /// @param NewMIs     Set that record all MIs in the basic block up to \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">  /// @param NewMIs     Set that record all MIs in the basic block up to \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">  /// MI. Has to be updated with any newly created MI or deleted ones.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">  /// MI. Has to be updated with any newly created MI or deleted ones.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">  /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">  /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">  /// @returns Optimized instruction or NULL.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">  /// @returns Optimized instruction or NULL.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">  virtual MachineInstr *optimizeSelect(MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">  virtual MachineInstr *optimizeSelect(MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">                                       SmallPtrSetImpl<MachineInstr *> &NewMIs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">                                       SmallPtrSetImpl<MachineInstr *> &NewMIs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">                                       bool PreferFalse = false) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">                                       bool PreferFalse = false) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">    // This function must be implemented if Optimizable is ever set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">    // This function must be implemented if Optimizable is ever set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">    llvm_unreachable("Target must implement TargetInstrInfo::optimizeSelect!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">    llvm_unreachable("Target must implement TargetInstrInfo::optimizeSelect!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">  /// Emit instructions to copy a pair of physical registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">  /// Emit instructions to copy a pair of physical registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">  /// This function should support copies within any legal register class as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">  /// This function should support copies within any legal register class as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">  /// well as any cross-class copies created during instruction selection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">  /// well as any cross-class copies created during instruction selection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">  /// The source and destination registers may overlap, which may require a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">  /// The source and destination registers may overlap, which may require a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">  /// careful implementation when multiple copy instructions are required for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">  /// careful implementation when multiple copy instructions are required for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">  /// large registers. See for example the ARM target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">  /// large registers. See for example the ARM target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">  virtual void copyPhysReg(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">  virtual void copyPhysReg(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">                           MachineBasicBlock::iterator MI, const DebugLoc &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">                           MachineBasicBlock::iterator MI, const DebugLoc &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">                           MCRegister DestReg, MCRegister SrcReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">                           MCRegister DestReg, MCRegister SrcReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">                           bool KillSrc) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">                           bool KillSrc) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement TargetInstrInfo::copyPhysReg!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement TargetInstrInfo::copyPhysReg!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">  /// Allow targets to tell MachineVerifier whether a specific register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">  /// Allow targets to tell MachineVerifier whether a specific register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">  /// MachineOperand can be used as part of PC-relative addressing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">  /// MachineOperand can be used as part of PC-relative addressing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">  /// PC-relative addressing modes in many CISC architectures contain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">  /// PC-relative addressing modes in many CISC architectures contain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  /// (non-PC) registers as offsets or scaling values, which inherently</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  /// (non-PC) registers as offsets or scaling values, which inherently</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">  /// tags the corresponding MachineOperand with OPERAND_PCREL.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">  /// tags the corresponding MachineOperand with OPERAND_PCREL.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">  /// @param MO The MachineOperand in question. MO.isReg() should always</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">  /// @param MO The MachineOperand in question. MO.isReg() should always</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">  /// be true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">  /// be true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">  /// @return Whether this operand is allowed to be used PC-relatively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">  /// @return Whether this operand is allowed to be used PC-relatively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">  virtual bool isPCRelRegisterOperandLegal(const MachineOperand &MO) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">  virtual bool isPCRelRegisterOperandLegal(const MachineOperand &MO) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">  /// Return an index for MachineJumpTableInfo if \p insn is an indirect jump</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">  /// Return an index for MachineJumpTableInfo if \p insn is an indirect jump</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">  /// using a jump table, otherwise -1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">  /// using a jump table, otherwise -1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">  virtual int getJumpTableIndex(const MachineInstr &MI) const { return -1; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">  virtual int getJumpTableIndex(const MachineInstr &MI) const { return -1; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">  /// Target-dependent implementation for IsCopyInstr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">  /// Target-dependent implementation for IsCopyInstr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">  /// If the specific machine instruction is a instruction that moves/copies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">  /// If the specific machine instruction is a instruction that moves/copies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">  /// value from one register to another register return destination and source</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">  /// value from one register to another register return destination and source</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">  /// registers as machine operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">  /// registers as machine operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">  virtual std::optional<DestSourcePair></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">  virtual std::optional<DestSourcePair></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">  isCopyInstrImpl(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">  isCopyInstrImpl(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">  /// Return true if the given terminator MI is not expected to spill. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">  /// Return true if the given terminator MI is not expected to spill. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">  /// sets the live interval as not spillable and adjusts phi node lowering to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">  /// sets the live interval as not spillable and adjusts phi node lowering to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">  /// not introduce copies after the terminator. Use with care, these are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">  /// not introduce copies after the terminator. Use with care, these are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">  /// currently used for hardware loop intrinsics in very controlled situations,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">  /// currently used for hardware loop intrinsics in very controlled situations,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">  /// created prior to registry allocation in loops that only have single phi</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">  /// created prior to registry allocation in loops that only have single phi</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">  /// users for the terminators value. They may run out of registers if not used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">  /// users for the terminators value. They may run out of registers if not used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">  /// carefully.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">  /// carefully.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine coveredLine">  virtual bool isUnspillableTerminatorImpl(const MachineInstr *MI) const {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine coveredLine">  virtual bool isUnspillableTerminatorImpl(const MachineInstr *MI) const {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">  /// If the specific machine instruction is a instruction that moves/copies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">  /// If the specific machine instruction is a instruction that moves/copies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">  /// value from one register to another register return destination and source</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">  /// value from one register to another register return destination and source</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">  /// registers as machine operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">  /// registers as machine operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">  /// For COPY-instruction the method naturally returns destination and source</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">  /// For COPY-instruction the method naturally returns destination and source</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">  /// registers as machine operands, for all other instructions the method calls</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">  /// registers as machine operands, for all other instructions the method calls</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  /// target-dependent implementation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  /// target-dependent implementation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine coveredLine">  std::optional<DestSourcePair> isCopyInstr(const MachineInstr &MI) const {</td>
    <td class="lineNumber">23</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">  std::optional<DestSourcePair> isCopyInstr(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine coveredLine">    if (MI.isCopy()) {</td>
    <td class="lineNumber">23</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">    if (MI.isCopy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">      return DestSourcePair{MI.getOperand(0), MI.getOperand(1)};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">      return DestSourcePair{MI.getOperand(0), MI.getOperand(1)};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine coveredLine">    return isCopyInstrImpl(MI);</td>
    <td class="lineNumber">23</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">    return isCopyInstrImpl(MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">  /// If the specific machine instruction is an instruction that adds an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">  /// If the specific machine instruction is an instruction that adds an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">  /// immediate value and a physical register, and stores the result in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">  /// immediate value and a physical register, and stores the result in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">  /// the given physical register \c Reg, return a pair of the source</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">  /// the given physical register \c Reg, return a pair of the source</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">  /// register and the offset which has been added.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">  /// register and the offset which has been added.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">  virtual std::optional<RegImmPair> isAddImmediate(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">  virtual std::optional<RegImmPair> isAddImmediate(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">                                                   Register Reg) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">                                                   Register Reg) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">  /// Returns true if MI is an instruction that defines Reg to have a constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">  /// Returns true if MI is an instruction that defines Reg to have a constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">  /// value and the value is recorded in ImmVal. The ImmVal is a result that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">  /// value and the value is recorded in ImmVal. The ImmVal is a result that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">  /// should be interpreted as modulo size of Reg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">  /// should be interpreted as modulo size of Reg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  virtual bool getConstValDefinedInReg(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  virtual bool getConstValDefinedInReg(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">                                       const Register Reg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">                                       const Register Reg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">                                       int64_t &ImmVal) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">                                       int64_t &ImmVal) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">  /// Store the specified register of the given register class to the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">  /// Store the specified register of the given register class to the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">  /// stack frame index. The store instruction is to be added to the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">  /// stack frame index. The store instruction is to be added to the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">  /// machine basic block before the specified machine instruction. If isKill</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">  /// machine basic block before the specified machine instruction. If isKill</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">  /// is true, the register operand is the last use and must be marked kill. If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">  /// is true, the register operand is the last use and must be marked kill. If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">  /// \p SrcReg is being directly spilled as part of assigning a virtual</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">  /// \p SrcReg is being directly spilled as part of assigning a virtual</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">  /// register, \p VReg is the register being assigned. This additional register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">  /// register, \p VReg is the register being assigned. This additional register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">  /// argument is needed for certain targets when invoked from RegAllocFast to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">  /// argument is needed for certain targets when invoked from RegAllocFast to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">  /// map the spilled physical register to its virtual register. A null register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">  /// map the spilled physical register to its virtual register. A null register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">  /// can be passed elsewhere.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">  /// can be passed elsewhere.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">  virtual void storeRegToStackSlot(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">  virtual void storeRegToStackSlot(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">                                   MachineBasicBlock::iterator MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">                                   MachineBasicBlock::iterator MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">                                   Register SrcReg, bool isKill, int FrameIndex,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">                                   Register SrcReg, bool isKill, int FrameIndex,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">                                   const TargetRegisterClass *RC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">                                   const TargetRegisterClass *RC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">                                   const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">                                   const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">                                   Register VReg) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">                                   Register VReg) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">                     "TargetInstrInfo::storeRegToStackSlot!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">                     "TargetInstrInfo::storeRegToStackSlot!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">  /// Load the specified register of the given register class from the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">  /// Load the specified register of the given register class from the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">  /// stack frame index. The load instruction is to be added to the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">  /// stack frame index. The load instruction is to be added to the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">  /// machine basic block before the specified machine instruction. If \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">  /// machine basic block before the specified machine instruction. If \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">  /// DestReg is being directly reloaded as part of assigning a virtual</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">  /// DestReg is being directly reloaded as part of assigning a virtual</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">  /// register, \p VReg is the register being assigned. This additional register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">  /// register, \p VReg is the register being assigned. This additional register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">  /// argument is needed for certain targets when invoked from RegAllocFast to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">  /// argument is needed for certain targets when invoked from RegAllocFast to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">  /// map the loaded physical register to its virtual register. A null register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">  /// map the loaded physical register to its virtual register. A null register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">  /// can be passed elsewhere.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">  /// can be passed elsewhere.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">  virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">  virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">                                    MachineBasicBlock::iterator MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">                                    MachineBasicBlock::iterator MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">                                    Register DestReg, int FrameIndex,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">                                    Register DestReg, int FrameIndex,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">                                    const TargetRegisterClass *RC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">                                    const TargetRegisterClass *RC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">                                    const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">                                    const TargetRegisterInfo *TRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">                                    Register VReg) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">                                    Register VReg) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">                     "TargetInstrInfo::loadRegFromStackSlot!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">                     "TargetInstrInfo::loadRegFromStackSlot!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">  /// This function is called for all pseudo instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">  /// This function is called for all pseudo instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">  /// that remain after register allocation. Many pseudo instructions are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">  /// that remain after register allocation. Many pseudo instructions are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">  /// created to help register allocation. This is the place to convert them</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">  /// created to help register allocation. This is the place to convert them</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">  /// into real instructions. The target can edit MI in place, or it can insert</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">  /// into real instructions. The target can edit MI in place, or it can insert</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">  /// new instructions and erase MI. The function should return true if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">  /// new instructions and erase MI. The function should return true if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">  /// anything was changed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">  /// anything was changed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">  virtual bool expandPostRAPseudo(MachineInstr &MI) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">  virtual bool expandPostRAPseudo(MachineInstr &MI) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">  /// Check whether the target can fold a load that feeds a subreg operand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">  /// Check whether the target can fold a load that feeds a subreg operand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">  /// (or a subreg operand that feeds a store).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">  /// (or a subreg operand that feeds a store).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">  /// For example, X86 may want to return true if it can fold</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">  /// For example, X86 may want to return true if it can fold</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">  /// movl (%esp), %eax</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">  /// movl (%esp), %eax</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">  /// subb, %al, ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">  /// subb, %al, ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">  /// Into:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">  /// Into:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">  /// subb (%esp), ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">  /// subb (%esp), ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">  /// Ideally, we'd like the target implementation of foldMemoryOperand() to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">  /// Ideally, we'd like the target implementation of foldMemoryOperand() to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">  /// reject subregs - but since this behavior used to be enforced in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">  /// reject subregs - but since this behavior used to be enforced in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">  /// target-independent code, moving this responsibility to the targets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">  /// target-independent code, moving this responsibility to the targets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">  /// has the potential of causing nasty silent breakage in out-of-tree targets.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">  /// has the potential of causing nasty silent breakage in out-of-tree targets.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">  virtual bool isSubregFoldable() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">  virtual bool isSubregFoldable() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">  /// For a patchpoint, stackmap, or statepoint intrinsic, return the range of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">  /// For a patchpoint, stackmap, or statepoint intrinsic, return the range of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">  /// operands which can't be folded into stack references. Operands outside</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">  /// operands which can't be folded into stack references. Operands outside</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">  /// of the range are most likely foldable but it is not guaranteed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">  /// of the range are most likely foldable but it is not guaranteed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">  /// These instructions are unique in that stack references for some operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">  /// These instructions are unique in that stack references for some operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">  /// have the same execution cost (e.g. none) as the unfolded register forms.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">  /// have the same execution cost (e.g. none) as the unfolded register forms.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">  /// The ranged return is guaranteed to include all operands which can't be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">  /// The ranged return is guaranteed to include all operands which can't be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">  /// folded at zero cost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">  /// folded at zero cost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">  virtual std::pair<unsigned, unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">  virtual std::pair<unsigned, unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">  getPatchpointUnfoldableRange(const MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">  getPatchpointUnfoldableRange(const MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">  /// Attempt to fold a load or store of the specified stack</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">  /// Attempt to fold a load or store of the specified stack</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">  /// slot into the specified machine instruction for the specified operand(s).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">  /// slot into the specified machine instruction for the specified operand(s).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">  /// If this is possible, a new instruction is returned with the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">  /// If this is possible, a new instruction is returned with the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">  /// operand folded, otherwise NULL is returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">  /// operand folded, otherwise NULL is returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">  /// The new instruction is inserted before MI, and the client is responsible</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">  /// The new instruction is inserted before MI, and the client is responsible</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">  /// for removing the old instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">  /// for removing the old instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">  /// If VRM is passed, the assigned physregs can be inspected by target to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">  /// If VRM is passed, the assigned physregs can be inspected by target to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">  /// decide on using an opcode (note that those assignments can still change).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">  /// decide on using an opcode (note that those assignments can still change).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">  MachineInstr *foldMemoryOperand(MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">  MachineInstr *foldMemoryOperand(MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">                                  int FI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">                                  int FI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">                                  LiveIntervals *LIS = nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">                                  LiveIntervals *LIS = nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">                                  VirtRegMap *VRM = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">                                  VirtRegMap *VRM = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">  /// Same as the previous version except it allows folding of any load and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">  /// Same as the previous version except it allows folding of any load and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">  /// store from / to any address, not just from a specific stack slot.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">  /// store from / to any address, not just from a specific stack slot.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">  MachineInstr *foldMemoryOperand(MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">  MachineInstr *foldMemoryOperand(MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">                                  MachineInstr &LoadMI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">                                  MachineInstr &LoadMI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">                                  LiveIntervals *LIS = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">                                  LiveIntervals *LIS = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">  /// This function defines the logic to lower COPY instruction to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">  /// This function defines the logic to lower COPY instruction to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">  /// target specific instruction(s).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">  /// target specific instruction(s).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">  void lowerCopy(MachineInstr *MI, const TargetRegisterInfo *TRI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">  void lowerCopy(MachineInstr *MI, const TargetRegisterInfo *TRI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">  /// Return true when there is potentially a faster code sequence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">  /// Return true when there is potentially a faster code sequence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">  /// for an instruction chain ending in \p Root. All potential patterns are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">  /// for an instruction chain ending in \p Root. All potential patterns are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">  /// returned in the \p Pattern vector. Pattern should be sorted in priority</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">  /// returned in the \p Pattern vector. Pattern should be sorted in priority</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">  /// order since the pattern evaluator stops checking as soon as it finds a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">  /// order since the pattern evaluator stops checking as soon as it finds a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">  /// faster sequence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">  /// faster sequence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">  /// \param Root - Instruction that could be combined with one of its operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">  /// \param Root - Instruction that could be combined with one of its operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">  /// \param Patterns - Vector of possible combination patterns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">  /// \param Patterns - Vector of possible combination patterns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">  getMachineCombinerPatterns(MachineInstr &Root,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">  getMachineCombinerPatterns(MachineInstr &Root,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">                             SmallVectorImpl<MachineCombinerPattern> &Patterns,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">                             SmallVectorImpl<MachineCombinerPattern> &Patterns,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">                             bool DoRegPressureReduce) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">                             bool DoRegPressureReduce) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">  /// Return true if target supports reassociation of instructions in machine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">  /// Return true if target supports reassociation of instructions in machine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">  /// combiner pass to reduce register pressure for a given BB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">  /// combiner pass to reduce register pressure for a given BB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">  shouldReduceRegisterPressure(const MachineBasicBlock *MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">  shouldReduceRegisterPressure(const MachineBasicBlock *MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">                               const RegisterClassInfo *RegClassInfo) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">                               const RegisterClassInfo *RegClassInfo) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">  /// Fix up the placeholder we may add in genAlternativeCodeSequence().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">  /// Fix up the placeholder we may add in genAlternativeCodeSequence().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">  virtual void</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">  virtual void</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">  finalizeInsInstrs(MachineInstr &Root, MachineCombinerPattern &P,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">  finalizeInsInstrs(MachineInstr &Root, MachineCombinerPattern &P,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">                    SmallVectorImpl<MachineInstr *> &InsInstrs) const {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">                    SmallVectorImpl<MachineInstr *> &InsInstrs) const {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">  /// Return true when a code sequence can improve throughput. It</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">  /// Return true when a code sequence can improve throughput. It</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">  /// should be called only for instructions in loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">  /// should be called only for instructions in loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">  /// \param Pattern - combiner pattern</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">  /// \param Pattern - combiner pattern</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">  virtual bool isThroughputPattern(MachineCombinerPattern Pattern) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">  virtual bool isThroughputPattern(MachineCombinerPattern Pattern) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">  /// Return true if the input \P Inst is part of a chain of dependent ops</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">  /// Return true if the input \P Inst is part of a chain of dependent ops</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">  /// that are suitable for reassociation, otherwise return false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">  /// that are suitable for reassociation, otherwise return false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">  /// If the instruction's operands must be commuted to have a previous</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">  /// If the instruction's operands must be commuted to have a previous</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">  /// instruction of the same type define the first source operand, \P Commuted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">  /// instruction of the same type define the first source operand, \P Commuted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">  /// will be set to true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">  /// will be set to true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">  bool isReassociationCandidate(const MachineInstr &Inst, bool &Commuted) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">  bool isReassociationCandidate(const MachineInstr &Inst, bool &Commuted) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">  /// Return true when \P Inst is both associative and commutative. If \P Invert</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">  /// Return true when \P Inst is both associative and commutative. If \P Invert</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">  /// is true, then the inverse of \P Inst operation must be tested.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">  /// is true, then the inverse of \P Inst operation must be tested.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">  virtual bool isAssociativeAndCommutative(const MachineInstr &Inst,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">  virtual bool isAssociativeAndCommutative(const MachineInstr &Inst,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">                                           bool Invert = false) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">                                           bool Invert = false) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">  /// Return the inverse operation opcode if it exists for \P Opcode (e.g. add</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">  /// Return the inverse operation opcode if it exists for \P Opcode (e.g. add</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">  /// for sub and vice versa).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">  /// for sub and vice versa).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">  virtual std::optional<unsigned> getInverseOpcode(unsigned Opcode) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">  virtual std::optional<unsigned> getInverseOpcode(unsigned Opcode) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">  /// Return true when \P Opcode1 or its inversion is equal to \P Opcode2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">  /// Return true when \P Opcode1 or its inversion is equal to \P Opcode2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">  bool areOpcodesEqualOrInverse(unsigned Opcode1, unsigned Opcode2) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">  bool areOpcodesEqualOrInverse(unsigned Opcode1, unsigned Opcode2) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">  /// Return true when \P Inst has reassociable operands in the same \P MBB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">  /// Return true when \P Inst has reassociable operands in the same \P MBB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">  virtual bool hasReassociableOperands(const MachineInstr &Inst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">  virtual bool hasReassociableOperands(const MachineInstr &Inst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">                                       const MachineBasicBlock *MBB) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">                                       const MachineBasicBlock *MBB) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  /// Return true when \P Inst has reassociable sibling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  /// Return true when \P Inst has reassociable sibling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">  virtual bool hasReassociableSibling(const MachineInstr &Inst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">  virtual bool hasReassociableSibling(const MachineInstr &Inst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">                                      bool &Commuted) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">                                      bool &Commuted) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  /// When getMachineCombinerPatterns() finds patterns, this function generates</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  /// When getMachineCombinerPatterns() finds patterns, this function generates</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">  /// the instructions that could replace the original code sequence. The client</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">  /// the instructions that could replace the original code sequence. The client</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">  /// has to decide whether the actual replacement is beneficial or not.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">  /// has to decide whether the actual replacement is beneficial or not.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">  /// \param Root - Instruction that could be combined with one of its operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">  /// \param Root - Instruction that could be combined with one of its operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">  /// \param Pattern - Combination pattern for Root</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">  /// \param Pattern - Combination pattern for Root</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">  /// \param InsInstrs - Vector of new instructions that implement P</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">  /// \param InsInstrs - Vector of new instructions that implement P</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">  /// \param DelInstrs - Old instructions, including Root, that could be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">  /// \param DelInstrs - Old instructions, including Root, that could be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">  /// replaced by InsInstr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">  /// replaced by InsInstr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">  /// \param InstIdxForVirtReg - map of virtual register to instruction in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">  /// \param InstIdxForVirtReg - map of virtual register to instruction in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  /// InsInstr that defines it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  /// InsInstr that defines it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">  virtual void genAlternativeCodeSequence(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">  virtual void genAlternativeCodeSequence(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">      MachineInstr &Root, MachineCombinerPattern Pattern,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">      MachineInstr &Root, MachineCombinerPattern Pattern,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">      SmallVectorImpl<MachineInstr *> &InsInstrs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">      SmallVectorImpl<MachineInstr *> &InsInstrs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">      SmallVectorImpl<MachineInstr *> &DelInstrs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">      SmallVectorImpl<MachineInstr *> &DelInstrs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">      DenseMap<unsigned, unsigned> &InstIdxForVirtReg) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">      DenseMap<unsigned, unsigned> &InstIdxForVirtReg) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">  /// When calculate the latency of the root instruction, accumulate the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">  /// When calculate the latency of the root instruction, accumulate the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  /// latency of the sequence to the root latency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  /// latency of the sequence to the root latency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">  /// \param Root - Instruction that could be combined with one of its operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">  /// \param Root - Instruction that could be combined with one of its operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  virtual bool accumulateInstrSeqToRootLatency(MachineInstr &Root) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  virtual bool accumulateInstrSeqToRootLatency(MachineInstr &Root) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">  /// Attempt to reassociate \P Root and \P Prev according to \P Pattern to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">  /// Attempt to reassociate \P Root and \P Prev according to \P Pattern to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">  /// reduce critical path length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">  /// reduce critical path length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">  void reassociateOps(MachineInstr &Root, MachineInstr &Prev,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">  void reassociateOps(MachineInstr &Root, MachineInstr &Prev,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">                      MachineCombinerPattern Pattern,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">                      MachineCombinerPattern Pattern,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">                      SmallVectorImpl<MachineInstr *> &InsInstrs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">                      SmallVectorImpl<MachineInstr *> &InsInstrs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">                      SmallVectorImpl<MachineInstr *> &DelInstrs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">                      SmallVectorImpl<MachineInstr *> &DelInstrs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">                      DenseMap<unsigned, unsigned> &InstrIdxForVirtReg) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">                      DenseMap<unsigned, unsigned> &InstrIdxForVirtReg) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">  /// Reassociation of some instructions requires inverse operations (e.g.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">  /// Reassociation of some instructions requires inverse operations (e.g.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">  /// (X + A) - Y => (X - Y) + A). This method returns a pair of new opcodes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">  /// (X + A) - Y => (X - Y) + A). This method returns a pair of new opcodes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">  /// (new root opcode, new prev opcode) that must be used to reassociate \P</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">  /// (new root opcode, new prev opcode) that must be used to reassociate \P</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">  /// Root and \P Prev accoring to \P Pattern.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">  /// Root and \P Prev accoring to \P Pattern.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">  std::pair<unsigned, unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">  std::pair<unsigned, unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">  getReassociationOpcodes(MachineCombinerPattern Pattern,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">  getReassociationOpcodes(MachineCombinerPattern Pattern,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">                          const MachineInstr &Root,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">                          const MachineInstr &Root,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">                          const MachineInstr &Prev) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">                          const MachineInstr &Prev) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  /// The limit on resource length extension we accept in MachineCombiner Pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  /// The limit on resource length extension we accept in MachineCombiner Pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">  virtual int getExtendResourceLenLimit() const { return 0; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">  virtual int getExtendResourceLenLimit() const { return 0; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">  /// This is an architecture-specific helper function of reassociateOps.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">  /// This is an architecture-specific helper function of reassociateOps.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">  /// Set special operand attributes for new instructions after reassociation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">  /// Set special operand attributes for new instructions after reassociation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">  virtual void setSpecialOperandAttr(MachineInstr &OldMI1, MachineInstr &OldMI2,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">  virtual void setSpecialOperandAttr(MachineInstr &OldMI1, MachineInstr &OldMI2,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">                                     MachineInstr &NewMI1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">                                     MachineInstr &NewMI1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">                                     MachineInstr &NewMI2) const {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">                                     MachineInstr &NewMI2) const {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">  /// Return true when a target supports MachineCombiner.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">  /// Return true when a target supports MachineCombiner.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">  virtual bool useMachineCombiner() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">  virtual bool useMachineCombiner() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">  /// Return a strategy that MachineCombiner must use when creating traces.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">  /// Return a strategy that MachineCombiner must use when creating traces.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">  virtual MachineTraceStrategy getMachineCombinerTraceStrategy() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">  virtual MachineTraceStrategy getMachineCombinerTraceStrategy() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">  /// Return true if the given SDNode can be copied during scheduling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">  /// Return true if the given SDNode can be copied during scheduling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  /// even if it has glue.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  /// even if it has glue.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">  virtual bool canCopyGluedNodeDuringSchedule(SDNode *N) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">  virtual bool canCopyGluedNodeDuringSchedule(SDNode *N) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">  /// Target-dependent implementation for foldMemoryOperand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">  /// Target-dependent implementation for foldMemoryOperand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">  /// Target-independent code in foldMemoryOperand will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">  /// Target-independent code in foldMemoryOperand will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">  /// take care of adding a MachineMemOperand to the newly created instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">  /// take care of adding a MachineMemOperand to the newly created instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">  /// The instruction and any auxiliary instructions necessary will be inserted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">  /// The instruction and any auxiliary instructions necessary will be inserted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">  /// at InsertPt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">  /// at InsertPt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">  virtual MachineInstr *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">  virtual MachineInstr *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">  foldMemoryOperandImpl(MachineFunction &MF, MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">  foldMemoryOperandImpl(MachineFunction &MF, MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">                        ArrayRef<unsigned> Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">                        ArrayRef<unsigned> Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">                        MachineBasicBlock::iterator InsertPt, int FrameIndex,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">                        MachineBasicBlock::iterator InsertPt, int FrameIndex,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">                        LiveIntervals *LIS = nullptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">                        LiveIntervals *LIS = nullptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">                        VirtRegMap *VRM = nullptr) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">                        VirtRegMap *VRM = nullptr) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">  /// Target-dependent implementation for foldMemoryOperand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">  /// Target-dependent implementation for foldMemoryOperand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">  /// Target-independent code in foldMemoryOperand will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">  /// Target-independent code in foldMemoryOperand will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">  /// take care of adding a MachineMemOperand to the newly created instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">  /// take care of adding a MachineMemOperand to the newly created instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">  /// The instruction and any auxiliary instructions necessary will be inserted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">  /// The instruction and any auxiliary instructions necessary will be inserted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">  /// at InsertPt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">  /// at InsertPt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">  virtual MachineInstr *foldMemoryOperandImpl(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">  virtual MachineInstr *foldMemoryOperandImpl(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">      MachineFunction &MF, MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">      MachineFunction &MF, MachineInstr &MI, ArrayRef<unsigned> Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">      MachineBasicBlock::iterator InsertPt, MachineInstr &LoadMI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">      MachineBasicBlock::iterator InsertPt, MachineInstr &LoadMI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">      LiveIntervals *LIS = nullptr) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">      LiveIntervals *LIS = nullptr) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">  /// Target-dependent implementation of getRegSequenceInputs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">  /// Target-dependent implementation of getRegSequenceInputs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">  /// \returns true if it is possible to build the equivalent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">  /// \returns true if it is possible to build the equivalent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">  /// REG_SEQUENCE inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">  /// REG_SEQUENCE inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">  /// \pre MI.isRegSequenceLike().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">  /// \pre MI.isRegSequenceLike().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">  /// \see TargetInstrInfo::getRegSequenceInputs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">  /// \see TargetInstrInfo::getRegSequenceInputs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">  virtual bool getRegSequenceLikeInputs(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">  virtual bool getRegSequenceLikeInputs(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">      const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">      const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">      SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">      SmallVectorImpl<RegSubRegPairAndIdx> &InputRegs) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">  /// Target-dependent implementation of getExtractSubregInputs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">  /// Target-dependent implementation of getExtractSubregInputs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">  /// \returns true if it is possible to build the equivalent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">  /// \returns true if it is possible to build the equivalent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">  /// EXTRACT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">  /// EXTRACT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">  /// \pre MI.isExtractSubregLike().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">  /// \pre MI.isExtractSubregLike().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">  /// \see TargetInstrInfo::getExtractSubregInputs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">  /// \see TargetInstrInfo::getExtractSubregInputs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">  virtual bool getExtractSubregLikeInputs(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">  virtual bool getExtractSubregLikeInputs(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">                                          unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">                                          unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">                                          RegSubRegPairAndIdx &InputReg) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">                                          RegSubRegPairAndIdx &InputReg) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">  /// Target-dependent implementation of getInsertSubregInputs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">  /// Target-dependent implementation of getInsertSubregInputs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">  /// \returns true if it is possible to build the equivalent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">  /// \returns true if it is possible to build the equivalent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">  /// INSERT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">  /// INSERT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">  /// \pre MI.isInsertSubregLike().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">  /// \pre MI.isInsertSubregLike().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">  /// \see TargetInstrInfo::getInsertSubregInputs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">  /// \see TargetInstrInfo::getInsertSubregInputs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">  getInsertSubregLikeInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">  getInsertSubregLikeInputs(const MachineInstr &MI, unsigned DefIdx,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">                            RegSubRegPair &BaseReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">                            RegSubRegPair &BaseReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">                            RegSubRegPairAndIdx &InsertedReg) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">                            RegSubRegPairAndIdx &InsertedReg) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">  /// unfoldMemoryOperand - Separate a single instruction which folded a load or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">  /// unfoldMemoryOperand - Separate a single instruction which folded a load or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">  /// a store or a load and a store into two or more instruction. If this is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">  /// a store or a load and a store into two or more instruction. If this is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">  /// possible, returns true as well as the new instructions by reference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">  /// possible, returns true as well as the new instructions by reference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">  unfoldMemoryOperand(MachineFunction &MF, MachineInstr &MI, unsigned Reg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">  unfoldMemoryOperand(MachineFunction &MF, MachineInstr &MI, unsigned Reg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">                      bool UnfoldLoad, bool UnfoldStore,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">                      bool UnfoldLoad, bool UnfoldStore,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">                      SmallVectorImpl<MachineInstr *> &NewMIs) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">                      SmallVectorImpl<MachineInstr *> &NewMIs) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">  virtual bool unfoldMemoryOperand(SelectionDAG &DAG, SDNode *N,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">  virtual bool unfoldMemoryOperand(SelectionDAG &DAG, SDNode *N,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">                                   SmallVectorImpl<SDNode *> &NewNodes) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">                                   SmallVectorImpl<SDNode *> &NewNodes) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">  /// Returns the opcode of the would be new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">  /// Returns the opcode of the would be new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">  /// instruction after load / store are unfolded from an instruction of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">  /// instruction after load / store are unfolded from an instruction of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">  /// specified opcode. It returns zero if the specified unfolding is not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">  /// specified opcode. It returns zero if the specified unfolding is not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">  /// possible. If LoadRegIndex is non-null, it is filled in with the operand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">  /// possible. If LoadRegIndex is non-null, it is filled in with the operand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">  /// index of the operand which will hold the register holding the loaded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">  /// index of the operand which will hold the register holding the loaded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">  /// value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">  /// value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">  virtual unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">  virtual unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">  getOpcodeAfterMemoryUnfold(unsigned Opc, bool UnfoldLoad, bool UnfoldStore,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">  getOpcodeAfterMemoryUnfold(unsigned Opc, bool UnfoldLoad, bool UnfoldStore,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">                             unsigned *LoadRegIndex = nullptr) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">                             unsigned *LoadRegIndex = nullptr) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">  /// This is used by the pre-regalloc scheduler to determine if two loads are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">  /// This is used by the pre-regalloc scheduler to determine if two loads are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">  /// loading from the same base address. It should only return true if the base</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">  /// loading from the same base address. It should only return true if the base</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">  /// pointers are the same and the only differences between the two addresses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">  /// pointers are the same and the only differences between the two addresses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">  /// are the offset. It also returns the offsets by reference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">  /// are the offset. It also returns the offsets by reference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine coveredLine">  virtual bool areLoadsFromSameBasePtr(SDNode *Load1, SDNode *Load2,</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine coveredLine">  virtual bool areLoadsFromSameBasePtr(SDNode *Load1, SDNode *Load2,</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">                                       int64_t &Offset1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">                                       int64_t &Offset1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">                                       int64_t &Offset2) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">                                       int64_t &Offset2) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">  /// This is a used by the pre-regalloc scheduler to determine (in conjunction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">  /// This is a used by the pre-regalloc scheduler to determine (in conjunction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">  /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">  /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">  /// On some targets if two loads are loading from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">  /// On some targets if two loads are loading from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">  /// addresses in the same cache line, it's better if they are scheduled</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">  /// addresses in the same cache line, it's better if they are scheduled</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">  /// together. This function takes two integers that represent the load offsets</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">  /// together. This function takes two integers that represent the load offsets</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">  /// from the common base address. It returns true if it decides it's desirable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">  /// from the common base address. It returns true if it decides it's desirable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">  /// to schedule the two loads together. "NumLoads" is the number of loads that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">  /// to schedule the two loads together. "NumLoads" is the number of loads that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">  /// have already been scheduled after Load1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">  /// have already been scheduled after Load1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">  virtual bool shouldScheduleLoadsNear(SDNode *Load1, SDNode *Load2,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">  virtual bool shouldScheduleLoadsNear(SDNode *Load1, SDNode *Load2,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">                                       int64_t Offset1, int64_t Offset2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">                                       int64_t Offset1, int64_t Offset2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">                                       unsigned NumLoads) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">                                       unsigned NumLoads) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">  /// Get the base operand and byte offset of an instruction that reads/writes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">  /// Get the base operand and byte offset of an instruction that reads/writes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">  /// memory. This is a convenience function for callers that are only prepared</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">  /// memory. This is a convenience function for callers that are only prepared</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">  /// to handle a single base operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">  /// to handle a single base operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">  bool getMemOperandWithOffset(const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">  bool getMemOperandWithOffset(const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">                               const MachineOperand *&BaseOp, int64_t &Offset,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">                               const MachineOperand *&BaseOp, int64_t &Offset,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">                               bool &OffsetIsScalable,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">                               bool &OffsetIsScalable,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">                               const TargetRegisterInfo *TRI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">                               const TargetRegisterInfo *TRI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">  /// Get zero or more base operands and the byte offset of an instruction that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">  /// Get zero or more base operands and the byte offset of an instruction that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">  /// reads/writes memory. Note that there may be zero base operands if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">  /// reads/writes memory. Note that there may be zero base operands if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">  /// instruction accesses a constant address.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">  /// instruction accesses a constant address.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">  /// It returns false if MI does not read/write memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">  /// It returns false if MI does not read/write memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">  /// It returns false if base operands and offset could not be determined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">  /// It returns false if base operands and offset could not be determined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">  /// It is not guaranteed to always recognize base operands and offsets in all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">  /// It is not guaranteed to always recognize base operands and offsets in all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">  /// cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">  /// cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">  virtual bool getMemOperandsWithOffsetWidth(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">  virtual bool getMemOperandsWithOffsetWidth(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">      const MachineInstr &MI, SmallVectorImpl<const MachineOperand *> &BaseOps,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">      const MachineInstr &MI, SmallVectorImpl<const MachineOperand *> &BaseOps,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">      int64_t &Offset, bool &OffsetIsScalable, unsigned &Width,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">      int64_t &Offset, bool &OffsetIsScalable, unsigned &Width,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">      const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">      const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">  /// Return true if the instruction contains a base register and offset. If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">  /// Return true if the instruction contains a base register and offset. If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">  /// true, the function also sets the operand position in the instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">  /// true, the function also sets the operand position in the instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">  /// for the base register and offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">  /// for the base register and offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">  virtual bool getBaseAndOffsetPosition(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">  virtual bool getBaseAndOffsetPosition(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">                                        unsigned &BasePos,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">                                        unsigned &BasePos,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">                                        unsigned &OffsetPos) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">                                        unsigned &OffsetPos) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">  /// Target dependent implementation to get the values constituting the address</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">  /// Target dependent implementation to get the values constituting the address</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">  /// MachineInstr that is accessing memory. These values are returned as a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">  /// MachineInstr that is accessing memory. These values are returned as a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">  /// struct ExtAddrMode which contains all relevant information to make up the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">  /// struct ExtAddrMode which contains all relevant information to make up the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">  /// address.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">  /// address.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">  virtual std::optional<ExtAddrMode></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">  virtual std::optional<ExtAddrMode></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">  getAddrModeFromMemoryOp(const MachineInstr &MemI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">  getAddrModeFromMemoryOp(const MachineInstr &MemI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">                          const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">                          const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">  /// Returns true if MI's Def is NullValueReg, and the MI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">  /// Returns true if MI's Def is NullValueReg, and the MI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">  /// does not change the Zero value. i.e. cases such as rax = shr rax, X where</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">  /// does not change the Zero value. i.e. cases such as rax = shr rax, X where</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">  /// NullValueReg = rax. Note that if the NullValueReg is non-zero, this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">  /// NullValueReg = rax. Note that if the NullValueReg is non-zero, this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">  /// function can return true even if becomes zero. Specifically cases such as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">  /// function can return true even if becomes zero. Specifically cases such as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">  /// NullValueReg = shl NullValueReg, 63.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">  /// NullValueReg = shl NullValueReg, 63.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">  virtual bool preservesZeroValueInReg(const MachineInstr *MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">  virtual bool preservesZeroValueInReg(const MachineInstr *MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">                                       const Register NullValueReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">                                       const Register NullValueReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">                                       const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">                                       const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">  /// If the instruction is an increment of a constant value, return the amount.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">  /// If the instruction is an increment of a constant value, return the amount.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">  virtual bool getIncrementValue(const MachineInstr &MI, int &Value) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">  virtual bool getIncrementValue(const MachineInstr &MI, int &Value) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">  /// Returns true if the two given memory operations should be scheduled</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">  /// Returns true if the two given memory operations should be scheduled</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">  /// adjacent. Note that you have to add:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">  /// adjacent. Note that you have to add:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">  ///   DAG->addMutation(createLoadClusterDAGMutation(DAG->TII, DAG->TRI));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">  ///   DAG->addMutation(createLoadClusterDAGMutation(DAG->TII, DAG->TRI));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">  /// or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">  /// or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">  ///   DAG->addMutation(createStoreClusterDAGMutation(DAG->TII, DAG->TRI));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">  ///   DAG->addMutation(createStoreClusterDAGMutation(DAG->TII, DAG->TRI));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">  /// to TargetPassConfig::createMachineScheduler() to have an effect.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">  /// to TargetPassConfig::createMachineScheduler() to have an effect.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">  /// \p BaseOps1 and \p BaseOps2 are memory operands of two memory operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">  /// \p BaseOps1 and \p BaseOps2 are memory operands of two memory operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">  /// \p NumLoads is the number of loads that will be in the cluster if this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">  /// \p NumLoads is the number of loads that will be in the cluster if this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">  /// hook returns true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">  /// hook returns true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">  /// \p NumBytes is the number of bytes that will be loaded from all the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">  /// \p NumBytes is the number of bytes that will be loaded from all the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">  /// clustered loads if this hook returns true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">  /// clustered loads if this hook returns true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">  virtual bool shouldClusterMemOps(ArrayRef<const MachineOperand *> BaseOps1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">  virtual bool shouldClusterMemOps(ArrayRef<const MachineOperand *> BaseOps1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">                                   ArrayRef<const MachineOperand *> BaseOps2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">                                   ArrayRef<const MachineOperand *> BaseOps2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">                                   unsigned NumLoads, unsigned NumBytes) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">                                   unsigned NumLoads, unsigned NumBytes) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">    llvm_unreachable("target did not implement shouldClusterMemOps()");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">    llvm_unreachable("target did not implement shouldClusterMemOps()");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">  /// Reverses the branch condition of the specified condition list,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">  /// Reverses the branch condition of the specified condition list,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">  /// returning false on success and true if it cannot be reversed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">  /// returning false on success and true if it cannot be reversed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">  reverseBranchCondition(SmallVectorImpl<MachineOperand> &Cond) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">  reverseBranchCondition(SmallVectorImpl<MachineOperand> &Cond) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">  /// Insert a noop into the instruction stream at the specified point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">  /// Insert a noop into the instruction stream at the specified point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">  virtual void insertNoop(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">  virtual void insertNoop(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">                          MachineBasicBlock::iterator MI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">                          MachineBasicBlock::iterator MI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">  /// Insert noops into the instruction stream at the specified point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">  /// Insert noops into the instruction stream at the specified point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">  virtual void insertNoops(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">  virtual void insertNoops(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">                           MachineBasicBlock::iterator MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">                           MachineBasicBlock::iterator MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">                           unsigned Quantity) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">                           unsigned Quantity) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">  /// Return the noop instruction to use for a noop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">  /// Return the noop instruction to use for a noop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">  virtual MCInst getNop() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">  virtual MCInst getNop() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">  /// Return true for post-incremented instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">  /// Return true for post-incremented instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">  virtual bool isPostIncrement(const MachineInstr &MI) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">  virtual bool isPostIncrement(const MachineInstr &MI) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">  /// Returns true if the instruction is already predicated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">  /// Returns true if the instruction is already predicated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  virtual bool isPredicated(const MachineInstr &MI) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  virtual bool isPredicated(const MachineInstr &MI) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">  /// Assumes the instruction is already predicated and returns true if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">  /// Assumes the instruction is already predicated and returns true if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">  /// instruction can be predicated again.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">  /// instruction can be predicated again.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">  virtual bool canPredicatePredicatedInstr(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">  virtual bool canPredicatePredicatedInstr(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">    assert(isPredicated(MI) && "Instruction is not predicated");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">    assert(isPredicated(MI) && "Instruction is not predicated");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">  // Returns a MIRPrinter comment for this machine operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">  // Returns a MIRPrinter comment for this machine operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">  virtual std::string</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">  virtual std::string</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">  createMIROperandComment(const MachineInstr &MI, const MachineOperand &Op,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">  createMIROperandComment(const MachineInstr &MI, const MachineOperand &Op,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">                          unsigned OpIdx, const TargetRegisterInfo *TRI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">                          unsigned OpIdx, const TargetRegisterInfo *TRI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">  /// Returns true if the instruction is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">  /// Returns true if the instruction is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">  /// terminator instruction that has not been predicated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">  /// terminator instruction that has not been predicated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">  bool isUnpredicatedTerminator(const MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">  bool isUnpredicatedTerminator(const MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">  /// Returns true if MI is an unconditional tail call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">  /// Returns true if MI is an unconditional tail call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">  virtual bool isUnconditionalTailCall(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">  virtual bool isUnconditionalTailCall(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">  /// Returns true if the tail call can be made conditional on BranchCond.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">  /// Returns true if the tail call can be made conditional on BranchCond.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">  virtual bool canMakeTailCallConditional(SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">  virtual bool canMakeTailCallConditional(SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">                                          const MachineInstr &TailCall) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">                                          const MachineInstr &TailCall) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">  /// Replace the conditional branch in MBB with a conditional tail call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">  /// Replace the conditional branch in MBB with a conditional tail call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">  virtual void replaceBranchWithTailCall(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">  virtual void replaceBranchWithTailCall(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">                                         SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">                                         SmallVectorImpl<MachineOperand> &Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">                                         const MachineInstr &TailCall) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">                                         const MachineInstr &TailCall) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement replaceBranchWithTailCall!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement replaceBranchWithTailCall!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">  /// Convert the instruction into a predicated instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">  /// Convert the instruction into a predicated instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">  /// It returns true if the operation was successful.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">  /// It returns true if the operation was successful.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">  virtual bool PredicateInstruction(MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">  virtual bool PredicateInstruction(MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">                                    ArrayRef<MachineOperand> Pred) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">                                    ArrayRef<MachineOperand> Pred) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">  /// Returns true if the first specified predicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">  /// Returns true if the first specified predicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">  /// subsumes the second, e.g. GE subsumes GT.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">  /// subsumes the second, e.g. GE subsumes GT.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">  virtual bool SubsumesPredicate(ArrayRef<MachineOperand> Pred1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">  virtual bool SubsumesPredicate(ArrayRef<MachineOperand> Pred1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">                                 ArrayRef<MachineOperand> Pred2) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">                                 ArrayRef<MachineOperand> Pred2) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">  /// If the specified instruction defines any predicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">  /// If the specified instruction defines any predicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">  /// or condition code register(s) used for predication, returns true as well</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">  /// or condition code register(s) used for predication, returns true as well</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">  /// as the definition predicate(s) by reference.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">  /// as the definition predicate(s) by reference.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">  /// SkipDead should be set to false at any point that dead</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">  /// SkipDead should be set to false at any point that dead</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">  /// predicate instructions should be considered as being defined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">  /// predicate instructions should be considered as being defined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">  /// A dead predicate instruction is one that is guaranteed to be removed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">  /// A dead predicate instruction is one that is guaranteed to be removed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">  /// after a call to PredicateInstruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">  /// after a call to PredicateInstruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine">  virtual bool ClobbersPredicate(MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine">  virtual bool ClobbersPredicate(MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">                                 std::vector<MachineOperand> &Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">                                 std::vector<MachineOperand> &Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">                                 bool SkipDead) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">                                 bool SkipDead) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">  /// Return true if the specified instruction can be predicated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">  /// Return true if the specified instruction can be predicated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">  /// By default, this returns true for every instruction with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">  /// By default, this returns true for every instruction with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">  /// PredicateOperand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">  /// PredicateOperand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">  virtual bool isPredicable(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">  virtual bool isPredicable(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">    return MI.getDesc().isPredicable();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">    return MI.getDesc().isPredicable();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">  /// Return true if it's safe to move a machine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">  /// Return true if it's safe to move a machine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">  /// instruction that defines the specified register class.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">  /// instruction that defines the specified register class.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">  virtual bool isSafeToMoveRegClassDefs(const TargetRegisterClass *RC) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">  virtual bool isSafeToMoveRegClassDefs(const TargetRegisterClass *RC) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">  /// Test if the given instruction should be considered a scheduling boundary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">  /// Test if the given instruction should be considered a scheduling boundary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">  /// This primarily includes labels and terminators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">  /// This primarily includes labels and terminators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">  virtual bool isSchedulingBoundary(const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">  virtual bool isSchedulingBoundary(const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">                                    const MachineBasicBlock *MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">                                    const MachineBasicBlock *MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">                                    const MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">                                    const MachineFunction &MF) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">  /// Measure the specified inline asm to determine an approximation of its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">  /// Measure the specified inline asm to determine an approximation of its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">  /// length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">  /// length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">  virtual unsigned getInlineAsmLength(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">  virtual unsigned getInlineAsmLength(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">    const char *Str, const MCAsmInfo &MAI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">    const char *Str, const MCAsmInfo &MAI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">    const TargetSubtargetInfo *STI = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">    const TargetSubtargetInfo *STI = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">  /// Allocate and return a hazard recognizer to use for this target when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">  /// Allocate and return a hazard recognizer to use for this target when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">  /// scheduling the machine instructions before register allocation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">  /// scheduling the machine instructions before register allocation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">  virtual ScheduleHazardRecognizer *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">  virtual ScheduleHazardRecognizer *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">  CreateTargetHazardRecognizer(const TargetSubtargetInfo *STI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">  CreateTargetHazardRecognizer(const TargetSubtargetInfo *STI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">                               const ScheduleDAG *DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">                               const ScheduleDAG *DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">  /// Allocate and return a hazard recognizer to use for this target when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">  /// Allocate and return a hazard recognizer to use for this target when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">  /// scheduling the machine instructions before register allocation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">  /// scheduling the machine instructions before register allocation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">  virtual ScheduleHazardRecognizer *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">  virtual ScheduleHazardRecognizer *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">  CreateTargetMIHazardRecognizer(const InstrItineraryData *,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">  CreateTargetMIHazardRecognizer(const InstrItineraryData *,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">                                 const ScheduleDAGMI *DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">                                 const ScheduleDAGMI *DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">  /// Allocate and return a hazard recognizer to use for this target when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">  /// Allocate and return a hazard recognizer to use for this target when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">  /// scheduling the machine instructions after register allocation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">  /// scheduling the machine instructions after register allocation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">  virtual ScheduleHazardRecognizer *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">  virtual ScheduleHazardRecognizer *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">  CreateTargetPostRAHazardRecognizer(const InstrItineraryData *,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">  CreateTargetPostRAHazardRecognizer(const InstrItineraryData *,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">                                     const ScheduleDAG *DAG) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">                                     const ScheduleDAG *DAG) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">  /// Allocate and return a hazard recognizer to use for by non-scheduling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">  /// Allocate and return a hazard recognizer to use for by non-scheduling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">  /// passes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">  /// passes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">  virtual ScheduleHazardRecognizer *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">  virtual ScheduleHazardRecognizer *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">  CreateTargetPostRAHazardRecognizer(const MachineFunction &MF) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">  CreateTargetPostRAHazardRecognizer(const MachineFunction &MF) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">  /// Provide a global flag for disabling the PreRA hazard recognizer that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">  /// Provide a global flag for disabling the PreRA hazard recognizer that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">  /// targets may choose to honor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">  /// targets may choose to honor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">  bool usePreRAHazardRecognizer() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">  bool usePreRAHazardRecognizer() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">  /// For a comparison instruction, return the source registers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">  /// For a comparison instruction, return the source registers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">  /// in SrcReg and SrcReg2 if having two register operands, and the value it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">  /// in SrcReg and SrcReg2 if having two register operands, and the value it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">  /// compares against in CmpValue. Return true if the comparison instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">  /// compares against in CmpValue. Return true if the comparison instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">  /// can be analyzed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">  /// can be analyzed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">  virtual bool analyzeCompare(const MachineInstr &MI, Register &SrcReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">  virtual bool analyzeCompare(const MachineInstr &MI, Register &SrcReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">                              Register &SrcReg2, int64_t &Mask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">                              Register &SrcReg2, int64_t &Mask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">                              int64_t &Value) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">                              int64_t &Value) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">  /// See if the comparison instruction can be converted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">  /// See if the comparison instruction can be converted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">  /// into something more efficient. E.g., on ARM most instructions can set the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">  /// into something more efficient. E.g., on ARM most instructions can set the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">  /// flags register, obviating the need for a separate CMP.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">  /// flags register, obviating the need for a separate CMP.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">  virtual bool optimizeCompareInstr(MachineInstr &CmpInstr, Register SrcReg,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">  virtual bool optimizeCompareInstr(MachineInstr &CmpInstr, Register SrcReg,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">                                    Register SrcReg2, int64_t Mask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">                                    Register SrcReg2, int64_t Mask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">                                    int64_t Value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">                                    int64_t Value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">                                    const MachineRegisterInfo *MRI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">                                    const MachineRegisterInfo *MRI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">  virtual bool optimizeCondBranch(MachineInstr &MI) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">  virtual bool optimizeCondBranch(MachineInstr &MI) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">  /// Try to remove the load by folding it to a register operand at the use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">  /// Try to remove the load by folding it to a register operand at the use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">  /// We fold the load instructions if and only if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">  /// We fold the load instructions if and only if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">  /// def and use are in the same BB. We only look at one load and see</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">  /// def and use are in the same BB. We only look at one load and see</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">  /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">  /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">  /// defined by the load we are trying to fold. DefMI returns the machine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">  /// defined by the load we are trying to fold. DefMI returns the machine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">  /// instruction that defines FoldAsLoadDefReg, and the function returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">  /// instruction that defines FoldAsLoadDefReg, and the function returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">  /// the machine instruction generated due to folding.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">  /// the machine instruction generated due to folding.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">  virtual MachineInstr *optimizeLoadInstr(MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">  virtual MachineInstr *optimizeLoadInstr(MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">                                          const MachineRegisterInfo *MRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">                                          const MachineRegisterInfo *MRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">                                          Register &FoldAsLoadDefReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">                                          Register &FoldAsLoadDefReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">                                          MachineInstr *&DefMI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">                                          MachineInstr *&DefMI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">  /// 'Reg' is known to be defined by a move immediate instruction,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">  /// 'Reg' is known to be defined by a move immediate instruction,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">  /// try to fold the immediate into the use instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">  /// try to fold the immediate into the use instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">  /// If MRI->hasOneNonDBGUse(Reg) is true, and this function returns true,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">  /// If MRI->hasOneNonDBGUse(Reg) is true, and this function returns true,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">  /// then the caller may assume that DefMI has been erased from its parent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">  /// then the caller may assume that DefMI has been erased from its parent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">  /// block. The caller may assume that it will not be erased by this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">  /// block. The caller may assume that it will not be erased by this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">  /// function otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">  /// function otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">  virtual bool FoldImmediate(MachineInstr &UseMI, MachineInstr &DefMI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">  virtual bool FoldImmediate(MachineInstr &UseMI, MachineInstr &DefMI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">                             Register Reg, MachineRegisterInfo *MRI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">                             Register Reg, MachineRegisterInfo *MRI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">  /// Return the number of u-operations the given machine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">  /// Return the number of u-operations the given machine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">  /// instruction will be decoded to on the target cpu. The itinerary's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">  /// instruction will be decoded to on the target cpu. The itinerary's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">  /// IssueWidth is the number of microops that can be dispatched each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">  /// IssueWidth is the number of microops that can be dispatched each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">  /// cycle. An instruction with zero microops takes no dispatch resources.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">  /// cycle. An instruction with zero microops takes no dispatch resources.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">  virtual unsigned getNumMicroOps(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">  virtual unsigned getNumMicroOps(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">                                  const MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">                                  const MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">  /// Return true for pseudo instructions that don't consume any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">  /// Return true for pseudo instructions that don't consume any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">  /// machine resources in their current form. These are common cases that the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">  /// machine resources in their current form. These are common cases that the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">  /// scheduler should consider free, rather than conservatively handling them</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">  /// scheduler should consider free, rather than conservatively handling them</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">  /// as instructions with no itinerary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">  /// as instructions with no itinerary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">  bool isZeroCost(unsigned Opcode) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">  bool isZeroCost(unsigned Opcode) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">    return Opcode <= TargetOpcode::COPY;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">    return Opcode <= TargetOpcode::COPY;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">  virtual int getOperandLatency(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">  virtual int getOperandLatency(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">                                SDNode *DefNode, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">                                SDNode *DefNode, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">                                SDNode *UseNode, unsigned UseIdx) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">                                SDNode *UseNode, unsigned UseIdx) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">  /// Compute and return the use operand latency of a given pair of def and use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">  /// Compute and return the use operand latency of a given pair of def and use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">  /// In most cases, the static scheduling itinerary was enough to determine the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">  /// In most cases, the static scheduling itinerary was enough to determine the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">  /// operand latency. But it may not be possible for instructions with variable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">  /// operand latency. But it may not be possible for instructions with variable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">  /// number of defs / uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">  /// number of defs / uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">  /// This is a raw interface to the itinerary that may be directly overridden</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">  /// This is a raw interface to the itinerary that may be directly overridden</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">  /// by a target. Use computeOperandLatency to get the best estimate of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">  /// by a target. Use computeOperandLatency to get the best estimate of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">  /// latency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">  /// latency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">  virtual int getOperandLatency(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">  virtual int getOperandLatency(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">                                const MachineInstr &DefMI, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">                                const MachineInstr &DefMI, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">                                const MachineInstr &UseMI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">                                const MachineInstr &UseMI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">                                unsigned UseIdx) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">                                unsigned UseIdx) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">  /// Compute the instruction latency of a given instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">  /// Compute the instruction latency of a given instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">  /// If the instruction has higher cost when predicated, it's returned via</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">  /// If the instruction has higher cost when predicated, it's returned via</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">  /// PredCost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">  /// PredCost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">  virtual unsigned getInstrLatency(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">  virtual unsigned getInstrLatency(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">                                   const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">                                   const MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">                                   unsigned *PredCost = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">                                   unsigned *PredCost = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">  virtual unsigned getPredicationCost(const MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">  virtual unsigned getPredicationCost(const MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">  virtual int getInstrLatency(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">  virtual int getInstrLatency(const InstrItineraryData *ItinData,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">                              SDNode *Node) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">                              SDNode *Node) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">  /// Return the default expected latency for a def based on its opcode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">  /// Return the default expected latency for a def based on its opcode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">  unsigned defaultDefLatency(const MCSchedModel &SchedModel,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">  unsigned defaultDefLatency(const MCSchedModel &SchedModel,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">                             const MachineInstr &DefMI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">                             const MachineInstr &DefMI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">  /// Return true if this opcode has high latency to its result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">  /// Return true if this opcode has high latency to its result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">  virtual bool isHighLatencyDef(int opc) const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">  virtual bool isHighLatencyDef(int opc) const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">  /// Compute operand latency between a def of 'Reg'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">  /// Compute operand latency between a def of 'Reg'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">  /// and a use in the current loop. Return true if the target considered</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">  /// and a use in the current loop. Return true if the target considered</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">  /// it 'high'. This is used by optimization passes such as machine LICM to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">  /// it 'high'. This is used by optimization passes such as machine LICM to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">  /// determine whether it makes sense to hoist an instruction out even in a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">  /// determine whether it makes sense to hoist an instruction out even in a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">  /// high register pressure situation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">  /// high register pressure situation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">  virtual bool hasHighOperandLatency(const TargetSchedModel &SchedModel,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">  virtual bool hasHighOperandLatency(const TargetSchedModel &SchedModel,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">                                     const MachineRegisterInfo *MRI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">                                     const MachineRegisterInfo *MRI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">                                     const MachineInstr &DefMI, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">                                     const MachineInstr &DefMI, unsigned DefIdx,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">                                     const MachineInstr &UseMI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">                                     const MachineInstr &UseMI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">                                     unsigned UseIdx) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">                                     unsigned UseIdx) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">  /// Compute operand latency of a def of 'Reg'. Return true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">  /// Compute operand latency of a def of 'Reg'. Return true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">  /// if the target considered it 'low'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">  /// if the target considered it 'low'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">  virtual bool hasLowDefLatency(const TargetSchedModel &SchedModel,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">  virtual bool hasLowDefLatency(const TargetSchedModel &SchedModel,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">                                const MachineInstr &DefMI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">                                const MachineInstr &DefMI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">                                unsigned DefIdx) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">                                unsigned DefIdx) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">  /// Perform target-specific instruction verification.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">  /// Perform target-specific instruction verification.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">  virtual bool verifyInstruction(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">  virtual bool verifyInstruction(const MachineInstr &MI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">                                 StringRef &ErrInfo) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">                                 StringRef &ErrInfo) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">  /// Return the current execution domain and bit mask of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">  /// Return the current execution domain and bit mask of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">  /// possible domains for instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">  /// possible domains for instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">  /// Some micro-architectures have multiple execution domains, and multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">  /// Some micro-architectures have multiple execution domains, and multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">  /// opcodes that perform the same operation in different domains.  For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">  /// opcodes that perform the same operation in different domains.  For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">  /// example, the x86 architecture provides the por, orps, and orpd</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">  /// example, the x86 architecture provides the por, orps, and orpd</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">  /// instructions that all do the same thing.  There is a latency penalty if a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">  /// instructions that all do the same thing.  There is a latency penalty if a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">  /// register is written in one domain and read in another.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">  /// register is written in one domain and read in another.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">  /// This function returns a pair (domain, mask) containing the execution</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">  /// This function returns a pair (domain, mask) containing the execution</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">  /// domain of MI, and a bit mask of possible domains.  The setExecutionDomain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">  /// domain of MI, and a bit mask of possible domains.  The setExecutionDomain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">  /// function can be used to change the opcode to one of the domains in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">  /// function can be used to change the opcode to one of the domains in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">  /// bit mask.  Instructions whose execution domain can't be changed should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">  /// bit mask.  Instructions whose execution domain can't be changed should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">  /// return a 0 mask.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">  /// return a 0 mask.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">  /// The execution domain numbers don't have any special meaning except domain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">  /// The execution domain numbers don't have any special meaning except domain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">  /// 0 is used for instructions that are not associated with any interesting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">  /// 0 is used for instructions that are not associated with any interesting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">  /// execution domain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">  /// execution domain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">  virtual std::pair<uint16_t, uint16_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">  virtual std::pair<uint16_t, uint16_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">  getExecutionDomain(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">  getExecutionDomain(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">    return std::make_pair(0, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">    return std::make_pair(0, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">  /// Change the opcode of MI to execute in Domain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">  /// Change the opcode of MI to execute in Domain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">  /// The bit (1 << Domain) must be set in the mask returned from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">  /// The bit (1 << Domain) must be set in the mask returned from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">  /// getExecutionDomain(MI).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">  /// getExecutionDomain(MI).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">  virtual void setExecutionDomain(MachineInstr &MI, unsigned Domain) const {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">  virtual void setExecutionDomain(MachineInstr &MI, unsigned Domain) const {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">  /// Returns the preferred minimum clearance</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">  /// Returns the preferred minimum clearance</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">  /// before an instruction with an unwanted partial register update.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">  /// before an instruction with an unwanted partial register update.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">  /// Some instructions only write part of a register, and implicitly need to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">  /// Some instructions only write part of a register, and implicitly need to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">  /// read the other parts of the register.  This may cause unwanted stalls</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">  /// read the other parts of the register.  This may cause unwanted stalls</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">  /// preventing otherwise unrelated instructions from executing in parallel in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">  /// preventing otherwise unrelated instructions from executing in parallel in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">  /// an out-of-order CPU.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">  /// an out-of-order CPU.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">  /// For example, the x86 instruction cvtsi2ss writes its result to bits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">  /// For example, the x86 instruction cvtsi2ss writes its result to bits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">  /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">  /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">  /// the instruction needs to wait for the old value of the register to become</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">  /// the instruction needs to wait for the old value of the register to become</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">  /// available:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">  /// available:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">  ///   addps %xmm1, %xmm0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">  ///   addps %xmm1, %xmm0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">  ///   movaps %xmm0, (%rax)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">  ///   movaps %xmm0, (%rax)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">  ///   cvtsi2ss %rbx, %xmm0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">  ///   cvtsi2ss %rbx, %xmm0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">  /// In the code above, the cvtsi2ss instruction needs to wait for the addps</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">  /// In the code above, the cvtsi2ss instruction needs to wait for the addps</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">  /// instruction before it can issue, even though the high bits of %xmm0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">  /// instruction before it can issue, even though the high bits of %xmm0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">  /// probably aren't needed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">  /// probably aren't needed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">  /// This hook returns the preferred clearance before MI, measured in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">  /// This hook returns the preferred clearance before MI, measured in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">  /// instructions.  Other defs of MI's operand OpNum are avoided in the last N</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">  /// instructions.  Other defs of MI's operand OpNum are avoided in the last N</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">  /// instructions before MI.  It should only return a positive value for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">  /// instructions before MI.  It should only return a positive value for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">  /// unwanted dependencies.  If the old bits of the defined register have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">  /// unwanted dependencies.  If the old bits of the defined register have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">  /// useful values, or if MI is determined to otherwise read the dependency,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">  /// useful values, or if MI is determined to otherwise read the dependency,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">  /// the hook should return 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">  /// the hook should return 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">  /// The unwanted dependency may be handled by:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">  /// The unwanted dependency may be handled by:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">  /// 1. Allocating the same register for an MI def and use.  That makes the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">  /// 1. Allocating the same register for an MI def and use.  That makes the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">  ///    unwanted dependency identical to a required dependency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">  ///    unwanted dependency identical to a required dependency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">  /// 2. Allocating a register for the def that has no defs in the previous N</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">  /// 2. Allocating a register for the def that has no defs in the previous N</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">  ///    instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">  ///    instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">  /// 3. Calling breakPartialRegDependency() with the same arguments.  This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">  /// 3. Calling breakPartialRegDependency() with the same arguments.  This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">  ///    allows the target to insert a dependency breaking instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">  ///    allows the target to insert a dependency breaking instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">  virtual unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">  virtual unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">  getPartialRegUpdateClearance(const MachineInstr &MI, unsigned OpNum,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">  getPartialRegUpdateClearance(const MachineInstr &MI, unsigned OpNum,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">                               const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">                               const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">    // The default implementation returns 0 for no partial register dependency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">    // The default implementation returns 0 for no partial register dependency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">  /// Return the minimum clearance before an instruction that reads an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">  /// Return the minimum clearance before an instruction that reads an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">  /// unused register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">  /// unused register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">  /// For example, AVX instructions may copy part of a register operand into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">  /// For example, AVX instructions may copy part of a register operand into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">  /// the unused high bits of the destination register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">  /// the unused high bits of the destination register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">  /// vcvtsi2sdq %rax, undef %xmm0, %xmm14</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">  /// vcvtsi2sdq %rax, undef %xmm0, %xmm14</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">  /// In the code above, vcvtsi2sdq copies %xmm0[127:64] into %xmm14 creating a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">  /// In the code above, vcvtsi2sdq copies %xmm0[127:64] into %xmm14 creating a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">  /// false dependence on any previous write to %xmm0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">  /// false dependence on any previous write to %xmm0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">  /// This hook works similarly to getPartialRegUpdateClearance, except that it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">  /// This hook works similarly to getPartialRegUpdateClearance, except that it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">  /// does not take an operand index. Instead sets \p OpNum to the index of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">  /// does not take an operand index. Instead sets \p OpNum to the index of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">  /// unused register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">  /// unused register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">  virtual unsigned getUndefRegClearance(const MachineInstr &MI, unsigned OpNum,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">  virtual unsigned getUndefRegClearance(const MachineInstr &MI, unsigned OpNum,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">                                        const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">                                        const TargetRegisterInfo *TRI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">    // The default implementation returns 0 for no undef register dependency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">    // The default implementation returns 0 for no undef register dependency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">  /// Insert a dependency-breaking instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">  /// Insert a dependency-breaking instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">  /// before MI to eliminate an unwanted dependency on OpNum.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">  /// before MI to eliminate an unwanted dependency on OpNum.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">  /// If it wasn't possible to avoid a def in the last N instructions before MI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">  /// If it wasn't possible to avoid a def in the last N instructions before MI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">  /// (see getPartialRegUpdateClearance), this hook will be called to break the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">  /// (see getPartialRegUpdateClearance), this hook will be called to break the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">  /// unwanted dependency.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">  /// unwanted dependency.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">  /// On x86, an xorps instruction can be used as a dependency breaker:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">  /// On x86, an xorps instruction can be used as a dependency breaker:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">  ///   addps %xmm1, %xmm0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">  ///   addps %xmm1, %xmm0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">  ///   movaps %xmm0, (%rax)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">  ///   movaps %xmm0, (%rax)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">  ///   xorps %xmm0, %xmm0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">  ///   xorps %xmm0, %xmm0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">  ///   cvtsi2ss %rbx, %xmm0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">  ///   cvtsi2ss %rbx, %xmm0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">  /// An <imp-kill> operand should be added to MI if an instruction was</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">  /// An <imp-kill> operand should be added to MI if an instruction was</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">  /// inserted.  This ties the instructions together in the post-ra scheduler.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">  /// inserted.  This ties the instructions together in the post-ra scheduler.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">  virtual void breakPartialRegDependency(MachineInstr &MI, unsigned OpNum,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">  virtual void breakPartialRegDependency(MachineInstr &MI, unsigned OpNum,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">                                         const TargetRegisterInfo *TRI) const {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">                                         const TargetRegisterInfo *TRI) const {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">  /// Create machine specific model for scheduling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">  /// Create machine specific model for scheduling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">  virtual DFAPacketizer *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">  virtual DFAPacketizer *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">  CreateTargetScheduleState(const TargetSubtargetInfo &) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">  CreateTargetScheduleState(const TargetSubtargetInfo &) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">  /// Sometimes, it is possible for the target</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">  /// Sometimes, it is possible for the target</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">  /// to tell, even without aliasing information, that two MIs access different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">  /// to tell, even without aliasing information, that two MIs access different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">  /// memory addresses. This function returns true if two MIs access different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">  /// memory addresses. This function returns true if two MIs access different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">  /// memory addresses and false otherwise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">  /// memory addresses and false otherwise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">  /// Assumes any physical registers used to compute addresses have the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">  /// Assumes any physical registers used to compute addresses have the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">  /// value for both instructions. (This is the most useful assumption for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">  /// value for both instructions. (This is the most useful assumption for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">  /// post-RA scheduling.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">  /// post-RA scheduling.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">  /// See also MachineInstr::mayAlias, which is implemented on top of this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">  /// See also MachineInstr::mayAlias, which is implemented on top of this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">  /// function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">  /// function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">  virtual bool</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">  areMemAccessesTriviallyDisjoint(const MachineInstr &MIa,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">  areMemAccessesTriviallyDisjoint(const MachineInstr &MIa,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">                                  const MachineInstr &MIb) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">                                  const MachineInstr &MIb) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">    assert(MIa.mayLoadOrStore() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">    assert(MIa.mayLoadOrStore() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">           "MIa must load from or modify a memory location");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">           "MIa must load from or modify a memory location");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">    assert(MIb.mayLoadOrStore() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">    assert(MIb.mayLoadOrStore() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">           "MIb must load from or modify a memory location");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">           "MIb must load from or modify a memory location");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">  /// Return the value to use for the MachineCSE's LookAheadLimit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">  /// Return the value to use for the MachineCSE's LookAheadLimit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">  /// which is a heuristic used for CSE'ing phys reg defs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">  /// which is a heuristic used for CSE'ing phys reg defs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">  virtual unsigned getMachineCSELookAheadLimit() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">  virtual unsigned getMachineCSELookAheadLimit() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">    // The default lookahead is small to prevent unprofitable quadratic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">    // The default lookahead is small to prevent unprofitable quadratic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">    // behavior.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">    // behavior.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">    return 5;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">    return 5;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">  /// Return the maximal number of alias checks on memory operands. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">  /// Return the maximal number of alias checks on memory operands. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">  /// instructions with more than one memory operands, the alias check on a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">  /// instructions with more than one memory operands, the alias check on a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">  /// single MachineInstr pair has quadratic overhead and results in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">  /// single MachineInstr pair has quadratic overhead and results in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">  /// unacceptable performance in the worst case. The limit here is to clamp</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">  /// unacceptable performance in the worst case. The limit here is to clamp</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">  /// that maximal checks performed. Usually, that's the product of memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">  /// that maximal checks performed. Usually, that's the product of memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">  /// operand numbers from that pair of MachineInstr to be checked. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">  /// operand numbers from that pair of MachineInstr to be checked. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">  /// instance, with two MachineInstrs with 4 and 5 memory operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">  /// instance, with two MachineInstrs with 4 and 5 memory operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">  /// correspondingly, a total of 20 checks are required. With this limit set to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">  /// correspondingly, a total of 20 checks are required. With this limit set to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">  /// 16, their alias check is skipped. We choose to limit the product instead</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">  /// 16, their alias check is skipped. We choose to limit the product instead</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">  /// of the individual instruction as targets may have special MachineInstrs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">  /// of the individual instruction as targets may have special MachineInstrs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">  /// with a considerably high number of memory operands, such as `ldm` in ARM.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">  /// with a considerably high number of memory operands, such as `ldm` in ARM.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">  /// Setting this limit per MachineInstr would result in either too high</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">  /// Setting this limit per MachineInstr would result in either too high</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">  /// overhead or too rigid restriction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">  /// overhead or too rigid restriction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">  virtual unsigned getMemOperandAACheckLimit() const { return 16; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">  virtual unsigned getMemOperandAACheckLimit() const { return 16; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">  /// Return an array that contains the ids of the target indices (used for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">  /// Return an array that contains the ids of the target indices (used for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">  /// TargetIndex machine operand) and their names.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">  /// TargetIndex machine operand) and their names.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">  /// MIR Serialization is able to serialize only the target indices that are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">  /// MIR Serialization is able to serialize only the target indices that are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">  /// defined by this method.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">  /// defined by this method.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">  virtual ArrayRef<std::pair<int, const char *>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">  virtual ArrayRef<std::pair<int, const char *>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">  getSerializableTargetIndices() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">  getSerializableTargetIndices() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">  /// Decompose the machine operand's target flags into two values - the direct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">  /// Decompose the machine operand's target flags into two values - the direct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">  /// target flag value and any of bit flags that are applied.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">  /// target flag value and any of bit flags that are applied.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">  virtual std::pair<unsigned, unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">  virtual std::pair<unsigned, unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">  decomposeMachineOperandsTargetFlags(unsigned /*TF*/) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">  decomposeMachineOperandsTargetFlags(unsigned /*TF*/) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">    return std::make_pair(0u, 0u);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">    return std::make_pair(0u, 0u);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">  /// Return an array that contains the direct target flag values and their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">  /// Return an array that contains the direct target flag values and their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">  /// names.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">  /// names.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">  /// MIR Serialization is able to serialize only the target flags that are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">  /// MIR Serialization is able to serialize only the target flags that are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">  /// defined by this method.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">  /// defined by this method.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">  virtual ArrayRef<std::pair<unsigned, const char *>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">  virtual ArrayRef<std::pair<unsigned, const char *>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">  getSerializableDirectMachineOperandTargetFlags() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">  getSerializableDirectMachineOperandTargetFlags() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">  /// Return an array that contains the bitmask target flag values and their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">  /// Return an array that contains the bitmask target flag values and their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">  /// names.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">  /// names.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">  /// MIR Serialization is able to serialize only the target flags that are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">  /// MIR Serialization is able to serialize only the target flags that are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">  /// defined by this method.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">  /// defined by this method.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine">  virtual ArrayRef<std::pair<unsigned, const char *>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine">  virtual ArrayRef<std::pair<unsigned, const char *>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">  getSerializableBitmaskMachineOperandTargetFlags() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">  getSerializableBitmaskMachineOperandTargetFlags() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">  /// Return an array that contains the MMO target flag values and their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">  /// Return an array that contains the MMO target flag values and their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">  /// names.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">  /// names.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">  /// MIR Serialization is able to serialize only the MMO target flags that are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">  /// MIR Serialization is able to serialize only the MMO target flags that are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">  /// defined by this method.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">  /// defined by this method.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">  virtual ArrayRef<std::pair<MachineMemOperand::Flags, const char *>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">  virtual ArrayRef<std::pair<MachineMemOperand::Flags, const char *>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">  getSerializableMachineMemOperandTargetFlags() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">  getSerializableMachineMemOperandTargetFlags() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">    return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">  /// Determines whether \p Inst is a tail call instruction. Override this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">  /// Determines whether \p Inst is a tail call instruction. Override this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">  /// method on targets that do not properly set MCID::Return and MCID::Call on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">  /// method on targets that do not properly set MCID::Return and MCID::Call on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">  /// tail call instructions."</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">  /// tail call instructions."</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">  virtual bool isTailCall(const MachineInstr &Inst) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">  virtual bool isTailCall(const MachineInstr &Inst) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">    return Inst.isReturn() && Inst.isCall();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">    return Inst.isReturn() && Inst.isCall();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">  /// True if the instruction is bound to the top of its basic block and no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">  /// True if the instruction is bound to the top of its basic block and no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">  /// other instructions shall be inserted before it. This can be implemented</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">  /// other instructions shall be inserted before it. This can be implemented</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">  /// to prevent register allocator to insert spills before such instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">  /// to prevent register allocator to insert spills before such instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">  virtual bool isBasicBlockPrologue(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">  virtual bool isBasicBlockPrologue(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">  /// During PHI eleimination lets target to make necessary checks and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">  /// During PHI eleimination lets target to make necessary checks and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">  /// insert the copy to the PHI destination register in a target specific</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">  /// insert the copy to the PHI destination register in a target specific</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">  /// manner.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">  /// manner.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">  virtual MachineInstr *createPHIDestinationCopy(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">  virtual MachineInstr *createPHIDestinationCopy(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">      MachineBasicBlock &MBB, MachineBasicBlock::iterator InsPt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">      MachineBasicBlock &MBB, MachineBasicBlock::iterator InsPt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">      const DebugLoc &DL, Register Src, Register Dst) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">      const DebugLoc &DL, Register Src, Register Dst) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">    return BuildMI(MBB, InsPt, DL, get(TargetOpcode::COPY), Dst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">    return BuildMI(MBB, InsPt, DL, get(TargetOpcode::COPY), Dst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">        .addReg(Src);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">        .addReg(Src);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">  /// During PHI eleimination lets target to make necessary checks and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">  /// During PHI eleimination lets target to make necessary checks and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">  /// insert the copy to the PHI destination register in a target specific</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">  /// insert the copy to the PHI destination register in a target specific</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">  /// manner.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">  /// manner.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">  virtual MachineInstr *createPHISourceCopy(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">  virtual MachineInstr *createPHISourceCopy(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">                                            MachineBasicBlock::iterator InsPt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">                                            MachineBasicBlock::iterator InsPt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">                                            const DebugLoc &DL, Register Src,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">                                            const DebugLoc &DL, Register Src,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">                                            unsigned SrcSubReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">                                            unsigned SrcSubReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">                                            Register Dst) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">                                            Register Dst) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">    return BuildMI(MBB, InsPt, DL, get(TargetOpcode::COPY), Dst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">    return BuildMI(MBB, InsPt, DL, get(TargetOpcode::COPY), Dst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">        .addReg(Src, 0, SrcSubReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">        .addReg(Src, 0, SrcSubReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">  /// Returns a \p outliner::OutlinedFunction struct containing target-specific</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">  /// Returns a \p outliner::OutlinedFunction struct containing target-specific</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">  /// information for a set of outlining candidates. Returns std::nullopt if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">  /// information for a set of outlining candidates. Returns std::nullopt if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">  /// candidates are not suitable for outlining.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">  /// candidates are not suitable for outlining.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">  virtual std::optional<outliner::OutlinedFunction> getOutliningCandidateInfo(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">  virtual std::optional<outliner::OutlinedFunction> getOutliningCandidateInfo(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">      std::vector<outliner::Candidate> &RepeatedSequenceLocs) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">      std::vector<outliner::Candidate> &RepeatedSequenceLocs) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">        "Target didn't implement TargetInstrInfo::getOutliningCandidateInfo!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">        "Target didn't implement TargetInstrInfo::getOutliningCandidateInfo!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">  /// Optional target hook to create the LLVM IR attributes for the outlined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">  /// Optional target hook to create the LLVM IR attributes for the outlined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">  /// function. If overridden, the overriding function must call the default</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">  /// function. If overridden, the overriding function must call the default</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">  /// implementation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">  /// implementation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">  virtual void mergeOutliningCandidateAttributes(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">  virtual void mergeOutliningCandidateAttributes(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">      Function &F, std::vector<outliner::Candidate> &Candidates) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">      Function &F, std::vector<outliner::Candidate> &Candidates) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">  /// Target-dependent implementation for getOutliningTypeImpl.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">  /// Target-dependent implementation for getOutliningTypeImpl.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">  virtual outliner::InstrType</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">  virtual outliner::InstrType</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">  getOutliningTypeImpl(MachineBasicBlock::iterator &MIT, unsigned Flags) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">  getOutliningTypeImpl(MachineBasicBlock::iterator &MIT, unsigned Flags) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">        "Target didn't implement TargetInstrInfo::getOutliningTypeImpl!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">        "Target didn't implement TargetInstrInfo::getOutliningTypeImpl!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">  /// Returns how or if \p MIT should be outlined. \p Flags is the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">  /// Returns how or if \p MIT should be outlined. \p Flags is the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">  /// target-specific information returned by isMBBSafeToOutlineFrom.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">  /// target-specific information returned by isMBBSafeToOutlineFrom.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">  outliner::InstrType</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">  outliner::InstrType</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">  getOutliningType(MachineBasicBlock::iterator &MIT, unsigned Flags) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">  getOutliningType(MachineBasicBlock::iterator &MIT, unsigned Flags) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">  /// Optional target hook that returns true if \p MBB is safe to outline from,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">  /// Optional target hook that returns true if \p MBB is safe to outline from,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">  /// and returns any target-specific information in \p Flags.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">  /// and returns any target-specific information in \p Flags.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">  virtual bool isMBBSafeToOutlineFrom(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">  virtual bool isMBBSafeToOutlineFrom(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">                                      unsigned &Flags) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">                                      unsigned &Flags) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">  /// Optional target hook which partitions \p MBB into outlinable ranges for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">  /// Optional target hook which partitions \p MBB into outlinable ranges for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">  /// instruction mapping purposes. Each range is defined by two iterators:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">  /// instruction mapping purposes. Each range is defined by two iterators:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">  /// [start, end).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">  /// [start, end).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">  /// Ranges are expected to be ordered top-down. That is, ranges closer to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">  /// Ranges are expected to be ordered top-down. That is, ranges closer to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">  /// top of the block should come before ranges closer to the end of the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">  /// top of the block should come before ranges closer to the end of the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">  /// Ranges cannot overlap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">  /// Ranges cannot overlap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">  /// If an entire block is mappable, then its range is [MBB.begin(), MBB.end())</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">  /// If an entire block is mappable, then its range is [MBB.begin(), MBB.end())</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">  /// All instructions not present in an outlinable range are considered</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">  /// All instructions not present in an outlinable range are considered</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">  /// illegal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">  /// illegal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">  virtual SmallVector<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">  virtual SmallVector<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">      std::pair<MachineBasicBlock::iterator, MachineBasicBlock::iterator>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">      std::pair<MachineBasicBlock::iterator, MachineBasicBlock::iterator>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">  getOutlinableRanges(MachineBasicBlock &MBB, unsigned &Flags) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">  getOutlinableRanges(MachineBasicBlock &MBB, unsigned &Flags) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">    return {std::make_pair(MBB.begin(), MBB.end())};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">    return {std::make_pair(MBB.begin(), MBB.end())};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">  /// Insert a custom frame for outlined functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">  /// Insert a custom frame for outlined functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">  virtual void buildOutlinedFrame(MachineBasicBlock &MBB, MachineFunction &MF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">  virtual void buildOutlinedFrame(MachineBasicBlock &MBB, MachineFunction &MF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">                                  const outliner::OutlinedFunction &OF) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">                                  const outliner::OutlinedFunction &OF) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">        "Target didn't implement TargetInstrInfo::buildOutlinedFrame!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">        "Target didn't implement TargetInstrInfo::buildOutlinedFrame!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">  /// Insert a call to an outlined function into the program.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">  /// Insert a call to an outlined function into the program.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">  /// Returns an iterator to the spot where we inserted the call. This must be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">  /// Returns an iterator to the spot where we inserted the call. This must be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">  /// implemented by the target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">  /// implemented by the target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">  virtual MachineBasicBlock::iterator</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">  virtual MachineBasicBlock::iterator</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">  insertOutlinedCall(Module &M, MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">  insertOutlinedCall(Module &M, MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">                     MachineBasicBlock::iterator &It, MachineFunction &MF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">                     MachineBasicBlock::iterator &It, MachineFunction &MF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">                     outliner::Candidate &C) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">                     outliner::Candidate &C) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">    llvm_unreachable(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">        "Target didn't implement TargetInstrInfo::insertOutlinedCall!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">        "Target didn't implement TargetInstrInfo::insertOutlinedCall!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">  /// Return true if the function can safely be outlined from.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">  /// Return true if the function can safely be outlined from.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">  /// A function \p MF is considered safe for outlining if an outlined function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">  /// A function \p MF is considered safe for outlining if an outlined function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">  /// produced from instructions in F will produce a program which produces the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">  /// produced from instructions in F will produce a program which produces the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">  /// same output for any set of given inputs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">  /// same output for any set of given inputs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">  virtual bool isFunctionSafeToOutlineFrom(MachineFunction &MF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">  virtual bool isFunctionSafeToOutlineFrom(MachineFunction &MF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine">                                           bool OutlineFromLinkOnceODRs) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine">                                           bool OutlineFromLinkOnceODRs) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">    llvm_unreachable("Target didn't implement "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">                     "TargetInstrInfo::isFunctionSafeToOutlineFrom!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">                     "TargetInstrInfo::isFunctionSafeToOutlineFrom!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">  /// Return true if the function should be outlined from by default.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">  /// Return true if the function should be outlined from by default.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">  virtual bool shouldOutlineFromFunctionByDefault(MachineFunction &MF) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">  virtual bool shouldOutlineFromFunctionByDefault(MachineFunction &MF) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">  /// Produce the expression describing the \p MI loading a value into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">  /// Produce the expression describing the \p MI loading a value into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">  /// the physical register \p Reg. This hook should only be used with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">  /// the physical register \p Reg. This hook should only be used with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">  /// \p MIs belonging to VReg-less functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">  /// \p MIs belonging to VReg-less functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">  virtual std::optional<ParamLoadedValue></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">  virtual std::optional<ParamLoadedValue></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">  describeLoadedValue(const MachineInstr &MI, Register Reg) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">  describeLoadedValue(const MachineInstr &MI, Register Reg) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">  /// Given the generic extension instruction \p ExtMI, returns true if this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">  /// Given the generic extension instruction \p ExtMI, returns true if this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">  /// extension is a likely candidate for being folded into an another</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">  /// extension is a likely candidate for being folded into an another</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">  /// instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">  /// instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">  virtual bool isExtendLikelyToBeFolded(MachineInstr &ExtMI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">  virtual bool isExtendLikelyToBeFolded(MachineInstr &ExtMI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">                                        MachineRegisterInfo &MRI) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">                                        MachineRegisterInfo &MRI) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">  /// Return MIR formatter to format/parse MIR operands.  Target can override</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">  /// Return MIR formatter to format/parse MIR operands.  Target can override</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">  /// this virtual function and return target specific MIR formatter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">  /// this virtual function and return target specific MIR formatter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">  virtual const MIRFormatter *getMIRFormatter() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">  virtual const MIRFormatter *getMIRFormatter() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">    if (!Formatter.get())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">    if (!Formatter.get())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">      Formatter = std::make_unique<MIRFormatter>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">      Formatter = std::make_unique<MIRFormatter>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">    return Formatter.get();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">    return Formatter.get();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">  /// Returns the target-specific default value for tail duplication.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">  /// Returns the target-specific default value for tail duplication.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">  /// This value will be used if the tail-dup-placement-threshold argument is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">  /// This value will be used if the tail-dup-placement-threshold argument is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">  /// not provided.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">  /// not provided.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">  virtual unsigned getTailDuplicateSize(CodeGenOpt::Level OptLevel) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">  virtual unsigned getTailDuplicateSize(CodeGenOpt::Level OptLevel) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">    return OptLevel >= CodeGenOpt::Aggressive ? 4 : 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">    return OptLevel >= CodeGenOpt::Aggressive ? 4 : 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">  /// Returns the callee operand from the given \p MI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">  /// Returns the callee operand from the given \p MI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">  virtual const MachineOperand &getCalleeOperand(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">  virtual const MachineOperand &getCalleeOperand(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">    return MI.getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">    return MI.getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">  /// Return the uniformity behavior of the given instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">  /// Return the uniformity behavior of the given instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">  virtual InstructionUniformity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">  virtual InstructionUniformity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">  getInstructionUniformity(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">  getInstructionUniformity(const MachineInstr &MI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">    return InstructionUniformity::Default;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">    return InstructionUniformity::Default;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">  /// Returns true if the given \p MI defines a TargetIndex operand that can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">  /// Returns true if the given \p MI defines a TargetIndex operand that can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">  /// tracked by their offset, can have values, and can have debug info</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">  /// tracked by their offset, can have values, and can have debug info</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">  /// associated with it. If so, sets \p Index and \p Offset of the target index</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">  /// associated with it. If so, sets \p Index and \p Offset of the target index</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">  /// operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">  /// operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine coveredLine">  virtual bool isExplicitTargetIndexDef(const MachineInstr &MI, int &Index,</td>
    <td class="lineNumber">23</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">  virtual bool isExplicitTargetIndexDef(const MachineInstr &MI, int &Index,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">                                        int64_t &Offset) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">                                        int64_t &Offset) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine coveredLine">    return false;</td>
    <td class="lineNumber">23</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">  // Get the call frame size just before MI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">  // Get the call frame size just before MI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">  unsigned getCallFrameSizeAt(MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">  unsigned getCallFrameSizeAt(MachineInstr &MI) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">  mutable std::unique_ptr<MIRFormatter> Formatter;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">  mutable std::unique_ptr<MIRFormatter> Formatter;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">  unsigned CallFrameSetupOpcode, CallFrameDestroyOpcode;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">  unsigned CallFrameSetupOpcode, CallFrameDestroyOpcode;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">  unsigned CatchRetOpcode;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">  unsigned CatchRetOpcode;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">  unsigned ReturnOpcode;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">  unsigned ReturnOpcode;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">/// Provide DenseMapInfo for TargetInstrInfo::RegSubRegPair.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">/// Provide DenseMapInfo for TargetInstrInfo::RegSubRegPair.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">template <> struct DenseMapInfo<TargetInstrInfo::RegSubRegPair> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">template <> struct DenseMapInfo<TargetInstrInfo::RegSubRegPair> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">  using RegInfo = DenseMapInfo<unsigned>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">  using RegInfo = DenseMapInfo<unsigned>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">  static inline TargetInstrInfo::RegSubRegPair getEmptyKey() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">  static inline TargetInstrInfo::RegSubRegPair getEmptyKey() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">    return TargetInstrInfo::RegSubRegPair(RegInfo::getEmptyKey(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">    return TargetInstrInfo::RegSubRegPair(RegInfo::getEmptyKey(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">                                          RegInfo::getEmptyKey());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">                                          RegInfo::getEmptyKey());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">  static inline TargetInstrInfo::RegSubRegPair getTombstoneKey() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">  static inline TargetInstrInfo::RegSubRegPair getTombstoneKey() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">    return TargetInstrInfo::RegSubRegPair(RegInfo::getTombstoneKey(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">    return TargetInstrInfo::RegSubRegPair(RegInfo::getTombstoneKey(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">                                          RegInfo::getTombstoneKey());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">                                          RegInfo::getTombstoneKey());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">  /// Reuse getHashValue implementation from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">  /// Reuse getHashValue implementation from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">  /// std::pair<unsigned, unsigned>.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">  /// std::pair<unsigned, unsigned>.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">  static unsigned getHashValue(const TargetInstrInfo::RegSubRegPair &Val) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">  static unsigned getHashValue(const TargetInstrInfo::RegSubRegPair &Val) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">    std::pair<unsigned, unsigned> PairVal = std::make_pair(Val.Reg, Val.SubReg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">    std::pair<unsigned, unsigned> PairVal = std::make_pair(Val.Reg, Val.SubReg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">    return DenseMapInfo<std::pair<unsigned, unsigned>>::getHashValue(PairVal);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">    return DenseMapInfo<std::pair<unsigned, unsigned>>::getHashValue(PairVal);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">  static bool isEqual(const TargetInstrInfo::RegSubRegPair &LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">  static bool isEqual(const TargetInstrInfo::RegSubRegPair &LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">                      const TargetInstrInfo::RegSubRegPair &RHS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">                      const TargetInstrInfo::RegSubRegPair &RHS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">    return RegInfo::isEqual(LHS.Reg, RHS.Reg) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">    return RegInfo::isEqual(LHS.Reg, RHS.Reg) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">           RegInfo::isEqual(LHS.SubReg, RHS.SubReg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">           RegInfo::isEqual(LHS.SubReg, RHS.SubReg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">#endif // LLVM_CODEGEN_TARGETINSTRINFO_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">#endif // LLVM_CODEGEN_TARGETINSTRINFO_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>