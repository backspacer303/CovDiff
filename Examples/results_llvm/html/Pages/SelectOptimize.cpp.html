<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>SelectOptimize.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===--- SelectOptimize.cpp - Convert select to branches if profitable ---===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This pass converts selects to conditional jumps when profitable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">#include "llvm/ADT/Statistic.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#include "llvm/Analysis/BlockFrequencyInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "llvm/Analysis/BranchProbabilityInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "llvm/Analysis/LoopInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/Analysis/ProfileSummaryInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/CodeGen/Passes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/CodeGen/TargetSchedule.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/IR/BasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/IR/Dominators.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/IR/IRBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/IR/Instruction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/IR/PatternMatch.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/IR/ProfDataUtils.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/Support/ScaledNumber.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/Target/TargetMachine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/Transforms/Utils/SizeOpts.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include <memory></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include <queue></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include <stack></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include <string></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#define DEBUG_TYPE "select-optimize"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">STATISTIC(NumSelectOptAnalyzed,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">          "Number of select groups considered for conversion to branch");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">STATISTIC(NumSelectConvertedExpColdOperand,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">          "Number of select groups converted due to expensive cold operand");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">STATISTIC(NumSelectConvertedHighPred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">          "Number of select groups converted due to high-predictability");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">STATISTIC(NumSelectUnPred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">          "Number of select groups not converted due to unpredictability");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">STATISTIC(NumSelectColdBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">          "Number of select groups not converted due to cold basic block");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">STATISTIC(NumSelectConvertedLoop,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">          "Number of select groups converted due to loop-level analysis");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">STATISTIC(NumSelectsConverted, "Number of selects converted");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">static cl::opt<unsigned> ColdOperandThreshold(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">    "cold-operand-threshold",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">    cl::desc("Maximum frequency of path for an operand to be considered cold."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">    cl::init(20), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">static cl::opt<unsigned> ColdOperandMaxCostMultiplier(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">    "cold-operand-max-cost-multiplier",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">    cl::desc("Maximum cost multiplier of TCC_expensive for the dependence "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">             "slice of a cold operand to be considered inexpensive."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">    cl::init(1), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">static cl::opt<unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">    GainGradientThreshold("select-opti-loop-gradient-gain-threshold",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">                          cl::desc("Gradient gain threshold (%)."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">                          cl::init(25), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">static cl::opt<unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">    GainCycleThreshold("select-opti-loop-cycle-gain-threshold",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">                       cl::desc("Minimum gain per loop (in cycles) threshold."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">                       cl::init(4), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">static cl::opt<unsigned> GainRelativeThreshold(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">    "select-opti-loop-relative-gain-threshold",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">    cl::desc(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">        "Minimum relative gain per loop threshold (1/X). Defaults to 12.5%"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">    cl::init(8), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">static cl::opt<unsigned> MispredictDefaultRate(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">    "mispredict-default-rate", cl::Hidden, cl::init(25),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">    cl::desc("Default mispredict rate (initialized to 25%)."));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">static cl::opt<bool></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">    DisableLoopLevelHeuristics("disable-loop-level-heuristics", cl::Hidden,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">                               cl::init(false),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">                               cl::desc("Disable loop-level heuristics."));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">class SelectOptimize : public FunctionPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">  const TargetMachine *TM = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  const TargetSubtargetInfo *TSI = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">  const TargetLowering *TLI = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">  const TargetTransformInfo *TTI = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">  const LoopInfo *LI = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">  DominatorTree *DT = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">  std::unique_ptr<BlockFrequencyInfo> BFI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">  std::unique_ptr<BranchProbabilityInfo> BPI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">  ProfileSummaryInfo *PSI = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">  OptimizationRemarkEmitter *ORE = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">  TargetSchedModel TSchedModel;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">  static char ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="uncoveredLine">  SelectOptimize() : FunctionPass(ID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="uncoveredLine">    initializeSelectOptimizePass(*PassRegistry::getPassRegistry());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">  bool runOnFunction(Function &F) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="uncoveredLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="uncoveredLine">    AU.addRequired<ProfileSummaryInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="uncoveredLine">    AU.addRequired<TargetPassConfig>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="uncoveredLine">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="uncoveredLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="uncoveredLine">    AU.addRequired<LoopInfoWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="uncoveredLine">    AU.addRequired<OptimizationRemarkEmitterWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">  // Select groups consist of consecutive select instructions with the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">  // condition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">  using SelectGroup = SmallVector<SelectInst *, 2>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">  using SelectGroups = SmallVector<SelectGroup, 2>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">  using Scaled64 = ScaledNumber<uint64_t>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">  struct CostInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">    /// Predicated cost (with selects as conditional moves).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">    Scaled64 PredCost;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">    /// Non-predicated cost (with selects converted to branches).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">    Scaled64 NonPredCost;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">  // Converts select instructions of a function to conditional jumps when deemed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">  // profitable. Returns true if at least one select was converted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">  bool optimizeSelects(Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">  // Heuristics for determining which select instructions can be profitably</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">  // conveted to branches. Separate heuristics for selects in inner-most loops</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">  // and the rest of code regions (base heuristics for non-inner-most loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">  // regions).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">  void optimizeSelectsBase(Function &F, SelectGroups &ProfSIGroups);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">  void optimizeSelectsInnerLoops(Function &F, SelectGroups &ProfSIGroups);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">  // Converts to branches the select groups that were deemed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">  // profitable-to-convert.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">  void convertProfitableSIGroups(SelectGroups &ProfSIGroups);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">  // Splits selects of a given basic block into select groups.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">  void collectSelectGroups(BasicBlock &BB, SelectGroups &SIGroups);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">  // Determines for which select groups it is profitable converting to branches</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">  // (base and inner-most-loop heuristics).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">  void findProfitableSIGroupsBase(SelectGroups &SIGroups,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">                                  SelectGroups &ProfSIGroups);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">  void findProfitableSIGroupsInnerLoops(const Loop *L, SelectGroups &SIGroups,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">                                        SelectGroups &ProfSIGroups);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">  // Determines if a select group should be converted to a branch (base</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">  // heuristics).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">  bool isConvertToBranchProfitableBase(const SmallVector<SelectInst *, 2> &ASI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">  // Returns true if there are expensive instructions in the cold value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">  // operand's (if any) dependence slice of any of the selects of the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">  // group.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">  bool hasExpensiveColdOperand(const SmallVector<SelectInst *, 2> &ASI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">  // For a given source instruction, collect its backwards dependence slice</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">  // consisting of instructions exclusively computed for producing the operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">  // of the source instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">  void getExclBackwardsSlice(Instruction *I, std::stack<Instruction *> &Slice,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">                             Instruction *SI, bool ForSinking = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">  // Returns true if the condition of the select is highly predictable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">  bool isSelectHighlyPredictable(const SelectInst *SI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">  // Loop-level checks to determine if a non-predicated version (with branches)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">  // of the given loop is more profitable than its predicated version.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">  bool checkLoopHeuristics(const Loop *L, const CostInfo LoopDepth[2]);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">  // Computes instruction and loop-critical-path costs for both the predicated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">  // and non-predicated version of the given loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">  bool computeLoopCosts(const Loop *L, const SelectGroups &SIGroups,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">                        DenseMap<const Instruction *, CostInfo> &InstCostMap,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">                        CostInfo *LoopCost);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">  // Returns a set of all the select instructions in the given select groups.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">  SmallPtrSet<const Instruction *, 2> getSIset(const SelectGroups &SIGroups);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">  // Returns the latency cost of a given instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">  std::optional<uint64_t> computeInstCost(const Instruction *I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  // Returns the misprediction cost of a given select when converted to branch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">  Scaled64 getMispredictionCost(const SelectInst *SI, const Scaled64 CondCost);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">  // Returns the cost of a branch when the prediction is correct.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">  Scaled64 getPredictedPathCost(Scaled64 TrueCost, Scaled64 FalseCost,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">                                const SelectInst *SI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">  // Returns true if the target architecture supports lowering a given select.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">  bool isSelectKindSupported(SelectInst *SI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">} // namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">char SelectOptimize::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(SelectOptimize, DEBUG_TYPE, "Optimize selects", false,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">                      false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(ProfileSummaryInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(OptimizationRemarkEmitterWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="coveredLine">INITIALIZE_PASS_END(SelectOptimize, DEBUG_TYPE, "Optimize selects", false,</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">                    false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="uncoveredLine">FunctionPass *llvm::createSelectOptimizePass() { return new SelectOptimize(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="uncoveredLine">bool SelectOptimize::runOnFunction(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">  TM = &getAnalysis<TargetPassConfig>().getTM<TargetMachine>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="uncoveredLine">  TSI = TM->getSubtargetImpl(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">  TLI = TSI->getTargetLowering();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">  // If none of the select types is supported then skip this pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">  // This is an optimization pass. Legality issues will be handled by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">  // instruction selection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="uncoveredLine">  if (!TLI->isSelectSupported(TargetLowering::ScalarValSelect) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">      !TLI->isSelectSupported(TargetLowering::ScalarCondVectorVal) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="uncoveredLine">      !TLI->isSelectSupported(TargetLowering::VectorMaskSelect))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="uncoveredLine">  TTI = &getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">  if (!TTI->enableSelectOptimize())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="uncoveredLine">  DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="uncoveredLine">  LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="uncoveredLine">  BPI.reset(new BranchProbabilityInfo(F, *LI));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="uncoveredLine">  BFI.reset(new BlockFrequencyInfo(F, *BPI, *LI));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="uncoveredLine">  PSI = &getAnalysis<ProfileSummaryInfoWrapperPass>().getPSI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">  ORE = &getAnalysis<OptimizationRemarkEmitterWrapperPass>().getORE();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">  TSchedModel.init(TSI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">  // When optimizing for size, selects are preferable over branches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="uncoveredLine">  if (F.hasOptSize() || llvm::shouldOptimizeForSize(&F, PSI, BFI.get()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="uncoveredLine">  return optimizeSelects(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="uncoveredLine">bool SelectOptimize::optimizeSelects(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">  // Determine for which select groups it is profitable converting to branches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="uncoveredLine">  SelectGroups ProfSIGroups;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">  // Base heuristics apply only to non-loops and outer loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="uncoveredLine">  optimizeSelectsBase(F, ProfSIGroups);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">  // Separate heuristics for inner-most loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="uncoveredLine">  optimizeSelectsInnerLoops(F, ProfSIGroups);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">  // Convert to branches the select groups that were deemed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">  // profitable-to-convert.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="uncoveredLine">  convertProfitableSIGroups(ProfSIGroups);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">  // Code modified if at least one select group was converted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="uncoveredLine">  return !ProfSIGroups.empty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="uncoveredLine">void SelectOptimize::optimizeSelectsBase(Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">                                         SelectGroups &ProfSIGroups) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">  // Collect all the select groups.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="uncoveredLine">  SelectGroups SIGroups;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="uncoveredLine">  for (BasicBlock &BB : F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">    // Base heuristics apply only to non-loops and outer loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="uncoveredLine">    Loop *L = LI->getLoopFor(&BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="uncoveredLine">    if (L && L->isInnermost())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="uncoveredLine">    collectSelectGroups(BB, SIGroups);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">  // Determine for which select groups it is profitable converting to branches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">  findProfitableSIGroupsBase(SIGroups, ProfSIGroups);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">void SelectOptimize::optimizeSelectsInnerLoops(Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">                                               SelectGroups &ProfSIGroups) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="uncoveredLine">  SmallVector<Loop *, 4> Loops(LI->begin(), LI->end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">  // Need to check size on each iteration as we accumulate child loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="uncoveredLine">  for (unsigned long i = 0; i < Loops.size(); ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="uncoveredLine">    for (Loop *ChildL : Loops[i]->getSubLoops())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="uncoveredLine">      Loops.push_back(ChildL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="uncoveredLine">  for (Loop *L : Loops) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">    if (!L->isInnermost())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="uncoveredLine">    SelectGroups SIGroups;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="uncoveredLine">    for (BasicBlock *BB : L->getBlocks())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="uncoveredLine">      collectSelectGroups(*BB, SIGroups);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="uncoveredLine">    findProfitableSIGroupsInnerLoops(L, SIGroups, ProfSIGroups);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">/// If \p isTrue is true, return the true value of \p SI, otherwise return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">/// false value of \p SI. If the true/false value of \p SI is defined by any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">/// select instructions in \p Selects, look through the defining select</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">/// instruction until the true/false value is not defined in \p Selects.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">static Value *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="uncoveredLine">getTrueOrFalseValue(SelectInst *SI, bool isTrue,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">                    const SmallPtrSet<const Instruction *, 2> &Selects) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="uncoveredLine">  Value *V = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="uncoveredLine">  for (SelectInst *DefSI = SI; DefSI != nullptr && Selects.count(DefSI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="uncoveredLine">       DefSI = dyn_cast<SelectInst>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="uncoveredLine">    assert(DefSI->getCondition() == SI->getCondition() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">           "The condition of DefSI does not match with SI");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="uncoveredLine">    V = (isTrue ? DefSI->getTrueValue() : DefSI->getFalseValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">  assert(V && "Failed to get select true/false value");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="uncoveredLine">  return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="uncoveredLine">void SelectOptimize::convertProfitableSIGroups(SelectGroups &ProfSIGroups) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="uncoveredLine">  for (SelectGroup &ASI : ProfSIGroups) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">    // The code transformation here is a modified version of the sinking</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">    // transformation in CodeGenPrepare::optimizeSelectInst with a more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">    // aggressive strategy of which instructions to sink.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">    // TODO: eliminate the redundancy of logic transforming selects to branches</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">    // by removing CodeGenPrepare::optimizeSelectInst and optimizing here</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">    // selects for all cases (with and without profile information).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">    // Transform a sequence like this:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">    //    start:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">    //       %cmp = cmp uge i32 %a, %b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">    //       %sel = select i1 %cmp, i32 %c, i32 %d</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">    // Into:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">    //    start:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">    //       %cmp = cmp uge i32 %a, %b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">    //       %cmp.frozen = freeze %cmp</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">    //       br i1 %cmp.frozen, label %select.true, label %select.false</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">    //    select.true:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">    //       br label %select.end</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">    //    select.false:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">    //       br label %select.end</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">    //    select.end:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">    //       %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">    // %cmp should be frozen, otherwise it may introduce undefined behavior.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">    // In addition, we may sink instructions that produce %c or %d into the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">    // destination(s) of the new branch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">    // If the true or false blocks do not contain a sunken instruction, that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">    // block and its branch may be optimized away. In that case, one side of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">    // first branch will point directly to select.end, and the corresponding PHI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">    // predecessor block will be the start block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">    // Find all the instructions that can be soundly sunk to the true/false</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">    // blocks. These are instructions that are computed solely for producing the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">    // operands of the select instructions in the group and can be sunk without</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">    // breaking the semantics of the LLVM IR (e.g., cannot sink instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">    // with side effects).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">    SmallVector<std::stack<Instruction *>, 2> TrueSlices, FalseSlices;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">    typedef std::stack<Instruction *>::size_type StackSizeType;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">    StackSizeType maxTrueSliceLen = 0, maxFalseSliceLen = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="uncoveredLine">    for (SelectInst *SI : ASI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">      // For each select, compute the sinkable dependence chains of the true and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">      // false operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">      if (auto *TI = dyn_cast<Instruction>(SI->getTrueValue())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">        std::stack<Instruction *> TrueSlice;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">        getExclBackwardsSlice(TI, TrueSlice, SI, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="uncoveredLine">        maxTrueSliceLen = std::max(maxTrueSliceLen, TrueSlice.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">        TrueSlices.push_back(TrueSlice);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">      if (auto *FI = dyn_cast<Instruction>(SI->getFalseValue())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">        std::stack<Instruction *> FalseSlice;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">        getExclBackwardsSlice(FI, FalseSlice, SI, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="uncoveredLine">        maxFalseSliceLen = std::max(maxFalseSliceLen, FalseSlice.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="uncoveredLine">        FalseSlices.push_back(FalseSlice);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">    // In the case of multiple select instructions in the same group, the order</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">    // of non-dependent instructions (instructions of different dependence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">    // slices) in the true/false blocks appears to affect performance.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">    // Interleaving the slices seems to experimentally be the optimal approach.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">    // This interleaving scheduling allows for more ILP (with a natural downside</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">    // of increasing a bit register pressure) compared to a simple ordering of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">    // one whole chain after another. One would expect that this ordering would</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">    // not matter since the scheduling in the backend of the compiler  would</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">    // take care of it, but apparently the scheduler fails to deliver optimal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">    // ILP with a naive ordering here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="uncoveredLine">    SmallVector<Instruction *, 2> TrueSlicesInterleaved, FalseSlicesInterleaved;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">    for (StackSizeType IS = 0; IS < maxTrueSliceLen; ++IS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">      for (auto &S : TrueSlices) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="uncoveredLine">        if (!S.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">          TrueSlicesInterleaved.push_back(S.top());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="uncoveredLine">          S.pop();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">    for (StackSizeType IS = 0; IS < maxFalseSliceLen; ++IS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">      for (auto &S : FalseSlices) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="uncoveredLine">        if (!S.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="uncoveredLine">          FalseSlicesInterleaved.push_back(S.top());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="uncoveredLine">          S.pop();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">    // We split the block containing the select(s) into two blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="uncoveredLine">    SelectInst *SI = ASI.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="uncoveredLine">    SelectInst *LastSI = ASI.back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="uncoveredLine">    BasicBlock *StartBlock = SI->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="uncoveredLine">    BasicBlock::iterator SplitPt = ++(BasicBlock::iterator(LastSI));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">    BasicBlock *EndBlock = StartBlock->splitBasicBlock(SplitPt, "select.end");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">    BFI->setBlockFreq(EndBlock, BFI->getBlockFreq(StartBlock).getFrequency());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">    // Delete the unconditional branch that was just created by the split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="uncoveredLine">    StartBlock->getTerminator()->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">    // Move any debug/pseudo instructions that were in-between the select</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">    // group to the newly-created end block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="uncoveredLine">    SmallVector<Instruction *, 2> DebugPseudoINS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">    auto DIt = SI->getIterator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="uncoveredLine">    while (&*DIt != LastSI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="uncoveredLine">      if (DIt->isDebugOrPseudoInst())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="uncoveredLine">        DebugPseudoINS.push_back(&*DIt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">      DIt++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">    for (auto *DI : DebugPseudoINS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">      DI->moveBefore(&*EndBlock->getFirstInsertionPt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">    // These are the new basic blocks for the conditional branch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">    // At least one will become an actual new basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="uncoveredLine">    BasicBlock *TrueBlock = nullptr, *FalseBlock = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="uncoveredLine">    BranchInst *TrueBranch = nullptr, *FalseBranch = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">    if (!TrueSlicesInterleaved.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="uncoveredLine">      TrueBlock = BasicBlock::Create(LastSI->getContext(), "select.true.sink",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">                                     EndBlock->getParent(), EndBlock);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="uncoveredLine">      TrueBranch = BranchInst::Create(EndBlock, TrueBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">      TrueBranch->setDebugLoc(LastSI->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="uncoveredLine">      for (Instruction *TrueInst : TrueSlicesInterleaved)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="uncoveredLine">        TrueInst->moveBefore(TrueBranch);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="uncoveredLine">    if (!FalseSlicesInterleaved.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">      FalseBlock = BasicBlock::Create(LastSI->getContext(), "select.false.sink",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">                                      EndBlock->getParent(), EndBlock);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">      FalseBranch = BranchInst::Create(EndBlock, FalseBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">      FalseBranch->setDebugLoc(LastSI->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">      for (Instruction *FalseInst : FalseSlicesInterleaved)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">        FalseInst->moveBefore(FalseBranch);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">    // If there was nothing to sink, then arbitrarily choose the 'false' side</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">    // for a new input value to the PHI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="uncoveredLine">    if (TrueBlock == FalseBlock) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="uncoveredLine">      assert(TrueBlock == nullptr &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">             "Unexpected basic block transform while optimizing select");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="uncoveredLine">      FalseBlock = BasicBlock::Create(SI->getContext(), "select.false",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">                                      EndBlock->getParent(), EndBlock);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="uncoveredLine">      auto *FalseBranch = BranchInst::Create(EndBlock, FalseBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">      FalseBranch->setDebugLoc(SI->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">    // Insert the real conditional branch based on the original condition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">    // If we did not create a new block for one of the 'true' or 'false' paths</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">    // of the condition, it means that side of the branch goes to the end block</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">    // directly and the path originates from the start block from the point of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">    // view of the new PHI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">    BasicBlock *TT, *FT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="uncoveredLine">    if (TrueBlock == nullptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="uncoveredLine">      TT = EndBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">      FT = FalseBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="uncoveredLine">      TrueBlock = StartBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="uncoveredLine">    } else if (FalseBlock == nullptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="uncoveredLine">      TT = TrueBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="uncoveredLine">      FT = EndBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="uncoveredLine">      FalseBlock = StartBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="uncoveredLine">      TT = TrueBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="uncoveredLine">      FT = FalseBlock;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="uncoveredLine">    IRBuilder<> IB(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">    auto *CondFr =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="uncoveredLine">        IB.CreateFreeze(SI->getCondition(), SI->getName() + ".frozen");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="uncoveredLine">    IB.CreateCondBr(CondFr, TT, FT, SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="uncoveredLine">    SmallPtrSet<const Instruction *, 2> INS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">    INS.insert(ASI.begin(), ASI.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">    // Use reverse iterator because later select may use the value of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">    // earlier select, and we need to propagate value through earlier select</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">    // to get the PHI operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="uncoveredLine">    for (auto It = ASI.rbegin(); It != ASI.rend(); ++It) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="uncoveredLine">      SelectInst *SI = *It;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">      // The select itself is replaced with a PHI Node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">      PHINode *PN = PHINode::Create(SI->getType(), 2, "", &EndBlock->front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="uncoveredLine">      PN->takeName(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="uncoveredLine">      PN->addIncoming(getTrueOrFalseValue(SI, true, INS), TrueBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="uncoveredLine">      PN->addIncoming(getTrueOrFalseValue(SI, false, INS), FalseBlock);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="uncoveredLine">      PN->setDebugLoc(SI->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="uncoveredLine">      SI->replaceAllUsesWith(PN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">      SI->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="uncoveredLine">      INS.erase(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="uncoveredLine">      ++NumSelectsConverted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="uncoveredLine">static bool isSpecialSelect(SelectInst *SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">  using namespace llvm::PatternMatch;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">  // If the select is a logical-and/logical-or then it is better treated as a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">  // and/or by the backend.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">  if (match(SI, m_CombineOr(m_LogicalAnd(m_Value(), m_Value()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">                            m_LogicalOr(m_Value(), m_Value()))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="uncoveredLine">void SelectOptimize::collectSelectGroups(BasicBlock &BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">                                         SelectGroups &SIGroups) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="uncoveredLine">  BasicBlock::iterator BBIt = BB.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="uncoveredLine">  while (BBIt != BB.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">    Instruction *I = &*BBIt++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">    if (SelectInst *SI = dyn_cast<SelectInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="uncoveredLine">      if (isSpecialSelect(SI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="uncoveredLine">      SelectGroup SIGroup;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="uncoveredLine">      SIGroup.push_back(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">      while (BBIt != BB.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="uncoveredLine">        Instruction *NI = &*BBIt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="uncoveredLine">        SelectInst *NSI = dyn_cast<SelectInst>(NI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="uncoveredLine">        if (NSI && SI->getCondition() == NSI->getCondition()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="uncoveredLine">          SIGroup.push_back(NSI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">        } else if (!NI->isDebugOrPseudoInst()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">          // Debug/pseudo instructions should be skipped and not prevent the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">          // formation of a select group.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="uncoveredLine">        ++BBIt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">      // If the select type is not supported, no point optimizing it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">      // Instruction selection will take care of it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="uncoveredLine">      if (!isSelectKindSupported(SI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="uncoveredLine">      SIGroups.push_back(SIGroup);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="uncoveredLine">void SelectOptimize::findProfitableSIGroupsBase(SelectGroups &SIGroups,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">                                                SelectGroups &ProfSIGroups) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="uncoveredLine">  for (SelectGroup &ASI : SIGroups) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="uncoveredLine">    ++NumSelectOptAnalyzed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="uncoveredLine">    if (isConvertToBranchProfitableBase(ASI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="uncoveredLine">      ProfSIGroups.push_back(ASI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">static void EmitAndPrintRemark(OptimizationRemarkEmitter *ORE,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">                               DiagnosticInfoOptimizationBase &Rem) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << Rem.getMsg() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="uncoveredLine">  ORE->emit(Rem);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="uncoveredLine">void SelectOptimize::findProfitableSIGroupsInnerLoops(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">    const Loop *L, SelectGroups &SIGroups, SelectGroups &ProfSIGroups) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="uncoveredLine">  NumSelectOptAnalyzed += SIGroups.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">  // For each select group in an inner-most loop,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">  // a branch is more preferable than a select/conditional-move if:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">  // i) conversion to branches for all the select groups of the loop satisfies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">  //    loop-level heuristics including reducing the loop's critical path by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="">  //    some threshold (see SelectOptimize::checkLoopHeuristics); and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">  // ii) the total cost of the select group is cheaper with a branch compared</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">  //     to its predicated version. The cost is in terms of latency and the cost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">  //     of a select group is the cost of its most expensive select instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">  //     (assuming infinite resources and thus fully leveraging available ILP).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="uncoveredLine">  DenseMap<const Instruction *, CostInfo> InstCostMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="uncoveredLine">  CostInfo LoopCost[2] = {{Scaled64::getZero(), Scaled64::getZero()},</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="uncoveredLine">                          {Scaled64::getZero(), Scaled64::getZero()}};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="uncoveredLine">  if (!computeLoopCosts(L, SIGroups, InstCostMap, LoopCost) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="uncoveredLine">      !checkLoopHeuristics(L, LoopCost)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="uncoveredLine">  for (SelectGroup &ASI : SIGroups) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">    // Assuming infinite resources, the cost of a group of instructions is the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">    // cost of the most expensive instruction of the group.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">    Scaled64 SelectCost = Scaled64::getZero(), BranchCost = Scaled64::getZero();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">    for (SelectInst *SI : ASI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">      SelectCost = std::max(SelectCost, InstCostMap[SI].PredCost);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="uncoveredLine">      BranchCost = std::max(BranchCost, InstCostMap[SI].NonPredCost);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="uncoveredLine">    if (BranchCost < SelectCost) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="uncoveredLine">      OptimizationRemark OR(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="uncoveredLine">      OR << "Profitable to convert to branch (loop analysis). BranchCost="</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="uncoveredLine">         << BranchCost.toString() << ", SelectCost=" << SelectCost.toString()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="uncoveredLine">         << ". ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="uncoveredLine">      EmitAndPrintRemark(ORE, OR);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="uncoveredLine">      ++NumSelectConvertedLoop;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="uncoveredLine">      ProfSIGroups.push_back(ASI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="uncoveredLine">    } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="uncoveredLine">      OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="uncoveredLine">      ORmiss << "Select is more profitable (loop analysis). BranchCost="</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">             << BranchCost.toString()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="uncoveredLine">             << ", SelectCost=" << SelectCost.toString() << ". ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="uncoveredLine">      EmitAndPrintRemark(ORE, ORmiss);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="uncoveredLine">bool SelectOptimize::isConvertToBranchProfitableBase(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">    const SmallVector<SelectInst *, 2> &ASI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="uncoveredLine">  SelectInst *SI = ASI.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Analyzing select group containing " << *SI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">  OptimizationRemark OR(DEBUG_TYPE, "SelectOpti", SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="uncoveredLine">  OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">  // Skip cold basic blocks. Better to optimize for size for cold blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="uncoveredLine">  if (PSI->isColdBlock(SI->getParent(), BFI.get())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="uncoveredLine">    ++NumSelectColdBB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="uncoveredLine">    ORmiss << "Not converted to branch because of cold basic block. ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="uncoveredLine">    EmitAndPrintRemark(ORE, ORmiss);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">  // If unpredictable, branch form is less profitable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="uncoveredLine">  if (SI->getMetadata(LLVMContext::MD_unpredictable)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">    ++NumSelectUnPred;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="uncoveredLine">    ORmiss << "Not converted to branch because of unpredictable branch. ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="uncoveredLine">    EmitAndPrintRemark(ORE, ORmiss);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">  // If highly predictable, branch form is more profitable, unless a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">  // predictable select is inexpensive in the target architecture.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="uncoveredLine">  if (isSelectHighlyPredictable(SI) && TLI->isPredictableSelectExpensive()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">    ++NumSelectConvertedHighPred;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="uncoveredLine">    OR << "Converted to branch because of highly predictable branch. ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="uncoveredLine">    EmitAndPrintRemark(ORE, OR);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">  // Look for expensive instructions in the cold operand's (if any) dependence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="">  // slice of any of the selects in the group.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="uncoveredLine">  if (hasExpensiveColdOperand(ASI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="uncoveredLine">    ++NumSelectConvertedExpColdOperand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="uncoveredLine">    OR << "Converted to branch because of expensive cold operand.";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="uncoveredLine">    EmitAndPrintRemark(ORE, OR);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">  ORmiss << "Not profitable to convert to branch (base heuristic).";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="uncoveredLine">  EmitAndPrintRemark(ORE, ORmiss);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="uncoveredLine">static InstructionCost divideNearest(InstructionCost Numerator,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">                                     uint64_t Denominator) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">  return (Numerator + (Denominator / 2)) / Denominator;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="uncoveredLine">bool SelectOptimize::hasExpensiveColdOperand(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">    const SmallVector<SelectInst *, 2> &ASI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="uncoveredLine">  bool ColdOperand = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">  uint64_t TrueWeight, FalseWeight, TotalWeight;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="uncoveredLine">  if (extractBranchWeights(*ASI.front(), TrueWeight, FalseWeight)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="uncoveredLine">    uint64_t MinWeight = std::min(TrueWeight, FalseWeight);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">    TotalWeight = TrueWeight + FalseWeight;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">    // Is there a path with frequency <ColdOperandThreshold% (default:20%) ?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="uncoveredLine">    ColdOperand = TotalWeight * ColdOperandThreshold > 100 * MinWeight;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">  } else if (PSI->hasProfileSummary()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="uncoveredLine">    OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">    ORmiss << "Profile data available but missing branch-weights metadata for "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="uncoveredLine">              "select instruction. ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="uncoveredLine">    EmitAndPrintRemark(ORE, ORmiss);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="uncoveredLine">  if (!ColdOperand)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">  // Check if the cold path's dependence slice is expensive for any of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">  // selects of the group.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">  for (SelectInst *SI : ASI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">    Instruction *ColdI = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="">    uint64_t HotWeight;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">    if (TrueWeight < FalseWeight) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="uncoveredLine">      ColdI = dyn_cast<Instruction>(SI->getTrueValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">      HotWeight = FalseWeight;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="uncoveredLine">      ColdI = dyn_cast<Instruction>(SI->getFalseValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="uncoveredLine">      HotWeight = TrueWeight;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">    if (ColdI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="uncoveredLine">      std::stack<Instruction *> ColdSlice;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">      getExclBackwardsSlice(ColdI, ColdSlice, SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">      InstructionCost SliceCost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="uncoveredLine">      while (!ColdSlice.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="uncoveredLine">        SliceCost += TTI->getInstructionCost(ColdSlice.top(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="uncoveredLine">                                             TargetTransformInfo::TCK_Latency);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="uncoveredLine">        ColdSlice.pop();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="">      // The colder the cold value operand of the select is the more expensive</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">      // the cmov becomes for computing the cold value operand every time. Thus,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">      // the colder the cold operand is the more its cost counts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="">      // Get nearest integer cost adjusted for coldness.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">      InstructionCost AdjSliceCost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">          divideNearest(SliceCost * HotWeight, TotalWeight);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="uncoveredLine">      if (AdjSliceCost >=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="uncoveredLine">          ColdOperandMaxCostMultiplier * TargetTransformInfo::TCC_Expensive)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">// Check if it is safe to move LoadI next to the SI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">// Conservatively assume it is safe only if there is no instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">// modifying memory in-between the load and the select instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="uncoveredLine">static bool isSafeToSinkLoad(Instruction *LoadI, Instruction *SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="">  // Assume loads from different basic blocks are unsafe to move.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="uncoveredLine">  if (LoadI->getParent() != SI->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">  auto It = LoadI->getIterator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="uncoveredLine">  while (&*It != SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">    if (It->mayWriteToMemory())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="uncoveredLine">    It++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">// For a given source instruction, collect its backwards dependence slice</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">// consisting of instructions exclusively computed for the purpose of producing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">// the operands of the source instruction. As an approximation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">// (sufficiently-accurate in practice), we populate this set with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">// instructions of the backwards dependence slice that only have one-use and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">// form an one-use chain that leads to the source instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="uncoveredLine">void SelectOptimize::getExclBackwardsSlice(Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">                                           std::stack<Instruction *> &Slice,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">                                           Instruction *SI, bool ForSinking) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">  SmallPtrSet<Instruction *, 2> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="uncoveredLine">  std::queue<Instruction *> Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="uncoveredLine">  Worklist.push(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="uncoveredLine">    Instruction *II = Worklist.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="uncoveredLine">    Worklist.pop();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">    // Avoid cycles.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">    if (!Visited.insert(II).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">    if (!II->hasOneUse())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">    // Cannot soundly sink instructions with side-effects.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">    // Terminator or phi instructions cannot be sunk.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">    // Avoid sinking other select instructions (should be handled separetely).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">    if (ForSinking && (II->isTerminator() || II->mayHaveSideEffects() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">                       isa<SelectInst>(II) || isa<PHINode>(II)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">    // Avoid sinking loads in order not to skip state-modifying instructions,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">    // that may alias with the loaded address.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">    // Only allow sinking of loads within the same basic block that are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">    // conservatively proven to be safe.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">    if (ForSinking && II->mayReadFromMemory() && !isSafeToSinkLoad(II, SI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">    // Avoid considering instructions with less frequency than the source</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="">    // instruction (i.e., avoid colder code regions of the dependence slice).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">    if (BFI->getBlockFreq(II->getParent()) < BFI->getBlockFreq(I->getParent()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">    // Eligible one-use instruction added to the dependence slice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">    Slice.push(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">    // Explore all the operands of the current instruction to expand the slice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">    for (unsigned k = 0; k < II->getNumOperands(); ++k)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="uncoveredLine">      if (auto *OpI = dyn_cast<Instruction>(II->getOperand(k)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="uncoveredLine">        Worklist.push(OpI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">bool SelectOptimize::isSelectHighlyPredictable(const SelectInst *SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="">  uint64_t TrueWeight, FalseWeight;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="uncoveredLine">  if (extractBranchWeights(*SI, TrueWeight, FalseWeight)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="uncoveredLine">    uint64_t Max = std::max(TrueWeight, FalseWeight);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="uncoveredLine">    uint64_t Sum = TrueWeight + FalseWeight;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">    if (Sum != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="uncoveredLine">      auto Probability = BranchProbability::getBranchProbability(Max, Sum);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">      if (Probability > TTI->getPredictableBranchThreshold())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="uncoveredLine">bool SelectOptimize::checkLoopHeuristics(const Loop *L,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">                                         const CostInfo LoopCost[2]) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">  // Loop-level checks to determine if a non-predicated version (with branches)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">  // of the loop is more profitable than its predicated version.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="uncoveredLine">  if (DisableLoopLevelHeuristics)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">  OptimizationRemarkMissed ORmissL(DEBUG_TYPE, "SelectOpti",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">                                   L->getHeader()->getFirstNonPHI());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="uncoveredLine">  if (LoopCost[0].NonPredCost > LoopCost[0].PredCost ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="uncoveredLine">      LoopCost[1].NonPredCost >= LoopCost[1].PredCost) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">    ORmissL << "No select conversion in the loop due to no reduction of loop's "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">               "critical path. ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">    EmitAndPrintRemark(ORE, ORmissL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">  Scaled64 Gain[2] = {LoopCost[0].PredCost - LoopCost[0].NonPredCost,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">                      LoopCost[1].PredCost - LoopCost[1].NonPredCost};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">  // Profitably converting to branches need to reduce the loop's critical path</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">  // by at least some threshold (absolute gain of GainCycleThreshold cycles and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">  // relative gain of 12.5%).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="uncoveredLine">  if (Gain[1] < Scaled64::get(GainCycleThreshold) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="uncoveredLine">      Gain[1] * Scaled64::get(GainRelativeThreshold) < LoopCost[1].PredCost) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">    Scaled64 RelativeGain = Scaled64::get(100) * Gain[1] / LoopCost[1].PredCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">    ORmissL << "No select conversion in the loop due to small reduction of "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="uncoveredLine">               "loop's critical path. Gain="</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">            << Gain[1].toString()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="uncoveredLine">            << ", RelativeGain=" << RelativeGain.toString() << "%. ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="uncoveredLine">    EmitAndPrintRemark(ORE, ORmissL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">  // If the loop's critical path involves loop-carried dependences, the gradient</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">  // of the gain needs to be at least GainGradientThreshold% (defaults to 25%).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">  // This check ensures that the latency reduction for the loop's critical path</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">  // keeps decreasing with sufficient rate beyond the two analyzed loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">  // iterations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">  if (Gain[1] > Gain[0]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="uncoveredLine">    Scaled64 GradientGain = Scaled64::get(100) * (Gain[1] - Gain[0]) /</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="uncoveredLine">                            (LoopCost[1].PredCost - LoopCost[0].PredCost);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="uncoveredLine">    if (GradientGain < Scaled64::get(GainGradientThreshold)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">      ORmissL << "No select conversion in the loop due to small gradient gain. "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="uncoveredLine">                 "GradientGain="</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="uncoveredLine">              << GradientGain.toString() << "%. ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="uncoveredLine">      EmitAndPrintRemark(ORE, ORmissL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">  // If the gain decreases it is not profitable to convert.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">  else if (Gain[1] < Gain[0]) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="">    ORmissL</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">        << "No select conversion in the loop due to negative gradient gain. ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="uncoveredLine">    EmitAndPrintRemark(ORE, ORmissL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">  // Non-predicated version of the loop is more profitable than its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">  // predicated version.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="">// Computes instruction and loop-critical-path costs for both the predicated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="">// and non-predicated version of the given loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">// Returns false if unable to compute these costs due to invalid cost of loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">// instruction(s).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="uncoveredLine">bool SelectOptimize::computeLoopCosts(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">    const Loop *L, const SelectGroups &SIGroups,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">    DenseMap<const Instruction *, CostInfo> &InstCostMap, CostInfo *LoopCost) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Calculating Latency / IPredCost / INonPredCost of loop "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">                    << L->getHeader()->getName() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="uncoveredLine">  const auto &SIset = getSIset(SIGroups);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">  // Compute instruction and loop-critical-path costs across two iterations for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">  // both predicated and non-predicated version.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="uncoveredLine">  const unsigned Iterations = 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="uncoveredLine">  for (unsigned Iter = 0; Iter < Iterations; ++Iter) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="">    // Cost of the loop's critical path.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="uncoveredLine">    CostInfo &MaxCost = LoopCost[Iter];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="uncoveredLine">    for (BasicBlock *BB : L->getBlocks()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="uncoveredLine">      for (const Instruction &I : *BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="uncoveredLine">        if (I.isDebugOrPseudoInst())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">        // Compute the predicated and non-predicated cost of the instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="uncoveredLine">        Scaled64 IPredCost = Scaled64::getZero(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="uncoveredLine">                 INonPredCost = Scaled64::getZero();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="">        // Assume infinite resources that allow to fully exploit the available</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">        // instruction-level parallelism.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">        // InstCost = InstLatency + max(Op1Cost, Op2Cost, … OpNCost)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="uncoveredLine">        for (const Use &U : I.operands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="uncoveredLine">          auto UI = dyn_cast<Instruction>(U.get());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="uncoveredLine">          if (!UI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">          if (InstCostMap.count(UI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="uncoveredLine">            IPredCost = std::max(IPredCost, InstCostMap[UI].PredCost);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="uncoveredLine">            INonPredCost = std::max(INonPredCost, InstCostMap[UI].NonPredCost);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="uncoveredLine">        auto ILatency = computeInstCost(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">        if (!ILatency) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">          OptimizationRemarkMissed ORmissL(DEBUG_TYPE, "SelectOpti", &I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="">          ORmissL << "Invalid instruction cost preventing analysis and "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="">                     "optimization of the inner-most loop containing this "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">                     "instruction. ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="uncoveredLine">          EmitAndPrintRemark(ORE, ORmissL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="uncoveredLine">          return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="uncoveredLine">        }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">        IPredCost += Scaled64::get(*ILatency);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="uncoveredLine">        INonPredCost += Scaled64::get(*ILatency);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="">        // For a select that can be converted to branch,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">        // compute its cost as a branch (non-predicated cost).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">        //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">        // BranchCost = PredictedPathCost + MispredictCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">        // PredictedPathCost = TrueOpCost * TrueProb + FalseOpCost * FalseProb</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">        // MispredictCost = max(MispredictPenalty, CondCost) * MispredictRate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="uncoveredLine">        if (SIset.contains(&I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="uncoveredLine">          auto SI = cast<SelectInst>(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="uncoveredLine">          Scaled64 TrueOpCost = Scaled64::getZero(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="uncoveredLine">                   FalseOpCost = Scaled64::getZero();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="uncoveredLine">          if (auto *TI = dyn_cast<Instruction>(SI->getTrueValue()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="uncoveredLine">            if (InstCostMap.count(TI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="uncoveredLine">              TrueOpCost = InstCostMap[TI].NonPredCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="uncoveredLine">          if (auto *FI = dyn_cast<Instruction>(SI->getFalseValue()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="uncoveredLine">            if (InstCostMap.count(FI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="uncoveredLine">              FalseOpCost = InstCostMap[FI].NonPredCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">          Scaled64 PredictedPathCost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">              getPredictedPathCost(TrueOpCost, FalseOpCost, SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="uncoveredLine">          Scaled64 CondCost = Scaled64::getZero();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="uncoveredLine">          if (auto *CI = dyn_cast<Instruction>(SI->getCondition()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">            if (InstCostMap.count(CI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="uncoveredLine">              CondCost = InstCostMap[CI].NonPredCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="uncoveredLine">          Scaled64 MispredictCost = getMispredictionCost(SI, CondCost);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="uncoveredLine">          INonPredCost = PredictedPathCost + MispredictCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << " " << ILatency << "/" << IPredCost << "/"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">                          << INonPredCost << " for " << I << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="uncoveredLine">        InstCostMap[&I] = {IPredCost, INonPredCost};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="uncoveredLine">        MaxCost.PredCost = std::max(MaxCost.PredCost, IPredCost);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">        MaxCost.NonPredCost = std::max(MaxCost.NonPredCost, INonPredCost);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Iteration " << Iter + 1</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="">                      << " MaxCost = " << MaxCost.PredCost << " "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="">                      << MaxCost.NonPredCost << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="">SmallPtrSet<const Instruction *, 2></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="uncoveredLine">SelectOptimize::getSIset(const SelectGroups &SIGroups) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="uncoveredLine">  SmallPtrSet<const Instruction *, 2> SIset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="uncoveredLine">  for (const SelectGroup &ASI : SIGroups)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="uncoveredLine">    for (const SelectInst *SI : ASI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">      SIset.insert(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="uncoveredLine">  return SIset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="uncoveredLine">std::optional<uint64_t> SelectOptimize::computeInstCost(const Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">  InstructionCost ICost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="uncoveredLine">      TTI->getInstructionCost(I, TargetTransformInfo::TCK_Latency);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="uncoveredLine">  if (auto OC = ICost.getValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="uncoveredLine">    return std::optional<uint64_t>(*OC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="uncoveredLine">  return std::nullopt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">ScaledNumber<uint64_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">SelectOptimize::getMispredictionCost(const SelectInst *SI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="">                                     const Scaled64 CondCost) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="uncoveredLine">  uint64_t MispredictPenalty = TSchedModel.getMCSchedModel()->MispredictPenalty;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="">  // Account for the default misprediction rate when using a branch</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">  // (conservatively set to 25% by default).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="uncoveredLine">  uint64_t MispredictRate = MispredictDefaultRate;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">  // If the select condition is obviously predictable, then the misprediction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">  // rate is zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="uncoveredLine">  if (isSelectHighlyPredictable(SI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="uncoveredLine">    MispredictRate = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="">  // CondCost is included to account for cases where the computation of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">  // condition is part of a long dependence chain (potentially loop-carried)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">  // that would delay detection of a misprediction and increase its cost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="">  Scaled64 MispredictCost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="uncoveredLine">      std::max(Scaled64::get(MispredictPenalty), CondCost) *</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="uncoveredLine">      Scaled64::get(MispredictRate);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="uncoveredLine">  MispredictCost /= Scaled64::get(100);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="uncoveredLine">  return MispredictCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="">// Returns the cost of a branch when the prediction is correct.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">// TrueCost * TrueProbability + FalseCost * FalseProbability.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">ScaledNumber<uint64_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="uncoveredLine">SelectOptimize::getPredictedPathCost(Scaled64 TrueCost, Scaled64 FalseCost,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">                                     const SelectInst *SI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="uncoveredLine">  Scaled64 PredPathCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="">  uint64_t TrueWeight, FalseWeight;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">  if (extractBranchWeights(*SI, TrueWeight, FalseWeight)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">    uint64_t SumWeight = TrueWeight + FalseWeight;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="uncoveredLine">    if (SumWeight != 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="uncoveredLine">      PredPathCost = TrueCost * Scaled64::get(TrueWeight) +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="uncoveredLine">                     FalseCost * Scaled64::get(FalseWeight);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="uncoveredLine">      PredPathCost /= Scaled64::get(SumWeight);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="uncoveredLine">      return PredPathCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">  // Without branch weight metadata, we assume 75% for the one path and 25% for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">  // the other, and pick the result with the biggest cost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="uncoveredLine">  PredPathCost = std::max(TrueCost * Scaled64::get(3) + FalseCost,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">                          FalseCost * Scaled64::get(3) + TrueCost);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="uncoveredLine">  PredPathCost /= Scaled64::get(4);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="uncoveredLine">  return PredPathCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="uncoveredLine">bool SelectOptimize::isSelectKindSupported(SelectInst *SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="uncoveredLine">  bool VectorCond = !SI->getCondition()->getType()->isIntegerTy(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="uncoveredLine">  if (VectorCond)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">  TargetLowering::SelectSupportKind SelectKind;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="uncoveredLine">  if (SI->getType()->isVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="uncoveredLine">    SelectKind = TargetLowering::ScalarCondVectorVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="uncoveredLine">    SelectKind = TargetLowering::ScalarValSelect;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="uncoveredLine">  return TLI->isSelectSupported(SelectKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimizeC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_114SelectOptimize16getAnalysisUsageERN4llvm13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL32initializeSelectOptimizePassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm28initializeSelectOptimizePassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm24createSelectOptimizePassEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize13runOnFunctionERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize15optimizeSelectsERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize19optimizeSelectsBaseERN4llvm8FunctionERNS1_11SmallVectorINS4_IPNS1_10SelectInstELj2EEELj2EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize25optimizeSelectsInnerLoopsERN4llvm8FunctionERNS1_11SmallVectorINS4_IPNS1_10SelectInstELj2EEELj2EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL19getTrueOrFalseValuePN4llvm10SelectInstEbRKNS_11SmallPtrSetIPKNS_11InstructionELj2EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize25convertProfitableSIGroupsERN4llvm11SmallVectorINS2_IPNS1_10SelectInstELj2EEELj2EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15isSpecialSelectPN4llvm10SelectInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize19collectSelectGroupsERN4llvm10BasicBlockERNS1_11SmallVectorINS4_IPNS1_10SelectInstELj2EEELj2EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize26findProfitableSIGroupsBaseERN4llvm11SmallVectorINS2_IPNS1_10SelectInstELj2EEELj2EEES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL18EmitAndPrintRemarkPN4llvm25OptimizationRemarkEmitterERNS_30DiagnosticInfoOptimizationBaseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize32findProfitableSIGroupsInnerLoopsEPKN4llvm4LoopERNS1_11SmallVectorINS5_IPNS1_10SelectInstELj2EEELj2EEESA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize31isConvertToBranchProfitableBaseERKN4llvm11SmallVectorIPNS1_10SelectInstELj2EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL13divideNearestN4llvm15InstructionCostEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize23hasExpensiveColdOperandERKN4llvm11SmallVectorIPNS1_10SelectInstELj2EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL16isSafeToSinkLoadPN4llvm11InstructionES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize21getExclBackwardsSliceEPN4llvm11InstructionERSt5stackIS3_St5dequeIS3_SaIS3_EEES3_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize25isSelectHighlyPredictableEPKN4llvm10SelectInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize19checkLoopHeuristicsEPKN4llvm4LoopEPKNS0_8CostInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize16computeLoopCostsEPKN4llvm4LoopERKNS1_11SmallVectorINS5_IPNS1_10SelectInstELj2EEELj2EEERNS1_8DenseMapIPKNS1_11InstructionENS0_8CostInfoENS1_12DenseMapInfoISF_vEENS1_6detail12DenseMapPairISF_SG_EEEEPSG_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize8getSIsetERKN4llvm11SmallVectorINS2_IPNS1_10SelectInstELj2EEELj2EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize15computeInstCostEPKN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize20getMispredictionCostEPKN4llvm10SelectInstENS1_12ScaledNumberImEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize20getPredictedPathCostEN4llvm12ScaledNumberImEES3_PKNS1_10SelectInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114SelectOptimize21isSelectKindSupportedEPN4llvm10SelectInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===--- SelectOptimize.cpp - Convert select to branches if profitable ---===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===--- SelectOptimize.cpp - Convert select to branches if profitable ---===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This pass converts selects to conditional jumps when profitable.</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This pass converts selects to conditional jumps when profitable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">11</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline"></td>
    <td class="lineNumber">12</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">13</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/Analysis/BlockFrequencyInfo.h"</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/Analysis/BlockFrequencyInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/Analysis/BranchProbabilityInfo.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/Analysis/BranchProbabilityInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/Analysis/LoopInfo.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/Analysis/LoopInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/Analysis/ProfileSummaryInfo.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/Analysis/ProfileSummaryInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/Analysis/TargetTransformInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/CodeGen/Passes.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/CodeGen/Passes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/CodeGen/TargetLowering.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/CodeGen/TargetPassConfig.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSchedule.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSchedule.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/IR/PatternMatch.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/IR/ProfDataUtils.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/IR/ProfDataUtils.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/Support/ScaledNumber.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/Support/ScaledNumber.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/Target/TargetMachine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/Transforms/Utils/SizeOpts.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/Transforms/Utils/SizeOpts.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include <memory></td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include <memory></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include <queue></td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include <queue></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include <stack></td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include <stack></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include <string></td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include <string></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline"></td>
    <td class="lineNumber">43</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">44</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline"></td>
    <td class="lineNumber">45</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#define DEBUG_TYPE "select-optimize"</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#define DEBUG_TYPE "select-optimize"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline"></td>
    <td class="lineNumber">47</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">STATISTIC(NumSelectOptAnalyzed,</td>
    <td class="lineNumber">48</td>
    <td class="codeline">STATISTIC(NumSelectOptAnalyzed,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">          "Number of select groups considered for conversion to branch");</td>
    <td class="lineNumber">49</td>
    <td class="codeline">          "Number of select groups considered for conversion to branch");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">STATISTIC(NumSelectConvertedExpColdOperand,</td>
    <td class="lineNumber">50</td>
    <td class="codeline">STATISTIC(NumSelectConvertedExpColdOperand,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">          "Number of select groups converted due to expensive cold operand");</td>
    <td class="lineNumber">51</td>
    <td class="codeline">          "Number of select groups converted due to expensive cold operand");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">STATISTIC(NumSelectConvertedHighPred,</td>
    <td class="lineNumber">52</td>
    <td class="codeline">STATISTIC(NumSelectConvertedHighPred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">          "Number of select groups converted due to high-predictability");</td>
    <td class="lineNumber">53</td>
    <td class="codeline">          "Number of select groups converted due to high-predictability");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">STATISTIC(NumSelectUnPred,</td>
    <td class="lineNumber">54</td>
    <td class="codeline">STATISTIC(NumSelectUnPred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">          "Number of select groups not converted due to unpredictability");</td>
    <td class="lineNumber">55</td>
    <td class="codeline">          "Number of select groups not converted due to unpredictability");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">STATISTIC(NumSelectColdBB,</td>
    <td class="lineNumber">56</td>
    <td class="codeline">STATISTIC(NumSelectColdBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">          "Number of select groups not converted due to cold basic block");</td>
    <td class="lineNumber">57</td>
    <td class="codeline">          "Number of select groups not converted due to cold basic block");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">STATISTIC(NumSelectConvertedLoop,</td>
    <td class="lineNumber">58</td>
    <td class="codeline">STATISTIC(NumSelectConvertedLoop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">          "Number of select groups converted due to loop-level analysis");</td>
    <td class="lineNumber">59</td>
    <td class="codeline">          "Number of select groups converted due to loop-level analysis");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">STATISTIC(NumSelectsConverted, "Number of selects converted");</td>
    <td class="lineNumber">60</td>
    <td class="codeline">STATISTIC(NumSelectsConverted, "Number of selects converted");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline"></td>
    <td class="lineNumber">61</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">static cl::opt<unsigned> ColdOperandThreshold(</td>
    <td class="lineNumber">62</td>
    <td class="codeline">static cl::opt<unsigned> ColdOperandThreshold(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">    "cold-operand-threshold",</td>
    <td class="lineNumber">63</td>
    <td class="codeline">    "cold-operand-threshold",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">    cl::desc("Maximum frequency of path for an operand to be considered cold."),</td>
    <td class="lineNumber">64</td>
    <td class="codeline">    cl::desc("Maximum frequency of path for an operand to be considered cold."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">    cl::init(20), cl::Hidden);</td>
    <td class="lineNumber">65</td>
    <td class="codeline">    cl::init(20), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline"></td>
    <td class="lineNumber">66</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">static cl::opt<unsigned> ColdOperandMaxCostMultiplier(</td>
    <td class="lineNumber">67</td>
    <td class="codeline">static cl::opt<unsigned> ColdOperandMaxCostMultiplier(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">    "cold-operand-max-cost-multiplier",</td>
    <td class="lineNumber">68</td>
    <td class="codeline">    "cold-operand-max-cost-multiplier",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">    cl::desc("Maximum cost multiplier of TCC_expensive for the dependence "</td>
    <td class="lineNumber">69</td>
    <td class="codeline">    cl::desc("Maximum cost multiplier of TCC_expensive for the dependence "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">             "slice of a cold operand to be considered inexpensive."),</td>
    <td class="lineNumber">70</td>
    <td class="codeline">             "slice of a cold operand to be considered inexpensive."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">    cl::init(1), cl::Hidden);</td>
    <td class="lineNumber">71</td>
    <td class="codeline">    cl::init(1), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline"></td>
    <td class="lineNumber">72</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">static cl::opt<unsigned></td>
    <td class="lineNumber">73</td>
    <td class="codeline">static cl::opt<unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">    GainGradientThreshold("select-opti-loop-gradient-gain-threshold",</td>
    <td class="lineNumber">74</td>
    <td class="codeline">    GainGradientThreshold("select-opti-loop-gradient-gain-threshold",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">                          cl::desc("Gradient gain threshold (%)."),</td>
    <td class="lineNumber">75</td>
    <td class="codeline">                          cl::desc("Gradient gain threshold (%)."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">                          cl::init(25), cl::Hidden);</td>
    <td class="lineNumber">76</td>
    <td class="codeline">                          cl::init(25), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">static cl::opt<unsigned></td>
    <td class="lineNumber">78</td>
    <td class="codeline">static cl::opt<unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">    GainCycleThreshold("select-opti-loop-cycle-gain-threshold",</td>
    <td class="lineNumber">79</td>
    <td class="codeline">    GainCycleThreshold("select-opti-loop-cycle-gain-threshold",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">                       cl::desc("Minimum gain per loop (in cycles) threshold."),</td>
    <td class="lineNumber">80</td>
    <td class="codeline">                       cl::desc("Minimum gain per loop (in cycles) threshold."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">                       cl::init(4), cl::Hidden);</td>
    <td class="lineNumber">81</td>
    <td class="codeline">                       cl::init(4), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">static cl::opt<unsigned> GainRelativeThreshold(</td>
    <td class="lineNumber">83</td>
    <td class="codeline">static cl::opt<unsigned> GainRelativeThreshold(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">    "select-opti-loop-relative-gain-threshold",</td>
    <td class="lineNumber">84</td>
    <td class="codeline">    "select-opti-loop-relative-gain-threshold",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">    cl::desc(</td>
    <td class="lineNumber">85</td>
    <td class="codeline">    cl::desc(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">        "Minimum relative gain per loop threshold (1/X). Defaults to 12.5%"),</td>
    <td class="lineNumber">86</td>
    <td class="codeline">        "Minimum relative gain per loop threshold (1/X). Defaults to 12.5%"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">    cl::init(8), cl::Hidden);</td>
    <td class="lineNumber">87</td>
    <td class="codeline">    cl::init(8), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">static cl::opt<unsigned> MispredictDefaultRate(</td>
    <td class="lineNumber">89</td>
    <td class="codeline">static cl::opt<unsigned> MispredictDefaultRate(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">    "mispredict-default-rate", cl::Hidden, cl::init(25),</td>
    <td class="lineNumber">90</td>
    <td class="codeline">    "mispredict-default-rate", cl::Hidden, cl::init(25),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">    cl::desc("Default mispredict rate (initialized to 25%)."));</td>
    <td class="lineNumber">91</td>
    <td class="codeline">    cl::desc("Default mispredict rate (initialized to 25%)."));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline"></td>
    <td class="lineNumber">92</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">static cl::opt<bool></td>
    <td class="lineNumber">93</td>
    <td class="codeline">static cl::opt<bool></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">    DisableLoopLevelHeuristics("disable-loop-level-heuristics", cl::Hidden,</td>
    <td class="lineNumber">94</td>
    <td class="codeline">    DisableLoopLevelHeuristics("disable-loop-level-heuristics", cl::Hidden,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">                               cl::init(false),</td>
    <td class="lineNumber">95</td>
    <td class="codeline">                               cl::init(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">                               cl::desc("Disable loop-level heuristics."));</td>
    <td class="lineNumber">96</td>
    <td class="codeline">                               cl::desc("Disable loop-level heuristics."));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
    <td class="lineNumber">97</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">98</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline"></td>
    <td class="lineNumber">99</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">class SelectOptimize : public FunctionPass {</td>
    <td class="lineNumber">100</td>
    <td class="codeline">class SelectOptimize : public FunctionPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">  const TargetMachine *TM = nullptr;</td>
    <td class="lineNumber">101</td>
    <td class="codeline">  const TargetMachine *TM = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  const TargetSubtargetInfo *TSI = nullptr;</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  const TargetSubtargetInfo *TSI = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">  const TargetLowering *TLI = nullptr;</td>
    <td class="lineNumber">103</td>
    <td class="codeline">  const TargetLowering *TLI = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">  const TargetTransformInfo *TTI = nullptr;</td>
    <td class="lineNumber">104</td>
    <td class="codeline">  const TargetTransformInfo *TTI = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">  const LoopInfo *LI = nullptr;</td>
    <td class="lineNumber">105</td>
    <td class="codeline">  const LoopInfo *LI = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">  DominatorTree *DT = nullptr;</td>
    <td class="lineNumber">106</td>
    <td class="codeline">  DominatorTree *DT = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">  std::unique_ptr<BlockFrequencyInfo> BFI;</td>
    <td class="lineNumber">107</td>
    <td class="codeline">  std::unique_ptr<BlockFrequencyInfo> BFI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">  std::unique_ptr<BranchProbabilityInfo> BPI;</td>
    <td class="lineNumber">108</td>
    <td class="codeline">  std::unique_ptr<BranchProbabilityInfo> BPI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">  ProfileSummaryInfo *PSI = nullptr;</td>
    <td class="lineNumber">109</td>
    <td class="codeline">  ProfileSummaryInfo *PSI = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  OptimizationRemarkEmitter *ORE = nullptr;</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  OptimizationRemarkEmitter *ORE = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">  TargetSchedModel TSchedModel;</td>
    <td class="lineNumber">111</td>
    <td class="codeline">  TargetSchedModel TSchedModel;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline"></td>
    <td class="lineNumber">112</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">113</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  static char ID;</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  static char ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline"></td>
    <td class="lineNumber">115</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">  SelectOptimize() : FunctionPass(ID) {</td>
    <td class="lineNumber">116</td>
    <td class="codeline">  SelectOptimize() : FunctionPass(ID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">    initializeSelectOptimizePass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">117</td>
    <td class="codeline">    initializeSelectOptimizePass(*PassRegistry::getPassRegistry());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
    <td class="lineNumber">119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">120</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">122</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">    AU.addRequired<ProfileSummaryInfoWrapperPass>();</td>
    <td class="lineNumber">123</td>
    <td class="codeline">    AU.addRequired<ProfileSummaryInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">    AU.addRequired<TargetPassConfig>();</td>
    <td class="lineNumber">124</td>
    <td class="codeline">    AU.addRequired<TargetPassConfig>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
    <td class="lineNumber">125</td>
    <td class="codeline">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">126</td>
    <td class="codeline">    AU.addRequired<DominatorTreeWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">    AU.addRequired<LoopInfoWrapperPass>();</td>
    <td class="lineNumber">127</td>
    <td class="codeline">    AU.addRequired<LoopInfoWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">    AU.addRequired<OptimizationRemarkEmitterWrapperPass>();</td>
    <td class="lineNumber">128</td>
    <td class="codeline">    AU.addRequired<OptimizationRemarkEmitterWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">129</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">131</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">  // Select groups consist of consecutive select instructions with the same</td>
    <td class="lineNumber">132</td>
    <td class="codeline">  // Select groups consist of consecutive select instructions with the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">  // condition.</td>
    <td class="lineNumber">133</td>
    <td class="codeline">  // condition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">  using SelectGroup = SmallVector<SelectInst *, 2>;</td>
    <td class="lineNumber">134</td>
    <td class="codeline">  using SelectGroup = SmallVector<SelectInst *, 2>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">  using SelectGroups = SmallVector<SelectGroup, 2>;</td>
    <td class="lineNumber">135</td>
    <td class="codeline">  using SelectGroups = SmallVector<SelectGroup, 2>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline"></td>
    <td class="lineNumber">136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">  using Scaled64 = ScaledNumber<uint64_t>;</td>
    <td class="lineNumber">137</td>
    <td class="codeline">  using Scaled64 = ScaledNumber<uint64_t>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">  struct CostInfo {</td>
    <td class="lineNumber">139</td>
    <td class="codeline">  struct CostInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">    /// Predicated cost (with selects as conditional moves).</td>
    <td class="lineNumber">140</td>
    <td class="codeline">    /// Predicated cost (with selects as conditional moves).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">    Scaled64 PredCost;</td>
    <td class="lineNumber">141</td>
    <td class="codeline">    Scaled64 PredCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">    /// Non-predicated cost (with selects converted to branches).</td>
    <td class="lineNumber">142</td>
    <td class="codeline">    /// Non-predicated cost (with selects converted to branches).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">    Scaled64 NonPredCost;</td>
    <td class="lineNumber">143</td>
    <td class="codeline">    Scaled64 NonPredCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">  // Converts select instructions of a function to conditional jumps when deemed</td>
    <td class="lineNumber">146</td>
    <td class="codeline">  // Converts select instructions of a function to conditional jumps when deemed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  // profitable. Returns true if at least one select was converted.</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  // profitable. Returns true if at least one select was converted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">  bool optimizeSelects(Function &F);</td>
    <td class="lineNumber">148</td>
    <td class="codeline">  bool optimizeSelects(Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">  // Heuristics for determining which select instructions can be profitably</td>
    <td class="lineNumber">150</td>
    <td class="codeline">  // Heuristics for determining which select instructions can be profitably</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">  // conveted to branches. Separate heuristics for selects in inner-most loops</td>
    <td class="lineNumber">151</td>
    <td class="codeline">  // conveted to branches. Separate heuristics for selects in inner-most loops</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">  // and the rest of code regions (base heuristics for non-inner-most loop</td>
    <td class="lineNumber">152</td>
    <td class="codeline">  // and the rest of code regions (base heuristics for non-inner-most loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">  // regions).</td>
    <td class="lineNumber">153</td>
    <td class="codeline">  // regions).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">  void optimizeSelectsBase(Function &F, SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">154</td>
    <td class="codeline">  void optimizeSelectsBase(Function &F, SelectGroups &ProfSIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">  void optimizeSelectsInnerLoops(Function &F, SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">155</td>
    <td class="codeline">  void optimizeSelectsInnerLoops(Function &F, SelectGroups &ProfSIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline"></td>
    <td class="lineNumber">156</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  // Converts to branches the select groups that were deemed</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  // Converts to branches the select groups that were deemed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">  // profitable-to-convert.</td>
    <td class="lineNumber">158</td>
    <td class="codeline">  // profitable-to-convert.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  void convertProfitableSIGroups(SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  void convertProfitableSIGroups(SelectGroups &ProfSIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">  // Splits selects of a given basic block into select groups.</td>
    <td class="lineNumber">161</td>
    <td class="codeline">  // Splits selects of a given basic block into select groups.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">  void collectSelectGroups(BasicBlock &BB, SelectGroups &SIGroups);</td>
    <td class="lineNumber">162</td>
    <td class="codeline">  void collectSelectGroups(BasicBlock &BB, SelectGroups &SIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline"></td>
    <td class="lineNumber">163</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  // Determines for which select groups it is profitable converting to branches</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  // Determines for which select groups it is profitable converting to branches</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">  // (base and inner-most-loop heuristics).</td>
    <td class="lineNumber">165</td>
    <td class="codeline">  // (base and inner-most-loop heuristics).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">  void findProfitableSIGroupsBase(SelectGroups &SIGroups,</td>
    <td class="lineNumber">166</td>
    <td class="codeline">  void findProfitableSIGroupsBase(SelectGroups &SIGroups,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">                                  SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">167</td>
    <td class="codeline">                                  SelectGroups &ProfSIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  void findProfitableSIGroupsInnerLoops(const Loop *L, SelectGroups &SIGroups,</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  void findProfitableSIGroupsInnerLoops(const Loop *L, SelectGroups &SIGroups,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">                                        SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">169</td>
    <td class="codeline">                                        SelectGroups &ProfSIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline"></td>
    <td class="lineNumber">170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  // Determines if a select group should be converted to a branch (base</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  // Determines if a select group should be converted to a branch (base</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  // heuristics).</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  // heuristics).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">  bool isConvertToBranchProfitableBase(const SmallVector<SelectInst *, 2> &ASI);</td>
    <td class="lineNumber">173</td>
    <td class="codeline">  bool isConvertToBranchProfitableBase(const SmallVector<SelectInst *, 2> &ASI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline"></td>
    <td class="lineNumber">174</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  // Returns true if there are expensive instructions in the cold value</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  // Returns true if there are expensive instructions in the cold value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">  // operand's (if any) dependence slice of any of the selects of the given</td>
    <td class="lineNumber">176</td>
    <td class="codeline">  // operand's (if any) dependence slice of any of the selects of the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">  // group.</td>
    <td class="lineNumber">177</td>
    <td class="codeline">  // group.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  bool hasExpensiveColdOperand(const SmallVector<SelectInst *, 2> &ASI);</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  bool hasExpensiveColdOperand(const SmallVector<SelectInst *, 2> &ASI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline"></td>
    <td class="lineNumber">179</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">  // For a given source instruction, collect its backwards dependence slice</td>
    <td class="lineNumber">180</td>
    <td class="codeline">  // For a given source instruction, collect its backwards dependence slice</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">  // consisting of instructions exclusively computed for producing the operands</td>
    <td class="lineNumber">181</td>
    <td class="codeline">  // consisting of instructions exclusively computed for producing the operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">  // of the source instruction.</td>
    <td class="lineNumber">182</td>
    <td class="codeline">  // of the source instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  void getExclBackwardsSlice(Instruction *I, std::stack<Instruction *> &Slice,</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  void getExclBackwardsSlice(Instruction *I, std::stack<Instruction *> &Slice,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">                             Instruction *SI, bool ForSinking = false);</td>
    <td class="lineNumber">184</td>
    <td class="codeline">                             Instruction *SI, bool ForSinking = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">  // Returns true if the condition of the select is highly predictable.</td>
    <td class="lineNumber">186</td>
    <td class="codeline">  // Returns true if the condition of the select is highly predictable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  bool isSelectHighlyPredictable(const SelectInst *SI);</td>
    <td class="lineNumber">187</td>
    <td class="codeline">  bool isSelectHighlyPredictable(const SelectInst *SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline"></td>
    <td class="lineNumber">188</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  // Loop-level checks to determine if a non-predicated version (with branches)</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  // Loop-level checks to determine if a non-predicated version (with branches)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  // of the given loop is more profitable than its predicated version.</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  // of the given loop is more profitable than its predicated version.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  bool checkLoopHeuristics(const Loop *L, const CostInfo LoopDepth[2]);</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  bool checkLoopHeuristics(const Loop *L, const CostInfo LoopDepth[2]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
    <td class="lineNumber">192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  // Computes instruction and loop-critical-path costs for both the predicated</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  // Computes instruction and loop-critical-path costs for both the predicated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">  // and non-predicated version of the given loop.</td>
    <td class="lineNumber">194</td>
    <td class="codeline">  // and non-predicated version of the given loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">  bool computeLoopCosts(const Loop *L, const SelectGroups &SIGroups,</td>
    <td class="lineNumber">195</td>
    <td class="codeline">  bool computeLoopCosts(const Loop *L, const SelectGroups &SIGroups,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">                        DenseMap<const Instruction *, CostInfo> &InstCostMap,</td>
    <td class="lineNumber">196</td>
    <td class="codeline">                        DenseMap<const Instruction *, CostInfo> &InstCostMap,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">                        CostInfo *LoopCost);</td>
    <td class="lineNumber">197</td>
    <td class="codeline">                        CostInfo *LoopCost);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
    <td class="lineNumber">198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">  // Returns a set of all the select instructions in the given select groups.</td>
    <td class="lineNumber">199</td>
    <td class="codeline">  // Returns a set of all the select instructions in the given select groups.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">  SmallPtrSet<const Instruction *, 2> getSIset(const SelectGroups &SIGroups);</td>
    <td class="lineNumber">200</td>
    <td class="codeline">  SmallPtrSet<const Instruction *, 2> getSIset(const SelectGroups &SIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline"></td>
    <td class="lineNumber">201</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">  // Returns the latency cost of a given instruction.</td>
    <td class="lineNumber">202</td>
    <td class="codeline">  // Returns the latency cost of a given instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">  std::optional<uint64_t> computeInstCost(const Instruction *I);</td>
    <td class="lineNumber">203</td>
    <td class="codeline">  std::optional<uint64_t> computeInstCost(const Instruction *I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  // Returns the misprediction cost of a given select when converted to branch.</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  // Returns the misprediction cost of a given select when converted to branch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  Scaled64 getMispredictionCost(const SelectInst *SI, const Scaled64 CondCost);</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  Scaled64 getMispredictionCost(const SelectInst *SI, const Scaled64 CondCost);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline"></td>
    <td class="lineNumber">207</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  // Returns the cost of a branch when the prediction is correct.</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  // Returns the cost of a branch when the prediction is correct.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">  Scaled64 getPredictedPathCost(Scaled64 TrueCost, Scaled64 FalseCost,</td>
    <td class="lineNumber">209</td>
    <td class="codeline">  Scaled64 getPredictedPathCost(Scaled64 TrueCost, Scaled64 FalseCost,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">                                const SelectInst *SI);</td>
    <td class="lineNumber">210</td>
    <td class="codeline">                                const SelectInst *SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline"></td>
    <td class="lineNumber">211</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  // Returns true if the target architecture supports lowering a given select.</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  // Returns true if the target architecture supports lowering a given select.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  bool isSelectKindSupported(SelectInst *SI);</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  bool isSelectKindSupported(SelectInst *SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">};</td>
    <td class="lineNumber">214</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">} // namespace</td>
    <td class="lineNumber">215</td>
    <td class="codeline">} // namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline"></td>
    <td class="lineNumber">216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">char SelectOptimize::ID = 0;</td>
    <td class="lineNumber">217</td>
    <td class="codeline">char SelectOptimize::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline"></td>
    <td class="lineNumber">218</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(SelectOptimize, DEBUG_TYPE, "Optimize selects", false,</td>
    <td class="lineNumber">219</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(SelectOptimize, DEBUG_TYPE, "Optimize selects", false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">                      false)</td>
    <td class="lineNumber">220</td>
    <td class="codeline">                      false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
    <td class="lineNumber">221</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">222</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(ProfileSummaryInfoWrapperPass)</td>
    <td class="lineNumber">223</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(ProfileSummaryInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td class="lineNumber">224</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
    <td class="lineNumber">225</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(OptimizationRemarkEmitterWrapperPass)</td>
    <td class="lineNumber">226</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(OptimizationRemarkEmitterWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">INITIALIZE_PASS_END(SelectOptimize, DEBUG_TYPE, "Optimize selects", false,</td>
    <td class="lineNumber">227</td>
    <td class="codeline">INITIALIZE_PASS_END(SelectOptimize, DEBUG_TYPE, "Optimize selects", false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">                    false)</td>
    <td class="lineNumber">228</td>
    <td class="codeline">                    false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">FunctionPass *llvm::createSelectOptimizePass() { return new SelectOptimize(); }</td>
    <td class="lineNumber">230</td>
    <td class="codeline">FunctionPass *llvm::createSelectOptimizePass() { return new SelectOptimize(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline"></td>
    <td class="lineNumber">231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">bool SelectOptimize::runOnFunction(Function &F) {</td>
    <td class="lineNumber">232</td>
    <td class="codeline">bool SelectOptimize::runOnFunction(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  TM = &getAnalysis<TargetPassConfig>().getTM<TargetMachine>();</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  TM = &getAnalysis<TargetPassConfig>().getTM<TargetMachine>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">  TSI = TM->getSubtargetImpl(F);</td>
    <td class="lineNumber">234</td>
    <td class="codeline">  TSI = TM->getSubtargetImpl(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  TLI = TSI->getTargetLowering();</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  TLI = TSI->getTargetLowering();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline"></td>
    <td class="lineNumber">236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  // If none of the select types is supported then skip this pass.</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  // If none of the select types is supported then skip this pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  // This is an optimization pass. Legality issues will be handled by</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  // This is an optimization pass. Legality issues will be handled by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  // instruction selection.</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  // instruction selection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  if (!TLI->isSelectSupported(TargetLowering::ScalarValSelect) &&</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  if (!TLI->isSelectSupported(TargetLowering::ScalarValSelect) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">      !TLI->isSelectSupported(TargetLowering::ScalarCondVectorVal) &&</td>
    <td class="lineNumber">241</td>
    <td class="codeline">      !TLI->isSelectSupported(TargetLowering::ScalarCondVectorVal) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">      !TLI->isSelectSupported(TargetLowering::VectorMaskSelect))</td>
    <td class="lineNumber">242</td>
    <td class="codeline">      !TLI->isSelectSupported(TargetLowering::VectorMaskSelect))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">243</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline"></td>
    <td class="lineNumber">244</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">  TTI = &getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
    <td class="lineNumber">245</td>
    <td class="codeline">  TTI = &getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  if (!TTI->enableSelectOptimize())</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  if (!TTI->enableSelectOptimize())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">248</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline"></td>
    <td class="lineNumber">249</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  BPI.reset(new BranchProbabilityInfo(F, *LI));</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  BPI.reset(new BranchProbabilityInfo(F, *LI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  BFI.reset(new BlockFrequencyInfo(F, *BPI, *LI));</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  BFI.reset(new BlockFrequencyInfo(F, *BPI, *LI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  PSI = &getAnalysis<ProfileSummaryInfoWrapperPass>().getPSI();</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  PSI = &getAnalysis<ProfileSummaryInfoWrapperPass>().getPSI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  ORE = &getAnalysis<OptimizationRemarkEmitterWrapperPass>().getORE();</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  ORE = &getAnalysis<OptimizationRemarkEmitterWrapperPass>().getORE();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">  TSchedModel.init(TSI);</td>
    <td class="lineNumber">256</td>
    <td class="codeline">  TSchedModel.init(TSI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline"></td>
    <td class="lineNumber">257</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">  // When optimizing for size, selects are preferable over branches.</td>
    <td class="lineNumber">258</td>
    <td class="codeline">  // When optimizing for size, selects are preferable over branches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">  if (F.hasOptSize() || llvm::shouldOptimizeForSize(&F, PSI, BFI.get()))</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  if (F.hasOptSize() || llvm::shouldOptimizeForSize(&F, PSI, BFI.get()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">260</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  return optimizeSelects(F);</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  return optimizeSelects(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">}</td>
    <td class="lineNumber">263</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline"></td>
    <td class="lineNumber">264</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">bool SelectOptimize::optimizeSelects(Function &F) {</td>
    <td class="lineNumber">265</td>
    <td class="codeline">bool SelectOptimize::optimizeSelects(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  // Determine for which select groups it is profitable converting to branches.</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  // Determine for which select groups it is profitable converting to branches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  SelectGroups ProfSIGroups;</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  SelectGroups ProfSIGroups;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">  // Base heuristics apply only to non-loops and outer loops.</td>
    <td class="lineNumber">268</td>
    <td class="codeline">  // Base heuristics apply only to non-loops and outer loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  optimizeSelectsBase(F, ProfSIGroups);</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  optimizeSelectsBase(F, ProfSIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  // Separate heuristics for inner-most loops.</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  // Separate heuristics for inner-most loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  optimizeSelectsInnerLoops(F, ProfSIGroups);</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  optimizeSelectsInnerLoops(F, ProfSIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline"></td>
    <td class="lineNumber">272</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  // Convert to branches the select groups that were deemed</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  // Convert to branches the select groups that were deemed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  // profitable-to-convert.</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  // profitable-to-convert.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  convertProfitableSIGroups(ProfSIGroups);</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  convertProfitableSIGroups(ProfSIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline"></td>
    <td class="lineNumber">276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">  // Code modified if at least one select group was converted.</td>
    <td class="lineNumber">277</td>
    <td class="codeline">  // Code modified if at least one select group was converted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  return !ProfSIGroups.empty();</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  return !ProfSIGroups.empty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">}</td>
    <td class="lineNumber">279</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline"></td>
    <td class="lineNumber">280</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">void SelectOptimize::optimizeSelectsBase(Function &F,</td>
    <td class="lineNumber">281</td>
    <td class="codeline">void SelectOptimize::optimizeSelectsBase(Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">                                         SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">282</td>
    <td class="codeline">                                         SelectGroups &ProfSIGroups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  // Collect all the select groups.</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  // Collect all the select groups.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  SelectGroups SIGroups;</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  SelectGroups SIGroups;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  for (BasicBlock &BB : F) {</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  for (BasicBlock &BB : F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">    // Base heuristics apply only to non-loops and outer loops.</td>
    <td class="lineNumber">286</td>
    <td class="codeline">    // Base heuristics apply only to non-loops and outer loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">    Loop *L = LI->getLoopFor(&BB);</td>
    <td class="lineNumber">287</td>
    <td class="codeline">    Loop *L = LI->getLoopFor(&BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">    if (L && L->isInnermost())</td>
    <td class="lineNumber">288</td>
    <td class="codeline">    if (L && L->isInnermost())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">289</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">    collectSelectGroups(BB, SIGroups);</td>
    <td class="lineNumber">290</td>
    <td class="codeline">    collectSelectGroups(BB, SIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  // Determine for which select groups it is profitable converting to branches.</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  // Determine for which select groups it is profitable converting to branches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  findProfitableSIGroupsBase(SIGroups, ProfSIGroups);</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  findProfitableSIGroupsBase(SIGroups, ProfSIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">}</td>
    <td class="lineNumber">295</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline"></td>
    <td class="lineNumber">296</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">void SelectOptimize::optimizeSelectsInnerLoops(Function &F,</td>
    <td class="lineNumber">297</td>
    <td class="codeline">void SelectOptimize::optimizeSelectsInnerLoops(Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">                                               SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">298</td>
    <td class="codeline">                                               SelectGroups &ProfSIGroups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  SmallVector<Loop *, 4> Loops(LI->begin(), LI->end());</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  SmallVector<Loop *, 4> Loops(LI->begin(), LI->end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">  // Need to check size on each iteration as we accumulate child loops.</td>
    <td class="lineNumber">300</td>
    <td class="codeline">  // Need to check size on each iteration as we accumulate child loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  for (unsigned long i = 0; i < Loops.size(); ++i)</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  for (unsigned long i = 0; i < Loops.size(); ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">    for (Loop *ChildL : Loops[i]->getSubLoops())</td>
    <td class="lineNumber">302</td>
    <td class="codeline">    for (Loop *ChildL : Loops[i]->getSubLoops())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">      Loops.push_back(ChildL);</td>
    <td class="lineNumber">303</td>
    <td class="codeline">      Loops.push_back(ChildL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline"></td>
    <td class="lineNumber">304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">  for (Loop *L : Loops) {</td>
    <td class="lineNumber">305</td>
    <td class="codeline">  for (Loop *L : Loops) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">    if (!L->isInnermost())</td>
    <td class="lineNumber">306</td>
    <td class="codeline">    if (!L->isInnermost())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">307</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">    SelectGroups SIGroups;</td>
    <td class="lineNumber">309</td>
    <td class="codeline">    SelectGroups SIGroups;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">    for (BasicBlock *BB : L->getBlocks())</td>
    <td class="lineNumber">310</td>
    <td class="codeline">    for (BasicBlock *BB : L->getBlocks())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">      collectSelectGroups(*BB, SIGroups);</td>
    <td class="lineNumber">311</td>
    <td class="codeline">      collectSelectGroups(*BB, SIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline"></td>
    <td class="lineNumber">312</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">    findProfitableSIGroupsInnerLoops(L, SIGroups, ProfSIGroups);</td>
    <td class="lineNumber">313</td>
    <td class="codeline">    findProfitableSIGroupsInnerLoops(L, SIGroups, ProfSIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">314</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">}</td>
    <td class="lineNumber">315</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">/// If \p isTrue is true, return the true value of \p SI, otherwise return</td>
    <td class="lineNumber">317</td>
    <td class="codeline">/// If \p isTrue is true, return the true value of \p SI, otherwise return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">/// false value of \p SI. If the true/false value of \p SI is defined by any</td>
    <td class="lineNumber">318</td>
    <td class="codeline">/// false value of \p SI. If the true/false value of \p SI is defined by any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">/// select instructions in \p Selects, look through the defining select</td>
    <td class="lineNumber">319</td>
    <td class="codeline">/// select instructions in \p Selects, look through the defining select</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">/// instruction until the true/false value is not defined in \p Selects.</td>
    <td class="lineNumber">320</td>
    <td class="codeline">/// instruction until the true/false value is not defined in \p Selects.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">static Value *</td>
    <td class="lineNumber">321</td>
    <td class="codeline">static Value *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">getTrueOrFalseValue(SelectInst *SI, bool isTrue,</td>
    <td class="lineNumber">322</td>
    <td class="codeline">getTrueOrFalseValue(SelectInst *SI, bool isTrue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">                    const SmallPtrSet<const Instruction *, 2> &Selects) {</td>
    <td class="lineNumber">323</td>
    <td class="codeline">                    const SmallPtrSet<const Instruction *, 2> &Selects) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">  Value *V = nullptr;</td>
    <td class="lineNumber">324</td>
    <td class="codeline">  Value *V = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">  for (SelectInst *DefSI = SI; DefSI != nullptr && Selects.count(DefSI);</td>
    <td class="lineNumber">325</td>
    <td class="codeline">  for (SelectInst *DefSI = SI; DefSI != nullptr && Selects.count(DefSI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">       DefSI = dyn_cast<SelectInst>(V)) {</td>
    <td class="lineNumber">326</td>
    <td class="codeline">       DefSI = dyn_cast<SelectInst>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">    assert(DefSI->getCondition() == SI->getCondition() &&</td>
    <td class="lineNumber">327</td>
    <td class="codeline">    assert(DefSI->getCondition() == SI->getCondition() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">           "The condition of DefSI does not match with SI");</td>
    <td class="lineNumber">328</td>
    <td class="codeline">           "The condition of DefSI does not match with SI");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">    V = (isTrue ? DefSI->getTrueValue() : DefSI->getFalseValue());</td>
    <td class="lineNumber">329</td>
    <td class="codeline">    V = (isTrue ? DefSI->getTrueValue() : DefSI->getFalseValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">  assert(V && "Failed to get select true/false value");</td>
    <td class="lineNumber">331</td>
    <td class="codeline">  assert(V && "Failed to get select true/false value");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">332</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">}</td>
    <td class="lineNumber">333</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline"></td>
    <td class="lineNumber">334</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">void SelectOptimize::convertProfitableSIGroups(SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">335</td>
    <td class="codeline">void SelectOptimize::convertProfitableSIGroups(SelectGroups &ProfSIGroups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">  for (SelectGroup &ASI : ProfSIGroups) {</td>
    <td class="lineNumber">336</td>
    <td class="codeline">  for (SelectGroup &ASI : ProfSIGroups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">    // The code transformation here is a modified version of the sinking</td>
    <td class="lineNumber">337</td>
    <td class="codeline">    // The code transformation here is a modified version of the sinking</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">    // transformation in CodeGenPrepare::optimizeSelectInst with a more</td>
    <td class="lineNumber">338</td>
    <td class="codeline">    // transformation in CodeGenPrepare::optimizeSelectInst with a more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">    // aggressive strategy of which instructions to sink.</td>
    <td class="lineNumber">339</td>
    <td class="codeline">    // aggressive strategy of which instructions to sink.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">340</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">    // TODO: eliminate the redundancy of logic transforming selects to branches</td>
    <td class="lineNumber">341</td>
    <td class="codeline">    // TODO: eliminate the redundancy of logic transforming selects to branches</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">    // by removing CodeGenPrepare::optimizeSelectInst and optimizing here</td>
    <td class="lineNumber">342</td>
    <td class="codeline">    // by removing CodeGenPrepare::optimizeSelectInst and optimizing here</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">    // selects for all cases (with and without profile information).</td>
    <td class="lineNumber">343</td>
    <td class="codeline">    // selects for all cases (with and without profile information).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">    // Transform a sequence like this:</td>
    <td class="lineNumber">345</td>
    <td class="codeline">    // Transform a sequence like this:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">    //    start:</td>
    <td class="lineNumber">346</td>
    <td class="codeline">    //    start:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">    //       %cmp = cmp uge i32 %a, %b</td>
    <td class="lineNumber">347</td>
    <td class="codeline">    //       %cmp = cmp uge i32 %a, %b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">    //       %sel = select i1 %cmp, i32 %c, i32 %d</td>
    <td class="lineNumber">348</td>
    <td class="codeline">    //       %sel = select i1 %cmp, i32 %c, i32 %d</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">349</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">    // Into:</td>
    <td class="lineNumber">350</td>
    <td class="codeline">    // Into:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">    //    start:</td>
    <td class="lineNumber">351</td>
    <td class="codeline">    //    start:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">    //       %cmp = cmp uge i32 %a, %b</td>
    <td class="lineNumber">352</td>
    <td class="codeline">    //       %cmp = cmp uge i32 %a, %b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">    //       %cmp.frozen = freeze %cmp</td>
    <td class="lineNumber">353</td>
    <td class="codeline">    //       %cmp.frozen = freeze %cmp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">    //       br i1 %cmp.frozen, label %select.true, label %select.false</td>
    <td class="lineNumber">354</td>
    <td class="codeline">    //       br i1 %cmp.frozen, label %select.true, label %select.false</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">    //    select.true:</td>
    <td class="lineNumber">355</td>
    <td class="codeline">    //    select.true:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">    //       br label %select.end</td>
    <td class="lineNumber">356</td>
    <td class="codeline">    //       br label %select.end</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">    //    select.false:</td>
    <td class="lineNumber">357</td>
    <td class="codeline">    //    select.false:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">    //       br label %select.end</td>
    <td class="lineNumber">358</td>
    <td class="codeline">    //       br label %select.end</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">    //    select.end:</td>
    <td class="lineNumber">359</td>
    <td class="codeline">    //    select.end:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">    //       %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]</td>
    <td class="lineNumber">360</td>
    <td class="codeline">    //       %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">361</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">    // %cmp should be frozen, otherwise it may introduce undefined behavior.</td>
    <td class="lineNumber">362</td>
    <td class="codeline">    // %cmp should be frozen, otherwise it may introduce undefined behavior.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">    // In addition, we may sink instructions that produce %c or %d into the</td>
    <td class="lineNumber">363</td>
    <td class="codeline">    // In addition, we may sink instructions that produce %c or %d into the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">    // destination(s) of the new branch.</td>
    <td class="lineNumber">364</td>
    <td class="codeline">    // destination(s) of the new branch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">    // If the true or false blocks do not contain a sunken instruction, that</td>
    <td class="lineNumber">365</td>
    <td class="codeline">    // If the true or false blocks do not contain a sunken instruction, that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">    // block and its branch may be optimized away. In that case, one side of the</td>
    <td class="lineNumber">366</td>
    <td class="codeline">    // block and its branch may be optimized away. In that case, one side of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">    // first branch will point directly to select.end, and the corresponding PHI</td>
    <td class="lineNumber">367</td>
    <td class="codeline">    // first branch will point directly to select.end, and the corresponding PHI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">    // predecessor block will be the start block.</td>
    <td class="lineNumber">368</td>
    <td class="codeline">    // predecessor block will be the start block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">    // Find all the instructions that can be soundly sunk to the true/false</td>
    <td class="lineNumber">370</td>
    <td class="codeline">    // Find all the instructions that can be soundly sunk to the true/false</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">    // blocks. These are instructions that are computed solely for producing the</td>
    <td class="lineNumber">371</td>
    <td class="codeline">    // blocks. These are instructions that are computed solely for producing the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">    // operands of the select instructions in the group and can be sunk without</td>
    <td class="lineNumber">372</td>
    <td class="codeline">    // operands of the select instructions in the group and can be sunk without</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">    // breaking the semantics of the LLVM IR (e.g., cannot sink instructions</td>
    <td class="lineNumber">373</td>
    <td class="codeline">    // breaking the semantics of the LLVM IR (e.g., cannot sink instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">    // with side effects).</td>
    <td class="lineNumber">374</td>
    <td class="codeline">    // with side effects).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">    SmallVector<std::stack<Instruction *>, 2> TrueSlices, FalseSlices;</td>
    <td class="lineNumber">375</td>
    <td class="codeline">    SmallVector<std::stack<Instruction *>, 2> TrueSlices, FalseSlices;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">    typedef std::stack<Instruction *>::size_type StackSizeType;</td>
    <td class="lineNumber">376</td>
    <td class="codeline">    typedef std::stack<Instruction *>::size_type StackSizeType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">    StackSizeType maxTrueSliceLen = 0, maxFalseSliceLen = 0;</td>
    <td class="lineNumber">377</td>
    <td class="codeline">    StackSizeType maxTrueSliceLen = 0, maxFalseSliceLen = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">    for (SelectInst *SI : ASI) {</td>
    <td class="lineNumber">378</td>
    <td class="codeline">    for (SelectInst *SI : ASI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">      // For each select, compute the sinkable dependence chains of the true and</td>
    <td class="lineNumber">379</td>
    <td class="codeline">      // For each select, compute the sinkable dependence chains of the true and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">      // false operands.</td>
    <td class="lineNumber">380</td>
    <td class="codeline">      // false operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">      if (auto *TI = dyn_cast<Instruction>(SI->getTrueValue())) {</td>
    <td class="lineNumber">381</td>
    <td class="codeline">      if (auto *TI = dyn_cast<Instruction>(SI->getTrueValue())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">        std::stack<Instruction *> TrueSlice;</td>
    <td class="lineNumber">382</td>
    <td class="codeline">        std::stack<Instruction *> TrueSlice;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">        getExclBackwardsSlice(TI, TrueSlice, SI, true);</td>
    <td class="lineNumber">383</td>
    <td class="codeline">        getExclBackwardsSlice(TI, TrueSlice, SI, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">        maxTrueSliceLen = std::max(maxTrueSliceLen, TrueSlice.size());</td>
    <td class="lineNumber">384</td>
    <td class="codeline">        maxTrueSliceLen = std::max(maxTrueSliceLen, TrueSlice.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">        TrueSlices.push_back(TrueSlice);</td>
    <td class="lineNumber">385</td>
    <td class="codeline">        TrueSlices.push_back(TrueSlice);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">386</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">      if (auto *FI = dyn_cast<Instruction>(SI->getFalseValue())) {</td>
    <td class="lineNumber">387</td>
    <td class="codeline">      if (auto *FI = dyn_cast<Instruction>(SI->getFalseValue())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">        std::stack<Instruction *> FalseSlice;</td>
    <td class="lineNumber">388</td>
    <td class="codeline">        std::stack<Instruction *> FalseSlice;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">        getExclBackwardsSlice(FI, FalseSlice, SI, true);</td>
    <td class="lineNumber">389</td>
    <td class="codeline">        getExclBackwardsSlice(FI, FalseSlice, SI, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">        maxFalseSliceLen = std::max(maxFalseSliceLen, FalseSlice.size());</td>
    <td class="lineNumber">390</td>
    <td class="codeline">        maxFalseSliceLen = std::max(maxFalseSliceLen, FalseSlice.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">        FalseSlices.push_back(FalseSlice);</td>
    <td class="lineNumber">391</td>
    <td class="codeline">        FalseSlices.push_back(FalseSlice);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">392</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">393</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">    // In the case of multiple select instructions in the same group, the order</td>
    <td class="lineNumber">394</td>
    <td class="codeline">    // In the case of multiple select instructions in the same group, the order</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">    // of non-dependent instructions (instructions of different dependence</td>
    <td class="lineNumber">395</td>
    <td class="codeline">    // of non-dependent instructions (instructions of different dependence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">    // slices) in the true/false blocks appears to affect performance.</td>
    <td class="lineNumber">396</td>
    <td class="codeline">    // slices) in the true/false blocks appears to affect performance.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">    // Interleaving the slices seems to experimentally be the optimal approach.</td>
    <td class="lineNumber">397</td>
    <td class="codeline">    // Interleaving the slices seems to experimentally be the optimal approach.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">    // This interleaving scheduling allows for more ILP (with a natural downside</td>
    <td class="lineNumber">398</td>
    <td class="codeline">    // This interleaving scheduling allows for more ILP (with a natural downside</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">    // of increasing a bit register pressure) compared to a simple ordering of</td>
    <td class="lineNumber">399</td>
    <td class="codeline">    // of increasing a bit register pressure) compared to a simple ordering of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">    // one whole chain after another. One would expect that this ordering would</td>
    <td class="lineNumber">400</td>
    <td class="codeline">    // one whole chain after another. One would expect that this ordering would</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">    // not matter since the scheduling in the backend of the compiler  would</td>
    <td class="lineNumber">401</td>
    <td class="codeline">    // not matter since the scheduling in the backend of the compiler  would</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">    // take care of it, but apparently the scheduler fails to deliver optimal</td>
    <td class="lineNumber">402</td>
    <td class="codeline">    // take care of it, but apparently the scheduler fails to deliver optimal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">    // ILP with a naive ordering here.</td>
    <td class="lineNumber">403</td>
    <td class="codeline">    // ILP with a naive ordering here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">    SmallVector<Instruction *, 2> TrueSlicesInterleaved, FalseSlicesInterleaved;</td>
    <td class="lineNumber">404</td>
    <td class="codeline">    SmallVector<Instruction *, 2> TrueSlicesInterleaved, FalseSlicesInterleaved;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">    for (StackSizeType IS = 0; IS < maxTrueSliceLen; ++IS) {</td>
    <td class="lineNumber">405</td>
    <td class="codeline">    for (StackSizeType IS = 0; IS < maxTrueSliceLen; ++IS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">      for (auto &S : TrueSlices) {</td>
    <td class="lineNumber">406</td>
    <td class="codeline">      for (auto &S : TrueSlices) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">        if (!S.empty()) {</td>
    <td class="lineNumber">407</td>
    <td class="codeline">        if (!S.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">          TrueSlicesInterleaved.push_back(S.top());</td>
    <td class="lineNumber">408</td>
    <td class="codeline">          TrueSlicesInterleaved.push_back(S.top());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">          S.pop();</td>
    <td class="lineNumber">409</td>
    <td class="codeline">          S.pop();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">410</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">411</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">412</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">    for (StackSizeType IS = 0; IS < maxFalseSliceLen; ++IS) {</td>
    <td class="lineNumber">413</td>
    <td class="codeline">    for (StackSizeType IS = 0; IS < maxFalseSliceLen; ++IS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">      for (auto &S : FalseSlices) {</td>
    <td class="lineNumber">414</td>
    <td class="codeline">      for (auto &S : FalseSlices) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">        if (!S.empty()) {</td>
    <td class="lineNumber">415</td>
    <td class="codeline">        if (!S.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">          FalseSlicesInterleaved.push_back(S.top());</td>
    <td class="lineNumber">416</td>
    <td class="codeline">          FalseSlicesInterleaved.push_back(S.top());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">          S.pop();</td>
    <td class="lineNumber">417</td>
    <td class="codeline">          S.pop();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">418</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">419</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">420</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline"></td>
    <td class="lineNumber">421</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">    // We split the block containing the select(s) into two blocks.</td>
    <td class="lineNumber">422</td>
    <td class="codeline">    // We split the block containing the select(s) into two blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">    SelectInst *SI = ASI.front();</td>
    <td class="lineNumber">423</td>
    <td class="codeline">    SelectInst *SI = ASI.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">    SelectInst *LastSI = ASI.back();</td>
    <td class="lineNumber">424</td>
    <td class="codeline">    SelectInst *LastSI = ASI.back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">    BasicBlock *StartBlock = SI->getParent();</td>
    <td class="lineNumber">425</td>
    <td class="codeline">    BasicBlock *StartBlock = SI->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">    BasicBlock::iterator SplitPt = ++(BasicBlock::iterator(LastSI));</td>
    <td class="lineNumber">426</td>
    <td class="codeline">    BasicBlock::iterator SplitPt = ++(BasicBlock::iterator(LastSI));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">    BasicBlock *EndBlock = StartBlock->splitBasicBlock(SplitPt, "select.end");</td>
    <td class="lineNumber">427</td>
    <td class="codeline">    BasicBlock *EndBlock = StartBlock->splitBasicBlock(SplitPt, "select.end");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">    BFI->setBlockFreq(EndBlock, BFI->getBlockFreq(StartBlock).getFrequency());</td>
    <td class="lineNumber">428</td>
    <td class="codeline">    BFI->setBlockFreq(EndBlock, BFI->getBlockFreq(StartBlock).getFrequency());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">    // Delete the unconditional branch that was just created by the split.</td>
    <td class="lineNumber">429</td>
    <td class="codeline">    // Delete the unconditional branch that was just created by the split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">    StartBlock->getTerminator()->eraseFromParent();</td>
    <td class="lineNumber">430</td>
    <td class="codeline">    StartBlock->getTerminator()->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline"></td>
    <td class="lineNumber">431</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">    // Move any debug/pseudo instructions that were in-between the select</td>
    <td class="lineNumber">432</td>
    <td class="codeline">    // Move any debug/pseudo instructions that were in-between the select</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">    // group to the newly-created end block.</td>
    <td class="lineNumber">433</td>
    <td class="codeline">    // group to the newly-created end block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">    SmallVector<Instruction *, 2> DebugPseudoINS;</td>
    <td class="lineNumber">434</td>
    <td class="codeline">    SmallVector<Instruction *, 2> DebugPseudoINS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">    auto DIt = SI->getIterator();</td>
    <td class="lineNumber">435</td>
    <td class="codeline">    auto DIt = SI->getIterator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">    while (&*DIt != LastSI) {</td>
    <td class="lineNumber">436</td>
    <td class="codeline">    while (&*DIt != LastSI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">      if (DIt->isDebugOrPseudoInst())</td>
    <td class="lineNumber">437</td>
    <td class="codeline">      if (DIt->isDebugOrPseudoInst())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">        DebugPseudoINS.push_back(&*DIt);</td>
    <td class="lineNumber">438</td>
    <td class="codeline">        DebugPseudoINS.push_back(&*DIt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">      DIt++;</td>
    <td class="lineNumber">439</td>
    <td class="codeline">      DIt++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">440</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">    for (auto *DI : DebugPseudoINS) {</td>
    <td class="lineNumber">441</td>
    <td class="codeline">    for (auto *DI : DebugPseudoINS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">      DI->moveBefore(&*EndBlock->getFirstInsertionPt());</td>
    <td class="lineNumber">442</td>
    <td class="codeline">      DI->moveBefore(&*EndBlock->getFirstInsertionPt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">443</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline"></td>
    <td class="lineNumber">444</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">    // These are the new basic blocks for the conditional branch.</td>
    <td class="lineNumber">445</td>
    <td class="codeline">    // These are the new basic blocks for the conditional branch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">    // At least one will become an actual new basic block.</td>
    <td class="lineNumber">446</td>
    <td class="codeline">    // At least one will become an actual new basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">    BasicBlock *TrueBlock = nullptr, *FalseBlock = nullptr;</td>
    <td class="lineNumber">447</td>
    <td class="codeline">    BasicBlock *TrueBlock = nullptr, *FalseBlock = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">    BranchInst *TrueBranch = nullptr, *FalseBranch = nullptr;</td>
    <td class="lineNumber">448</td>
    <td class="codeline">    BranchInst *TrueBranch = nullptr, *FalseBranch = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">    if (!TrueSlicesInterleaved.empty()) {</td>
    <td class="lineNumber">449</td>
    <td class="codeline">    if (!TrueSlicesInterleaved.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">      TrueBlock = BasicBlock::Create(LastSI->getContext(), "select.true.sink",</td>
    <td class="lineNumber">450</td>
    <td class="codeline">      TrueBlock = BasicBlock::Create(LastSI->getContext(), "select.true.sink",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">                                     EndBlock->getParent(), EndBlock);</td>
    <td class="lineNumber">451</td>
    <td class="codeline">                                     EndBlock->getParent(), EndBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">      TrueBranch = BranchInst::Create(EndBlock, TrueBlock);</td>
    <td class="lineNumber">452</td>
    <td class="codeline">      TrueBranch = BranchInst::Create(EndBlock, TrueBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">      TrueBranch->setDebugLoc(LastSI->getDebugLoc());</td>
    <td class="lineNumber">453</td>
    <td class="codeline">      TrueBranch->setDebugLoc(LastSI->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">      for (Instruction *TrueInst : TrueSlicesInterleaved)</td>
    <td class="lineNumber">454</td>
    <td class="codeline">      for (Instruction *TrueInst : TrueSlicesInterleaved)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">        TrueInst->moveBefore(TrueBranch);</td>
    <td class="lineNumber">455</td>
    <td class="codeline">        TrueInst->moveBefore(TrueBranch);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">456</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">    if (!FalseSlicesInterleaved.empty()) {</td>
    <td class="lineNumber">457</td>
    <td class="codeline">    if (!FalseSlicesInterleaved.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">      FalseBlock = BasicBlock::Create(LastSI->getContext(), "select.false.sink",</td>
    <td class="lineNumber">458</td>
    <td class="codeline">      FalseBlock = BasicBlock::Create(LastSI->getContext(), "select.false.sink",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">                                      EndBlock->getParent(), EndBlock);</td>
    <td class="lineNumber">459</td>
    <td class="codeline">                                      EndBlock->getParent(), EndBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">      FalseBranch = BranchInst::Create(EndBlock, FalseBlock);</td>
    <td class="lineNumber">460</td>
    <td class="codeline">      FalseBranch = BranchInst::Create(EndBlock, FalseBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">      FalseBranch->setDebugLoc(LastSI->getDebugLoc());</td>
    <td class="lineNumber">461</td>
    <td class="codeline">      FalseBranch->setDebugLoc(LastSI->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">      for (Instruction *FalseInst : FalseSlicesInterleaved)</td>
    <td class="lineNumber">462</td>
    <td class="codeline">      for (Instruction *FalseInst : FalseSlicesInterleaved)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">        FalseInst->moveBefore(FalseBranch);</td>
    <td class="lineNumber">463</td>
    <td class="codeline">        FalseInst->moveBefore(FalseBranch);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">464</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">    // If there was nothing to sink, then arbitrarily choose the 'false' side</td>
    <td class="lineNumber">465</td>
    <td class="codeline">    // If there was nothing to sink, then arbitrarily choose the 'false' side</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">    // for a new input value to the PHI.</td>
    <td class="lineNumber">466</td>
    <td class="codeline">    // for a new input value to the PHI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">    if (TrueBlock == FalseBlock) {</td>
    <td class="lineNumber">467</td>
    <td class="codeline">    if (TrueBlock == FalseBlock) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">      assert(TrueBlock == nullptr &&</td>
    <td class="lineNumber">468</td>
    <td class="codeline">      assert(TrueBlock == nullptr &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">             "Unexpected basic block transform while optimizing select");</td>
    <td class="lineNumber">469</td>
    <td class="codeline">             "Unexpected basic block transform while optimizing select");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline"></td>
    <td class="lineNumber">470</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">      FalseBlock = BasicBlock::Create(SI->getContext(), "select.false",</td>
    <td class="lineNumber">471</td>
    <td class="codeline">      FalseBlock = BasicBlock::Create(SI->getContext(), "select.false",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">                                      EndBlock->getParent(), EndBlock);</td>
    <td class="lineNumber">472</td>
    <td class="codeline">                                      EndBlock->getParent(), EndBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">      auto *FalseBranch = BranchInst::Create(EndBlock, FalseBlock);</td>
    <td class="lineNumber">473</td>
    <td class="codeline">      auto *FalseBranch = BranchInst::Create(EndBlock, FalseBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">      FalseBranch->setDebugLoc(SI->getDebugLoc());</td>
    <td class="lineNumber">474</td>
    <td class="codeline">      FalseBranch->setDebugLoc(SI->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">475</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline"></td>
    <td class="lineNumber">476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">    // Insert the real conditional branch based on the original condition.</td>
    <td class="lineNumber">477</td>
    <td class="codeline">    // Insert the real conditional branch based on the original condition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">    // If we did not create a new block for one of the 'true' or 'false' paths</td>
    <td class="lineNumber">478</td>
    <td class="codeline">    // If we did not create a new block for one of the 'true' or 'false' paths</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">    // of the condition, it means that side of the branch goes to the end block</td>
    <td class="lineNumber">479</td>
    <td class="codeline">    // of the condition, it means that side of the branch goes to the end block</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">    // directly and the path originates from the start block from the point of</td>
    <td class="lineNumber">480</td>
    <td class="codeline">    // directly and the path originates from the start block from the point of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">    // view of the new PHI.</td>
    <td class="lineNumber">481</td>
    <td class="codeline">    // view of the new PHI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">    BasicBlock *TT, *FT;</td>
    <td class="lineNumber">482</td>
    <td class="codeline">    BasicBlock *TT, *FT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">    if (TrueBlock == nullptr) {</td>
    <td class="lineNumber">483</td>
    <td class="codeline">    if (TrueBlock == nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">      TT = EndBlock;</td>
    <td class="lineNumber">484</td>
    <td class="codeline">      TT = EndBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">      FT = FalseBlock;</td>
    <td class="lineNumber">485</td>
    <td class="codeline">      FT = FalseBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">      TrueBlock = StartBlock;</td>
    <td class="lineNumber">486</td>
    <td class="codeline">      TrueBlock = StartBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">    } else if (FalseBlock == nullptr) {</td>
    <td class="lineNumber">487</td>
    <td class="codeline">    } else if (FalseBlock == nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">      TT = TrueBlock;</td>
    <td class="lineNumber">488</td>
    <td class="codeline">      TT = TrueBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">      FT = EndBlock;</td>
    <td class="lineNumber">489</td>
    <td class="codeline">      FT = EndBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">      FalseBlock = StartBlock;</td>
    <td class="lineNumber">490</td>
    <td class="codeline">      FalseBlock = StartBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">491</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">      TT = TrueBlock;</td>
    <td class="lineNumber">492</td>
    <td class="codeline">      TT = TrueBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">      FT = FalseBlock;</td>
    <td class="lineNumber">493</td>
    <td class="codeline">      FT = FalseBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">494</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">    IRBuilder<> IB(SI);</td>
    <td class="lineNumber">495</td>
    <td class="codeline">    IRBuilder<> IB(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">    auto *CondFr =</td>
    <td class="lineNumber">496</td>
    <td class="codeline">    auto *CondFr =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">        IB.CreateFreeze(SI->getCondition(), SI->getName() + ".frozen");</td>
    <td class="lineNumber">497</td>
    <td class="codeline">        IB.CreateFreeze(SI->getCondition(), SI->getName() + ".frozen");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">    IB.CreateCondBr(CondFr, TT, FT, SI);</td>
    <td class="lineNumber">498</td>
    <td class="codeline">    IB.CreateCondBr(CondFr, TT, FT, SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline"></td>
    <td class="lineNumber">499</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">    SmallPtrSet<const Instruction *, 2> INS;</td>
    <td class="lineNumber">500</td>
    <td class="codeline">    SmallPtrSet<const Instruction *, 2> INS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">    INS.insert(ASI.begin(), ASI.end());</td>
    <td class="lineNumber">501</td>
    <td class="codeline">    INS.insert(ASI.begin(), ASI.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">    // Use reverse iterator because later select may use the value of the</td>
    <td class="lineNumber">502</td>
    <td class="codeline">    // Use reverse iterator because later select may use the value of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">    // earlier select, and we need to propagate value through earlier select</td>
    <td class="lineNumber">503</td>
    <td class="codeline">    // earlier select, and we need to propagate value through earlier select</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">    // to get the PHI operand.</td>
    <td class="lineNumber">504</td>
    <td class="codeline">    // to get the PHI operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">    for (auto It = ASI.rbegin(); It != ASI.rend(); ++It) {</td>
    <td class="lineNumber">505</td>
    <td class="codeline">    for (auto It = ASI.rbegin(); It != ASI.rend(); ++It) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">      SelectInst *SI = *It;</td>
    <td class="lineNumber">506</td>
    <td class="codeline">      SelectInst *SI = *It;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">      // The select itself is replaced with a PHI Node.</td>
    <td class="lineNumber">507</td>
    <td class="codeline">      // The select itself is replaced with a PHI Node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">      PHINode *PN = PHINode::Create(SI->getType(), 2, "", &EndBlock->front());</td>
    <td class="lineNumber">508</td>
    <td class="codeline">      PHINode *PN = PHINode::Create(SI->getType(), 2, "", &EndBlock->front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">      PN->takeName(SI);</td>
    <td class="lineNumber">509</td>
    <td class="codeline">      PN->takeName(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">      PN->addIncoming(getTrueOrFalseValue(SI, true, INS), TrueBlock);</td>
    <td class="lineNumber">510</td>
    <td class="codeline">      PN->addIncoming(getTrueOrFalseValue(SI, true, INS), TrueBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">      PN->addIncoming(getTrueOrFalseValue(SI, false, INS), FalseBlock);</td>
    <td class="lineNumber">511</td>
    <td class="codeline">      PN->addIncoming(getTrueOrFalseValue(SI, false, INS), FalseBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">      PN->setDebugLoc(SI->getDebugLoc());</td>
    <td class="lineNumber">512</td>
    <td class="codeline">      PN->setDebugLoc(SI->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">      SI->replaceAllUsesWith(PN);</td>
    <td class="lineNumber">514</td>
    <td class="codeline">      SI->replaceAllUsesWith(PN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">      SI->eraseFromParent();</td>
    <td class="lineNumber">515</td>
    <td class="codeline">      SI->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">      INS.erase(SI);</td>
    <td class="lineNumber">516</td>
    <td class="codeline">      INS.erase(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">      ++NumSelectsConverted;</td>
    <td class="lineNumber">517</td>
    <td class="codeline">      ++NumSelectsConverted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">518</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">}</td>
    <td class="lineNumber">520</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline"></td>
    <td class="lineNumber">521</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">static bool isSpecialSelect(SelectInst *SI) {</td>
    <td class="lineNumber">522</td>
    <td class="codeline">static bool isSpecialSelect(SelectInst *SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  using namespace llvm::PatternMatch;</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  using namespace llvm::PatternMatch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline"></td>
    <td class="lineNumber">524</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  // If the select is a logical-and/logical-or then it is better treated as a</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  // If the select is a logical-and/logical-or then it is better treated as a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">  // and/or by the backend.</td>
    <td class="lineNumber">526</td>
    <td class="codeline">  // and/or by the backend.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  if (match(SI, m_CombineOr(m_LogicalAnd(m_Value(), m_Value()),</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  if (match(SI, m_CombineOr(m_LogicalAnd(m_Value(), m_Value()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">                            m_LogicalOr(m_Value(), m_Value()))))</td>
    <td class="lineNumber">528</td>
    <td class="codeline">                            m_LogicalOr(m_Value(), m_Value()))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">529</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline"></td>
    <td class="lineNumber">530</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">531</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">}</td>
    <td class="lineNumber">532</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">void SelectOptimize::collectSelectGroups(BasicBlock &BB,</td>
    <td class="lineNumber">534</td>
    <td class="codeline">void SelectOptimize::collectSelectGroups(BasicBlock &BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">                                         SelectGroups &SIGroups) {</td>
    <td class="lineNumber">535</td>
    <td class="codeline">                                         SelectGroups &SIGroups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  BasicBlock::iterator BBIt = BB.begin();</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  BasicBlock::iterator BBIt = BB.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  while (BBIt != BB.end()) {</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  while (BBIt != BB.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">    Instruction *I = &*BBIt++;</td>
    <td class="lineNumber">538</td>
    <td class="codeline">    Instruction *I = &*BBIt++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">    if (SelectInst *SI = dyn_cast<SelectInst>(I)) {</td>
    <td class="lineNumber">539</td>
    <td class="codeline">    if (SelectInst *SI = dyn_cast<SelectInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">      if (isSpecialSelect(SI))</td>
    <td class="lineNumber">540</td>
    <td class="codeline">      if (isSpecialSelect(SI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">541</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline"></td>
    <td class="lineNumber">542</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">      SelectGroup SIGroup;</td>
    <td class="lineNumber">543</td>
    <td class="codeline">      SelectGroup SIGroup;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">      SIGroup.push_back(SI);</td>
    <td class="lineNumber">544</td>
    <td class="codeline">      SIGroup.push_back(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">      while (BBIt != BB.end()) {</td>
    <td class="lineNumber">545</td>
    <td class="codeline">      while (BBIt != BB.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">        Instruction *NI = &*BBIt;</td>
    <td class="lineNumber">546</td>
    <td class="codeline">        Instruction *NI = &*BBIt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">        SelectInst *NSI = dyn_cast<SelectInst>(NI);</td>
    <td class="lineNumber">547</td>
    <td class="codeline">        SelectInst *NSI = dyn_cast<SelectInst>(NI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">        if (NSI && SI->getCondition() == NSI->getCondition()) {</td>
    <td class="lineNumber">548</td>
    <td class="codeline">        if (NSI && SI->getCondition() == NSI->getCondition()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">          SIGroup.push_back(NSI);</td>
    <td class="lineNumber">549</td>
    <td class="codeline">          SIGroup.push_back(NSI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">        } else if (!NI->isDebugOrPseudoInst()) {</td>
    <td class="lineNumber">550</td>
    <td class="codeline">        } else if (!NI->isDebugOrPseudoInst()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">          // Debug/pseudo instructions should be skipped and not prevent the</td>
    <td class="lineNumber">551</td>
    <td class="codeline">          // Debug/pseudo instructions should be skipped and not prevent the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">          // formation of a select group.</td>
    <td class="lineNumber">552</td>
    <td class="codeline">          // formation of a select group.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">553</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">554</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">        ++BBIt;</td>
    <td class="lineNumber">555</td>
    <td class="codeline">        ++BBIt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">556</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline"></td>
    <td class="lineNumber">557</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">      // If the select type is not supported, no point optimizing it.</td>
    <td class="lineNumber">558</td>
    <td class="codeline">      // If the select type is not supported, no point optimizing it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">      // Instruction selection will take care of it.</td>
    <td class="lineNumber">559</td>
    <td class="codeline">      // Instruction selection will take care of it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">      if (!isSelectKindSupported(SI))</td>
    <td class="lineNumber">560</td>
    <td class="codeline">      if (!isSelectKindSupported(SI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">561</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline"></td>
    <td class="lineNumber">562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">      SIGroups.push_back(SIGroup);</td>
    <td class="lineNumber">563</td>
    <td class="codeline">      SIGroups.push_back(SIGroup);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">564</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">565</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">}</td>
    <td class="lineNumber">566</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline"></td>
    <td class="lineNumber">567</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">void SelectOptimize::findProfitableSIGroupsBase(SelectGroups &SIGroups,</td>
    <td class="lineNumber">568</td>
    <td class="codeline">void SelectOptimize::findProfitableSIGroupsBase(SelectGroups &SIGroups,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">                                                SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">569</td>
    <td class="codeline">                                                SelectGroups &ProfSIGroups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">  for (SelectGroup &ASI : SIGroups) {</td>
    <td class="lineNumber">570</td>
    <td class="codeline">  for (SelectGroup &ASI : SIGroups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">    ++NumSelectOptAnalyzed;</td>
    <td class="lineNumber">571</td>
    <td class="codeline">    ++NumSelectOptAnalyzed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">    if (isConvertToBranchProfitableBase(ASI))</td>
    <td class="lineNumber">572</td>
    <td class="codeline">    if (isConvertToBranchProfitableBase(ASI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">      ProfSIGroups.push_back(ASI);</td>
    <td class="lineNumber">573</td>
    <td class="codeline">      ProfSIGroups.push_back(ASI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">574</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">}</td>
    <td class="lineNumber">575</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline"></td>
    <td class="lineNumber">576</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">static void EmitAndPrintRemark(OptimizationRemarkEmitter *ORE,</td>
    <td class="lineNumber">577</td>
    <td class="codeline">static void EmitAndPrintRemark(OptimizationRemarkEmitter *ORE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">                               DiagnosticInfoOptimizationBase &Rem) {</td>
    <td class="lineNumber">578</td>
    <td class="codeline">                               DiagnosticInfoOptimizationBase &Rem) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << Rem.getMsg() << "\n");</td>
    <td class="lineNumber">579</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << Rem.getMsg() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">  ORE->emit(Rem);</td>
    <td class="lineNumber">580</td>
    <td class="codeline">  ORE->emit(Rem);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">}</td>
    <td class="lineNumber">581</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">void SelectOptimize::findProfitableSIGroupsInnerLoops(</td>
    <td class="lineNumber">583</td>
    <td class="codeline">void SelectOptimize::findProfitableSIGroupsInnerLoops(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">    const Loop *L, SelectGroups &SIGroups, SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">584</td>
    <td class="codeline">    const Loop *L, SelectGroups &SIGroups, SelectGroups &ProfSIGroups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  NumSelectOptAnalyzed += SIGroups.size();</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  NumSelectOptAnalyzed += SIGroups.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">  // For each select group in an inner-most loop,</td>
    <td class="lineNumber">586</td>
    <td class="codeline">  // For each select group in an inner-most loop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">  // a branch is more preferable than a select/conditional-move if:</td>
    <td class="lineNumber">587</td>
    <td class="codeline">  // a branch is more preferable than a select/conditional-move if:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">  // i) conversion to branches for all the select groups of the loop satisfies</td>
    <td class="lineNumber">588</td>
    <td class="codeline">  // i) conversion to branches for all the select groups of the loop satisfies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">  //    loop-level heuristics including reducing the loop's critical path by</td>
    <td class="lineNumber">589</td>
    <td class="codeline">  //    loop-level heuristics including reducing the loop's critical path by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">  //    some threshold (see SelectOptimize::checkLoopHeuristics); and</td>
    <td class="lineNumber">590</td>
    <td class="codeline">  //    some threshold (see SelectOptimize::checkLoopHeuristics); and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">  // ii) the total cost of the select group is cheaper with a branch compared</td>
    <td class="lineNumber">591</td>
    <td class="codeline">  // ii) the total cost of the select group is cheaper with a branch compared</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">  //     to its predicated version. The cost is in terms of latency and the cost</td>
    <td class="lineNumber">592</td>
    <td class="codeline">  //     to its predicated version. The cost is in terms of latency and the cost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">  //     of a select group is the cost of its most expensive select instruction</td>
    <td class="lineNumber">593</td>
    <td class="codeline">  //     of a select group is the cost of its most expensive select instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">  //     (assuming infinite resources and thus fully leveraging available ILP).</td>
    <td class="lineNumber">594</td>
    <td class="codeline">  //     (assuming infinite resources and thus fully leveraging available ILP).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline"></td>
    <td class="lineNumber">595</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  DenseMap<const Instruction *, CostInfo> InstCostMap;</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  DenseMap<const Instruction *, CostInfo> InstCostMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">  CostInfo LoopCost[2] = {{Scaled64::getZero(), Scaled64::getZero()},</td>
    <td class="lineNumber">597</td>
    <td class="codeline">  CostInfo LoopCost[2] = {{Scaled64::getZero(), Scaled64::getZero()},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">                          {Scaled64::getZero(), Scaled64::getZero()}};</td>
    <td class="lineNumber">598</td>
    <td class="codeline">                          {Scaled64::getZero(), Scaled64::getZero()}};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  if (!computeLoopCosts(L, SIGroups, InstCostMap, LoopCost) ||</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  if (!computeLoopCosts(L, SIGroups, InstCostMap, LoopCost) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">      !checkLoopHeuristics(L, LoopCost)) {</td>
    <td class="lineNumber">600</td>
    <td class="codeline">      !checkLoopHeuristics(L, LoopCost)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">601</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">602</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline"></td>
    <td class="lineNumber">603</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  for (SelectGroup &ASI : SIGroups) {</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  for (SelectGroup &ASI : SIGroups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">    // Assuming infinite resources, the cost of a group of instructions is the</td>
    <td class="lineNumber">605</td>
    <td class="codeline">    // Assuming infinite resources, the cost of a group of instructions is the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">    // cost of the most expensive instruction of the group.</td>
    <td class="lineNumber">606</td>
    <td class="codeline">    // cost of the most expensive instruction of the group.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">    Scaled64 SelectCost = Scaled64::getZero(), BranchCost = Scaled64::getZero();</td>
    <td class="lineNumber">607</td>
    <td class="codeline">    Scaled64 SelectCost = Scaled64::getZero(), BranchCost = Scaled64::getZero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">    for (SelectInst *SI : ASI) {</td>
    <td class="lineNumber">608</td>
    <td class="codeline">    for (SelectInst *SI : ASI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">      SelectCost = std::max(SelectCost, InstCostMap[SI].PredCost);</td>
    <td class="lineNumber">609</td>
    <td class="codeline">      SelectCost = std::max(SelectCost, InstCostMap[SI].PredCost);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">      BranchCost = std::max(BranchCost, InstCostMap[SI].NonPredCost);</td>
    <td class="lineNumber">610</td>
    <td class="codeline">      BranchCost = std::max(BranchCost, InstCostMap[SI].NonPredCost);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">611</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">    if (BranchCost < SelectCost) {</td>
    <td class="lineNumber">612</td>
    <td class="codeline">    if (BranchCost < SelectCost) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">      OptimizationRemark OR(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
    <td class="lineNumber">613</td>
    <td class="codeline">      OptimizationRemark OR(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">      OR << "Profitable to convert to branch (loop analysis). BranchCost="</td>
    <td class="lineNumber">614</td>
    <td class="codeline">      OR << "Profitable to convert to branch (loop analysis). BranchCost="</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">         << BranchCost.toString() << ", SelectCost=" << SelectCost.toString()</td>
    <td class="lineNumber">615</td>
    <td class="codeline">         << BranchCost.toString() << ", SelectCost=" << SelectCost.toString()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">         << ". ";</td>
    <td class="lineNumber">616</td>
    <td class="codeline">         << ". ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">      EmitAndPrintRemark(ORE, OR);</td>
    <td class="lineNumber">617</td>
    <td class="codeline">      EmitAndPrintRemark(ORE, OR);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">      ++NumSelectConvertedLoop;</td>
    <td class="lineNumber">618</td>
    <td class="codeline">      ++NumSelectConvertedLoop;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">      ProfSIGroups.push_back(ASI);</td>
    <td class="lineNumber">619</td>
    <td class="codeline">      ProfSIGroups.push_back(ASI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">620</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">      OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
    <td class="lineNumber">621</td>
    <td class="codeline">      OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">      ORmiss << "Select is more profitable (loop analysis). BranchCost="</td>
    <td class="lineNumber">622</td>
    <td class="codeline">      ORmiss << "Select is more profitable (loop analysis). BranchCost="</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">             << BranchCost.toString()</td>
    <td class="lineNumber">623</td>
    <td class="codeline">             << BranchCost.toString()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">             << ", SelectCost=" << SelectCost.toString() << ". ";</td>
    <td class="lineNumber">624</td>
    <td class="codeline">             << ", SelectCost=" << SelectCost.toString() << ". ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">      EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">625</td>
    <td class="codeline">      EmitAndPrintRemark(ORE, ORmiss);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">626</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">627</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">}</td>
    <td class="lineNumber">628</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline"></td>
    <td class="lineNumber">629</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">bool SelectOptimize::isConvertToBranchProfitableBase(</td>
    <td class="lineNumber">630</td>
    <td class="codeline">bool SelectOptimize::isConvertToBranchProfitableBase(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">    const SmallVector<SelectInst *, 2> &ASI) {</td>
    <td class="lineNumber">631</td>
    <td class="codeline">    const SmallVector<SelectInst *, 2> &ASI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  SelectInst *SI = ASI.front();</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  SelectInst *SI = ASI.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Analyzing select group containing " << *SI << "\n");</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Analyzing select group containing " << *SI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  OptimizationRemark OR(DEBUG_TYPE, "SelectOpti", SI);</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  OptimizationRemark OR(DEBUG_TYPE, "SelectOpti", SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">  OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", SI);</td>
    <td class="lineNumber">635</td>
    <td class="codeline">  OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline"></td>
    <td class="lineNumber">636</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">  // Skip cold basic blocks. Better to optimize for size for cold blocks.</td>
    <td class="lineNumber">637</td>
    <td class="codeline">  // Skip cold basic blocks. Better to optimize for size for cold blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">  if (PSI->isColdBlock(SI->getParent(), BFI.get())) {</td>
    <td class="lineNumber">638</td>
    <td class="codeline">  if (PSI->isColdBlock(SI->getParent(), BFI.get())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">    ++NumSelectColdBB;</td>
    <td class="lineNumber">639</td>
    <td class="codeline">    ++NumSelectColdBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">    ORmiss << "Not converted to branch because of cold basic block. ";</td>
    <td class="lineNumber">640</td>
    <td class="codeline">    ORmiss << "Not converted to branch because of cold basic block. ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">641</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, ORmiss);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">642</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  // If unpredictable, branch form is less profitable.</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  // If unpredictable, branch form is less profitable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">  if (SI->getMetadata(LLVMContext::MD_unpredictable)) {</td>
    <td class="lineNumber">646</td>
    <td class="codeline">  if (SI->getMetadata(LLVMContext::MD_unpredictable)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">    ++NumSelectUnPred;</td>
    <td class="lineNumber">647</td>
    <td class="codeline">    ++NumSelectUnPred;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">    ORmiss << "Not converted to branch because of unpredictable branch. ";</td>
    <td class="lineNumber">648</td>
    <td class="codeline">    ORmiss << "Not converted to branch because of unpredictable branch. ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">649</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, ORmiss);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">650</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline"></td>
    <td class="lineNumber">652</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">  // If highly predictable, branch form is more profitable, unless a</td>
    <td class="lineNumber">653</td>
    <td class="codeline">  // If highly predictable, branch form is more profitable, unless a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  // predictable select is inexpensive in the target architecture.</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  // predictable select is inexpensive in the target architecture.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  if (isSelectHighlyPredictable(SI) && TLI->isPredictableSelectExpensive()) {</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  if (isSelectHighlyPredictable(SI) && TLI->isPredictableSelectExpensive()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">    ++NumSelectConvertedHighPred;</td>
    <td class="lineNumber">656</td>
    <td class="codeline">    ++NumSelectConvertedHighPred;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">    OR << "Converted to branch because of highly predictable branch. ";</td>
    <td class="lineNumber">657</td>
    <td class="codeline">    OR << "Converted to branch because of highly predictable branch. ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, OR);</td>
    <td class="lineNumber">658</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, OR);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">659</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline"></td>
    <td class="lineNumber">661</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  // Look for expensive instructions in the cold operand's (if any) dependence</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  // Look for expensive instructions in the cold operand's (if any) dependence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">  // slice of any of the selects in the group.</td>
    <td class="lineNumber">663</td>
    <td class="codeline">  // slice of any of the selects in the group.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">  if (hasExpensiveColdOperand(ASI)) {</td>
    <td class="lineNumber">664</td>
    <td class="codeline">  if (hasExpensiveColdOperand(ASI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">    ++NumSelectConvertedExpColdOperand;</td>
    <td class="lineNumber">665</td>
    <td class="codeline">    ++NumSelectConvertedExpColdOperand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">    OR << "Converted to branch because of expensive cold operand.";</td>
    <td class="lineNumber">666</td>
    <td class="codeline">    OR << "Converted to branch because of expensive cold operand.";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, OR);</td>
    <td class="lineNumber">667</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, OR);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">668</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">669</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline"></td>
    <td class="lineNumber">670</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">  ORmiss << "Not profitable to convert to branch (base heuristic).";</td>
    <td class="lineNumber">671</td>
    <td class="codeline">  ORmiss << "Not profitable to convert to branch (base heuristic).";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">  EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">672</td>
    <td class="codeline">  EmitAndPrintRemark(ORE, ORmiss);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">}</td>
    <td class="lineNumber">674</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">static InstructionCost divideNearest(InstructionCost Numerator,</td>
    <td class="lineNumber">676</td>
    <td class="codeline">static InstructionCost divideNearest(InstructionCost Numerator,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">                                     uint64_t Denominator) {</td>
    <td class="lineNumber">677</td>
    <td class="codeline">                                     uint64_t Denominator) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">  return (Numerator + (Denominator / 2)) / Denominator;</td>
    <td class="lineNumber">678</td>
    <td class="codeline">  return (Numerator + (Denominator / 2)) / Denominator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">}</td>
    <td class="lineNumber">679</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline"></td>
    <td class="lineNumber">680</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">bool SelectOptimize::hasExpensiveColdOperand(</td>
    <td class="lineNumber">681</td>
    <td class="codeline">bool SelectOptimize::hasExpensiveColdOperand(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">    const SmallVector<SelectInst *, 2> &ASI) {</td>
    <td class="lineNumber">682</td>
    <td class="codeline">    const SmallVector<SelectInst *, 2> &ASI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">  bool ColdOperand = false;</td>
    <td class="lineNumber">683</td>
    <td class="codeline">  bool ColdOperand = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  uint64_t TrueWeight, FalseWeight, TotalWeight;</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  uint64_t TrueWeight, FalseWeight, TotalWeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">  if (extractBranchWeights(*ASI.front(), TrueWeight, FalseWeight)) {</td>
    <td class="lineNumber">685</td>
    <td class="codeline">  if (extractBranchWeights(*ASI.front(), TrueWeight, FalseWeight)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">    uint64_t MinWeight = std::min(TrueWeight, FalseWeight);</td>
    <td class="lineNumber">686</td>
    <td class="codeline">    uint64_t MinWeight = std::min(TrueWeight, FalseWeight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">    TotalWeight = TrueWeight + FalseWeight;</td>
    <td class="lineNumber">687</td>
    <td class="codeline">    TotalWeight = TrueWeight + FalseWeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">    // Is there a path with frequency <ColdOperandThreshold% (default:20%) ?</td>
    <td class="lineNumber">688</td>
    <td class="codeline">    // Is there a path with frequency <ColdOperandThreshold% (default:20%) ?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">    ColdOperand = TotalWeight * ColdOperandThreshold > 100 * MinWeight;</td>
    <td class="lineNumber">689</td>
    <td class="codeline">    ColdOperand = TotalWeight * ColdOperandThreshold > 100 * MinWeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  } else if (PSI->hasProfileSummary()) {</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  } else if (PSI->hasProfileSummary()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">    OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
    <td class="lineNumber">691</td>
    <td class="codeline">    OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">    ORmiss << "Profile data available but missing branch-weights metadata for "</td>
    <td class="lineNumber">692</td>
    <td class="codeline">    ORmiss << "Profile data available but missing branch-weights metadata for "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">              "select instruction. ";</td>
    <td class="lineNumber">693</td>
    <td class="codeline">              "select instruction. ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">694</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, ORmiss);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">695</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  if (!ColdOperand)</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  if (!ColdOperand)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">697</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  // Check if the cold path's dependence slice is expensive for any of the</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  // Check if the cold path's dependence slice is expensive for any of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  // selects of the group.</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  // selects of the group.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  for (SelectInst *SI : ASI) {</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  for (SelectInst *SI : ASI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">    Instruction *ColdI = nullptr;</td>
    <td class="lineNumber">701</td>
    <td class="codeline">    Instruction *ColdI = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">    uint64_t HotWeight;</td>
    <td class="lineNumber">702</td>
    <td class="codeline">    uint64_t HotWeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">    if (TrueWeight < FalseWeight) {</td>
    <td class="lineNumber">703</td>
    <td class="codeline">    if (TrueWeight < FalseWeight) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">      ColdI = dyn_cast<Instruction>(SI->getTrueValue());</td>
    <td class="lineNumber">704</td>
    <td class="codeline">      ColdI = dyn_cast<Instruction>(SI->getTrueValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">      HotWeight = FalseWeight;</td>
    <td class="lineNumber">705</td>
    <td class="codeline">      HotWeight = FalseWeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">706</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">      ColdI = dyn_cast<Instruction>(SI->getFalseValue());</td>
    <td class="lineNumber">707</td>
    <td class="codeline">      ColdI = dyn_cast<Instruction>(SI->getFalseValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">      HotWeight = TrueWeight;</td>
    <td class="lineNumber">708</td>
    <td class="codeline">      HotWeight = TrueWeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">709</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">    if (ColdI) {</td>
    <td class="lineNumber">710</td>
    <td class="codeline">    if (ColdI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">      std::stack<Instruction *> ColdSlice;</td>
    <td class="lineNumber">711</td>
    <td class="codeline">      std::stack<Instruction *> ColdSlice;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">      getExclBackwardsSlice(ColdI, ColdSlice, SI);</td>
    <td class="lineNumber">712</td>
    <td class="codeline">      getExclBackwardsSlice(ColdI, ColdSlice, SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">      InstructionCost SliceCost = 0;</td>
    <td class="lineNumber">713</td>
    <td class="codeline">      InstructionCost SliceCost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">      while (!ColdSlice.empty()) {</td>
    <td class="lineNumber">714</td>
    <td class="codeline">      while (!ColdSlice.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">        SliceCost += TTI->getInstructionCost(ColdSlice.top(),</td>
    <td class="lineNumber">715</td>
    <td class="codeline">        SliceCost += TTI->getInstructionCost(ColdSlice.top(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">                                             TargetTransformInfo::TCK_Latency);</td>
    <td class="lineNumber">716</td>
    <td class="codeline">                                             TargetTransformInfo::TCK_Latency);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">        ColdSlice.pop();</td>
    <td class="lineNumber">717</td>
    <td class="codeline">        ColdSlice.pop();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">718</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">      // The colder the cold value operand of the select is the more expensive</td>
    <td class="lineNumber">719</td>
    <td class="codeline">      // The colder the cold value operand of the select is the more expensive</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">      // the cmov becomes for computing the cold value operand every time. Thus,</td>
    <td class="lineNumber">720</td>
    <td class="codeline">      // the cmov becomes for computing the cold value operand every time. Thus,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">      // the colder the cold operand is the more its cost counts.</td>
    <td class="lineNumber">721</td>
    <td class="codeline">      // the colder the cold operand is the more its cost counts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">      // Get nearest integer cost adjusted for coldness.</td>
    <td class="lineNumber">722</td>
    <td class="codeline">      // Get nearest integer cost adjusted for coldness.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">      InstructionCost AdjSliceCost =</td>
    <td class="lineNumber">723</td>
    <td class="codeline">      InstructionCost AdjSliceCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">          divideNearest(SliceCost * HotWeight, TotalWeight);</td>
    <td class="lineNumber">724</td>
    <td class="codeline">          divideNearest(SliceCost * HotWeight, TotalWeight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">      if (AdjSliceCost >=</td>
    <td class="lineNumber">725</td>
    <td class="codeline">      if (AdjSliceCost >=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">          ColdOperandMaxCostMultiplier * TargetTransformInfo::TCC_Expensive)</td>
    <td class="lineNumber">726</td>
    <td class="codeline">          ColdOperandMaxCostMultiplier * TargetTransformInfo::TCC_Expensive)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">727</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">728</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">729</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">730</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">}</td>
    <td class="lineNumber">731</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline"></td>
    <td class="lineNumber">732</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">// Check if it is safe to move LoadI next to the SI.</td>
    <td class="lineNumber">733</td>
    <td class="codeline">// Check if it is safe to move LoadI next to the SI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">// Conservatively assume it is safe only if there is no instruction</td>
    <td class="lineNumber">734</td>
    <td class="codeline">// Conservatively assume it is safe only if there is no instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">// modifying memory in-between the load and the select instruction.</td>
    <td class="lineNumber">735</td>
    <td class="codeline">// modifying memory in-between the load and the select instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">static bool isSafeToSinkLoad(Instruction *LoadI, Instruction *SI) {</td>
    <td class="lineNumber">736</td>
    <td class="codeline">static bool isSafeToSinkLoad(Instruction *LoadI, Instruction *SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">  // Assume loads from different basic blocks are unsafe to move.</td>
    <td class="lineNumber">737</td>
    <td class="codeline">  // Assume loads from different basic blocks are unsafe to move.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  if (LoadI->getParent() != SI->getParent())</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  if (LoadI->getParent() != SI->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">739</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">  auto It = LoadI->getIterator();</td>
    <td class="lineNumber">740</td>
    <td class="codeline">  auto It = LoadI->getIterator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">  while (&*It != SI) {</td>
    <td class="lineNumber">741</td>
    <td class="codeline">  while (&*It != SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">    if (It->mayWriteToMemory())</td>
    <td class="lineNumber">742</td>
    <td class="codeline">    if (It->mayWriteToMemory())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">743</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">    It++;</td>
    <td class="lineNumber">744</td>
    <td class="codeline">    It++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">745</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">}</td>
    <td class="lineNumber">747</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline"></td>
    <td class="lineNumber">748</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">// For a given source instruction, collect its backwards dependence slice</td>
    <td class="lineNumber">749</td>
    <td class="codeline">// For a given source instruction, collect its backwards dependence slice</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">// consisting of instructions exclusively computed for the purpose of producing</td>
    <td class="lineNumber">750</td>
    <td class="codeline">// consisting of instructions exclusively computed for the purpose of producing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">// the operands of the source instruction. As an approximation</td>
    <td class="lineNumber">751</td>
    <td class="codeline">// the operands of the source instruction. As an approximation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">// (sufficiently-accurate in practice), we populate this set with the</td>
    <td class="lineNumber">752</td>
    <td class="codeline">// (sufficiently-accurate in practice), we populate this set with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">// instructions of the backwards dependence slice that only have one-use and</td>
    <td class="lineNumber">753</td>
    <td class="codeline">// instructions of the backwards dependence slice that only have one-use and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">// form an one-use chain that leads to the source instruction.</td>
    <td class="lineNumber">754</td>
    <td class="codeline">// form an one-use chain that leads to the source instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">void SelectOptimize::getExclBackwardsSlice(Instruction *I,</td>
    <td class="lineNumber">755</td>
    <td class="codeline">void SelectOptimize::getExclBackwardsSlice(Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">                                           std::stack<Instruction *> &Slice,</td>
    <td class="lineNumber">756</td>
    <td class="codeline">                                           std::stack<Instruction *> &Slice,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">                                           Instruction *SI, bool ForSinking) {</td>
    <td class="lineNumber">757</td>
    <td class="codeline">                                           Instruction *SI, bool ForSinking) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">  SmallPtrSet<Instruction *, 2> Visited;</td>
    <td class="lineNumber">758</td>
    <td class="codeline">  SmallPtrSet<Instruction *, 2> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">  std::queue<Instruction *> Worklist;</td>
    <td class="lineNumber">759</td>
    <td class="codeline">  std::queue<Instruction *> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">  Worklist.push(I);</td>
    <td class="lineNumber">760</td>
    <td class="codeline">  Worklist.push(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">761</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">    Instruction *II = Worklist.front();</td>
    <td class="lineNumber">762</td>
    <td class="codeline">    Instruction *II = Worklist.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">    Worklist.pop();</td>
    <td class="lineNumber">763</td>
    <td class="codeline">    Worklist.pop();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline"></td>
    <td class="lineNumber">764</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">    // Avoid cycles.</td>
    <td class="lineNumber">765</td>
    <td class="codeline">    // Avoid cycles.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">    if (!Visited.insert(II).second)</td>
    <td class="lineNumber">766</td>
    <td class="codeline">    if (!Visited.insert(II).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">767</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline"></td>
    <td class="lineNumber">768</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">    if (!II->hasOneUse())</td>
    <td class="lineNumber">769</td>
    <td class="codeline">    if (!II->hasOneUse())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">770</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">    // Cannot soundly sink instructions with side-effects.</td>
    <td class="lineNumber">772</td>
    <td class="codeline">    // Cannot soundly sink instructions with side-effects.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">    // Terminator or phi instructions cannot be sunk.</td>
    <td class="lineNumber">773</td>
    <td class="codeline">    // Terminator or phi instructions cannot be sunk.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">    // Avoid sinking other select instructions (should be handled separetely).</td>
    <td class="lineNumber">774</td>
    <td class="codeline">    // Avoid sinking other select instructions (should be handled separetely).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">    if (ForSinking && (II->isTerminator() || II->mayHaveSideEffects() ||</td>
    <td class="lineNumber">775</td>
    <td class="codeline">    if (ForSinking && (II->isTerminator() || II->mayHaveSideEffects() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">                       isa<SelectInst>(II) || isa<PHINode>(II)))</td>
    <td class="lineNumber">776</td>
    <td class="codeline">                       isa<SelectInst>(II) || isa<PHINode>(II)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">777</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">    // Avoid sinking loads in order not to skip state-modifying instructions,</td>
    <td class="lineNumber">779</td>
    <td class="codeline">    // Avoid sinking loads in order not to skip state-modifying instructions,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">    // that may alias with the loaded address.</td>
    <td class="lineNumber">780</td>
    <td class="codeline">    // that may alias with the loaded address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">    // Only allow sinking of loads within the same basic block that are</td>
    <td class="lineNumber">781</td>
    <td class="codeline">    // Only allow sinking of loads within the same basic block that are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">    // conservatively proven to be safe.</td>
    <td class="lineNumber">782</td>
    <td class="codeline">    // conservatively proven to be safe.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">    if (ForSinking && II->mayReadFromMemory() && !isSafeToSinkLoad(II, SI))</td>
    <td class="lineNumber">783</td>
    <td class="codeline">    if (ForSinking && II->mayReadFromMemory() && !isSafeToSinkLoad(II, SI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">784</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline"></td>
    <td class="lineNumber">785</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">    // Avoid considering instructions with less frequency than the source</td>
    <td class="lineNumber">786</td>
    <td class="codeline">    // Avoid considering instructions with less frequency than the source</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">    // instruction (i.e., avoid colder code regions of the dependence slice).</td>
    <td class="lineNumber">787</td>
    <td class="codeline">    // instruction (i.e., avoid colder code regions of the dependence slice).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">    if (BFI->getBlockFreq(II->getParent()) < BFI->getBlockFreq(I->getParent()))</td>
    <td class="lineNumber">788</td>
    <td class="codeline">    if (BFI->getBlockFreq(II->getParent()) < BFI->getBlockFreq(I->getParent()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">789</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline"></td>
    <td class="lineNumber">790</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">    // Eligible one-use instruction added to the dependence slice.</td>
    <td class="lineNumber">791</td>
    <td class="codeline">    // Eligible one-use instruction added to the dependence slice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">    Slice.push(II);</td>
    <td class="lineNumber">792</td>
    <td class="codeline">    Slice.push(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline"></td>
    <td class="lineNumber">793</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">    // Explore all the operands of the current instruction to expand the slice.</td>
    <td class="lineNumber">794</td>
    <td class="codeline">    // Explore all the operands of the current instruction to expand the slice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">    for (unsigned k = 0; k < II->getNumOperands(); ++k)</td>
    <td class="lineNumber">795</td>
    <td class="codeline">    for (unsigned k = 0; k < II->getNumOperands(); ++k)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">      if (auto *OpI = dyn_cast<Instruction>(II->getOperand(k)))</td>
    <td class="lineNumber">796</td>
    <td class="codeline">      if (auto *OpI = dyn_cast<Instruction>(II->getOperand(k)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">        Worklist.push(OpI);</td>
    <td class="lineNumber">797</td>
    <td class="codeline">        Worklist.push(OpI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">798</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">}</td>
    <td class="lineNumber">799</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline"></td>
    <td class="lineNumber">800</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">bool SelectOptimize::isSelectHighlyPredictable(const SelectInst *SI) {</td>
    <td class="lineNumber">801</td>
    <td class="codeline">bool SelectOptimize::isSelectHighlyPredictable(const SelectInst *SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">  uint64_t TrueWeight, FalseWeight;</td>
    <td class="lineNumber">802</td>
    <td class="codeline">  uint64_t TrueWeight, FalseWeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">  if (extractBranchWeights(*SI, TrueWeight, FalseWeight)) {</td>
    <td class="lineNumber">803</td>
    <td class="codeline">  if (extractBranchWeights(*SI, TrueWeight, FalseWeight)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">    uint64_t Max = std::max(TrueWeight, FalseWeight);</td>
    <td class="lineNumber">804</td>
    <td class="codeline">    uint64_t Max = std::max(TrueWeight, FalseWeight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">    uint64_t Sum = TrueWeight + FalseWeight;</td>
    <td class="lineNumber">805</td>
    <td class="codeline">    uint64_t Sum = TrueWeight + FalseWeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">    if (Sum != 0) {</td>
    <td class="lineNumber">806</td>
    <td class="codeline">    if (Sum != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">      auto Probability = BranchProbability::getBranchProbability(Max, Sum);</td>
    <td class="lineNumber">807</td>
    <td class="codeline">      auto Probability = BranchProbability::getBranchProbability(Max, Sum);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">      if (Probability > TTI->getPredictableBranchThreshold())</td>
    <td class="lineNumber">808</td>
    <td class="codeline">      if (Probability > TTI->getPredictableBranchThreshold())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">809</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">810</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">812</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">}</td>
    <td class="lineNumber">813</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline"></td>
    <td class="lineNumber">814</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">bool SelectOptimize::checkLoopHeuristics(const Loop *L,</td>
    <td class="lineNumber">815</td>
    <td class="codeline">bool SelectOptimize::checkLoopHeuristics(const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">                                         const CostInfo LoopCost[2]) {</td>
    <td class="lineNumber">816</td>
    <td class="codeline">                                         const CostInfo LoopCost[2]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  // Loop-level checks to determine if a non-predicated version (with branches)</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  // Loop-level checks to determine if a non-predicated version (with branches)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">  // of the loop is more profitable than its predicated version.</td>
    <td class="lineNumber">818</td>
    <td class="codeline">  // of the loop is more profitable than its predicated version.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline"></td>
    <td class="lineNumber">819</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  if (DisableLoopLevelHeuristics)</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  if (DisableLoopLevelHeuristics)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">821</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline"></td>
    <td class="lineNumber">822</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">  OptimizationRemarkMissed ORmissL(DEBUG_TYPE, "SelectOpti",</td>
    <td class="lineNumber">823</td>
    <td class="codeline">  OptimizationRemarkMissed ORmissL(DEBUG_TYPE, "SelectOpti",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">                                   L->getHeader()->getFirstNonPHI());</td>
    <td class="lineNumber">824</td>
    <td class="codeline">                                   L->getHeader()->getFirstNonPHI());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline"></td>
    <td class="lineNumber">825</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">  if (LoopCost[0].NonPredCost > LoopCost[0].PredCost ||</td>
    <td class="lineNumber">826</td>
    <td class="codeline">  if (LoopCost[0].NonPredCost > LoopCost[0].PredCost ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">      LoopCost[1].NonPredCost >= LoopCost[1].PredCost) {</td>
    <td class="lineNumber">827</td>
    <td class="codeline">      LoopCost[1].NonPredCost >= LoopCost[1].PredCost) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">    ORmissL << "No select conversion in the loop due to no reduction of loop's "</td>
    <td class="lineNumber">828</td>
    <td class="codeline">    ORmissL << "No select conversion in the loop due to no reduction of loop's "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">               "critical path. ";</td>
    <td class="lineNumber">829</td>
    <td class="codeline">               "critical path. ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">830</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, ORmissL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">831</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">832</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  Scaled64 Gain[2] = {LoopCost[0].PredCost - LoopCost[0].NonPredCost,</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  Scaled64 Gain[2] = {LoopCost[0].PredCost - LoopCost[0].NonPredCost,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">                      LoopCost[1].PredCost - LoopCost[1].NonPredCost};</td>
    <td class="lineNumber">835</td>
    <td class="codeline">                      LoopCost[1].PredCost - LoopCost[1].NonPredCost};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline"></td>
    <td class="lineNumber">836</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">  // Profitably converting to branches need to reduce the loop's critical path</td>
    <td class="lineNumber">837</td>
    <td class="codeline">  // Profitably converting to branches need to reduce the loop's critical path</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">  // by at least some threshold (absolute gain of GainCycleThreshold cycles and</td>
    <td class="lineNumber">838</td>
    <td class="codeline">  // by at least some threshold (absolute gain of GainCycleThreshold cycles and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">  // relative gain of 12.5%).</td>
    <td class="lineNumber">839</td>
    <td class="codeline">  // relative gain of 12.5%).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">  if (Gain[1] < Scaled64::get(GainCycleThreshold) ||</td>
    <td class="lineNumber">840</td>
    <td class="codeline">  if (Gain[1] < Scaled64::get(GainCycleThreshold) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">      Gain[1] * Scaled64::get(GainRelativeThreshold) < LoopCost[1].PredCost) {</td>
    <td class="lineNumber">841</td>
    <td class="codeline">      Gain[1] * Scaled64::get(GainRelativeThreshold) < LoopCost[1].PredCost) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">    Scaled64 RelativeGain = Scaled64::get(100) * Gain[1] / LoopCost[1].PredCost;</td>
    <td class="lineNumber">842</td>
    <td class="codeline">    Scaled64 RelativeGain = Scaled64::get(100) * Gain[1] / LoopCost[1].PredCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">    ORmissL << "No select conversion in the loop due to small reduction of "</td>
    <td class="lineNumber">843</td>
    <td class="codeline">    ORmissL << "No select conversion in the loop due to small reduction of "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">               "loop's critical path. Gain="</td>
    <td class="lineNumber">844</td>
    <td class="codeline">               "loop's critical path. Gain="</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">            << Gain[1].toString()</td>
    <td class="lineNumber">845</td>
    <td class="codeline">            << Gain[1].toString()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">            << ", RelativeGain=" << RelativeGain.toString() << "%. ";</td>
    <td class="lineNumber">846</td>
    <td class="codeline">            << ", RelativeGain=" << RelativeGain.toString() << "%. ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">847</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, ORmissL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">848</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">849</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline"></td>
    <td class="lineNumber">850</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">  // If the loop's critical path involves loop-carried dependences, the gradient</td>
    <td class="lineNumber">851</td>
    <td class="codeline">  // If the loop's critical path involves loop-carried dependences, the gradient</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">  // of the gain needs to be at least GainGradientThreshold% (defaults to 25%).</td>
    <td class="lineNumber">852</td>
    <td class="codeline">  // of the gain needs to be at least GainGradientThreshold% (defaults to 25%).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  // This check ensures that the latency reduction for the loop's critical path</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  // This check ensures that the latency reduction for the loop's critical path</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">  // keeps decreasing with sufficient rate beyond the two analyzed loop</td>
    <td class="lineNumber">854</td>
    <td class="codeline">  // keeps decreasing with sufficient rate beyond the two analyzed loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">  // iterations.</td>
    <td class="lineNumber">855</td>
    <td class="codeline">  // iterations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">  if (Gain[1] > Gain[0]) {</td>
    <td class="lineNumber">856</td>
    <td class="codeline">  if (Gain[1] > Gain[0]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">    Scaled64 GradientGain = Scaled64::get(100) * (Gain[1] - Gain[0]) /</td>
    <td class="lineNumber">857</td>
    <td class="codeline">    Scaled64 GradientGain = Scaled64::get(100) * (Gain[1] - Gain[0]) /</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">                            (LoopCost[1].PredCost - LoopCost[0].PredCost);</td>
    <td class="lineNumber">858</td>
    <td class="codeline">                            (LoopCost[1].PredCost - LoopCost[0].PredCost);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">    if (GradientGain < Scaled64::get(GainGradientThreshold)) {</td>
    <td class="lineNumber">859</td>
    <td class="codeline">    if (GradientGain < Scaled64::get(GainGradientThreshold)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">      ORmissL << "No select conversion in the loop due to small gradient gain. "</td>
    <td class="lineNumber">860</td>
    <td class="codeline">      ORmissL << "No select conversion in the loop due to small gradient gain. "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">                 "GradientGain="</td>
    <td class="lineNumber">861</td>
    <td class="codeline">                 "GradientGain="</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">              << GradientGain.toString() << "%. ";</td>
    <td class="lineNumber">862</td>
    <td class="codeline">              << GradientGain.toString() << "%. ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">      EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">863</td>
    <td class="codeline">      EmitAndPrintRemark(ORE, ORmissL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">864</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">865</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">866</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">  // If the gain decreases it is not profitable to convert.</td>
    <td class="lineNumber">867</td>
    <td class="codeline">  // If the gain decreases it is not profitable to convert.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">  else if (Gain[1] < Gain[0]) {</td>
    <td class="lineNumber">868</td>
    <td class="codeline">  else if (Gain[1] < Gain[0]) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">    ORmissL</td>
    <td class="lineNumber">869</td>
    <td class="codeline">    ORmissL</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">        << "No select conversion in the loop due to negative gradient gain. ";</td>
    <td class="lineNumber">870</td>
    <td class="codeline">        << "No select conversion in the loop due to negative gradient gain. ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">871</td>
    <td class="codeline">    EmitAndPrintRemark(ORE, ORmissL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">872</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">873</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  // Non-predicated version of the loop is more profitable than its</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  // Non-predicated version of the loop is more profitable than its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  // predicated version.</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  // predicated version.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">877</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">}</td>
    <td class="lineNumber">878</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline"></td>
    <td class="lineNumber">879</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">// Computes instruction and loop-critical-path costs for both the predicated</td>
    <td class="lineNumber">880</td>
    <td class="codeline">// Computes instruction and loop-critical-path costs for both the predicated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">// and non-predicated version of the given loop.</td>
    <td class="lineNumber">881</td>
    <td class="codeline">// and non-predicated version of the given loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">// Returns false if unable to compute these costs due to invalid cost of loop</td>
    <td class="lineNumber">882</td>
    <td class="codeline">// Returns false if unable to compute these costs due to invalid cost of loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">// instruction(s).</td>
    <td class="lineNumber">883</td>
    <td class="codeline">// instruction(s).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">bool SelectOptimize::computeLoopCosts(</td>
    <td class="lineNumber">884</td>
    <td class="codeline">bool SelectOptimize::computeLoopCosts(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">    const Loop *L, const SelectGroups &SIGroups,</td>
    <td class="lineNumber">885</td>
    <td class="codeline">    const Loop *L, const SelectGroups &SIGroups,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">    DenseMap<const Instruction *, CostInfo> &InstCostMap, CostInfo *LoopCost) {</td>
    <td class="lineNumber">886</td>
    <td class="codeline">    DenseMap<const Instruction *, CostInfo> &InstCostMap, CostInfo *LoopCost) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Calculating Latency / IPredCost / INonPredCost of loop "</td>
    <td class="lineNumber">887</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Calculating Latency / IPredCost / INonPredCost of loop "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">                    << L->getHeader()->getName() << "\n");</td>
    <td class="lineNumber">888</td>
    <td class="codeline">                    << L->getHeader()->getName() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">  const auto &SIset = getSIset(SIGroups);</td>
    <td class="lineNumber">889</td>
    <td class="codeline">  const auto &SIset = getSIset(SIGroups);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">  // Compute instruction and loop-critical-path costs across two iterations for</td>
    <td class="lineNumber">890</td>
    <td class="codeline">  // Compute instruction and loop-critical-path costs across two iterations for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">  // both predicated and non-predicated version.</td>
    <td class="lineNumber">891</td>
    <td class="codeline">  // both predicated and non-predicated version.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">  const unsigned Iterations = 2;</td>
    <td class="lineNumber">892</td>
    <td class="codeline">  const unsigned Iterations = 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">  for (unsigned Iter = 0; Iter < Iterations; ++Iter) {</td>
    <td class="lineNumber">893</td>
    <td class="codeline">  for (unsigned Iter = 0; Iter < Iterations; ++Iter) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">    // Cost of the loop's critical path.</td>
    <td class="lineNumber">894</td>
    <td class="codeline">    // Cost of the loop's critical path.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">    CostInfo &MaxCost = LoopCost[Iter];</td>
    <td class="lineNumber">895</td>
    <td class="codeline">    CostInfo &MaxCost = LoopCost[Iter];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">    for (BasicBlock *BB : L->getBlocks()) {</td>
    <td class="lineNumber">896</td>
    <td class="codeline">    for (BasicBlock *BB : L->getBlocks()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">      for (const Instruction &I : *BB) {</td>
    <td class="lineNumber">897</td>
    <td class="codeline">      for (const Instruction &I : *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">        if (I.isDebugOrPseudoInst())</td>
    <td class="lineNumber">898</td>
    <td class="codeline">        if (I.isDebugOrPseudoInst())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">899</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">        // Compute the predicated and non-predicated cost of the instruction.</td>
    <td class="lineNumber">900</td>
    <td class="codeline">        // Compute the predicated and non-predicated cost of the instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">        Scaled64 IPredCost = Scaled64::getZero(),</td>
    <td class="lineNumber">901</td>
    <td class="codeline">        Scaled64 IPredCost = Scaled64::getZero(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">                 INonPredCost = Scaled64::getZero();</td>
    <td class="lineNumber">902</td>
    <td class="codeline">                 INonPredCost = Scaled64::getZero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline"></td>
    <td class="lineNumber">903</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">        // Assume infinite resources that allow to fully exploit the available</td>
    <td class="lineNumber">904</td>
    <td class="codeline">        // Assume infinite resources that allow to fully exploit the available</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">        // instruction-level parallelism.</td>
    <td class="lineNumber">905</td>
    <td class="codeline">        // instruction-level parallelism.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">        // InstCost = InstLatency + max(Op1Cost, Op2Cost, … OpNCost)</td>
    <td class="lineNumber">906</td>
    <td class="codeline">        // InstCost = InstLatency + max(Op1Cost, Op2Cost, … OpNCost)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">        for (const Use &U : I.operands()) {</td>
    <td class="lineNumber">907</td>
    <td class="codeline">        for (const Use &U : I.operands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">          auto UI = dyn_cast<Instruction>(U.get());</td>
    <td class="lineNumber">908</td>
    <td class="codeline">          auto UI = dyn_cast<Instruction>(U.get());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">          if (!UI)</td>
    <td class="lineNumber">909</td>
    <td class="codeline">          if (!UI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">910</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">          if (InstCostMap.count(UI)) {</td>
    <td class="lineNumber">911</td>
    <td class="codeline">          if (InstCostMap.count(UI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">            IPredCost = std::max(IPredCost, InstCostMap[UI].PredCost);</td>
    <td class="lineNumber">912</td>
    <td class="codeline">            IPredCost = std::max(IPredCost, InstCostMap[UI].PredCost);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">            INonPredCost = std::max(INonPredCost, InstCostMap[UI].NonPredCost);</td>
    <td class="lineNumber">913</td>
    <td class="codeline">            INonPredCost = std::max(INonPredCost, InstCostMap[UI].NonPredCost);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">914</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">915</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">        auto ILatency = computeInstCost(&I);</td>
    <td class="lineNumber">916</td>
    <td class="codeline">        auto ILatency = computeInstCost(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">        if (!ILatency) {</td>
    <td class="lineNumber">917</td>
    <td class="codeline">        if (!ILatency) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">          OptimizationRemarkMissed ORmissL(DEBUG_TYPE, "SelectOpti", &I);</td>
    <td class="lineNumber">918</td>
    <td class="codeline">          OptimizationRemarkMissed ORmissL(DEBUG_TYPE, "SelectOpti", &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">          ORmissL << "Invalid instruction cost preventing analysis and "</td>
    <td class="lineNumber">919</td>
    <td class="codeline">          ORmissL << "Invalid instruction cost preventing analysis and "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">                     "optimization of the inner-most loop containing this "</td>
    <td class="lineNumber">920</td>
    <td class="codeline">                     "optimization of the inner-most loop containing this "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">                     "instruction. ";</td>
    <td class="lineNumber">921</td>
    <td class="codeline">                     "instruction. ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">          EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">922</td>
    <td class="codeline">          EmitAndPrintRemark(ORE, ORmissL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">          return false;</td>
    <td class="lineNumber">923</td>
    <td class="codeline">          return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">924</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">        IPredCost += Scaled64::get(*ILatency);</td>
    <td class="lineNumber">925</td>
    <td class="codeline">        IPredCost += Scaled64::get(*ILatency);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">        INonPredCost += Scaled64::get(*ILatency);</td>
    <td class="lineNumber">926</td>
    <td class="codeline">        INonPredCost += Scaled64::get(*ILatency);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline"></td>
    <td class="lineNumber">927</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">        // For a select that can be converted to branch,</td>
    <td class="lineNumber">928</td>
    <td class="codeline">        // For a select that can be converted to branch,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">        // compute its cost as a branch (non-predicated cost).</td>
    <td class="lineNumber">929</td>
    <td class="codeline">        // compute its cost as a branch (non-predicated cost).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">        //</td>
    <td class="lineNumber">930</td>
    <td class="codeline">        //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">        // BranchCost = PredictedPathCost + MispredictCost</td>
    <td class="lineNumber">931</td>
    <td class="codeline">        // BranchCost = PredictedPathCost + MispredictCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">        // PredictedPathCost = TrueOpCost * TrueProb + FalseOpCost * FalseProb</td>
    <td class="lineNumber">932</td>
    <td class="codeline">        // PredictedPathCost = TrueOpCost * TrueProb + FalseOpCost * FalseProb</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">        // MispredictCost = max(MispredictPenalty, CondCost) * MispredictRate</td>
    <td class="lineNumber">933</td>
    <td class="codeline">        // MispredictCost = max(MispredictPenalty, CondCost) * MispredictRate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">        if (SIset.contains(&I)) {</td>
    <td class="lineNumber">934</td>
    <td class="codeline">        if (SIset.contains(&I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">          auto SI = cast<SelectInst>(&I);</td>
    <td class="lineNumber">935</td>
    <td class="codeline">          auto SI = cast<SelectInst>(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline"></td>
    <td class="lineNumber">936</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">          Scaled64 TrueOpCost = Scaled64::getZero(),</td>
    <td class="lineNumber">937</td>
    <td class="codeline">          Scaled64 TrueOpCost = Scaled64::getZero(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">                   FalseOpCost = Scaled64::getZero();</td>
    <td class="lineNumber">938</td>
    <td class="codeline">                   FalseOpCost = Scaled64::getZero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">          if (auto *TI = dyn_cast<Instruction>(SI->getTrueValue()))</td>
    <td class="lineNumber">939</td>
    <td class="codeline">          if (auto *TI = dyn_cast<Instruction>(SI->getTrueValue()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">            if (InstCostMap.count(TI))</td>
    <td class="lineNumber">940</td>
    <td class="codeline">            if (InstCostMap.count(TI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">              TrueOpCost = InstCostMap[TI].NonPredCost;</td>
    <td class="lineNumber">941</td>
    <td class="codeline">              TrueOpCost = InstCostMap[TI].NonPredCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">          if (auto *FI = dyn_cast<Instruction>(SI->getFalseValue()))</td>
    <td class="lineNumber">942</td>
    <td class="codeline">          if (auto *FI = dyn_cast<Instruction>(SI->getFalseValue()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">            if (InstCostMap.count(FI))</td>
    <td class="lineNumber">943</td>
    <td class="codeline">            if (InstCostMap.count(FI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">              FalseOpCost = InstCostMap[FI].NonPredCost;</td>
    <td class="lineNumber">944</td>
    <td class="codeline">              FalseOpCost = InstCostMap[FI].NonPredCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">          Scaled64 PredictedPathCost =</td>
    <td class="lineNumber">945</td>
    <td class="codeline">          Scaled64 PredictedPathCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">              getPredictedPathCost(TrueOpCost, FalseOpCost, SI);</td>
    <td class="lineNumber">946</td>
    <td class="codeline">              getPredictedPathCost(TrueOpCost, FalseOpCost, SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline"></td>
    <td class="lineNumber">947</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">          Scaled64 CondCost = Scaled64::getZero();</td>
    <td class="lineNumber">948</td>
    <td class="codeline">          Scaled64 CondCost = Scaled64::getZero();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">          if (auto *CI = dyn_cast<Instruction>(SI->getCondition()))</td>
    <td class="lineNumber">949</td>
    <td class="codeline">          if (auto *CI = dyn_cast<Instruction>(SI->getCondition()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">            if (InstCostMap.count(CI))</td>
    <td class="lineNumber">950</td>
    <td class="codeline">            if (InstCostMap.count(CI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">              CondCost = InstCostMap[CI].NonPredCost;</td>
    <td class="lineNumber">951</td>
    <td class="codeline">              CondCost = InstCostMap[CI].NonPredCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">          Scaled64 MispredictCost = getMispredictionCost(SI, CondCost);</td>
    <td class="lineNumber">952</td>
    <td class="codeline">          Scaled64 MispredictCost = getMispredictionCost(SI, CondCost);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline"></td>
    <td class="lineNumber">953</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">          INonPredCost = PredictedPathCost + MispredictCost;</td>
    <td class="lineNumber">954</td>
    <td class="codeline">          INonPredCost = PredictedPathCost + MispredictCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">955</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << " " << ILatency << "/" << IPredCost << "/"</td>
    <td class="lineNumber">956</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << " " << ILatency << "/" << IPredCost << "/"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">                          << INonPredCost << " for " << I << "\n");</td>
    <td class="lineNumber">957</td>
    <td class="codeline">                          << INonPredCost << " for " << I << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline"></td>
    <td class="lineNumber">958</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">        InstCostMap[&I] = {IPredCost, INonPredCost};</td>
    <td class="lineNumber">959</td>
    <td class="codeline">        InstCostMap[&I] = {IPredCost, INonPredCost};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">        MaxCost.PredCost = std::max(MaxCost.PredCost, IPredCost);</td>
    <td class="lineNumber">960</td>
    <td class="codeline">        MaxCost.PredCost = std::max(MaxCost.PredCost, IPredCost);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">        MaxCost.NonPredCost = std::max(MaxCost.NonPredCost, INonPredCost);</td>
    <td class="lineNumber">961</td>
    <td class="codeline">        MaxCost.NonPredCost = std::max(MaxCost.NonPredCost, INonPredCost);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">962</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">963</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Iteration " << Iter + 1</td>
    <td class="lineNumber">964</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Iteration " << Iter + 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">                      << " MaxCost = " << MaxCost.PredCost << " "</td>
    <td class="lineNumber">965</td>
    <td class="codeline">                      << " MaxCost = " << MaxCost.PredCost << " "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">                      << MaxCost.NonPredCost << "\n");</td>
    <td class="lineNumber">966</td>
    <td class="codeline">                      << MaxCost.NonPredCost << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">}</td>
    <td class="lineNumber">969</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline"></td>
    <td class="lineNumber">970</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">SmallPtrSet<const Instruction *, 2></td>
    <td class="lineNumber">971</td>
    <td class="codeline">SmallPtrSet<const Instruction *, 2></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">SelectOptimize::getSIset(const SelectGroups &SIGroups) {</td>
    <td class="lineNumber">972</td>
    <td class="codeline">SelectOptimize::getSIset(const SelectGroups &SIGroups) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">  SmallPtrSet<const Instruction *, 2> SIset;</td>
    <td class="lineNumber">973</td>
    <td class="codeline">  SmallPtrSet<const Instruction *, 2> SIset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">  for (const SelectGroup &ASI : SIGroups)</td>
    <td class="lineNumber">974</td>
    <td class="codeline">  for (const SelectGroup &ASI : SIGroups)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">    for (const SelectInst *SI : ASI)</td>
    <td class="lineNumber">975</td>
    <td class="codeline">    for (const SelectInst *SI : ASI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">      SIset.insert(SI);</td>
    <td class="lineNumber">976</td>
    <td class="codeline">      SIset.insert(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">  return SIset;</td>
    <td class="lineNumber">977</td>
    <td class="codeline">  return SIset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">}</td>
    <td class="lineNumber">978</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline"></td>
    <td class="lineNumber">979</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">std::optional<uint64_t> SelectOptimize::computeInstCost(const Instruction *I) {</td>
    <td class="lineNumber">980</td>
    <td class="codeline">std::optional<uint64_t> SelectOptimize::computeInstCost(const Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">  InstructionCost ICost =</td>
    <td class="lineNumber">981</td>
    <td class="codeline">  InstructionCost ICost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">      TTI->getInstructionCost(I, TargetTransformInfo::TCK_Latency);</td>
    <td class="lineNumber">982</td>
    <td class="codeline">      TTI->getInstructionCost(I, TargetTransformInfo::TCK_Latency);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">  if (auto OC = ICost.getValue())</td>
    <td class="lineNumber">983</td>
    <td class="codeline">  if (auto OC = ICost.getValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">    return std::optional<uint64_t>(*OC);</td>
    <td class="lineNumber">984</td>
    <td class="codeline">    return std::optional<uint64_t>(*OC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">  return std::nullopt;</td>
    <td class="lineNumber">985</td>
    <td class="codeline">  return std::nullopt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">}</td>
    <td class="lineNumber">986</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline"></td>
    <td class="lineNumber">987</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">ScaledNumber<uint64_t></td>
    <td class="lineNumber">988</td>
    <td class="codeline">ScaledNumber<uint64_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">SelectOptimize::getMispredictionCost(const SelectInst *SI,</td>
    <td class="lineNumber">989</td>
    <td class="codeline">SelectOptimize::getMispredictionCost(const SelectInst *SI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">                                     const Scaled64 CondCost) {</td>
    <td class="lineNumber">990</td>
    <td class="codeline">                                     const Scaled64 CondCost) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">  uint64_t MispredictPenalty = TSchedModel.getMCSchedModel()->MispredictPenalty;</td>
    <td class="lineNumber">991</td>
    <td class="codeline">  uint64_t MispredictPenalty = TSchedModel.getMCSchedModel()->MispredictPenalty;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">  // Account for the default misprediction rate when using a branch</td>
    <td class="lineNumber">993</td>
    <td class="codeline">  // Account for the default misprediction rate when using a branch</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">  // (conservatively set to 25% by default).</td>
    <td class="lineNumber">994</td>
    <td class="codeline">  // (conservatively set to 25% by default).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">  uint64_t MispredictRate = MispredictDefaultRate;</td>
    <td class="lineNumber">995</td>
    <td class="codeline">  uint64_t MispredictRate = MispredictDefaultRate;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">  // If the select condition is obviously predictable, then the misprediction</td>
    <td class="lineNumber">996</td>
    <td class="codeline">  // If the select condition is obviously predictable, then the misprediction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">  // rate is zero.</td>
    <td class="lineNumber">997</td>
    <td class="codeline">  // rate is zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  if (isSelectHighlyPredictable(SI))</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  if (isSelectHighlyPredictable(SI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">    MispredictRate = 0;</td>
    <td class="lineNumber">999</td>
    <td class="codeline">    MispredictRate = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline"></td>
    <td class="lineNumber">1000</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">  // CondCost is included to account for cases where the computation of the</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">  // CondCost is included to account for cases where the computation of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">  // condition is part of a long dependence chain (potentially loop-carried)</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">  // condition is part of a long dependence chain (potentially loop-carried)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">  // that would delay detection of a misprediction and increase its cost.</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">  // that would delay detection of a misprediction and increase its cost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">  Scaled64 MispredictCost =</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">  Scaled64 MispredictCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">      std::max(Scaled64::get(MispredictPenalty), CondCost) *</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">      std::max(Scaled64::get(MispredictPenalty), CondCost) *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">      Scaled64::get(MispredictRate);</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">      Scaled64::get(MispredictRate);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">  MispredictCost /= Scaled64::get(100);</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">  MispredictCost /= Scaled64::get(100);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline"></td>
    <td class="lineNumber">1008</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">  return MispredictCost;</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">  return MispredictCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline"></td>
    <td class="lineNumber">1011</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">// Returns the cost of a branch when the prediction is correct.</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">// Returns the cost of a branch when the prediction is correct.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">// TrueCost * TrueProbability + FalseCost * FalseProbability.</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">// TrueCost * TrueProbability + FalseCost * FalseProbability.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">ScaledNumber<uint64_t></td>
    <td class="lineNumber">1014</td>
    <td class="codeline">ScaledNumber<uint64_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">SelectOptimize::getPredictedPathCost(Scaled64 TrueCost, Scaled64 FalseCost,</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">SelectOptimize::getPredictedPathCost(Scaled64 TrueCost, Scaled64 FalseCost,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">                                     const SelectInst *SI) {</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">                                     const SelectInst *SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">  Scaled64 PredPathCost;</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">  Scaled64 PredPathCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">  uint64_t TrueWeight, FalseWeight;</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">  uint64_t TrueWeight, FalseWeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">  if (extractBranchWeights(*SI, TrueWeight, FalseWeight)) {</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">  if (extractBranchWeights(*SI, TrueWeight, FalseWeight)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">    uint64_t SumWeight = TrueWeight + FalseWeight;</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">    uint64_t SumWeight = TrueWeight + FalseWeight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">    if (SumWeight != 0) {</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">    if (SumWeight != 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">      PredPathCost = TrueCost * Scaled64::get(TrueWeight) +</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">      PredPathCost = TrueCost * Scaled64::get(TrueWeight) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">                     FalseCost * Scaled64::get(FalseWeight);</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">                     FalseCost * Scaled64::get(FalseWeight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">      PredPathCost /= Scaled64::get(SumWeight);</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">      PredPathCost /= Scaled64::get(SumWeight);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">      return PredPathCost;</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">      return PredPathCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">  // Without branch weight metadata, we assume 75% for the one path and 25% for</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">  // Without branch weight metadata, we assume 75% for the one path and 25% for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">  // the other, and pick the result with the biggest cost.</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">  // the other, and pick the result with the biggest cost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">  PredPathCost = std::max(TrueCost * Scaled64::get(3) + FalseCost,</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">  PredPathCost = std::max(TrueCost * Scaled64::get(3) + FalseCost,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">                          FalseCost * Scaled64::get(3) + TrueCost);</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">                          FalseCost * Scaled64::get(3) + TrueCost);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">  PredPathCost /= Scaled64::get(4);</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">  PredPathCost /= Scaled64::get(4);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">  return PredPathCost;</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">  return PredPathCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline"></td>
    <td class="lineNumber">1035</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">bool SelectOptimize::isSelectKindSupported(SelectInst *SI) {</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">bool SelectOptimize::isSelectKindSupported(SelectInst *SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">  bool VectorCond = !SI->getCondition()->getType()->isIntegerTy(1);</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">  bool VectorCond = !SI->getCondition()->getType()->isIntegerTy(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">  if (VectorCond)</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">  if (VectorCond)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">  TargetLowering::SelectSupportKind SelectKind;</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">  TargetLowering::SelectSupportKind SelectKind;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">  if (SI->getType()->isVectorTy())</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">  if (SI->getType()->isVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">    SelectKind = TargetLowering::ScalarCondVectorVal;</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">    SelectKind = TargetLowering::ScalarCondVectorVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">    SelectKind = TargetLowering::ScalarValSelect;</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">    SelectKind = TargetLowering::ScalarValSelect;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">  return TLI->isSelectSupported(SelectKind);</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">  return TLI->isSelectSupported(SelectKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline"></td>
    <td class="lineNumber">1047</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===--- SelectOptimize.cpp - Convert select to branches if profitable ---===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===--- SelectOptimize.cpp - Convert select to branches if profitable ---===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This pass converts selects to conditional jumps when profitable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This pass converts selects to conditional jumps when profitable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/Analysis/BlockFrequencyInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/Analysis/BlockFrequencyInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/Analysis/BranchProbabilityInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/Analysis/BranchProbabilityInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/Analysis/LoopInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/Analysis/LoopInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/Analysis/ProfileSummaryInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/Analysis/ProfileSummaryInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/CodeGen/Passes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/CodeGen/Passes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSchedule.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSchedule.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/IR/ProfDataUtils.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/IR/ProfDataUtils.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/Support/ScaledNumber.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/Support/ScaledNumber.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/SizeOpts.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/SizeOpts.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include <memory></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include <memory></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include <queue></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include <queue></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include <stack></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include <stack></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include <string></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include <string></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#define DEBUG_TYPE "select-optimize"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#define DEBUG_TYPE "select-optimize"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">STATISTIC(NumSelectOptAnalyzed,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">STATISTIC(NumSelectOptAnalyzed,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">          "Number of select groups considered for conversion to branch");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">          "Number of select groups considered for conversion to branch");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">STATISTIC(NumSelectConvertedExpColdOperand,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">STATISTIC(NumSelectConvertedExpColdOperand,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">          "Number of select groups converted due to expensive cold operand");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">          "Number of select groups converted due to expensive cold operand");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">STATISTIC(NumSelectConvertedHighPred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">STATISTIC(NumSelectConvertedHighPred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">          "Number of select groups converted due to high-predictability");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">          "Number of select groups converted due to high-predictability");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">STATISTIC(NumSelectUnPred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">STATISTIC(NumSelectUnPred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">          "Number of select groups not converted due to unpredictability");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">          "Number of select groups not converted due to unpredictability");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">STATISTIC(NumSelectColdBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">STATISTIC(NumSelectColdBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">          "Number of select groups not converted due to cold basic block");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">          "Number of select groups not converted due to cold basic block");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">STATISTIC(NumSelectConvertedLoop,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">STATISTIC(NumSelectConvertedLoop,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">          "Number of select groups converted due to loop-level analysis");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">          "Number of select groups converted due to loop-level analysis");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">STATISTIC(NumSelectsConverted, "Number of selects converted");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">STATISTIC(NumSelectsConverted, "Number of selects converted");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">static cl::opt<unsigned> ColdOperandThreshold(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">static cl::opt<unsigned> ColdOperandThreshold(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">    "cold-operand-threshold",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">    "cold-operand-threshold",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">    cl::desc("Maximum frequency of path for an operand to be considered cold."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">    cl::desc("Maximum frequency of path for an operand to be considered cold."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">    cl::init(20), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">    cl::init(20), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">static cl::opt<unsigned> ColdOperandMaxCostMultiplier(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">static cl::opt<unsigned> ColdOperandMaxCostMultiplier(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">    "cold-operand-max-cost-multiplier",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">    "cold-operand-max-cost-multiplier",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">    cl::desc("Maximum cost multiplier of TCC_expensive for the dependence "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">    cl::desc("Maximum cost multiplier of TCC_expensive for the dependence "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">             "slice of a cold operand to be considered inexpensive."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">             "slice of a cold operand to be considered inexpensive."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">    cl::init(1), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">    cl::init(1), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">static cl::opt<unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">static cl::opt<unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">    GainGradientThreshold("select-opti-loop-gradient-gain-threshold",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">    GainGradientThreshold("select-opti-loop-gradient-gain-threshold",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">                          cl::desc("Gradient gain threshold (%)."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">                          cl::desc("Gradient gain threshold (%)."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">                          cl::init(25), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">                          cl::init(25), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">static cl::opt<unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">static cl::opt<unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">    GainCycleThreshold("select-opti-loop-cycle-gain-threshold",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">    GainCycleThreshold("select-opti-loop-cycle-gain-threshold",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">                       cl::desc("Minimum gain per loop (in cycles) threshold."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">                       cl::desc("Minimum gain per loop (in cycles) threshold."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">                       cl::init(4), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">                       cl::init(4), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">static cl::opt<unsigned> GainRelativeThreshold(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">static cl::opt<unsigned> GainRelativeThreshold(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">    "select-opti-loop-relative-gain-threshold",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">    "select-opti-loop-relative-gain-threshold",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">    cl::desc(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">    cl::desc(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">        "Minimum relative gain per loop threshold (1/X). Defaults to 12.5%"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">        "Minimum relative gain per loop threshold (1/X). Defaults to 12.5%"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">    cl::init(8), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">    cl::init(8), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">static cl::opt<unsigned> MispredictDefaultRate(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">static cl::opt<unsigned> MispredictDefaultRate(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">    "mispredict-default-rate", cl::Hidden, cl::init(25),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">    "mispredict-default-rate", cl::Hidden, cl::init(25),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">    cl::desc("Default mispredict rate (initialized to 25%)."));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">    cl::desc("Default mispredict rate (initialized to 25%)."));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">    DisableLoopLevelHeuristics("disable-loop-level-heuristics", cl::Hidden,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">    DisableLoopLevelHeuristics("disable-loop-level-heuristics", cl::Hidden,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">                               cl::init(false),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">                               cl::init(false),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">                               cl::desc("Disable loop-level heuristics."));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">                               cl::desc("Disable loop-level heuristics."));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">class SelectOptimize : public FunctionPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">class SelectOptimize : public FunctionPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">  const TargetMachine *TM = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">  const TargetMachine *TM = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  const TargetSubtargetInfo *TSI = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  const TargetSubtargetInfo *TSI = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">  const TargetLowering *TLI = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">  const TargetLowering *TLI = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">  const TargetTransformInfo *TTI = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">  const TargetTransformInfo *TTI = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">  const LoopInfo *LI = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">  const LoopInfo *LI = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">  DominatorTree *DT = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">  DominatorTree *DT = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">  std::unique_ptr<BlockFrequencyInfo> BFI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">  std::unique_ptr<BlockFrequencyInfo> BFI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">  std::unique_ptr<BranchProbabilityInfo> BPI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">  std::unique_ptr<BranchProbabilityInfo> BPI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">  ProfileSummaryInfo *PSI = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">  ProfileSummaryInfo *PSI = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  OptimizationRemarkEmitter *ORE = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  OptimizationRemarkEmitter *ORE = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">  TargetSchedModel TSchedModel;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">  TargetSchedModel TSchedModel;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">  SelectOptimize() : FunctionPass(ID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">  SelectOptimize() : FunctionPass(ID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">    initializeSelectOptimizePass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">    initializeSelectOptimizePass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">    AU.addRequired<ProfileSummaryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">    AU.addRequired<ProfileSummaryInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">    AU.addRequired<TargetPassConfig>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">    AU.addRequired<TargetPassConfig>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">    AU.addRequired<TargetTransformInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">    AU.addRequired<LoopInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">    AU.addRequired<LoopInfoWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">    AU.addRequired<OptimizationRemarkEmitterWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">    AU.addRequired<OptimizationRemarkEmitterWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">  // Select groups consist of consecutive select instructions with the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">  // Select groups consist of consecutive select instructions with the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">  // condition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">  // condition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">  using SelectGroup = SmallVector<SelectInst *, 2>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">  using SelectGroup = SmallVector<SelectInst *, 2>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">  using SelectGroups = SmallVector<SelectGroup, 2>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">  using SelectGroups = SmallVector<SelectGroup, 2>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">  using Scaled64 = ScaledNumber<uint64_t>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">  using Scaled64 = ScaledNumber<uint64_t>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">  struct CostInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">  struct CostInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">    /// Predicated cost (with selects as conditional moves).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">    /// Predicated cost (with selects as conditional moves).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">    Scaled64 PredCost;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">    Scaled64 PredCost;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">    /// Non-predicated cost (with selects converted to branches).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">    /// Non-predicated cost (with selects converted to branches).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">    Scaled64 NonPredCost;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">    Scaled64 NonPredCost;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">  // Converts select instructions of a function to conditional jumps when deemed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">  // Converts select instructions of a function to conditional jumps when deemed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  // profitable. Returns true if at least one select was converted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  // profitable. Returns true if at least one select was converted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">  bool optimizeSelects(Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">  bool optimizeSelects(Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">  // Heuristics for determining which select instructions can be profitably</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">  // Heuristics for determining which select instructions can be profitably</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">  // conveted to branches. Separate heuristics for selects in inner-most loops</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">  // conveted to branches. Separate heuristics for selects in inner-most loops</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">  // and the rest of code regions (base heuristics for non-inner-most loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">  // and the rest of code regions (base heuristics for non-inner-most loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">  // regions).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">  // regions).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">  void optimizeSelectsBase(Function &F, SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">  void optimizeSelectsBase(Function &F, SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">  void optimizeSelectsInnerLoops(Function &F, SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">  void optimizeSelectsInnerLoops(Function &F, SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  // Converts to branches the select groups that were deemed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  // Converts to branches the select groups that were deemed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">  // profitable-to-convert.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">  // profitable-to-convert.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">  void convertProfitableSIGroups(SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">  void convertProfitableSIGroups(SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">  // Splits selects of a given basic block into select groups.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">  // Splits selects of a given basic block into select groups.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">  void collectSelectGroups(BasicBlock &BB, SelectGroups &SIGroups);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">  void collectSelectGroups(BasicBlock &BB, SelectGroups &SIGroups);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  // Determines for which select groups it is profitable converting to branches</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  // Determines for which select groups it is profitable converting to branches</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">  // (base and inner-most-loop heuristics).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">  // (base and inner-most-loop heuristics).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">  void findProfitableSIGroupsBase(SelectGroups &SIGroups,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">  void findProfitableSIGroupsBase(SelectGroups &SIGroups,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">                                  SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">                                  SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">  void findProfitableSIGroupsInnerLoops(const Loop *L, SelectGroups &SIGroups,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">  void findProfitableSIGroupsInnerLoops(const Loop *L, SelectGroups &SIGroups,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">                                        SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">                                        SelectGroups &ProfSIGroups);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  // Determines if a select group should be converted to a branch (base</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  // Determines if a select group should be converted to a branch (base</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  // heuristics).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  // heuristics).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">  bool isConvertToBranchProfitableBase(const SmallVector<SelectInst *, 2> &ASI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">  bool isConvertToBranchProfitableBase(const SmallVector<SelectInst *, 2> &ASI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">  // Returns true if there are expensive instructions in the cold value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">  // Returns true if there are expensive instructions in the cold value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">  // operand's (if any) dependence slice of any of the selects of the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">  // operand's (if any) dependence slice of any of the selects of the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">  // group.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">  // group.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  bool hasExpensiveColdOperand(const SmallVector<SelectInst *, 2> &ASI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  bool hasExpensiveColdOperand(const SmallVector<SelectInst *, 2> &ASI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">  // For a given source instruction, collect its backwards dependence slice</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">  // For a given source instruction, collect its backwards dependence slice</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">  // consisting of instructions exclusively computed for producing the operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">  // consisting of instructions exclusively computed for producing the operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">  // of the source instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">  // of the source instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  void getExclBackwardsSlice(Instruction *I, std::stack<Instruction *> &Slice,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  void getExclBackwardsSlice(Instruction *I, std::stack<Instruction *> &Slice,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">                             Instruction *SI, bool ForSinking = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">                             Instruction *SI, bool ForSinking = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">  // Returns true if the condition of the select is highly predictable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">  // Returns true if the condition of the select is highly predictable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">  bool isSelectHighlyPredictable(const SelectInst *SI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">  bool isSelectHighlyPredictable(const SelectInst *SI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  // Loop-level checks to determine if a non-predicated version (with branches)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  // Loop-level checks to determine if a non-predicated version (with branches)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  // of the given loop is more profitable than its predicated version.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  // of the given loop is more profitable than its predicated version.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  bool checkLoopHeuristics(const Loop *L, const CostInfo LoopDepth[2]);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  bool checkLoopHeuristics(const Loop *L, const CostInfo LoopDepth[2]);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  // Computes instruction and loop-critical-path costs for both the predicated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  // Computes instruction and loop-critical-path costs for both the predicated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">  // and non-predicated version of the given loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">  // and non-predicated version of the given loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">  bool computeLoopCosts(const Loop *L, const SelectGroups &SIGroups,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">  bool computeLoopCosts(const Loop *L, const SelectGroups &SIGroups,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">                        DenseMap<const Instruction *, CostInfo> &InstCostMap,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">                        DenseMap<const Instruction *, CostInfo> &InstCostMap,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">                        CostInfo *LoopCost);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">                        CostInfo *LoopCost);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">  // Returns a set of all the select instructions in the given select groups.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">  // Returns a set of all the select instructions in the given select groups.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">  SmallPtrSet<const Instruction *, 2> getSIset(const SelectGroups &SIGroups);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">  SmallPtrSet<const Instruction *, 2> getSIset(const SelectGroups &SIGroups);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">  // Returns the latency cost of a given instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">  // Returns the latency cost of a given instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">  std::optional<uint64_t> computeInstCost(const Instruction *I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">  std::optional<uint64_t> computeInstCost(const Instruction *I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  // Returns the misprediction cost of a given select when converted to branch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  // Returns the misprediction cost of a given select when converted to branch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  Scaled64 getMispredictionCost(const SelectInst *SI, const Scaled64 CondCost);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  Scaled64 getMispredictionCost(const SelectInst *SI, const Scaled64 CondCost);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  // Returns the cost of a branch when the prediction is correct.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  // Returns the cost of a branch when the prediction is correct.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">  Scaled64 getPredictedPathCost(Scaled64 TrueCost, Scaled64 FalseCost,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">  Scaled64 getPredictedPathCost(Scaled64 TrueCost, Scaled64 FalseCost,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">                                const SelectInst *SI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">                                const SelectInst *SI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  // Returns true if the target architecture supports lowering a given select.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  // Returns true if the target architecture supports lowering a given select.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  bool isSelectKindSupported(SelectInst *SI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  bool isSelectKindSupported(SelectInst *SI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">char SelectOptimize::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">char SelectOptimize::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(SelectOptimize, DEBUG_TYPE, "Optimize selects", false,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">219</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(SelectOptimize, DEBUG_TYPE, "Optimize selects", false,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">                      false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">                      false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">221</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(LoopInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">222</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(ProfileSummaryInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">223</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(ProfileSummaryInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">224</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">225</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetTransformInfoWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(OptimizationRemarkEmitterWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">226</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(OptimizationRemarkEmitterWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(SelectOptimize, DEBUG_TYPE, "Optimize selects", false,</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">227</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(SelectOptimize, DEBUG_TYPE, "Optimize selects", false,</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">                    false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">                    false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">FunctionPass *llvm::createSelectOptimizePass() { return new SelectOptimize(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">FunctionPass *llvm::createSelectOptimizePass() { return new SelectOptimize(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">bool SelectOptimize::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">bool SelectOptimize::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  TM = &getAnalysis<TargetPassConfig>().getTM<TargetMachine>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  TM = &getAnalysis<TargetPassConfig>().getTM<TargetMachine>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">  TSI = TM->getSubtargetImpl(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">  TSI = TM->getSubtargetImpl(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  TLI = TSI->getTargetLowering();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  TLI = TSI->getTargetLowering();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">  // If none of the select types is supported then skip this pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">  // If none of the select types is supported then skip this pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  // This is an optimization pass. Legality issues will be handled by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  // This is an optimization pass. Legality issues will be handled by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  // instruction selection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  // instruction selection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  if (!TLI->isSelectSupported(TargetLowering::ScalarValSelect) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  if (!TLI->isSelectSupported(TargetLowering::ScalarValSelect) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">      !TLI->isSelectSupported(TargetLowering::ScalarCondVectorVal) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">      !TLI->isSelectSupported(TargetLowering::ScalarCondVectorVal) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">      !TLI->isSelectSupported(TargetLowering::VectorMaskSelect))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">      !TLI->isSelectSupported(TargetLowering::VectorMaskSelect))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">  TTI = &getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">  TTI = &getAnalysis<TargetTransformInfoWrapperPass>().getTTI(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">  if (!TTI->enableSelectOptimize())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">  if (!TTI->enableSelectOptimize())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">  LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">  LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  BPI.reset(new BranchProbabilityInfo(F, *LI));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  BPI.reset(new BranchProbabilityInfo(F, *LI));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  BFI.reset(new BlockFrequencyInfo(F, *BPI, *LI));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  BFI.reset(new BlockFrequencyInfo(F, *BPI, *LI));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  PSI = &getAnalysis<ProfileSummaryInfoWrapperPass>().getPSI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  PSI = &getAnalysis<ProfileSummaryInfoWrapperPass>().getPSI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  ORE = &getAnalysis<OptimizationRemarkEmitterWrapperPass>().getORE();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  ORE = &getAnalysis<OptimizationRemarkEmitterWrapperPass>().getORE();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">  TSchedModel.init(TSI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">  TSchedModel.init(TSI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">  // When optimizing for size, selects are preferable over branches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">  // When optimizing for size, selects are preferable over branches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">  if (F.hasOptSize() || llvm::shouldOptimizeForSize(&F, PSI, BFI.get()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">  if (F.hasOptSize() || llvm::shouldOptimizeForSize(&F, PSI, BFI.get()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  return optimizeSelects(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  return optimizeSelects(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">bool SelectOptimize::optimizeSelects(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">bool SelectOptimize::optimizeSelects(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  // Determine for which select groups it is profitable converting to branches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  // Determine for which select groups it is profitable converting to branches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  SelectGroups ProfSIGroups;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  SelectGroups ProfSIGroups;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">  // Base heuristics apply only to non-loops and outer loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">  // Base heuristics apply only to non-loops and outer loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  optimizeSelectsBase(F, ProfSIGroups);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  optimizeSelectsBase(F, ProfSIGroups);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">  // Separate heuristics for inner-most loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">  // Separate heuristics for inner-most loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  optimizeSelectsInnerLoops(F, ProfSIGroups);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  optimizeSelectsInnerLoops(F, ProfSIGroups);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">  // Convert to branches the select groups that were deemed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">  // Convert to branches the select groups that were deemed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  // profitable-to-convert.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  // profitable-to-convert.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">  convertProfitableSIGroups(ProfSIGroups);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  convertProfitableSIGroups(ProfSIGroups);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">  // Code modified if at least one select group was converted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">  // Code modified if at least one select group was converted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">  return !ProfSIGroups.empty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">  return !ProfSIGroups.empty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">void SelectOptimize::optimizeSelectsBase(Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">void SelectOptimize::optimizeSelectsBase(Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">                                         SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">                                         SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">  // Collect all the select groups.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">  // Collect all the select groups.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  SelectGroups SIGroups;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  SelectGroups SIGroups;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  for (BasicBlock &BB : F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  for (BasicBlock &BB : F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">    // Base heuristics apply only to non-loops and outer loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">    // Base heuristics apply only to non-loops and outer loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">    Loop *L = LI->getLoopFor(&BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">    Loop *L = LI->getLoopFor(&BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">    if (L && L->isInnermost())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">    if (L && L->isInnermost())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">    collectSelectGroups(BB, SIGroups);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">    collectSelectGroups(BB, SIGroups);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  // Determine for which select groups it is profitable converting to branches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  // Determine for which select groups it is profitable converting to branches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  findProfitableSIGroupsBase(SIGroups, ProfSIGroups);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  findProfitableSIGroupsBase(SIGroups, ProfSIGroups);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">void SelectOptimize::optimizeSelectsInnerLoops(Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">void SelectOptimize::optimizeSelectsInnerLoops(Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">                                               SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">                                               SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  SmallVector<Loop *, 4> Loops(LI->begin(), LI->end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  SmallVector<Loop *, 4> Loops(LI->begin(), LI->end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">  // Need to check size on each iteration as we accumulate child loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">  // Need to check size on each iteration as we accumulate child loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  for (unsigned long i = 0; i < Loops.size(); ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  for (unsigned long i = 0; i < Loops.size(); ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">    for (Loop *ChildL : Loops[i]->getSubLoops())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">    for (Loop *ChildL : Loops[i]->getSubLoops())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">      Loops.push_back(ChildL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">      Loops.push_back(ChildL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">  for (Loop *L : Loops) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">  for (Loop *L : Loops) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">    if (!L->isInnermost())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">    if (!L->isInnermost())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">    SelectGroups SIGroups;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">    SelectGroups SIGroups;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">    for (BasicBlock *BB : L->getBlocks())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">    for (BasicBlock *BB : L->getBlocks())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">      collectSelectGroups(*BB, SIGroups);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">      collectSelectGroups(*BB, SIGroups);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">    findProfitableSIGroupsInnerLoops(L, SIGroups, ProfSIGroups);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">    findProfitableSIGroupsInnerLoops(L, SIGroups, ProfSIGroups);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">/// If \p isTrue is true, return the true value of \p SI, otherwise return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">/// If \p isTrue is true, return the true value of \p SI, otherwise return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">/// false value of \p SI. If the true/false value of \p SI is defined by any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">/// false value of \p SI. If the true/false value of \p SI is defined by any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">/// select instructions in \p Selects, look through the defining select</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">/// select instructions in \p Selects, look through the defining select</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">/// instruction until the true/false value is not defined in \p Selects.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">/// instruction until the true/false value is not defined in \p Selects.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">static Value *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">static Value *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">getTrueOrFalseValue(SelectInst *SI, bool isTrue,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">getTrueOrFalseValue(SelectInst *SI, bool isTrue,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">                    const SmallPtrSet<const Instruction *, 2> &Selects) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">                    const SmallPtrSet<const Instruction *, 2> &Selects) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">  Value *V = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">  Value *V = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">  for (SelectInst *DefSI = SI; DefSI != nullptr && Selects.count(DefSI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">  for (SelectInst *DefSI = SI; DefSI != nullptr && Selects.count(DefSI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">       DefSI = dyn_cast<SelectInst>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">       DefSI = dyn_cast<SelectInst>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">    assert(DefSI->getCondition() == SI->getCondition() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">    assert(DefSI->getCondition() == SI->getCondition() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">           "The condition of DefSI does not match with SI");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">           "The condition of DefSI does not match with SI");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">    V = (isTrue ? DefSI->getTrueValue() : DefSI->getFalseValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">    V = (isTrue ? DefSI->getTrueValue() : DefSI->getFalseValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">  assert(V && "Failed to get select true/false value");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">  assert(V && "Failed to get select true/false value");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">void SelectOptimize::convertProfitableSIGroups(SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">void SelectOptimize::convertProfitableSIGroups(SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">  for (SelectGroup &ASI : ProfSIGroups) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">  for (SelectGroup &ASI : ProfSIGroups) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">    // The code transformation here is a modified version of the sinking</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">    // The code transformation here is a modified version of the sinking</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">    // transformation in CodeGenPrepare::optimizeSelectInst with a more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">    // transformation in CodeGenPrepare::optimizeSelectInst with a more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">    // aggressive strategy of which instructions to sink.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">    // aggressive strategy of which instructions to sink.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">    // TODO: eliminate the redundancy of logic transforming selects to branches</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">    // TODO: eliminate the redundancy of logic transforming selects to branches</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">    // by removing CodeGenPrepare::optimizeSelectInst and optimizing here</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">    // by removing CodeGenPrepare::optimizeSelectInst and optimizing here</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">    // selects for all cases (with and without profile information).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">    // selects for all cases (with and without profile information).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">    // Transform a sequence like this:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">    // Transform a sequence like this:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">    //    start:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">    //    start:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">    //       %cmp = cmp uge i32 %a, %b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">    //       %cmp = cmp uge i32 %a, %b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">    //       %sel = select i1 %cmp, i32 %c, i32 %d</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">    //       %sel = select i1 %cmp, i32 %c, i32 %d</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">    // Into:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">    // Into:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">    //    start:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">    //    start:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">    //       %cmp = cmp uge i32 %a, %b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">    //       %cmp = cmp uge i32 %a, %b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">    //       %cmp.frozen = freeze %cmp</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">    //       %cmp.frozen = freeze %cmp</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">    //       br i1 %cmp.frozen, label %select.true, label %select.false</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">    //       br i1 %cmp.frozen, label %select.true, label %select.false</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">    //    select.true:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">    //    select.true:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">    //       br label %select.end</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">    //       br label %select.end</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">    //    select.false:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">    //    select.false:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">    //       br label %select.end</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">    //       br label %select.end</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">    //    select.end:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">    //    select.end:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">    //       %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">    //       %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">    // %cmp should be frozen, otherwise it may introduce undefined behavior.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">    // %cmp should be frozen, otherwise it may introduce undefined behavior.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">    // In addition, we may sink instructions that produce %c or %d into the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">    // In addition, we may sink instructions that produce %c or %d into the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">    // destination(s) of the new branch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">    // destination(s) of the new branch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">    // If the true or false blocks do not contain a sunken instruction, that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">    // If the true or false blocks do not contain a sunken instruction, that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">    // block and its branch may be optimized away. In that case, one side of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">    // block and its branch may be optimized away. In that case, one side of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">    // first branch will point directly to select.end, and the corresponding PHI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">    // first branch will point directly to select.end, and the corresponding PHI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">    // predecessor block will be the start block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">    // predecessor block will be the start block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">    // Find all the instructions that can be soundly sunk to the true/false</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">    // Find all the instructions that can be soundly sunk to the true/false</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">    // blocks. These are instructions that are computed solely for producing the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">    // blocks. These are instructions that are computed solely for producing the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">    // operands of the select instructions in the group and can be sunk without</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">    // operands of the select instructions in the group and can be sunk without</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">    // breaking the semantics of the LLVM IR (e.g., cannot sink instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">    // breaking the semantics of the LLVM IR (e.g., cannot sink instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">    // with side effects).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">    // with side effects).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">    SmallVector<std::stack<Instruction *>, 2> TrueSlices, FalseSlices;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">    SmallVector<std::stack<Instruction *>, 2> TrueSlices, FalseSlices;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">    typedef std::stack<Instruction *>::size_type StackSizeType;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">    typedef std::stack<Instruction *>::size_type StackSizeType;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">    StackSizeType maxTrueSliceLen = 0, maxFalseSliceLen = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">    StackSizeType maxTrueSliceLen = 0, maxFalseSliceLen = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">    for (SelectInst *SI : ASI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">    for (SelectInst *SI : ASI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">      // For each select, compute the sinkable dependence chains of the true and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">      // For each select, compute the sinkable dependence chains of the true and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">      // false operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">      // false operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">      if (auto *TI = dyn_cast<Instruction>(SI->getTrueValue())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">      if (auto *TI = dyn_cast<Instruction>(SI->getTrueValue())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">        std::stack<Instruction *> TrueSlice;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">        std::stack<Instruction *> TrueSlice;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">        getExclBackwardsSlice(TI, TrueSlice, SI, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">        getExclBackwardsSlice(TI, TrueSlice, SI, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">        maxTrueSliceLen = std::max(maxTrueSliceLen, TrueSlice.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">        maxTrueSliceLen = std::max(maxTrueSliceLen, TrueSlice.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">        TrueSlices.push_back(TrueSlice);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">        TrueSlices.push_back(TrueSlice);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">      if (auto *FI = dyn_cast<Instruction>(SI->getFalseValue())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">      if (auto *FI = dyn_cast<Instruction>(SI->getFalseValue())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">        std::stack<Instruction *> FalseSlice;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">        std::stack<Instruction *> FalseSlice;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">        getExclBackwardsSlice(FI, FalseSlice, SI, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">        getExclBackwardsSlice(FI, FalseSlice, SI, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">        maxFalseSliceLen = std::max(maxFalseSliceLen, FalseSlice.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">        maxFalseSliceLen = std::max(maxFalseSliceLen, FalseSlice.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">        FalseSlices.push_back(FalseSlice);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">        FalseSlices.push_back(FalseSlice);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">    // In the case of multiple select instructions in the same group, the order</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">    // In the case of multiple select instructions in the same group, the order</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">    // of non-dependent instructions (instructions of different dependence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">    // of non-dependent instructions (instructions of different dependence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">    // slices) in the true/false blocks appears to affect performance.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">    // slices) in the true/false blocks appears to affect performance.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">    // Interleaving the slices seems to experimentally be the optimal approach.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">    // Interleaving the slices seems to experimentally be the optimal approach.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">    // This interleaving scheduling allows for more ILP (with a natural downside</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">    // This interleaving scheduling allows for more ILP (with a natural downside</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">    // of increasing a bit register pressure) compared to a simple ordering of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">    // of increasing a bit register pressure) compared to a simple ordering of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">    // one whole chain after another. One would expect that this ordering would</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">    // one whole chain after another. One would expect that this ordering would</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">    // not matter since the scheduling in the backend of the compiler  would</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">    // not matter since the scheduling in the backend of the compiler  would</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">    // take care of it, but apparently the scheduler fails to deliver optimal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">    // take care of it, but apparently the scheduler fails to deliver optimal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">    // ILP with a naive ordering here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">    // ILP with a naive ordering here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">    SmallVector<Instruction *, 2> TrueSlicesInterleaved, FalseSlicesInterleaved;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">    SmallVector<Instruction *, 2> TrueSlicesInterleaved, FalseSlicesInterleaved;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">    for (StackSizeType IS = 0; IS < maxTrueSliceLen; ++IS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">    for (StackSizeType IS = 0; IS < maxTrueSliceLen; ++IS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">      for (auto &S : TrueSlices) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">      for (auto &S : TrueSlices) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">        if (!S.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">        if (!S.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">          TrueSlicesInterleaved.push_back(S.top());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">          TrueSlicesInterleaved.push_back(S.top());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">          S.pop();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">          S.pop();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">    for (StackSizeType IS = 0; IS < maxFalseSliceLen; ++IS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">    for (StackSizeType IS = 0; IS < maxFalseSliceLen; ++IS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">      for (auto &S : FalseSlices) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">      for (auto &S : FalseSlices) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">        if (!S.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">        if (!S.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">          FalseSlicesInterleaved.push_back(S.top());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">          FalseSlicesInterleaved.push_back(S.top());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">          S.pop();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">          S.pop();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">    // We split the block containing the select(s) into two blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">    // We split the block containing the select(s) into two blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">    SelectInst *SI = ASI.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">    SelectInst *SI = ASI.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">    SelectInst *LastSI = ASI.back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">    SelectInst *LastSI = ASI.back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">    BasicBlock *StartBlock = SI->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">    BasicBlock *StartBlock = SI->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">    BasicBlock::iterator SplitPt = ++(BasicBlock::iterator(LastSI));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">    BasicBlock::iterator SplitPt = ++(BasicBlock::iterator(LastSI));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">    BasicBlock *EndBlock = StartBlock->splitBasicBlock(SplitPt, "select.end");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">    BasicBlock *EndBlock = StartBlock->splitBasicBlock(SplitPt, "select.end");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">    BFI->setBlockFreq(EndBlock, BFI->getBlockFreq(StartBlock).getFrequency());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">    BFI->setBlockFreq(EndBlock, BFI->getBlockFreq(StartBlock).getFrequency());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">    // Delete the unconditional branch that was just created by the split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">    // Delete the unconditional branch that was just created by the split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">    StartBlock->getTerminator()->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">    StartBlock->getTerminator()->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">    // Move any debug/pseudo instructions that were in-between the select</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">    // Move any debug/pseudo instructions that were in-between the select</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">    // group to the newly-created end block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">    // group to the newly-created end block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">    SmallVector<Instruction *, 2> DebugPseudoINS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">    SmallVector<Instruction *, 2> DebugPseudoINS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">    auto DIt = SI->getIterator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">    auto DIt = SI->getIterator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">    while (&*DIt != LastSI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">    while (&*DIt != LastSI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">      if (DIt->isDebugOrPseudoInst())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">      if (DIt->isDebugOrPseudoInst())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">        DebugPseudoINS.push_back(&*DIt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">        DebugPseudoINS.push_back(&*DIt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">      DIt++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">      DIt++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">    for (auto *DI : DebugPseudoINS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">    for (auto *DI : DebugPseudoINS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">      DI->moveBefore(&*EndBlock->getFirstInsertionPt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">      DI->moveBefore(&*EndBlock->getFirstInsertionPt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">    // These are the new basic blocks for the conditional branch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">    // These are the new basic blocks for the conditional branch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">    // At least one will become an actual new basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">    // At least one will become an actual new basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">    BasicBlock *TrueBlock = nullptr, *FalseBlock = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">    BasicBlock *TrueBlock = nullptr, *FalseBlock = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">    BranchInst *TrueBranch = nullptr, *FalseBranch = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">    BranchInst *TrueBranch = nullptr, *FalseBranch = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">    if (!TrueSlicesInterleaved.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">    if (!TrueSlicesInterleaved.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">      TrueBlock = BasicBlock::Create(LastSI->getContext(), "select.true.sink",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">      TrueBlock = BasicBlock::Create(LastSI->getContext(), "select.true.sink",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">                                     EndBlock->getParent(), EndBlock);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">                                     EndBlock->getParent(), EndBlock);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">      TrueBranch = BranchInst::Create(EndBlock, TrueBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">      TrueBranch = BranchInst::Create(EndBlock, TrueBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">      TrueBranch->setDebugLoc(LastSI->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">      TrueBranch->setDebugLoc(LastSI->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">      for (Instruction *TrueInst : TrueSlicesInterleaved)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">      for (Instruction *TrueInst : TrueSlicesInterleaved)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">        TrueInst->moveBefore(TrueBranch);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">        TrueInst->moveBefore(TrueBranch);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">    if (!FalseSlicesInterleaved.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">    if (!FalseSlicesInterleaved.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">      FalseBlock = BasicBlock::Create(LastSI->getContext(), "select.false.sink",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">      FalseBlock = BasicBlock::Create(LastSI->getContext(), "select.false.sink",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">                                      EndBlock->getParent(), EndBlock);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">                                      EndBlock->getParent(), EndBlock);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">      FalseBranch = BranchInst::Create(EndBlock, FalseBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">      FalseBranch = BranchInst::Create(EndBlock, FalseBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">      FalseBranch->setDebugLoc(LastSI->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">      FalseBranch->setDebugLoc(LastSI->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">      for (Instruction *FalseInst : FalseSlicesInterleaved)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">      for (Instruction *FalseInst : FalseSlicesInterleaved)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">        FalseInst->moveBefore(FalseBranch);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">        FalseInst->moveBefore(FalseBranch);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">    // If there was nothing to sink, then arbitrarily choose the 'false' side</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">    // If there was nothing to sink, then arbitrarily choose the 'false' side</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">    // for a new input value to the PHI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">    // for a new input value to the PHI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">    if (TrueBlock == FalseBlock) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">    if (TrueBlock == FalseBlock) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">      assert(TrueBlock == nullptr &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">      assert(TrueBlock == nullptr &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">             "Unexpected basic block transform while optimizing select");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">             "Unexpected basic block transform while optimizing select");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">      FalseBlock = BasicBlock::Create(SI->getContext(), "select.false",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">      FalseBlock = BasicBlock::Create(SI->getContext(), "select.false",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">                                      EndBlock->getParent(), EndBlock);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">                                      EndBlock->getParent(), EndBlock);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">      auto *FalseBranch = BranchInst::Create(EndBlock, FalseBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">      auto *FalseBranch = BranchInst::Create(EndBlock, FalseBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">      FalseBranch->setDebugLoc(SI->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">      FalseBranch->setDebugLoc(SI->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">    // Insert the real conditional branch based on the original condition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">    // Insert the real conditional branch based on the original condition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">    // If we did not create a new block for one of the 'true' or 'false' paths</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">    // If we did not create a new block for one of the 'true' or 'false' paths</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">    // of the condition, it means that side of the branch goes to the end block</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">    // of the condition, it means that side of the branch goes to the end block</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">    // directly and the path originates from the start block from the point of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">    // directly and the path originates from the start block from the point of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">    // view of the new PHI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">    // view of the new PHI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">    BasicBlock *TT, *FT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">    BasicBlock *TT, *FT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">    if (TrueBlock == nullptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">    if (TrueBlock == nullptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">      TT = EndBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">      TT = EndBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">      FT = FalseBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">      FT = FalseBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">      TrueBlock = StartBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">      TrueBlock = StartBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">    } else if (FalseBlock == nullptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">    } else if (FalseBlock == nullptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">      TT = TrueBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">      TT = TrueBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">      FT = EndBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">      FT = EndBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">      FalseBlock = StartBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">      FalseBlock = StartBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">      TT = TrueBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">      TT = TrueBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">      FT = FalseBlock;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">      FT = FalseBlock;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">    IRBuilder<> IB(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">    IRBuilder<> IB(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">    auto *CondFr =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">    auto *CondFr =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">        IB.CreateFreeze(SI->getCondition(), SI->getName() + ".frozen");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">        IB.CreateFreeze(SI->getCondition(), SI->getName() + ".frozen");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">    IB.CreateCondBr(CondFr, TT, FT, SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">    IB.CreateCondBr(CondFr, TT, FT, SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">    SmallPtrSet<const Instruction *, 2> INS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">    SmallPtrSet<const Instruction *, 2> INS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">    INS.insert(ASI.begin(), ASI.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">    INS.insert(ASI.begin(), ASI.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">    // Use reverse iterator because later select may use the value of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">    // Use reverse iterator because later select may use the value of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">    // earlier select, and we need to propagate value through earlier select</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">    // earlier select, and we need to propagate value through earlier select</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">    // to get the PHI operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">    // to get the PHI operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">    for (auto It = ASI.rbegin(); It != ASI.rend(); ++It) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">    for (auto It = ASI.rbegin(); It != ASI.rend(); ++It) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">      SelectInst *SI = *It;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">      SelectInst *SI = *It;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">      // The select itself is replaced with a PHI Node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">      // The select itself is replaced with a PHI Node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">      PHINode *PN = PHINode::Create(SI->getType(), 2, "", &EndBlock->front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">      PHINode *PN = PHINode::Create(SI->getType(), 2, "", &EndBlock->front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">      PN->takeName(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">      PN->takeName(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">      PN->addIncoming(getTrueOrFalseValue(SI, true, INS), TrueBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">      PN->addIncoming(getTrueOrFalseValue(SI, true, INS), TrueBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">      PN->addIncoming(getTrueOrFalseValue(SI, false, INS), FalseBlock);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">      PN->addIncoming(getTrueOrFalseValue(SI, false, INS), FalseBlock);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">      PN->setDebugLoc(SI->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">      PN->setDebugLoc(SI->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">      SI->replaceAllUsesWith(PN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">      SI->replaceAllUsesWith(PN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">      SI->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">      SI->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">      INS.erase(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">      INS.erase(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">      ++NumSelectsConverted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">      ++NumSelectsConverted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">static bool isSpecialSelect(SelectInst *SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">static bool isSpecialSelect(SelectInst *SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  using namespace llvm::PatternMatch;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  using namespace llvm::PatternMatch;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  // If the select is a logical-and/logical-or then it is better treated as a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  // If the select is a logical-and/logical-or then it is better treated as a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">  // and/or by the backend.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">  // and/or by the backend.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  if (match(SI, m_CombineOr(m_LogicalAnd(m_Value(), m_Value()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  if (match(SI, m_CombineOr(m_LogicalAnd(m_Value(), m_Value()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">                            m_LogicalOr(m_Value(), m_Value()))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">                            m_LogicalOr(m_Value(), m_Value()))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">void SelectOptimize::collectSelectGroups(BasicBlock &BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">void SelectOptimize::collectSelectGroups(BasicBlock &BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">                                         SelectGroups &SIGroups) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">                                         SelectGroups &SIGroups) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  BasicBlock::iterator BBIt = BB.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  BasicBlock::iterator BBIt = BB.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  while (BBIt != BB.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  while (BBIt != BB.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">    Instruction *I = &*BBIt++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">    Instruction *I = &*BBIt++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">    if (SelectInst *SI = dyn_cast<SelectInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">    if (SelectInst *SI = dyn_cast<SelectInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">      if (isSpecialSelect(SI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">      if (isSpecialSelect(SI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">      SelectGroup SIGroup;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">      SelectGroup SIGroup;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">      SIGroup.push_back(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">      SIGroup.push_back(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">      while (BBIt != BB.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">      while (BBIt != BB.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">        Instruction *NI = &*BBIt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">        Instruction *NI = &*BBIt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">        SelectInst *NSI = dyn_cast<SelectInst>(NI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">        SelectInst *NSI = dyn_cast<SelectInst>(NI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">        if (NSI && SI->getCondition() == NSI->getCondition()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">        if (NSI && SI->getCondition() == NSI->getCondition()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">          SIGroup.push_back(NSI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">          SIGroup.push_back(NSI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">        } else if (!NI->isDebugOrPseudoInst()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">        } else if (!NI->isDebugOrPseudoInst()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">          // Debug/pseudo instructions should be skipped and not prevent the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">          // Debug/pseudo instructions should be skipped and not prevent the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">          // formation of a select group.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">          // formation of a select group.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">        ++BBIt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">        ++BBIt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">      // If the select type is not supported, no point optimizing it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">      // If the select type is not supported, no point optimizing it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">      // Instruction selection will take care of it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">      // Instruction selection will take care of it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">      if (!isSelectKindSupported(SI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">      if (!isSelectKindSupported(SI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">      SIGroups.push_back(SIGroup);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">      SIGroups.push_back(SIGroup);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">void SelectOptimize::findProfitableSIGroupsBase(SelectGroups &SIGroups,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">void SelectOptimize::findProfitableSIGroupsBase(SelectGroups &SIGroups,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">                                                SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">                                                SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">  for (SelectGroup &ASI : SIGroups) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">  for (SelectGroup &ASI : SIGroups) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">    ++NumSelectOptAnalyzed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">    ++NumSelectOptAnalyzed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">    if (isConvertToBranchProfitableBase(ASI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">    if (isConvertToBranchProfitableBase(ASI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">      ProfSIGroups.push_back(ASI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">      ProfSIGroups.push_back(ASI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">static void EmitAndPrintRemark(OptimizationRemarkEmitter *ORE,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">static void EmitAndPrintRemark(OptimizationRemarkEmitter *ORE,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">                               DiagnosticInfoOptimizationBase &Rem) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">                               DiagnosticInfoOptimizationBase &Rem) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << Rem.getMsg() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << Rem.getMsg() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">  ORE->emit(Rem);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">  ORE->emit(Rem);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">void SelectOptimize::findProfitableSIGroupsInnerLoops(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">void SelectOptimize::findProfitableSIGroupsInnerLoops(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">    const Loop *L, SelectGroups &SIGroups, SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">    const Loop *L, SelectGroups &SIGroups, SelectGroups &ProfSIGroups) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  NumSelectOptAnalyzed += SIGroups.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  NumSelectOptAnalyzed += SIGroups.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">  // For each select group in an inner-most loop,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">  // For each select group in an inner-most loop,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">  // a branch is more preferable than a select/conditional-move if:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">  // a branch is more preferable than a select/conditional-move if:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">  // i) conversion to branches for all the select groups of the loop satisfies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">  // i) conversion to branches for all the select groups of the loop satisfies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">  //    loop-level heuristics including reducing the loop's critical path by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">  //    loop-level heuristics including reducing the loop's critical path by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">  //    some threshold (see SelectOptimize::checkLoopHeuristics); and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">  //    some threshold (see SelectOptimize::checkLoopHeuristics); and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">  // ii) the total cost of the select group is cheaper with a branch compared</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">  // ii) the total cost of the select group is cheaper with a branch compared</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">  //     to its predicated version. The cost is in terms of latency and the cost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">  //     to its predicated version. The cost is in terms of latency and the cost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">  //     of a select group is the cost of its most expensive select instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">  //     of a select group is the cost of its most expensive select instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">  //     (assuming infinite resources and thus fully leveraging available ILP).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">  //     (assuming infinite resources and thus fully leveraging available ILP).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  DenseMap<const Instruction *, CostInfo> InstCostMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  DenseMap<const Instruction *, CostInfo> InstCostMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">  CostInfo LoopCost[2] = {{Scaled64::getZero(), Scaled64::getZero()},</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">  CostInfo LoopCost[2] = {{Scaled64::getZero(), Scaled64::getZero()},</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">                          {Scaled64::getZero(), Scaled64::getZero()}};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">                          {Scaled64::getZero(), Scaled64::getZero()}};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  if (!computeLoopCosts(L, SIGroups, InstCostMap, LoopCost) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  if (!computeLoopCosts(L, SIGroups, InstCostMap, LoopCost) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">      !checkLoopHeuristics(L, LoopCost)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">      !checkLoopHeuristics(L, LoopCost)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  for (SelectGroup &ASI : SIGroups) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  for (SelectGroup &ASI : SIGroups) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">    // Assuming infinite resources, the cost of a group of instructions is the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">    // Assuming infinite resources, the cost of a group of instructions is the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">    // cost of the most expensive instruction of the group.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">    // cost of the most expensive instruction of the group.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">    Scaled64 SelectCost = Scaled64::getZero(), BranchCost = Scaled64::getZero();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">    Scaled64 SelectCost = Scaled64::getZero(), BranchCost = Scaled64::getZero();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">    for (SelectInst *SI : ASI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">    for (SelectInst *SI : ASI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">      SelectCost = std::max(SelectCost, InstCostMap[SI].PredCost);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">      SelectCost = std::max(SelectCost, InstCostMap[SI].PredCost);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">      BranchCost = std::max(BranchCost, InstCostMap[SI].NonPredCost);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">      BranchCost = std::max(BranchCost, InstCostMap[SI].NonPredCost);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">    if (BranchCost < SelectCost) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">    if (BranchCost < SelectCost) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">      OptimizationRemark OR(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">      OptimizationRemark OR(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">      OR << "Profitable to convert to branch (loop analysis). BranchCost="</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">      OR << "Profitable to convert to branch (loop analysis). BranchCost="</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">         << BranchCost.toString() << ", SelectCost=" << SelectCost.toString()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">         << BranchCost.toString() << ", SelectCost=" << SelectCost.toString()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">         << ". ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">         << ". ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">      EmitAndPrintRemark(ORE, OR);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">      EmitAndPrintRemark(ORE, OR);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">      ++NumSelectConvertedLoop;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">      ++NumSelectConvertedLoop;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">      ProfSIGroups.push_back(ASI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">      ProfSIGroups.push_back(ASI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">      OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">      OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">      ORmiss << "Select is more profitable (loop analysis). BranchCost="</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">      ORmiss << "Select is more profitable (loop analysis). BranchCost="</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">             << BranchCost.toString()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">             << BranchCost.toString()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">             << ", SelectCost=" << SelectCost.toString() << ". ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">             << ", SelectCost=" << SelectCost.toString() << ". ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">      EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">      EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">bool SelectOptimize::isConvertToBranchProfitableBase(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">bool SelectOptimize::isConvertToBranchProfitableBase(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">    const SmallVector<SelectInst *, 2> &ASI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">    const SmallVector<SelectInst *, 2> &ASI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  SelectInst *SI = ASI.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  SelectInst *SI = ASI.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Analyzing select group containing " << *SI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Analyzing select group containing " << *SI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  OptimizationRemark OR(DEBUG_TYPE, "SelectOpti", SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  OptimizationRemark OR(DEBUG_TYPE, "SelectOpti", SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">  OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">  OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">  // Skip cold basic blocks. Better to optimize for size for cold blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">  // Skip cold basic blocks. Better to optimize for size for cold blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">  if (PSI->isColdBlock(SI->getParent(), BFI.get())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">  if (PSI->isColdBlock(SI->getParent(), BFI.get())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">    ++NumSelectColdBB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">    ++NumSelectColdBB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">    ORmiss << "Not converted to branch because of cold basic block. ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">    ORmiss << "Not converted to branch because of cold basic block. ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  // If unpredictable, branch form is less profitable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  // If unpredictable, branch form is less profitable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">  if (SI->getMetadata(LLVMContext::MD_unpredictable)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">  if (SI->getMetadata(LLVMContext::MD_unpredictable)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">    ++NumSelectUnPred;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">    ++NumSelectUnPred;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">    ORmiss << "Not converted to branch because of unpredictable branch. ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">    ORmiss << "Not converted to branch because of unpredictable branch. ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">  // If highly predictable, branch form is more profitable, unless a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">  // If highly predictable, branch form is more profitable, unless a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  // predictable select is inexpensive in the target architecture.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  // predictable select is inexpensive in the target architecture.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  if (isSelectHighlyPredictable(SI) && TLI->isPredictableSelectExpensive()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  if (isSelectHighlyPredictable(SI) && TLI->isPredictableSelectExpensive()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">    ++NumSelectConvertedHighPred;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">    ++NumSelectConvertedHighPred;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">    OR << "Converted to branch because of highly predictable branch. ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">    OR << "Converted to branch because of highly predictable branch. ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, OR);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, OR);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  // Look for expensive instructions in the cold operand's (if any) dependence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  // Look for expensive instructions in the cold operand's (if any) dependence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">  // slice of any of the selects in the group.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">  // slice of any of the selects in the group.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">  if (hasExpensiveColdOperand(ASI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">  if (hasExpensiveColdOperand(ASI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">    ++NumSelectConvertedExpColdOperand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">    ++NumSelectConvertedExpColdOperand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">    OR << "Converted to branch because of expensive cold operand.";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">    OR << "Converted to branch because of expensive cold operand.";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, OR);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, OR);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">  ORmiss << "Not profitable to convert to branch (base heuristic).";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">  ORmiss << "Not profitable to convert to branch (base heuristic).";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">  EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">  EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">static InstructionCost divideNearest(InstructionCost Numerator,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">static InstructionCost divideNearest(InstructionCost Numerator,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">                                     uint64_t Denominator) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">                                     uint64_t Denominator) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">  return (Numerator + (Denominator / 2)) / Denominator;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">  return (Numerator + (Denominator / 2)) / Denominator;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">bool SelectOptimize::hasExpensiveColdOperand(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">bool SelectOptimize::hasExpensiveColdOperand(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">    const SmallVector<SelectInst *, 2> &ASI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">    const SmallVector<SelectInst *, 2> &ASI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">  bool ColdOperand = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">  bool ColdOperand = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  uint64_t TrueWeight, FalseWeight, TotalWeight;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  uint64_t TrueWeight, FalseWeight, TotalWeight;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">  if (extractBranchWeights(*ASI.front(), TrueWeight, FalseWeight)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">  if (extractBranchWeights(*ASI.front(), TrueWeight, FalseWeight)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">    uint64_t MinWeight = std::min(TrueWeight, FalseWeight);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">    uint64_t MinWeight = std::min(TrueWeight, FalseWeight);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">    TotalWeight = TrueWeight + FalseWeight;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">    TotalWeight = TrueWeight + FalseWeight;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">    // Is there a path with frequency <ColdOperandThreshold% (default:20%) ?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">    // Is there a path with frequency <ColdOperandThreshold% (default:20%) ?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">    ColdOperand = TotalWeight * ColdOperandThreshold > 100 * MinWeight;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">    ColdOperand = TotalWeight * ColdOperandThreshold > 100 * MinWeight;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  } else if (PSI->hasProfileSummary()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  } else if (PSI->hasProfileSummary()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">    OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">    OptimizationRemarkMissed ORmiss(DEBUG_TYPE, "SelectOpti", ASI.front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">    ORmiss << "Profile data available but missing branch-weights metadata for "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">    ORmiss << "Profile data available but missing branch-weights metadata for "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">              "select instruction. ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">              "select instruction. ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, ORmiss);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">  if (!ColdOperand)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">  if (!ColdOperand)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  // Check if the cold path's dependence slice is expensive for any of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  // Check if the cold path's dependence slice is expensive for any of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  // selects of the group.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  // selects of the group.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  for (SelectInst *SI : ASI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  for (SelectInst *SI : ASI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">    Instruction *ColdI = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">    Instruction *ColdI = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">    uint64_t HotWeight;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">    uint64_t HotWeight;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">    if (TrueWeight < FalseWeight) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">    if (TrueWeight < FalseWeight) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">      ColdI = dyn_cast<Instruction>(SI->getTrueValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">      ColdI = dyn_cast<Instruction>(SI->getTrueValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">      HotWeight = FalseWeight;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">      HotWeight = FalseWeight;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">      ColdI = dyn_cast<Instruction>(SI->getFalseValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">      ColdI = dyn_cast<Instruction>(SI->getFalseValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">      HotWeight = TrueWeight;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">      HotWeight = TrueWeight;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">    if (ColdI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">    if (ColdI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">      std::stack<Instruction *> ColdSlice;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">      std::stack<Instruction *> ColdSlice;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">      getExclBackwardsSlice(ColdI, ColdSlice, SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">      getExclBackwardsSlice(ColdI, ColdSlice, SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">      InstructionCost SliceCost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">      InstructionCost SliceCost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">      while (!ColdSlice.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">      while (!ColdSlice.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">        SliceCost += TTI->getInstructionCost(ColdSlice.top(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">        SliceCost += TTI->getInstructionCost(ColdSlice.top(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">                                             TargetTransformInfo::TCK_Latency);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">                                             TargetTransformInfo::TCK_Latency);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">        ColdSlice.pop();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">        ColdSlice.pop();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">      // The colder the cold value operand of the select is the more expensive</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">      // The colder the cold value operand of the select is the more expensive</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">      // the cmov becomes for computing the cold value operand every time. Thus,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">      // the cmov becomes for computing the cold value operand every time. Thus,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">      // the colder the cold operand is the more its cost counts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">      // the colder the cold operand is the more its cost counts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">      // Get nearest integer cost adjusted for coldness.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">      // Get nearest integer cost adjusted for coldness.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">      InstructionCost AdjSliceCost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">      InstructionCost AdjSliceCost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">          divideNearest(SliceCost * HotWeight, TotalWeight);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">          divideNearest(SliceCost * HotWeight, TotalWeight);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">      if (AdjSliceCost >=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">      if (AdjSliceCost >=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">          ColdOperandMaxCostMultiplier * TargetTransformInfo::TCC_Expensive)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">          ColdOperandMaxCostMultiplier * TargetTransformInfo::TCC_Expensive)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">// Check if it is safe to move LoadI next to the SI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">// Check if it is safe to move LoadI next to the SI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">// Conservatively assume it is safe only if there is no instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">// Conservatively assume it is safe only if there is no instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">// modifying memory in-between the load and the select instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">// modifying memory in-between the load and the select instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">static bool isSafeToSinkLoad(Instruction *LoadI, Instruction *SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">static bool isSafeToSinkLoad(Instruction *LoadI, Instruction *SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">  // Assume loads from different basic blocks are unsafe to move.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">  // Assume loads from different basic blocks are unsafe to move.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  if (LoadI->getParent() != SI->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  if (LoadI->getParent() != SI->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">  auto It = LoadI->getIterator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">  auto It = LoadI->getIterator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">  while (&*It != SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">  while (&*It != SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">    if (It->mayWriteToMemory())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">    if (It->mayWriteToMemory())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">    It++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">    It++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">// For a given source instruction, collect its backwards dependence slice</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">// For a given source instruction, collect its backwards dependence slice</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">// consisting of instructions exclusively computed for the purpose of producing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">// consisting of instructions exclusively computed for the purpose of producing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">// the operands of the source instruction. As an approximation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">// the operands of the source instruction. As an approximation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">// (sufficiently-accurate in practice), we populate this set with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">// (sufficiently-accurate in practice), we populate this set with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">// instructions of the backwards dependence slice that only have one-use and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">// instructions of the backwards dependence slice that only have one-use and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">// form an one-use chain that leads to the source instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">// form an one-use chain that leads to the source instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">void SelectOptimize::getExclBackwardsSlice(Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">void SelectOptimize::getExclBackwardsSlice(Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">                                           std::stack<Instruction *> &Slice,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">                                           std::stack<Instruction *> &Slice,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">                                           Instruction *SI, bool ForSinking) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">                                           Instruction *SI, bool ForSinking) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">  SmallPtrSet<Instruction *, 2> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">  SmallPtrSet<Instruction *, 2> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">  std::queue<Instruction *> Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">  std::queue<Instruction *> Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">  Worklist.push(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">  Worklist.push(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">    Instruction *II = Worklist.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">    Instruction *II = Worklist.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">    Worklist.pop();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">    Worklist.pop();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">    // Avoid cycles.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">    // Avoid cycles.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">    if (!Visited.insert(II).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">    if (!Visited.insert(II).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">    if (!II->hasOneUse())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">    if (!II->hasOneUse())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">    // Cannot soundly sink instructions with side-effects.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">    // Cannot soundly sink instructions with side-effects.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">    // Terminator or phi instructions cannot be sunk.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">    // Terminator or phi instructions cannot be sunk.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">    // Avoid sinking other select instructions (should be handled separetely).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">    // Avoid sinking other select instructions (should be handled separetely).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">    if (ForSinking && (II->isTerminator() || II->mayHaveSideEffects() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">    if (ForSinking && (II->isTerminator() || II->mayHaveSideEffects() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">                       isa<SelectInst>(II) || isa<PHINode>(II)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">                       isa<SelectInst>(II) || isa<PHINode>(II)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">    // Avoid sinking loads in order not to skip state-modifying instructions,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">    // Avoid sinking loads in order not to skip state-modifying instructions,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">    // that may alias with the loaded address.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">    // that may alias with the loaded address.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">    // Only allow sinking of loads within the same basic block that are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">    // Only allow sinking of loads within the same basic block that are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">    // conservatively proven to be safe.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">    // conservatively proven to be safe.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">    if (ForSinking && II->mayReadFromMemory() && !isSafeToSinkLoad(II, SI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">    if (ForSinking && II->mayReadFromMemory() && !isSafeToSinkLoad(II, SI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">    // Avoid considering instructions with less frequency than the source</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">    // Avoid considering instructions with less frequency than the source</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">    // instruction (i.e., avoid colder code regions of the dependence slice).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">    // instruction (i.e., avoid colder code regions of the dependence slice).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">    if (BFI->getBlockFreq(II->getParent()) < BFI->getBlockFreq(I->getParent()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">    if (BFI->getBlockFreq(II->getParent()) < BFI->getBlockFreq(I->getParent()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">    // Eligible one-use instruction added to the dependence slice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">    // Eligible one-use instruction added to the dependence slice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">    Slice.push(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">    Slice.push(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">    // Explore all the operands of the current instruction to expand the slice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">    // Explore all the operands of the current instruction to expand the slice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">    for (unsigned k = 0; k < II->getNumOperands(); ++k)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">    for (unsigned k = 0; k < II->getNumOperands(); ++k)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">      if (auto *OpI = dyn_cast<Instruction>(II->getOperand(k)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">      if (auto *OpI = dyn_cast<Instruction>(II->getOperand(k)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">        Worklist.push(OpI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">        Worklist.push(OpI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">bool SelectOptimize::isSelectHighlyPredictable(const SelectInst *SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">bool SelectOptimize::isSelectHighlyPredictable(const SelectInst *SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">  uint64_t TrueWeight, FalseWeight;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">  uint64_t TrueWeight, FalseWeight;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">  if (extractBranchWeights(*SI, TrueWeight, FalseWeight)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">  if (extractBranchWeights(*SI, TrueWeight, FalseWeight)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">    uint64_t Max = std::max(TrueWeight, FalseWeight);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">    uint64_t Max = std::max(TrueWeight, FalseWeight);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">    uint64_t Sum = TrueWeight + FalseWeight;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">    uint64_t Sum = TrueWeight + FalseWeight;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">    if (Sum != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">    if (Sum != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">      auto Probability = BranchProbability::getBranchProbability(Max, Sum);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">      auto Probability = BranchProbability::getBranchProbability(Max, Sum);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">      if (Probability > TTI->getPredictableBranchThreshold())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">      if (Probability > TTI->getPredictableBranchThreshold())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">bool SelectOptimize::checkLoopHeuristics(const Loop *L,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">bool SelectOptimize::checkLoopHeuristics(const Loop *L,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">                                         const CostInfo LoopCost[2]) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">                                         const CostInfo LoopCost[2]) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  // Loop-level checks to determine if a non-predicated version (with branches)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  // Loop-level checks to determine if a non-predicated version (with branches)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">  // of the loop is more profitable than its predicated version.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">  // of the loop is more profitable than its predicated version.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  if (DisableLoopLevelHeuristics)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  if (DisableLoopLevelHeuristics)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">  OptimizationRemarkMissed ORmissL(DEBUG_TYPE, "SelectOpti",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">  OptimizationRemarkMissed ORmissL(DEBUG_TYPE, "SelectOpti",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">                                   L->getHeader()->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">                                   L->getHeader()->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">  if (LoopCost[0].NonPredCost > LoopCost[0].PredCost ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">  if (LoopCost[0].NonPredCost > LoopCost[0].PredCost ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">      LoopCost[1].NonPredCost >= LoopCost[1].PredCost) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">      LoopCost[1].NonPredCost >= LoopCost[1].PredCost) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">    ORmissL << "No select conversion in the loop due to no reduction of loop's "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">    ORmissL << "No select conversion in the loop due to no reduction of loop's "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">               "critical path. ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">               "critical path. ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">  Scaled64 Gain[2] = {LoopCost[0].PredCost - LoopCost[0].NonPredCost,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">  Scaled64 Gain[2] = {LoopCost[0].PredCost - LoopCost[0].NonPredCost,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">                      LoopCost[1].PredCost - LoopCost[1].NonPredCost};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">                      LoopCost[1].PredCost - LoopCost[1].NonPredCost};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">  // Profitably converting to branches need to reduce the loop's critical path</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">  // Profitably converting to branches need to reduce the loop's critical path</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">  // by at least some threshold (absolute gain of GainCycleThreshold cycles and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">  // by at least some threshold (absolute gain of GainCycleThreshold cycles and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">  // relative gain of 12.5%).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">  // relative gain of 12.5%).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">  if (Gain[1] < Scaled64::get(GainCycleThreshold) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">  if (Gain[1] < Scaled64::get(GainCycleThreshold) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">      Gain[1] * Scaled64::get(GainRelativeThreshold) < LoopCost[1].PredCost) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">      Gain[1] * Scaled64::get(GainRelativeThreshold) < LoopCost[1].PredCost) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">    Scaled64 RelativeGain = Scaled64::get(100) * Gain[1] / LoopCost[1].PredCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">    Scaled64 RelativeGain = Scaled64::get(100) * Gain[1] / LoopCost[1].PredCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">    ORmissL << "No select conversion in the loop due to small reduction of "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">    ORmissL << "No select conversion in the loop due to small reduction of "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">               "loop's critical path. Gain="</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">               "loop's critical path. Gain="</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">            << Gain[1].toString()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">            << Gain[1].toString()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">            << ", RelativeGain=" << RelativeGain.toString() << "%. ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">            << ", RelativeGain=" << RelativeGain.toString() << "%. ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">  // If the loop's critical path involves loop-carried dependences, the gradient</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">  // If the loop's critical path involves loop-carried dependences, the gradient</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">  // of the gain needs to be at least GainGradientThreshold% (defaults to 25%).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">  // of the gain needs to be at least GainGradientThreshold% (defaults to 25%).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">  // This check ensures that the latency reduction for the loop's critical path</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">  // This check ensures that the latency reduction for the loop's critical path</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">  // keeps decreasing with sufficient rate beyond the two analyzed loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">  // keeps decreasing with sufficient rate beyond the two analyzed loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">  // iterations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">  // iterations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">  if (Gain[1] > Gain[0]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">  if (Gain[1] > Gain[0]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">    Scaled64 GradientGain = Scaled64::get(100) * (Gain[1] - Gain[0]) /</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">    Scaled64 GradientGain = Scaled64::get(100) * (Gain[1] - Gain[0]) /</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">                            (LoopCost[1].PredCost - LoopCost[0].PredCost);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">                            (LoopCost[1].PredCost - LoopCost[0].PredCost);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">    if (GradientGain < Scaled64::get(GainGradientThreshold)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">    if (GradientGain < Scaled64::get(GainGradientThreshold)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">      ORmissL << "No select conversion in the loop due to small gradient gain. "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">      ORmissL << "No select conversion in the loop due to small gradient gain. "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">                 "GradientGain="</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">                 "GradientGain="</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">              << GradientGain.toString() << "%. ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">              << GradientGain.toString() << "%. ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">      EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">      EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">  // If the gain decreases it is not profitable to convert.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">  // If the gain decreases it is not profitable to convert.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">  else if (Gain[1] < Gain[0]) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">  else if (Gain[1] < Gain[0]) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">    ORmissL</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">    ORmissL</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">        << "No select conversion in the loop due to negative gradient gain. ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">        << "No select conversion in the loop due to negative gradient gain. ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">    EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  // Non-predicated version of the loop is more profitable than its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  // Non-predicated version of the loop is more profitable than its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  // predicated version.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  // predicated version.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">// Computes instruction and loop-critical-path costs for both the predicated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">// Computes instruction and loop-critical-path costs for both the predicated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">// and non-predicated version of the given loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">// and non-predicated version of the given loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">// Returns false if unable to compute these costs due to invalid cost of loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">// Returns false if unable to compute these costs due to invalid cost of loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">// instruction(s).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">// instruction(s).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">bool SelectOptimize::computeLoopCosts(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">bool SelectOptimize::computeLoopCosts(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">    const Loop *L, const SelectGroups &SIGroups,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">    const Loop *L, const SelectGroups &SIGroups,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">    DenseMap<const Instruction *, CostInfo> &InstCostMap, CostInfo *LoopCost) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">    DenseMap<const Instruction *, CostInfo> &InstCostMap, CostInfo *LoopCost) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Calculating Latency / IPredCost / INonPredCost of loop "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Calculating Latency / IPredCost / INonPredCost of loop "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">                    << L->getHeader()->getName() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">                    << L->getHeader()->getName() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">  const auto &SIset = getSIset(SIGroups);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">  const auto &SIset = getSIset(SIGroups);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">  // Compute instruction and loop-critical-path costs across two iterations for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">  // Compute instruction and loop-critical-path costs across two iterations for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">  // both predicated and non-predicated version.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">  // both predicated and non-predicated version.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">  const unsigned Iterations = 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">  const unsigned Iterations = 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">  for (unsigned Iter = 0; Iter < Iterations; ++Iter) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">  for (unsigned Iter = 0; Iter < Iterations; ++Iter) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">    // Cost of the loop's critical path.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">    // Cost of the loop's critical path.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">    CostInfo &MaxCost = LoopCost[Iter];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">    CostInfo &MaxCost = LoopCost[Iter];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">    for (BasicBlock *BB : L->getBlocks()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">    for (BasicBlock *BB : L->getBlocks()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">      for (const Instruction &I : *BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">      for (const Instruction &I : *BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">        if (I.isDebugOrPseudoInst())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">        if (I.isDebugOrPseudoInst())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">        // Compute the predicated and non-predicated cost of the instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">        // Compute the predicated and non-predicated cost of the instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">        Scaled64 IPredCost = Scaled64::getZero(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">        Scaled64 IPredCost = Scaled64::getZero(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">                 INonPredCost = Scaled64::getZero();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">                 INonPredCost = Scaled64::getZero();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">        // Assume infinite resources that allow to fully exploit the available</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">        // Assume infinite resources that allow to fully exploit the available</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">        // instruction-level parallelism.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">        // instruction-level parallelism.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">        // InstCost = InstLatency + max(Op1Cost, Op2Cost, … OpNCost)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">        // InstCost = InstLatency + max(Op1Cost, Op2Cost, … OpNCost)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">        for (const Use &U : I.operands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">        for (const Use &U : I.operands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">          auto UI = dyn_cast<Instruction>(U.get());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">          auto UI = dyn_cast<Instruction>(U.get());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">          if (!UI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">          if (!UI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">          if (InstCostMap.count(UI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">          if (InstCostMap.count(UI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">            IPredCost = std::max(IPredCost, InstCostMap[UI].PredCost);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">            IPredCost = std::max(IPredCost, InstCostMap[UI].PredCost);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">            INonPredCost = std::max(INonPredCost, InstCostMap[UI].NonPredCost);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">            INonPredCost = std::max(INonPredCost, InstCostMap[UI].NonPredCost);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">        auto ILatency = computeInstCost(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">        auto ILatency = computeInstCost(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">        if (!ILatency) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">        if (!ILatency) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">          OptimizationRemarkMissed ORmissL(DEBUG_TYPE, "SelectOpti", &I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">          OptimizationRemarkMissed ORmissL(DEBUG_TYPE, "SelectOpti", &I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">          ORmissL << "Invalid instruction cost preventing analysis and "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">          ORmissL << "Invalid instruction cost preventing analysis and "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">                     "optimization of the inner-most loop containing this "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">                     "optimization of the inner-most loop containing this "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">                     "instruction. ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">                     "instruction. ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">          EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">          EmitAndPrintRemark(ORE, ORmissL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">          return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">        IPredCost += Scaled64::get(*ILatency);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">        IPredCost += Scaled64::get(*ILatency);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">        INonPredCost += Scaled64::get(*ILatency);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">        INonPredCost += Scaled64::get(*ILatency);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">        // For a select that can be converted to branch,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">        // For a select that can be converted to branch,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">        // compute its cost as a branch (non-predicated cost).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">        // compute its cost as a branch (non-predicated cost).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">        //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">        //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">        // BranchCost = PredictedPathCost + MispredictCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">        // BranchCost = PredictedPathCost + MispredictCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">        // PredictedPathCost = TrueOpCost * TrueProb + FalseOpCost * FalseProb</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">        // PredictedPathCost = TrueOpCost * TrueProb + FalseOpCost * FalseProb</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">        // MispredictCost = max(MispredictPenalty, CondCost) * MispredictRate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">        // MispredictCost = max(MispredictPenalty, CondCost) * MispredictRate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">        if (SIset.contains(&I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">        if (SIset.contains(&I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">          auto SI = cast<SelectInst>(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">          auto SI = cast<SelectInst>(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">          Scaled64 TrueOpCost = Scaled64::getZero(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">          Scaled64 TrueOpCost = Scaled64::getZero(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">                   FalseOpCost = Scaled64::getZero();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">                   FalseOpCost = Scaled64::getZero();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">          if (auto *TI = dyn_cast<Instruction>(SI->getTrueValue()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">          if (auto *TI = dyn_cast<Instruction>(SI->getTrueValue()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">            if (InstCostMap.count(TI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">            if (InstCostMap.count(TI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">              TrueOpCost = InstCostMap[TI].NonPredCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">              TrueOpCost = InstCostMap[TI].NonPredCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">          if (auto *FI = dyn_cast<Instruction>(SI->getFalseValue()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">          if (auto *FI = dyn_cast<Instruction>(SI->getFalseValue()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">            if (InstCostMap.count(FI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">            if (InstCostMap.count(FI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">              FalseOpCost = InstCostMap[FI].NonPredCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">              FalseOpCost = InstCostMap[FI].NonPredCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">          Scaled64 PredictedPathCost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">          Scaled64 PredictedPathCost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">              getPredictedPathCost(TrueOpCost, FalseOpCost, SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">              getPredictedPathCost(TrueOpCost, FalseOpCost, SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">          Scaled64 CondCost = Scaled64::getZero();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">          Scaled64 CondCost = Scaled64::getZero();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">          if (auto *CI = dyn_cast<Instruction>(SI->getCondition()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">          if (auto *CI = dyn_cast<Instruction>(SI->getCondition()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">            if (InstCostMap.count(CI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">            if (InstCostMap.count(CI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">              CondCost = InstCostMap[CI].NonPredCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">              CondCost = InstCostMap[CI].NonPredCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">          Scaled64 MispredictCost = getMispredictionCost(SI, CondCost);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">          Scaled64 MispredictCost = getMispredictionCost(SI, CondCost);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">          INonPredCost = PredictedPathCost + MispredictCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">          INonPredCost = PredictedPathCost + MispredictCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << " " << ILatency << "/" << IPredCost << "/"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << " " << ILatency << "/" << IPredCost << "/"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">                          << INonPredCost << " for " << I << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">                          << INonPredCost << " for " << I << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">        InstCostMap[&I] = {IPredCost, INonPredCost};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">        InstCostMap[&I] = {IPredCost, INonPredCost};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">        MaxCost.PredCost = std::max(MaxCost.PredCost, IPredCost);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">        MaxCost.PredCost = std::max(MaxCost.PredCost, IPredCost);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">        MaxCost.NonPredCost = std::max(MaxCost.NonPredCost, INonPredCost);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">        MaxCost.NonPredCost = std::max(MaxCost.NonPredCost, INonPredCost);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Iteration " << Iter + 1</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Iteration " << Iter + 1</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">                      << " MaxCost = " << MaxCost.PredCost << " "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">                      << " MaxCost = " << MaxCost.PredCost << " "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">                      << MaxCost.NonPredCost << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">                      << MaxCost.NonPredCost << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">SmallPtrSet<const Instruction *, 2></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">SmallPtrSet<const Instruction *, 2></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">SelectOptimize::getSIset(const SelectGroups &SIGroups) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">SelectOptimize::getSIset(const SelectGroups &SIGroups) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">  SmallPtrSet<const Instruction *, 2> SIset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">  SmallPtrSet<const Instruction *, 2> SIset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">  for (const SelectGroup &ASI : SIGroups)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">  for (const SelectGroup &ASI : SIGroups)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">    for (const SelectInst *SI : ASI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">    for (const SelectInst *SI : ASI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">      SIset.insert(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">      SIset.insert(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">  return SIset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">  return SIset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">std::optional<uint64_t> SelectOptimize::computeInstCost(const Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">std::optional<uint64_t> SelectOptimize::computeInstCost(const Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">  InstructionCost ICost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">  InstructionCost ICost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">      TTI->getInstructionCost(I, TargetTransformInfo::TCK_Latency);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">      TTI->getInstructionCost(I, TargetTransformInfo::TCK_Latency);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">  if (auto OC = ICost.getValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">  if (auto OC = ICost.getValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">    return std::optional<uint64_t>(*OC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">    return std::optional<uint64_t>(*OC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">  return std::nullopt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">ScaledNumber<uint64_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">ScaledNumber<uint64_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">SelectOptimize::getMispredictionCost(const SelectInst *SI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">SelectOptimize::getMispredictionCost(const SelectInst *SI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">                                     const Scaled64 CondCost) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">                                     const Scaled64 CondCost) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">  uint64_t MispredictPenalty = TSchedModel.getMCSchedModel()->MispredictPenalty;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">  uint64_t MispredictPenalty = TSchedModel.getMCSchedModel()->MispredictPenalty;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">  // Account for the default misprediction rate when using a branch</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">  // Account for the default misprediction rate when using a branch</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">  // (conservatively set to 25% by default).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">  // (conservatively set to 25% by default).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">  uint64_t MispredictRate = MispredictDefaultRate;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">  uint64_t MispredictRate = MispredictDefaultRate;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">  // If the select condition is obviously predictable, then the misprediction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">  // If the select condition is obviously predictable, then the misprediction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">  // rate is zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">  // rate is zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  if (isSelectHighlyPredictable(SI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  if (isSelectHighlyPredictable(SI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">    MispredictRate = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">    MispredictRate = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">  // CondCost is included to account for cases where the computation of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">  // CondCost is included to account for cases where the computation of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">  // condition is part of a long dependence chain (potentially loop-carried)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">  // condition is part of a long dependence chain (potentially loop-carried)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">  // that would delay detection of a misprediction and increase its cost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">  // that would delay detection of a misprediction and increase its cost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">  Scaled64 MispredictCost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">  Scaled64 MispredictCost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">      std::max(Scaled64::get(MispredictPenalty), CondCost) *</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">      std::max(Scaled64::get(MispredictPenalty), CondCost) *</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">      Scaled64::get(MispredictRate);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">      Scaled64::get(MispredictRate);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">  MispredictCost /= Scaled64::get(100);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">  MispredictCost /= Scaled64::get(100);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">  return MispredictCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">  return MispredictCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">// Returns the cost of a branch when the prediction is correct.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">// Returns the cost of a branch when the prediction is correct.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">// TrueCost * TrueProbability + FalseCost * FalseProbability.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">// TrueCost * TrueProbability + FalseCost * FalseProbability.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">ScaledNumber<uint64_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">ScaledNumber<uint64_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">SelectOptimize::getPredictedPathCost(Scaled64 TrueCost, Scaled64 FalseCost,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">SelectOptimize::getPredictedPathCost(Scaled64 TrueCost, Scaled64 FalseCost,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">                                     const SelectInst *SI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">                                     const SelectInst *SI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">  Scaled64 PredPathCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">  Scaled64 PredPathCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">  uint64_t TrueWeight, FalseWeight;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">  uint64_t TrueWeight, FalseWeight;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">  if (extractBranchWeights(*SI, TrueWeight, FalseWeight)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">  if (extractBranchWeights(*SI, TrueWeight, FalseWeight)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">    uint64_t SumWeight = TrueWeight + FalseWeight;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">    uint64_t SumWeight = TrueWeight + FalseWeight;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">    if (SumWeight != 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">    if (SumWeight != 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">      PredPathCost = TrueCost * Scaled64::get(TrueWeight) +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">      PredPathCost = TrueCost * Scaled64::get(TrueWeight) +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">                     FalseCost * Scaled64::get(FalseWeight);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">                     FalseCost * Scaled64::get(FalseWeight);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">      PredPathCost /= Scaled64::get(SumWeight);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">      PredPathCost /= Scaled64::get(SumWeight);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">      return PredPathCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">      return PredPathCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">  // Without branch weight metadata, we assume 75% for the one path and 25% for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">  // Without branch weight metadata, we assume 75% for the one path and 25% for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">  // the other, and pick the result with the biggest cost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">  // the other, and pick the result with the biggest cost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">  PredPathCost = std::max(TrueCost * Scaled64::get(3) + FalseCost,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">  PredPathCost = std::max(TrueCost * Scaled64::get(3) + FalseCost,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">                          FalseCost * Scaled64::get(3) + TrueCost);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">                          FalseCost * Scaled64::get(3) + TrueCost);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">  PredPathCost /= Scaled64::get(4);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">  PredPathCost /= Scaled64::get(4);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">  return PredPathCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">  return PredPathCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">bool SelectOptimize::isSelectKindSupported(SelectInst *SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">bool SelectOptimize::isSelectKindSupported(SelectInst *SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">  bool VectorCond = !SI->getCondition()->getType()->isIntegerTy(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">  bool VectorCond = !SI->getCondition()->getType()->isIntegerTy(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">  if (VectorCond)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">  if (VectorCond)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">  TargetLowering::SelectSupportKind SelectKind;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">  TargetLowering::SelectSupportKind SelectKind;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">  if (SI->getType()->isVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">  if (SI->getType()->isVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">    SelectKind = TargetLowering::ScalarCondVectorVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">    SelectKind = TargetLowering::ScalarCondVectorVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">    SelectKind = TargetLowering::ScalarValSelect;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">    SelectKind = TargetLowering::ScalarValSelect;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">  return TLI->isSelectSupported(SelectKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">  return TLI->isSelectSupported(SelectKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>