<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sequence.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/ADT/Sequence.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- Sequence.h - Utility for producing sequences of values ---*- C++ -*-===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">/// \file</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">/// Provides some synthesis utilities to produce sequences of values. The names</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">/// are intentionally kept very short as they tend to occur in common and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">/// widely used contexts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">/// The `seq(A, B)` function produces a sequence of values from `A` to up to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">/// (but not including) `B`, i.e., [`A`, `B`), that can be safely iterated over.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">/// `seq` supports both integral (e.g., `int`, `char`, `uint32_t`) and enum</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">/// types. `seq_inclusive(A, B)` produces a sequence of values from `A` to `B`,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">/// including `B`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">/// Examples with integral types:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">/// ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">/// for (int x : seq(0, 3))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">///   outs() << x << " ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">/// ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">/// Prints: `0 1 2 `.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">/// ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">/// for (int x : seq_inclusive(0, 3))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">///   outs() << x << " ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">/// ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">/// Prints: `0 1 2 3 `.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">/// Similar to `seq` and `seq_inclusive`, the `enum_seq` and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">/// `enum_seq_inclusive` functions produce sequences of enum values that can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">/// iterated over.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">/// To enable iteration with enum types, you need to either mark enums as safe</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">/// to iterate on by specializing `enum_iteration_traits`, or opt into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">/// potentially unsafe iteration at every callsite by passing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">/// `force_iteration_on_noniterable_enum`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">/// Examples with enum types:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">/// ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">/// namespace X {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">///   enum class MyEnum : unsigned {A = 0, B, C};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">/// } // namespace X</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">/// template <> struct enum_iteration_traits<X::MyEnum> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">///   static contexpr bool is_iterable = true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">/// };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">/// class MyClass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">/// public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">///   enum Safe { D = 3, E, F };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">///   enum MaybeUnsafe { G = 1, H = 2, I = 4 };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">/// };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">/// template <> struct enum_iteration_traits<MyClass::Safe> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">///   static contexpr bool is_iterable = true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">/// };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">/// ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">/// ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">///   for (auto v : enum_seq(MyClass::Safe::D, MyClass::Safe::F))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">///     outs() << int(v) << " ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">/// ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">/// Prints: `3 4 `.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">/// ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">///   for (auto v : enum_seq(MyClass::MaybeUnsafe::H, MyClass::MaybeUnsafe::I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">///                          force_iteration_on_noniterable_enum))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">///     outs() << int(v) << " ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">/// ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">/// Prints: `2 3 `.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">#ifndef LLVM_ADT_SEQUENCE_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">#define LLVM_ADT_SEQUENCE_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">#include <cassert>     // assert</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">#include <iterator>    // std::random_access_iterator_tag</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">#include <limits>      // std::numeric_limits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">#include <type_traits> // std::is_integral, std::is_enum, std::underlying_type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">                       // std::enable_if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">#include "llvm/Support/MathExtras.h" // AddOverflow / SubOverflow</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">// Enum traits that marks enums as safe or unsafe to iterate over.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">// By default, enum types are *not* considered safe for iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">// To allow iteration for your enum type, provide a specialization with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">// `is_iterable` set to `true` in the `llvm` namespace.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">// Alternatively, you can pass the `force_iteration_on_noniterable_enum` tag</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">// to `enum_seq` or `enum_seq_inclusive`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">template <typename EnumT> struct enum_iteration_traits {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">  static constexpr bool is_iterable = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">struct force_iteration_on_noniterable_enum_t {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">  explicit force_iteration_on_noniterable_enum_t() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">inline constexpr force_iteration_on_noniterable_enum_t</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">    force_iteration_on_noniterable_enum;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">// Returns whether a value of type U can be represented with type T.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="coveredLine">template <typename T, typename U> bool canTypeFitValue(const U Value) {</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="coveredLine">  const intmax_t BotT = intmax_t(std::numeric_limits<T>::min());</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="coveredLine">  const intmax_t BotU = intmax_t(std::numeric_limits<U>::min());</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="coveredLine">  const uintmax_t TopT = uintmax_t(std::numeric_limits<T>::max());</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="coveredLine">  const uintmax_t TopU = uintmax_t(std::numeric_limits<U>::max());</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="coveredLine">  return !((BotT > BotU && Value < static_cast<U>(BotT)) ||</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="coveredLine">           (TopT < TopU && Value > static_cast<U>(TopT)));</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">// An integer type that asserts when:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">// - constructed from a value that doesn't fit into intmax_t,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">// - casted to a type that cannot hold the current value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">// - its internal representation overflows.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">struct CheckedInt {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">  // Integral constructor, asserts if Value cannot be represented as intmax_t.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">  template <typename Integral,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">            std::enable_if_t<std::is_integral<Integral>::value, bool> = 0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="coveredLine">  static CheckedInt from(Integral FromValue) {</td>
    <td>216</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="coveredLine">    if (!canTypeFitValue<intmax_t>(FromValue))</td>
    <td>216</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="uncoveredLine">      assertOutOfBounds();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">    CheckedInt Result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="coveredLine">    Result.Value = static_cast<intmax_t>(FromValue);</td>
    <td>216</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="coveredLine">    return Result;</td>
    <td>216</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">  // Enum constructor, asserts if Value cannot be represented as intmax_t.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">  template <typename Enum,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">            std::enable_if_t<std::is_enum<Enum>::value, bool> = 0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="coveredLine">  static CheckedInt from(Enum FromValue) {</td>
    <td>196</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">    using type = std::underlying_type_t<Enum>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="coveredLine">    return from<type>(static_cast<type>(FromValue));</td>
    <td>196</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">  // Equality</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">  bool operator==(const CheckedInt &O) const { return Value == O.Value; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="coveredLine">  bool operator!=(const CheckedInt &O) const { return Value != O.Value; }</td>
    <td>12744</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="coveredLine">  CheckedInt operator+(intmax_t Offset) const {</td>
    <td>12734</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">    CheckedInt Result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="coveredLine">    if (AddOverflow(Value, Offset, Result.Value))</td>
    <td>12734</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="uncoveredLine">      assertOutOfBounds();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="coveredLine">    return Result;</td>
    <td>12734</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">  intmax_t operator-(CheckedInt Other) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">    intmax_t Result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">    if (SubOverflow(Value, Other.Value, Result))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">      assertOutOfBounds();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">    return Result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">  // Convert to integral, asserts if Value cannot be represented as Integral.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">  template <typename Integral,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">            std::enable_if_t<std::is_integral<Integral>::value, bool> = 0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="coveredLine">  Integral to() const {</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="coveredLine">    if (!canTypeFitValue<Integral>(Value))</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="uncoveredLine">      assertOutOfBounds();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="coveredLine">    return static_cast<Integral>(Value);</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">  // Convert to enum, asserts if Value cannot be represented as Enum's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  // underlying type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">  template <typename Enum,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">            std::enable_if_t<std::is_enum<Enum>::value, bool> = 0></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="coveredLine">  Enum to() const {</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">    using type = std::underlying_type_t<Enum>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="coveredLine">    return Enum(to<type>());</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="uncoveredLine">  static void assertOutOfBounds() { assert(false && "Out of bounds"); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">  intmax_t Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">template <typename T, bool IsReverse> struct SafeIntIterator {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">  using iterator_category = std::random_access_iterator_tag;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">  using value_type = T;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">  using difference_type = intmax_t;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">  using pointer = T *;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">  using reference = value_type; // The iterator does not reference memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">  // Construct from T.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="coveredLine">  explicit SafeIntIterator(T Value) : SI(CheckedInt::from<T>(Value)) {}</td>
    <td>196</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">  // Construct from other direction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">  SafeIntIterator(const SafeIntIterator<T, !IsReverse> &O) : SI(O.SI) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">  // Dereference</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="coveredLine">  reference operator*() const { return SI.to<T>(); }</td>
    <td>12636</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">  // Indexing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">  reference operator[](intmax_t Offset) const { return *(*this + Offset); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  // Can be compared for equivalence using the equality/inequality operators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">  bool operator==(const SafeIntIterator &O) const { return SI == O.SI; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="coveredLine">  bool operator!=(const SafeIntIterator &O) const { return SI != O.SI; }</td>
    <td>12744</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">  // Comparison</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">  bool operator<(const SafeIntIterator &O) const { return (*this - O) < 0; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">  bool operator>(const SafeIntIterator &O) const { return (*this - O) > 0; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">  bool operator<=(const SafeIntIterator &O) const { return (*this - O) <= 0; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">  bool operator>=(const SafeIntIterator &O) const { return (*this - O) >= 0; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">  // Pre Increment/Decrement</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="coveredLine">  void operator++() { offset(1); }</td>
    <td>12734</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">  void operator--() { offset(-1); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">  // Post Increment/Decrement</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">  SafeIntIterator operator++(int) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">    const auto Copy = *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">    ++*this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">    return Copy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">  SafeIntIterator operator--(int) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">    const auto Copy = *this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">    --*this;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">    return Copy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">  // Compound assignment operators</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">  void operator+=(intmax_t Offset) { offset(Offset); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">  void operator-=(intmax_t Offset) { offset(-Offset); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">  // Arithmetic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">  SafeIntIterator operator+(intmax_t Offset) const { return add(Offset); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">  SafeIntIterator operator-(intmax_t Offset) const { return add(-Offset); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">  // Difference</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">  intmax_t operator-(const SafeIntIterator &O) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">    return IsReverse ? O.SI - SI : SI - O.SI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  SafeIntIterator(const CheckedInt &SI) : SI(SI) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="coveredLine">  static intmax_t getOffset(intmax_t Offset) {</td>
    <td>12734</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="coveredLine">    return IsReverse ? -Offset : Offset;</td>
    <td>12734</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">  CheckedInt add(intmax_t Offset) const { return SI + getOffset(Offset); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="coveredLine">  void offset(intmax_t Offset) { SI = SI + getOffset(Offset); }</td>
    <td>12734</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">  CheckedInt SI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="">  // To allow construction from the other direction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">  template <typename, bool> friend struct SafeIntIterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">} // namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">template <typename T> struct iota_range {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">  using value_type = T;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  using reference = T &;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">  using const_reference = const T &;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">  using iterator = detail::SafeIntIterator<value_type, false>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">  using const_iterator = iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">  using reverse_iterator = detail::SafeIntIterator<value_type, true>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">  using const_reverse_iterator = reverse_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">  using difference_type = intmax_t;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">  using size_type = std::size_t;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="coveredLine">  explicit iota_range(T Begin, T End, bool Inclusive)</td>
    <td>98</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="coveredLine">      : BeginValue(Begin), PastEndValue(End) {</td>
    <td>98</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="coveredLine">    assert(Begin <= End && "Begin must be less or equal to End.");</td>
    <td>98</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="coveredLine">    if (Inclusive)</td>
    <td>98</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="coveredLine">      ++PastEndValue;</td>
    <td>98</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="coveredLine">  }</td>
    <td>98</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">  size_t size() const { return PastEndValue - BeginValue; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">  bool empty() const { return BeginValue == PastEndValue; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="coveredLine">  auto begin() const { return const_iterator(BeginValue); }</td>
    <td>108</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="coveredLine">  auto end() const { return const_iterator(PastEndValue); }</td>
    <td>108</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">  auto rbegin() const { return const_reverse_iterator(PastEndValue - 1); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  auto rend() const { return const_reverse_iterator(BeginValue - 1); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">  static_assert(std::is_integral<T>::value || std::is_enum<T>::value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">                "T must be an integral or enum type");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">  static_assert(std::is_same<T, std::remove_cv_t<T>>::value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">                "T must not be const nor volatile");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">  iterator BeginValue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">  iterator PastEndValue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">/// Iterate over an integral type from Begin up to - but not including - End.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">/// iteration).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="">                                                  !std::is_enum<T>::value>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">auto seq(T Begin, T End) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="">  return iota_range<T>(Begin, End, false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">/// Iterate over an integral type from 0 up to - but not including - Size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">/// Note: Size value has to be within [INTMAX_MIN, INTMAX_MAX - 1] for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">/// iteration).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">                                                  !std::is_enum<T>::value>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">auto seq(T Size) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">  return seq<T>(0, Size);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">/// Iterate over an integral type from Begin to End inclusive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">/// iteration).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">                                                  !std::is_enum<T>::value>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">auto seq_inclusive(T Begin, T End) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">  return iota_range<T>(Begin, End, true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">/// Iterate over an enum type from Begin up to - but not including - End.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">/// Note: `enum_seq` will generate each consecutive value, even if no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">/// enumerator with that value exists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">/// iteration).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">template <typename EnumT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="uncoveredLine">auto enum_seq(EnumT Begin, EnumT End) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">  static_assert(enum_iteration_traits<EnumT>::is_iterable,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">                "Enum type is not marked as iterable.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="uncoveredLine">  return iota_range<EnumT>(Begin, End, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">/// Iterate over an enum type from Begin up to - but not including - End, even</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">/// when `EnumT` is not marked as safely iterable by `enum_iteration_traits`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">/// Note: `enum_seq` will generate each consecutive value, even if no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">/// enumerator with that value exists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">/// iteration).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">template <typename EnumT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="coveredLine">auto enum_seq(EnumT Begin, EnumT End, force_iteration_on_noniterable_enum_t) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="coveredLine">  return iota_range<EnumT>(Begin, End, false);</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">/// Iterate over an enum type from Begin to End inclusive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">/// Note: `enum_seq_inclusive` will generate each consecutive value, even if no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">/// enumerator with that value exists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">/// iteration).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">template <typename EnumT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">auto enum_seq_inclusive(EnumT Begin, EnumT End) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">  static_assert(enum_iteration_traits<EnumT>::is_iterable,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">                "Enum type is not marked as iterable.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">  return iota_range<EnumT>(Begin, End, true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">/// Iterate over an enum type from Begin to End inclusive, even when `EnumT`</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">/// is not marked as safely iterable by `enum_iteration_traits`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">/// Note: `enum_seq_inclusive` will generate each consecutive value, even if no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">/// enumerator with that value exists.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">/// iteration).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="">template <typename EnumT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="coveredLine">auto enum_seq_inclusive(EnumT Begin, EnumT End,</td>
    <td>98</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">                        force_iteration_on_noniterable_enum_t) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="coveredLine">  return iota_range<EnumT>(Begin, End, true);</td>
    <td>98</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">#endif // LLVM_ADT_SEQUENCE_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15canTypeFitValueIljEEbT0_</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15canTypeFitValueIhlEEbT0_</td>
    <td class="numberOfCalls">8196</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15canTypeFitValueIjlEEbT0_</td>
    <td class="numberOfCalls">4380</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15canTypeFitValueIlhEEbT0_</td>
    <td class="numberOfCalls">156</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10CheckedInt4fromIhLb0EEES1_T_</td>
    <td class="numberOfCalls">156</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10CheckedInt4fromIjLb0EEES1_T_</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10CheckedInt4fromINS_3MVT15SimpleValueTypeELb0EEES1_T_</td>
    <td class="numberOfCalls">156</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10CheckedInt4fromINS_3ISD8NodeTypeELb0EEES1_T_</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10CheckedIntneERKS1_</td>
    <td class="numberOfCalls">12744</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10CheckedIntplEl</td>
    <td class="numberOfCalls">12734</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10CheckedInt2toIjLb0EEET_v</td>
    <td class="numberOfCalls">4380</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10CheckedInt2toIhLb0EEET_v</td>
    <td class="numberOfCalls">8196</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10CheckedInt2toINS_3MVT15SimpleValueTypeELb0EEET_v</td>
    <td class="numberOfCalls">8196</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10CheckedInt2toINS_3ISD8NodeTypeELb0EEET_v</td>
    <td class="numberOfCalls">4380</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10CheckedInt17assertOutOfBoundsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorINS_3ISD8NodeTypeELb0EEC2ES3_</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorINS_3MVT15SimpleValueTypeELb0EEC2ES3_</td>
    <td class="numberOfCalls">156</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail15SafeIntIteratorINS_3MVT15SimpleValueTypeELb0EEdeEv</td>
    <td class="numberOfCalls">8196</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail15SafeIntIteratorINS_3ISD8NodeTypeELb0EEdeEv</td>
    <td class="numberOfCalls">4380</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail15SafeIntIteratorINS_3MVT15SimpleValueTypeELb0EEneERKS4_</td>
    <td class="numberOfCalls">8274</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail15SafeIntIteratorINS_3ISD8NodeTypeELb0EEneERKS4_</td>
    <td class="numberOfCalls">4390</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorINS_3MVT15SimpleValueTypeELb0EEppEv</td>
    <td class="numberOfCalls">8274</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorINS_3ISD8NodeTypeELb0EEppEv</td>
    <td class="numberOfCalls">4380</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorINS_3ISD8NodeTypeELb0EE9getOffsetEl</td>
    <td class="numberOfCalls">4380</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorINS_3MVT15SimpleValueTypeELb0EE9getOffsetEl</td>
    <td class="numberOfCalls">8274</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorINS_3ISD8NodeTypeELb0EE6offsetEl</td>
    <td class="numberOfCalls">4380</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorINS_3MVT15SimpleValueTypeELb0EE6offsetEl</td>
    <td class="numberOfCalls">8274</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10iota_rangeINS_3MVT15SimpleValueTypeEEC2ES2_S2_b</td>
    <td class="numberOfCalls">78</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10iota_rangeINS_3ISD8NodeTypeEEC2ES2_S2_b</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10iota_rangeINS_3MVT15SimpleValueTypeEE5beginEv</td>
    <td class="numberOfCalls">78</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10iota_rangeINS_3ISD8NodeTypeEE5beginEv</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10iota_rangeINS_3MVT15SimpleValueTypeEE3endEv</td>
    <td class="numberOfCalls">78</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10iota_rangeINS_3ISD8NodeTypeEE3endEv</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8enum_seqINS_3ISD8NodeTypeEvEEDaT_S3_NS_37force_iteration_on_noniterable_enum_tE</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18enum_seq_inclusiveINS_3MVT15SimpleValueTypeEvEEDaT_S3_NS_37force_iteration_on_noniterable_enum_tE</td>
    <td class="numberOfCalls">78</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15canTypeFitValueIilEEbT0_</td>
    <td class="numberOfCalls">60</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15canTypeFitValueIliEEbT0_</td>
    <td class="numberOfCalls">40</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10CheckedInt4fromIiLb0EEES1_T_</td>
    <td class="numberOfCalls">40</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10CheckedInt4fromINS_13IRMemLocationELb0EEES1_T_</td>
    <td class="numberOfCalls">40</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10CheckedInt2toIiLb0EEET_v</td>
    <td class="numberOfCalls">60</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10CheckedInt2toINS_13IRMemLocationELb0EEET_v</td>
    <td class="numberOfCalls">60</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorINS_13IRMemLocationELb0EEC2ES2_</td>
    <td class="numberOfCalls">40</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail15SafeIntIteratorINS_13IRMemLocationELb0EEdeEv</td>
    <td class="numberOfCalls">60</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail15SafeIntIteratorINS_13IRMemLocationELb0EEneERKS3_</td>
    <td class="numberOfCalls">80</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorINS_13IRMemLocationELb0EEppEv</td>
    <td class="numberOfCalls">80</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorINS_13IRMemLocationELb0EE9getOffsetEl</td>
    <td class="numberOfCalls">80</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorINS_13IRMemLocationELb0EE6offsetEl</td>
    <td class="numberOfCalls">80</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10iota_rangeINS_13IRMemLocationEEC2ES1_S1_b</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10iota_rangeINS_13IRMemLocationEE5beginEv</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10iota_rangeINS_13IRMemLocationEE3endEv</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18enum_seq_inclusiveINS_13IRMemLocationEvEEDaT_S2_NS_37force_iteration_on_noniterable_enum_tE</td>
    <td class="numberOfCalls">20</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail10CheckedInt4fromIN12_GLOBAL__N_115InstCounterTypeELb0EEES1_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail10CheckedInt2toIN12_GLOBAL__N_115InstCounterTypeELb0EEET_v</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorIN12_GLOBAL__N_115InstCounterTypeELb0EEC2ES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail15SafeIntIteratorIN12_GLOBAL__N_115InstCounterTypeELb0EEdeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm6detail15SafeIntIteratorIN12_GLOBAL__N_115InstCounterTypeELb0EEneERKS4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorIN12_GLOBAL__N_115InstCounterTypeELb0EEppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorIN12_GLOBAL__N_115InstCounterTypeELb0EE9getOffsetEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm6detail15SafeIntIteratorIN12_GLOBAL__N_115InstCounterTypeELb0EE6offsetEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10iota_rangeIN12_GLOBAL__N_115InstCounterTypeEEC2ES2_S2_b</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10iota_rangeIN12_GLOBAL__N_115InstCounterTypeEE5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm10iota_rangeIN12_GLOBAL__N_115InstCounterTypeEE3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8enum_seqIN12_GLOBAL__N_115InstCounterTypeEvEEDaT_S3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- Sequence.h - Utility for producing sequences of values ---*- C++ -*-===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- Sequence.h - Utility for producing sequences of values ---*- C++ -*-===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">/// \file</td>
    <td class="lineNumber">8</td>
    <td class="codeline">/// \file</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">/// Provides some synthesis utilities to produce sequences of values. The names</td>
    <td class="lineNumber">9</td>
    <td class="codeline">/// Provides some synthesis utilities to produce sequences of values. The names</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">/// are intentionally kept very short as they tend to occur in common and</td>
    <td class="lineNumber">10</td>
    <td class="codeline">/// are intentionally kept very short as they tend to occur in common and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">/// widely used contexts.</td>
    <td class="lineNumber">11</td>
    <td class="codeline">/// widely used contexts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">///</td>
    <td class="lineNumber">12</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">/// The `seq(A, B)` function produces a sequence of values from `A` to up to</td>
    <td class="lineNumber">13</td>
    <td class="codeline">/// The `seq(A, B)` function produces a sequence of values from `A` to up to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">/// (but not including) `B`, i.e., [`A`, `B`), that can be safely iterated over.</td>
    <td class="lineNumber">14</td>
    <td class="codeline">/// (but not including) `B`, i.e., [`A`, `B`), that can be safely iterated over.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">/// `seq` supports both integral (e.g., `int`, `char`, `uint32_t`) and enum</td>
    <td class="lineNumber">15</td>
    <td class="codeline">/// `seq` supports both integral (e.g., `int`, `char`, `uint32_t`) and enum</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">/// types. `seq_inclusive(A, B)` produces a sequence of values from `A` to `B`,</td>
    <td class="lineNumber">16</td>
    <td class="codeline">/// types. `seq_inclusive(A, B)` produces a sequence of values from `A` to `B`,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">/// including `B`.</td>
    <td class="lineNumber">17</td>
    <td class="codeline">/// including `B`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">///</td>
    <td class="lineNumber">18</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">/// Examples with integral types:</td>
    <td class="lineNumber">19</td>
    <td class="codeline">/// Examples with integral types:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">/// ```</td>
    <td class="lineNumber">20</td>
    <td class="codeline">/// ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">/// for (int x : seq(0, 3))</td>
    <td class="lineNumber">21</td>
    <td class="codeline">/// for (int x : seq(0, 3))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">///   outs() << x << " ";</td>
    <td class="lineNumber">22</td>
    <td class="codeline">///   outs() << x << " ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">/// ```</td>
    <td class="lineNumber">23</td>
    <td class="codeline">/// ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">///</td>
    <td class="lineNumber">24</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">/// Prints: `0 1 2 `.</td>
    <td class="lineNumber">25</td>
    <td class="codeline">/// Prints: `0 1 2 `.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">///</td>
    <td class="lineNumber">26</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">/// ```</td>
    <td class="lineNumber">27</td>
    <td class="codeline">/// ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">/// for (int x : seq_inclusive(0, 3))</td>
    <td class="lineNumber">28</td>
    <td class="codeline">/// for (int x : seq_inclusive(0, 3))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">///   outs() << x << " ";</td>
    <td class="lineNumber">29</td>
    <td class="codeline">///   outs() << x << " ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">/// ```</td>
    <td class="lineNumber">30</td>
    <td class="codeline">/// ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">///</td>
    <td class="lineNumber">31</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">/// Prints: `0 1 2 3 `.</td>
    <td class="lineNumber">32</td>
    <td class="codeline">/// Prints: `0 1 2 3 `.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">///</td>
    <td class="lineNumber">33</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">/// Similar to `seq` and `seq_inclusive`, the `enum_seq` and</td>
    <td class="lineNumber">34</td>
    <td class="codeline">/// Similar to `seq` and `seq_inclusive`, the `enum_seq` and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">/// `enum_seq_inclusive` functions produce sequences of enum values that can be</td>
    <td class="lineNumber">35</td>
    <td class="codeline">/// `enum_seq_inclusive` functions produce sequences of enum values that can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">/// iterated over.</td>
    <td class="lineNumber">36</td>
    <td class="codeline">/// iterated over.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">/// To enable iteration with enum types, you need to either mark enums as safe</td>
    <td class="lineNumber">37</td>
    <td class="codeline">/// To enable iteration with enum types, you need to either mark enums as safe</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">/// to iterate on by specializing `enum_iteration_traits`, or opt into</td>
    <td class="lineNumber">38</td>
    <td class="codeline">/// to iterate on by specializing `enum_iteration_traits`, or opt into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">/// potentially unsafe iteration at every callsite by passing</td>
    <td class="lineNumber">39</td>
    <td class="codeline">/// potentially unsafe iteration at every callsite by passing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">/// `force_iteration_on_noniterable_enum`.</td>
    <td class="lineNumber">40</td>
    <td class="codeline">/// `force_iteration_on_noniterable_enum`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">///</td>
    <td class="lineNumber">41</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">/// Examples with enum types:</td>
    <td class="lineNumber">42</td>
    <td class="codeline">/// Examples with enum types:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">/// ```</td>
    <td class="lineNumber">43</td>
    <td class="codeline">/// ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">/// namespace X {</td>
    <td class="lineNumber">44</td>
    <td class="codeline">/// namespace X {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">///   enum class MyEnum : unsigned {A = 0, B, C};</td>
    <td class="lineNumber">45</td>
    <td class="codeline">///   enum class MyEnum : unsigned {A = 0, B, C};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">/// } // namespace X</td>
    <td class="lineNumber">46</td>
    <td class="codeline">/// } // namespace X</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">///</td>
    <td class="lineNumber">47</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">/// template <> struct enum_iteration_traits<X::MyEnum> {</td>
    <td class="lineNumber">48</td>
    <td class="codeline">/// template <> struct enum_iteration_traits<X::MyEnum> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">///   static contexpr bool is_iterable = true;</td>
    <td class="lineNumber">49</td>
    <td class="codeline">///   static contexpr bool is_iterable = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">/// };</td>
    <td class="lineNumber">50</td>
    <td class="codeline">/// };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">///</td>
    <td class="lineNumber">51</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">/// class MyClass {</td>
    <td class="lineNumber">52</td>
    <td class="codeline">/// class MyClass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">/// public:</td>
    <td class="lineNumber">53</td>
    <td class="codeline">/// public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">///   enum Safe { D = 3, E, F };</td>
    <td class="lineNumber">54</td>
    <td class="codeline">///   enum Safe { D = 3, E, F };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">///   enum MaybeUnsafe { G = 1, H = 2, I = 4 };</td>
    <td class="lineNumber">55</td>
    <td class="codeline">///   enum MaybeUnsafe { G = 1, H = 2, I = 4 };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">/// };</td>
    <td class="lineNumber">56</td>
    <td class="codeline">/// };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">///</td>
    <td class="lineNumber">57</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">/// template <> struct enum_iteration_traits<MyClass::Safe> {</td>
    <td class="lineNumber">58</td>
    <td class="codeline">/// template <> struct enum_iteration_traits<MyClass::Safe> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">///   static contexpr bool is_iterable = true;</td>
    <td class="lineNumber">59</td>
    <td class="codeline">///   static contexpr bool is_iterable = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">/// };</td>
    <td class="lineNumber">60</td>
    <td class="codeline">/// };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">/// ```</td>
    <td class="lineNumber">61</td>
    <td class="codeline">/// ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">///</td>
    <td class="lineNumber">62</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">/// ```</td>
    <td class="lineNumber">63</td>
    <td class="codeline">/// ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">///   for (auto v : enum_seq(MyClass::Safe::D, MyClass::Safe::F))</td>
    <td class="lineNumber">64</td>
    <td class="codeline">///   for (auto v : enum_seq(MyClass::Safe::D, MyClass::Safe::F))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">///     outs() << int(v) << " ";</td>
    <td class="lineNumber">65</td>
    <td class="codeline">///     outs() << int(v) << " ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">/// ```</td>
    <td class="lineNumber">66</td>
    <td class="codeline">/// ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">///</td>
    <td class="lineNumber">67</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">/// Prints: `3 4 `.</td>
    <td class="lineNumber">68</td>
    <td class="codeline">/// Prints: `3 4 `.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">///</td>
    <td class="lineNumber">69</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">/// ```</td>
    <td class="lineNumber">70</td>
    <td class="codeline">/// ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">///   for (auto v : enum_seq(MyClass::MaybeUnsafe::H, MyClass::MaybeUnsafe::I,</td>
    <td class="lineNumber">71</td>
    <td class="codeline">///   for (auto v : enum_seq(MyClass::MaybeUnsafe::H, MyClass::MaybeUnsafe::I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">///                          force_iteration_on_noniterable_enum))</td>
    <td class="lineNumber">72</td>
    <td class="codeline">///                          force_iteration_on_noniterable_enum))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">///     outs() << int(v) << " ";</td>
    <td class="lineNumber">73</td>
    <td class="codeline">///     outs() << int(v) << " ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">/// ```</td>
    <td class="lineNumber">74</td>
    <td class="codeline">/// ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">///</td>
    <td class="lineNumber">75</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">/// Prints: `2 3 `.</td>
    <td class="lineNumber">76</td>
    <td class="codeline">/// Prints: `2 3 `.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">///</td>
    <td class="lineNumber">77</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">78</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline"></td>
    <td class="lineNumber">79</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">#ifndef LLVM_ADT_SEQUENCE_H</td>
    <td class="lineNumber">80</td>
    <td class="codeline">#ifndef LLVM_ADT_SEQUENCE_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">#define LLVM_ADT_SEQUENCE_H</td>
    <td class="lineNumber">81</td>
    <td class="codeline">#define LLVM_ADT_SEQUENCE_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">#include <cassert>     // assert</td>
    <td class="lineNumber">83</td>
    <td class="codeline">#include <cassert>     // assert</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">#include <iterator>    // std::random_access_iterator_tag</td>
    <td class="lineNumber">84</td>
    <td class="codeline">#include <iterator>    // std::random_access_iterator_tag</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">#include <limits>      // std::numeric_limits</td>
    <td class="lineNumber">85</td>
    <td class="codeline">#include <limits>      // std::numeric_limits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">#include <type_traits> // std::is_integral, std::is_enum, std::underlying_type,</td>
    <td class="lineNumber">86</td>
    <td class="codeline">#include <type_traits> // std::is_integral, std::is_enum, std::underlying_type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">                       // std::enable_if</td>
    <td class="lineNumber">87</td>
    <td class="codeline">                       // std::enable_if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h" // AddOverflow / SubOverflow</td>
    <td class="lineNumber">89</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h" // AddOverflow / SubOverflow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline"></td>
    <td class="lineNumber">90</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">91</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline"></td>
    <td class="lineNumber">92</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">// Enum traits that marks enums as safe or unsafe to iterate over.</td>
    <td class="lineNumber">93</td>
    <td class="codeline">// Enum traits that marks enums as safe or unsafe to iterate over.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">// By default, enum types are *not* considered safe for iteration.</td>
    <td class="lineNumber">94</td>
    <td class="codeline">// By default, enum types are *not* considered safe for iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">// To allow iteration for your enum type, provide a specialization with</td>
    <td class="lineNumber">95</td>
    <td class="codeline">// To allow iteration for your enum type, provide a specialization with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">// `is_iterable` set to `true` in the `llvm` namespace.</td>
    <td class="lineNumber">96</td>
    <td class="codeline">// `is_iterable` set to `true` in the `llvm` namespace.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">// Alternatively, you can pass the `force_iteration_on_noniterable_enum` tag</td>
    <td class="lineNumber">97</td>
    <td class="codeline">// Alternatively, you can pass the `force_iteration_on_noniterable_enum` tag</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">// to `enum_seq` or `enum_seq_inclusive`.</td>
    <td class="lineNumber">98</td>
    <td class="codeline">// to `enum_seq` or `enum_seq_inclusive`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">template <typename EnumT> struct enum_iteration_traits {</td>
    <td class="lineNumber">99</td>
    <td class="codeline">template <typename EnumT> struct enum_iteration_traits {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  static constexpr bool is_iterable = false;</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  static constexpr bool is_iterable = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">};</td>
    <td class="lineNumber">101</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">struct force_iteration_on_noniterable_enum_t {</td>
    <td class="lineNumber">103</td>
    <td class="codeline">struct force_iteration_on_noniterable_enum_t {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">  explicit force_iteration_on_noniterable_enum_t() = default;</td>
    <td class="lineNumber">104</td>
    <td class="codeline">  explicit force_iteration_on_noniterable_enum_t() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">};</td>
    <td class="lineNumber">105</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline"></td>
    <td class="lineNumber">106</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">inline constexpr force_iteration_on_noniterable_enum_t</td>
    <td class="lineNumber">107</td>
    <td class="codeline">inline constexpr force_iteration_on_noniterable_enum_t</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">    force_iteration_on_noniterable_enum;</td>
    <td class="lineNumber">108</td>
    <td class="codeline">    force_iteration_on_noniterable_enum;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline"></td>
    <td class="lineNumber">109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">110</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">// Returns whether a value of type U can be represented with type T.</td>
    <td class="lineNumber">112</td>
    <td class="codeline">// Returns whether a value of type U can be represented with type T.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">template <typename T, typename U> bool canTypeFitValue(const U Value) {</td>
    <td class="lineNumber">113</td>
    <td class="codeline">template <typename T, typename U> bool canTypeFitValue(const U Value) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  const intmax_t BotT = intmax_t(std::numeric_limits<T>::min());</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  const intmax_t BotT = intmax_t(std::numeric_limits<T>::min());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">  const intmax_t BotU = intmax_t(std::numeric_limits<U>::min());</td>
    <td class="lineNumber">115</td>
    <td class="codeline">  const intmax_t BotU = intmax_t(std::numeric_limits<U>::min());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">  const uintmax_t TopT = uintmax_t(std::numeric_limits<T>::max());</td>
    <td class="lineNumber">116</td>
    <td class="codeline">  const uintmax_t TopT = uintmax_t(std::numeric_limits<T>::max());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  const uintmax_t TopU = uintmax_t(std::numeric_limits<U>::max());</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  const uintmax_t TopU = uintmax_t(std::numeric_limits<U>::max());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  return !((BotT > BotU && Value < static_cast<U>(BotT)) ||</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  return !((BotT > BotU && Value < static_cast<U>(BotT)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">           (TopT < TopU && Value > static_cast<U>(TopT)));</td>
    <td class="lineNumber">119</td>
    <td class="codeline">           (TopT < TopU && Value > static_cast<U>(TopT)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">}</td>
    <td class="lineNumber">120</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">// An integer type that asserts when:</td>
    <td class="lineNumber">122</td>
    <td class="codeline">// An integer type that asserts when:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">// - constructed from a value that doesn't fit into intmax_t,</td>
    <td class="lineNumber">123</td>
    <td class="codeline">// - constructed from a value that doesn't fit into intmax_t,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">// - casted to a type that cannot hold the current value,</td>
    <td class="lineNumber">124</td>
    <td class="codeline">// - casted to a type that cannot hold the current value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">// - its internal representation overflows.</td>
    <td class="lineNumber">125</td>
    <td class="codeline">// - its internal representation overflows.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">struct CheckedInt {</td>
    <td class="lineNumber">126</td>
    <td class="codeline">struct CheckedInt {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  // Integral constructor, asserts if Value cannot be represented as intmax_t.</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  // Integral constructor, asserts if Value cannot be represented as intmax_t.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  template <typename Integral,</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  template <typename Integral,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">            std::enable_if_t<std::is_integral<Integral>::value, bool> = 0></td>
    <td class="lineNumber">129</td>
    <td class="codeline">            std::enable_if_t<std::is_integral<Integral>::value, bool> = 0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  static CheckedInt from(Integral FromValue) {</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  static CheckedInt from(Integral FromValue) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">    if (!canTypeFitValue<intmax_t>(FromValue))</td>
    <td class="lineNumber">131</td>
    <td class="codeline">    if (!canTypeFitValue<intmax_t>(FromValue))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">      assertOutOfBounds();</td>
    <td class="lineNumber">132</td>
    <td class="codeline">      assertOutOfBounds();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">    CheckedInt Result;</td>
    <td class="lineNumber">133</td>
    <td class="codeline">    CheckedInt Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">    Result.Value = static_cast<intmax_t>(FromValue);</td>
    <td class="lineNumber">134</td>
    <td class="codeline">    Result.Value = static_cast<intmax_t>(FromValue);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">    return Result;</td>
    <td class="lineNumber">135</td>
    <td class="codeline">    return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">136</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">  // Enum constructor, asserts if Value cannot be represented as intmax_t.</td>
    <td class="lineNumber">138</td>
    <td class="codeline">  // Enum constructor, asserts if Value cannot be represented as intmax_t.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">  template <typename Enum,</td>
    <td class="lineNumber">139</td>
    <td class="codeline">  template <typename Enum,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">            std::enable_if_t<std::is_enum<Enum>::value, bool> = 0></td>
    <td class="lineNumber">140</td>
    <td class="codeline">            std::enable_if_t<std::is_enum<Enum>::value, bool> = 0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">  static CheckedInt from(Enum FromValue) {</td>
    <td class="lineNumber">141</td>
    <td class="codeline">  static CheckedInt from(Enum FromValue) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">    using type = std::underlying_type_t<Enum>;</td>
    <td class="lineNumber">142</td>
    <td class="codeline">    using type = std::underlying_type_t<Enum>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">    return from<type>(static_cast<type>(FromValue));</td>
    <td class="lineNumber">143</td>
    <td class="codeline">    return from<type>(static_cast<type>(FromValue));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">  // Equality</td>
    <td class="lineNumber">146</td>
    <td class="codeline">  // Equality</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  bool operator==(const CheckedInt &O) const { return Value == O.Value; }</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  bool operator==(const CheckedInt &O) const { return Value == O.Value; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">  bool operator!=(const CheckedInt &O) const { return Value != O.Value; }</td>
    <td class="lineNumber">148</td>
    <td class="codeline">  bool operator!=(const CheckedInt &O) const { return Value != O.Value; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">  CheckedInt operator+(intmax_t Offset) const {</td>
    <td class="lineNumber">150</td>
    <td class="codeline">  CheckedInt operator+(intmax_t Offset) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">    CheckedInt Result;</td>
    <td class="lineNumber">151</td>
    <td class="codeline">    CheckedInt Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">    if (AddOverflow(Value, Offset, Result.Value))</td>
    <td class="lineNumber">152</td>
    <td class="codeline">    if (AddOverflow(Value, Offset, Result.Value))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">      assertOutOfBounds();</td>
    <td class="lineNumber">153</td>
    <td class="codeline">      assertOutOfBounds();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">    return Result;</td>
    <td class="lineNumber">154</td>
    <td class="codeline">    return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">155</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline"></td>
    <td class="lineNumber">156</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  intmax_t operator-(CheckedInt Other) const {</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  intmax_t operator-(CheckedInt Other) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">    intmax_t Result;</td>
    <td class="lineNumber">158</td>
    <td class="codeline">    intmax_t Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">    if (SubOverflow(Value, Other.Value, Result))</td>
    <td class="lineNumber">159</td>
    <td class="codeline">    if (SubOverflow(Value, Other.Value, Result))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">      assertOutOfBounds();</td>
    <td class="lineNumber">160</td>
    <td class="codeline">      assertOutOfBounds();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">    return Result;</td>
    <td class="lineNumber">161</td>
    <td class="codeline">    return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">162</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline"></td>
    <td class="lineNumber">163</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  // Convert to integral, asserts if Value cannot be represented as Integral.</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  // Convert to integral, asserts if Value cannot be represented as Integral.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">  template <typename Integral,</td>
    <td class="lineNumber">165</td>
    <td class="codeline">  template <typename Integral,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">            std::enable_if_t<std::is_integral<Integral>::value, bool> = 0></td>
    <td class="lineNumber">166</td>
    <td class="codeline">            std::enable_if_t<std::is_integral<Integral>::value, bool> = 0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">  Integral to() const {</td>
    <td class="lineNumber">167</td>
    <td class="codeline">  Integral to() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">    if (!canTypeFitValue<Integral>(Value))</td>
    <td class="lineNumber">168</td>
    <td class="codeline">    if (!canTypeFitValue<Integral>(Value))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">      assertOutOfBounds();</td>
    <td class="lineNumber">169</td>
    <td class="codeline">      assertOutOfBounds();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">    return static_cast<Integral>(Value);</td>
    <td class="lineNumber">170</td>
    <td class="codeline">    return static_cast<Integral>(Value);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline"></td>
    <td class="lineNumber">172</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">  // Convert to enum, asserts if Value cannot be represented as Enum's</td>
    <td class="lineNumber">173</td>
    <td class="codeline">  // Convert to enum, asserts if Value cannot be represented as Enum's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  // underlying type.</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  // underlying type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  template <typename Enum,</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  template <typename Enum,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">            std::enable_if_t<std::is_enum<Enum>::value, bool> = 0></td>
    <td class="lineNumber">176</td>
    <td class="codeline">            std::enable_if_t<std::is_enum<Enum>::value, bool> = 0></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">  Enum to() const {</td>
    <td class="lineNumber">177</td>
    <td class="codeline">  Enum to() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">    using type = std::underlying_type_t<Enum>;</td>
    <td class="lineNumber">178</td>
    <td class="codeline">    using type = std::underlying_type_t<Enum>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">    return Enum(to<type>());</td>
    <td class="lineNumber">179</td>
    <td class="codeline">    return Enum(to<type>());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">180</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">182</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  static void assertOutOfBounds() { assert(false && "Out of bounds"); }</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  static void assertOutOfBounds() { assert(false && "Out of bounds"); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline"></td>
    <td class="lineNumber">184</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  intmax_t Value;</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  intmax_t Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">};</td>
    <td class="lineNumber">186</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline"></td>
    <td class="lineNumber">187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">template <typename T, bool IsReverse> struct SafeIntIterator {</td>
    <td class="lineNumber">188</td>
    <td class="codeline">template <typename T, bool IsReverse> struct SafeIntIterator {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  using iterator_category = std::random_access_iterator_tag;</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  using iterator_category = std::random_access_iterator_tag;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  using value_type = T;</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  using value_type = T;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  using difference_type = intmax_t;</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  using difference_type = intmax_t;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">  using pointer = T *;</td>
    <td class="lineNumber">192</td>
    <td class="codeline">  using pointer = T *;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  using reference = value_type; // The iterator does not reference memory.</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  using reference = value_type; // The iterator does not reference memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline"></td>
    <td class="lineNumber">194</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">  // Construct from T.</td>
    <td class="lineNumber">195</td>
    <td class="codeline">  // Construct from T.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">  explicit SafeIntIterator(T Value) : SI(CheckedInt::from<T>(Value)) {}</td>
    <td class="lineNumber">196</td>
    <td class="codeline">  explicit SafeIntIterator(T Value) : SI(CheckedInt::from<T>(Value)) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  // Construct from other direction.</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  // Construct from other direction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">  SafeIntIterator(const SafeIntIterator<T, !IsReverse> &O) : SI(O.SI) {}</td>
    <td class="lineNumber">198</td>
    <td class="codeline">  SafeIntIterator(const SafeIntIterator<T, !IsReverse> &O) : SI(O.SI) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline"></td>
    <td class="lineNumber">199</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">  // Dereference</td>
    <td class="lineNumber">200</td>
    <td class="codeline">  // Dereference</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  reference operator*() const { return SI.to<T>(); }</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  reference operator*() const { return SI.to<T>(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">  // Indexing</td>
    <td class="lineNumber">202</td>
    <td class="codeline">  // Indexing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">  reference operator[](intmax_t Offset) const { return *(*this + Offset); }</td>
    <td class="lineNumber">203</td>
    <td class="codeline">  reference operator[](intmax_t Offset) const { return *(*this + Offset); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  // Can be compared for equivalence using the equality/inequality operators.</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  // Can be compared for equivalence using the equality/inequality operators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  bool operator==(const SafeIntIterator &O) const { return SI == O.SI; }</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  bool operator==(const SafeIntIterator &O) const { return SI == O.SI; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  bool operator!=(const SafeIntIterator &O) const { return SI != O.SI; }</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  bool operator!=(const SafeIntIterator &O) const { return SI != O.SI; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  // Comparison</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  // Comparison</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">  bool operator<(const SafeIntIterator &O) const { return (*this - O) < 0; }</td>
    <td class="lineNumber">209</td>
    <td class="codeline">  bool operator<(const SafeIntIterator &O) const { return (*this - O) < 0; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">  bool operator>(const SafeIntIterator &O) const { return (*this - O) > 0; }</td>
    <td class="lineNumber">210</td>
    <td class="codeline">  bool operator>(const SafeIntIterator &O) const { return (*this - O) > 0; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  bool operator<=(const SafeIntIterator &O) const { return (*this - O) <= 0; }</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  bool operator<=(const SafeIntIterator &O) const { return (*this - O) <= 0; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  bool operator>=(const SafeIntIterator &O) const { return (*this - O) >= 0; }</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  bool operator>=(const SafeIntIterator &O) const { return (*this - O) >= 0; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline"></td>
    <td class="lineNumber">213</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">  // Pre Increment/Decrement</td>
    <td class="lineNumber">214</td>
    <td class="codeline">  // Pre Increment/Decrement</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">  void operator++() { offset(1); }</td>
    <td class="lineNumber">215</td>
    <td class="codeline">  void operator++() { offset(1); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">  void operator--() { offset(-1); }</td>
    <td class="lineNumber">216</td>
    <td class="codeline">  void operator--() { offset(-1); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  // Post Increment/Decrement</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  // Post Increment/Decrement</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  SafeIntIterator operator++(int) {</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  SafeIntIterator operator++(int) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">    const auto Copy = *this;</td>
    <td class="lineNumber">220</td>
    <td class="codeline">    const auto Copy = *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">    ++*this;</td>
    <td class="lineNumber">221</td>
    <td class="codeline">    ++*this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">    return Copy;</td>
    <td class="lineNumber">222</td>
    <td class="codeline">    return Copy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">  SafeIntIterator operator--(int) {</td>
    <td class="lineNumber">224</td>
    <td class="codeline">  SafeIntIterator operator--(int) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">    const auto Copy = *this;</td>
    <td class="lineNumber">225</td>
    <td class="codeline">    const auto Copy = *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">    --*this;</td>
    <td class="lineNumber">226</td>
    <td class="codeline">    --*this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">    return Copy;</td>
    <td class="lineNumber">227</td>
    <td class="codeline">    return Copy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">228</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  // Compound assignment operators</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  // Compound assignment operators</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  void operator+=(intmax_t Offset) { offset(Offset); }</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  void operator+=(intmax_t Offset) { offset(Offset); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  void operator-=(intmax_t Offset) { offset(-Offset); }</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  void operator-=(intmax_t Offset) { offset(-Offset); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">  // Arithmetic</td>
    <td class="lineNumber">234</td>
    <td class="codeline">  // Arithmetic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  SafeIntIterator operator+(intmax_t Offset) const { return add(Offset); }</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  SafeIntIterator operator+(intmax_t Offset) const { return add(Offset); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">  SafeIntIterator operator-(intmax_t Offset) const { return add(-Offset); }</td>
    <td class="lineNumber">236</td>
    <td class="codeline">  SafeIntIterator operator-(intmax_t Offset) const { return add(-Offset); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline"></td>
    <td class="lineNumber">237</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  // Difference</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  // Difference</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  intmax_t operator-(const SafeIntIterator &O) const {</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  intmax_t operator-(const SafeIntIterator &O) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">    return IsReverse ? O.SI - SI : SI - O.SI;</td>
    <td class="lineNumber">240</td>
    <td class="codeline">    return IsReverse ? O.SI - SI : SI - O.SI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline"></td>
    <td class="lineNumber">242</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">243</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  SafeIntIterator(const CheckedInt &SI) : SI(SI) {}</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  SafeIntIterator(const CheckedInt &SI) : SI(SI) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  static intmax_t getOffset(intmax_t Offset) {</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  static intmax_t getOffset(intmax_t Offset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">    return IsReverse ? -Offset : Offset;</td>
    <td class="lineNumber">247</td>
    <td class="codeline">    return IsReverse ? -Offset : Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">248</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline"></td>
    <td class="lineNumber">249</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  CheckedInt add(intmax_t Offset) const { return SI + getOffset(Offset); }</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  CheckedInt add(intmax_t Offset) const { return SI + getOffset(Offset); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline"></td>
    <td class="lineNumber">251</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  void offset(intmax_t Offset) { SI = SI + getOffset(Offset); }</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  void offset(intmax_t Offset) { SI = SI + getOffset(Offset); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline"></td>
    <td class="lineNumber">253</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  CheckedInt SI;</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  CheckedInt SI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline"></td>
    <td class="lineNumber">255</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">  // To allow construction from the other direction.</td>
    <td class="lineNumber">256</td>
    <td class="codeline">  // To allow construction from the other direction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  template <typename, bool> friend struct SafeIntIterator;</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  template <typename, bool> friend struct SafeIntIterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">};</td>
    <td class="lineNumber">258</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">} // namespace detail</td>
    <td class="lineNumber">260</td>
    <td class="codeline">} // namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">template <typename T> struct iota_range {</td>
    <td class="lineNumber">262</td>
    <td class="codeline">template <typename T> struct iota_range {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">  using value_type = T;</td>
    <td class="lineNumber">263</td>
    <td class="codeline">  using value_type = T;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  using reference = T &;</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  using reference = T &;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  using const_reference = const T &;</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  using const_reference = const T &;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  using iterator = detail::SafeIntIterator<value_type, false>;</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  using iterator = detail::SafeIntIterator<value_type, false>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  using const_iterator = iterator;</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  using const_iterator = iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">  using reverse_iterator = detail::SafeIntIterator<value_type, true>;</td>
    <td class="lineNumber">268</td>
    <td class="codeline">  using reverse_iterator = detail::SafeIntIterator<value_type, true>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  using const_reverse_iterator = reverse_iterator;</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  using const_reverse_iterator = reverse_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  using difference_type = intmax_t;</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  using difference_type = intmax_t;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  using size_type = std::size_t;</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  using size_type = std::size_t;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline"></td>
    <td class="lineNumber">272</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  explicit iota_range(T Begin, T End, bool Inclusive)</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  explicit iota_range(T Begin, T End, bool Inclusive)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">      : BeginValue(Begin), PastEndValue(End) {</td>
    <td class="lineNumber">274</td>
    <td class="codeline">      : BeginValue(Begin), PastEndValue(End) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">    assert(Begin <= End && "Begin must be less or equal to End.");</td>
    <td class="lineNumber">275</td>
    <td class="codeline">    assert(Begin <= End && "Begin must be less or equal to End.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">    if (Inclusive)</td>
    <td class="lineNumber">276</td>
    <td class="codeline">    if (Inclusive)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">      ++PastEndValue;</td>
    <td class="lineNumber">277</td>
    <td class="codeline">      ++PastEndValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline"></td>
    <td class="lineNumber">279</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  size_t size() const { return PastEndValue - BeginValue; }</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  size_t size() const { return PastEndValue - BeginValue; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">  bool empty() const { return BeginValue == PastEndValue; }</td>
    <td class="lineNumber">281</td>
    <td class="codeline">  bool empty() const { return BeginValue == PastEndValue; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  auto begin() const { return const_iterator(BeginValue); }</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  auto begin() const { return const_iterator(BeginValue); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  auto end() const { return const_iterator(PastEndValue); }</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  auto end() const { return const_iterator(PastEndValue); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline"></td>
    <td class="lineNumber">285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">  auto rbegin() const { return const_reverse_iterator(PastEndValue - 1); }</td>
    <td class="lineNumber">286</td>
    <td class="codeline">  auto rbegin() const { return const_reverse_iterator(PastEndValue - 1); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  auto rend() const { return const_reverse_iterator(BeginValue - 1); }</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  auto rend() const { return const_reverse_iterator(BeginValue - 1); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">289</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">  static_assert(std::is_integral<T>::value || std::is_enum<T>::value,</td>
    <td class="lineNumber">290</td>
    <td class="codeline">  static_assert(std::is_integral<T>::value || std::is_enum<T>::value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">                "T must be an integral or enum type");</td>
    <td class="lineNumber">291</td>
    <td class="codeline">                "T must be an integral or enum type");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">  static_assert(std::is_same<T, std::remove_cv_t<T>>::value,</td>
    <td class="lineNumber">292</td>
    <td class="codeline">  static_assert(std::is_same<T, std::remove_cv_t<T>>::value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">                "T must not be const nor volatile");</td>
    <td class="lineNumber">293</td>
    <td class="codeline">                "T must not be const nor volatile");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline"></td>
    <td class="lineNumber">294</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  iterator BeginValue;</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  iterator BeginValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  iterator PastEndValue;</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  iterator PastEndValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">};</td>
    <td class="lineNumber">297</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline"></td>
    <td class="lineNumber">298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">/// Iterate over an integral type from Begin up to - but not including - End.</td>
    <td class="lineNumber">299</td>
    <td class="codeline">/// Iterate over an integral type from Begin up to - but not including - End.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
    <td class="lineNumber">300</td>
    <td class="codeline">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
    <td class="lineNumber">301</td>
    <td class="codeline">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">/// iteration).</td>
    <td class="lineNumber">302</td>
    <td class="codeline">/// iteration).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
    <td class="lineNumber">303</td>
    <td class="codeline">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">                                                  !std::is_enum<T>::value>></td>
    <td class="lineNumber">304</td>
    <td class="codeline">                                                  !std::is_enum<T>::value>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">auto seq(T Begin, T End) {</td>
    <td class="lineNumber">305</td>
    <td class="codeline">auto seq(T Begin, T End) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">  return iota_range<T>(Begin, End, false);</td>
    <td class="lineNumber">306</td>
    <td class="codeline">  return iota_range<T>(Begin, End, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">}</td>
    <td class="lineNumber">307</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">/// Iterate over an integral type from 0 up to - but not including - Size.</td>
    <td class="lineNumber">309</td>
    <td class="codeline">/// Iterate over an integral type from 0 up to - but not including - Size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">/// Note: Size value has to be within [INTMAX_MIN, INTMAX_MAX - 1] for</td>
    <td class="lineNumber">310</td>
    <td class="codeline">/// Note: Size value has to be within [INTMAX_MIN, INTMAX_MAX - 1] for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td class="lineNumber">311</td>
    <td class="codeline">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">/// iteration).</td>
    <td class="lineNumber">312</td>
    <td class="codeline">/// iteration).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
    <td class="lineNumber">313</td>
    <td class="codeline">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">                                                  !std::is_enum<T>::value>></td>
    <td class="lineNumber">314</td>
    <td class="codeline">                                                  !std::is_enum<T>::value>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">auto seq(T Size) {</td>
    <td class="lineNumber">315</td>
    <td class="codeline">auto seq(T Size) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">  return seq<T>(0, Size);</td>
    <td class="lineNumber">316</td>
    <td class="codeline">  return seq<T>(0, Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">}</td>
    <td class="lineNumber">317</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline"></td>
    <td class="lineNumber">318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">/// Iterate over an integral type from Begin to End inclusive.</td>
    <td class="lineNumber">319</td>
    <td class="codeline">/// Iterate over an integral type from Begin to End inclusive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
    <td class="lineNumber">320</td>
    <td class="codeline">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td class="lineNumber">321</td>
    <td class="codeline">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">/// iteration).</td>
    <td class="lineNumber">322</td>
    <td class="codeline">/// iteration).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
    <td class="lineNumber">323</td>
    <td class="codeline">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">                                                  !std::is_enum<T>::value>></td>
    <td class="lineNumber">324</td>
    <td class="codeline">                                                  !std::is_enum<T>::value>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">auto seq_inclusive(T Begin, T End) {</td>
    <td class="lineNumber">325</td>
    <td class="codeline">auto seq_inclusive(T Begin, T End) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">  return iota_range<T>(Begin, End, true);</td>
    <td class="lineNumber">326</td>
    <td class="codeline">  return iota_range<T>(Begin, End, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">}</td>
    <td class="lineNumber">327</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline"></td>
    <td class="lineNumber">328</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">/// Iterate over an enum type from Begin up to - but not including - End.</td>
    <td class="lineNumber">329</td>
    <td class="codeline">/// Iterate over an enum type from Begin up to - but not including - End.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">/// Note: `enum_seq` will generate each consecutive value, even if no</td>
    <td class="lineNumber">330</td>
    <td class="codeline">/// Note: `enum_seq` will generate each consecutive value, even if no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">/// enumerator with that value exists.</td>
    <td class="lineNumber">331</td>
    <td class="codeline">/// enumerator with that value exists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
    <td class="lineNumber">332</td>
    <td class="codeline">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
    <td class="lineNumber">333</td>
    <td class="codeline">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">/// iteration).</td>
    <td class="lineNumber">334</td>
    <td class="codeline">/// iteration).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">template <typename EnumT,</td>
    <td class="lineNumber">335</td>
    <td class="codeline">template <typename EnumT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td class="lineNumber">336</td>
    <td class="codeline">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">auto enum_seq(EnumT Begin, EnumT End) {</td>
    <td class="lineNumber">337</td>
    <td class="codeline">auto enum_seq(EnumT Begin, EnumT End) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">  static_assert(enum_iteration_traits<EnumT>::is_iterable,</td>
    <td class="lineNumber">338</td>
    <td class="codeline">  static_assert(enum_iteration_traits<EnumT>::is_iterable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">                "Enum type is not marked as iterable.");</td>
    <td class="lineNumber">339</td>
    <td class="codeline">                "Enum type is not marked as iterable.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">  return iota_range<EnumT>(Begin, End, false);</td>
    <td class="lineNumber">340</td>
    <td class="codeline">  return iota_range<EnumT>(Begin, End, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">}</td>
    <td class="lineNumber">341</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline"></td>
    <td class="lineNumber">342</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">/// Iterate over an enum type from Begin up to - but not including - End, even</td>
    <td class="lineNumber">343</td>
    <td class="codeline">/// Iterate over an enum type from Begin up to - but not including - End, even</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">/// when `EnumT` is not marked as safely iterable by `enum_iteration_traits`.</td>
    <td class="lineNumber">344</td>
    <td class="codeline">/// when `EnumT` is not marked as safely iterable by `enum_iteration_traits`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">/// Note: `enum_seq` will generate each consecutive value, even if no</td>
    <td class="lineNumber">345</td>
    <td class="codeline">/// Note: `enum_seq` will generate each consecutive value, even if no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">/// enumerator with that value exists.</td>
    <td class="lineNumber">346</td>
    <td class="codeline">/// enumerator with that value exists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
    <td class="lineNumber">347</td>
    <td class="codeline">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
    <td class="lineNumber">348</td>
    <td class="codeline">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">/// iteration).</td>
    <td class="lineNumber">349</td>
    <td class="codeline">/// iteration).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">template <typename EnumT,</td>
    <td class="lineNumber">350</td>
    <td class="codeline">template <typename EnumT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td class="lineNumber">351</td>
    <td class="codeline">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">auto enum_seq(EnumT Begin, EnumT End, force_iteration_on_noniterable_enum_t) {</td>
    <td class="lineNumber">352</td>
    <td class="codeline">auto enum_seq(EnumT Begin, EnumT End, force_iteration_on_noniterable_enum_t) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">  return iota_range<EnumT>(Begin, End, false);</td>
    <td class="lineNumber">353</td>
    <td class="codeline">  return iota_range<EnumT>(Begin, End, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">}</td>
    <td class="lineNumber">354</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline"></td>
    <td class="lineNumber">355</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">/// Iterate over an enum type from Begin to End inclusive.</td>
    <td class="lineNumber">356</td>
    <td class="codeline">/// Iterate over an enum type from Begin to End inclusive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">/// Note: `enum_seq_inclusive` will generate each consecutive value, even if no</td>
    <td class="lineNumber">357</td>
    <td class="codeline">/// Note: `enum_seq_inclusive` will generate each consecutive value, even if no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">/// enumerator with that value exists.</td>
    <td class="lineNumber">358</td>
    <td class="codeline">/// enumerator with that value exists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
    <td class="lineNumber">359</td>
    <td class="codeline">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td class="lineNumber">360</td>
    <td class="codeline">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">/// iteration).</td>
    <td class="lineNumber">361</td>
    <td class="codeline">/// iteration).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">template <typename EnumT,</td>
    <td class="lineNumber">362</td>
    <td class="codeline">template <typename EnumT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td class="lineNumber">363</td>
    <td class="codeline">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">auto enum_seq_inclusive(EnumT Begin, EnumT End) {</td>
    <td class="lineNumber">364</td>
    <td class="codeline">auto enum_seq_inclusive(EnumT Begin, EnumT End) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">  static_assert(enum_iteration_traits<EnumT>::is_iterable,</td>
    <td class="lineNumber">365</td>
    <td class="codeline">  static_assert(enum_iteration_traits<EnumT>::is_iterable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">                "Enum type is not marked as iterable.");</td>
    <td class="lineNumber">366</td>
    <td class="codeline">                "Enum type is not marked as iterable.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">  return iota_range<EnumT>(Begin, End, true);</td>
    <td class="lineNumber">367</td>
    <td class="codeline">  return iota_range<EnumT>(Begin, End, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">}</td>
    <td class="lineNumber">368</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">/// Iterate over an enum type from Begin to End inclusive, even when `EnumT`</td>
    <td class="lineNumber">370</td>
    <td class="codeline">/// Iterate over an enum type from Begin to End inclusive, even when `EnumT`</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">/// is not marked as safely iterable by `enum_iteration_traits`.</td>
    <td class="lineNumber">371</td>
    <td class="codeline">/// is not marked as safely iterable by `enum_iteration_traits`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">/// Note: `enum_seq_inclusive` will generate each consecutive value, even if no</td>
    <td class="lineNumber">372</td>
    <td class="codeline">/// Note: `enum_seq_inclusive` will generate each consecutive value, even if no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">/// enumerator with that value exists.</td>
    <td class="lineNumber">373</td>
    <td class="codeline">/// enumerator with that value exists.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
    <td class="lineNumber">374</td>
    <td class="codeline">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td class="lineNumber">375</td>
    <td class="codeline">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">/// iteration).</td>
    <td class="lineNumber">376</td>
    <td class="codeline">/// iteration).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">template <typename EnumT,</td>
    <td class="lineNumber">377</td>
    <td class="codeline">template <typename EnumT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td class="lineNumber">378</td>
    <td class="codeline">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">auto enum_seq_inclusive(EnumT Begin, EnumT End,</td>
    <td class="lineNumber">379</td>
    <td class="codeline">auto enum_seq_inclusive(EnumT Begin, EnumT End,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">                        force_iteration_on_noniterable_enum_t) {</td>
    <td class="lineNumber">380</td>
    <td class="codeline">                        force_iteration_on_noniterable_enum_t) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">  return iota_range<EnumT>(Begin, End, true);</td>
    <td class="lineNumber">381</td>
    <td class="codeline">  return iota_range<EnumT>(Begin, End, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">}</td>
    <td class="lineNumber">382</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline"></td>
    <td class="lineNumber">383</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">384</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline"></td>
    <td class="lineNumber">385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">#endif // LLVM_ADT_SEQUENCE_H</td>
    <td class="lineNumber">386</td>
    <td class="codeline">#endif // LLVM_ADT_SEQUENCE_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline"></td>
    <td class="lineNumber">387</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- Sequence.h - Utility for producing sequences of values ---*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- Sequence.h - Utility for producing sequences of values ---*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">/// Provides some synthesis utilities to produce sequences of values. The names</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">/// Provides some synthesis utilities to produce sequences of values. The names</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">/// are intentionally kept very short as they tend to occur in common and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">/// are intentionally kept very short as they tend to occur in common and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">/// widely used contexts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">/// widely used contexts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">/// The `seq(A, B)` function produces a sequence of values from `A` to up to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">/// The `seq(A, B)` function produces a sequence of values from `A` to up to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">/// (but not including) `B`, i.e., [`A`, `B`), that can be safely iterated over.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">/// (but not including) `B`, i.e., [`A`, `B`), that can be safely iterated over.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">/// `seq` supports both integral (e.g., `int`, `char`, `uint32_t`) and enum</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">/// `seq` supports both integral (e.g., `int`, `char`, `uint32_t`) and enum</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">/// types. `seq_inclusive(A, B)` produces a sequence of values from `A` to `B`,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">/// types. `seq_inclusive(A, B)` produces a sequence of values from `A` to `B`,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">/// including `B`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">/// including `B`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">/// Examples with integral types:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">/// Examples with integral types:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">/// for (int x : seq(0, 3))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">/// for (int x : seq(0, 3))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">///   outs() << x << " ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">///   outs() << x << " ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">/// Prints: `0 1 2 `.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">/// Prints: `0 1 2 `.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">/// for (int x : seq_inclusive(0, 3))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">/// for (int x : seq_inclusive(0, 3))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">///   outs() << x << " ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">///   outs() << x << " ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">/// Prints: `0 1 2 3 `.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">/// Prints: `0 1 2 3 `.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">/// Similar to `seq` and `seq_inclusive`, the `enum_seq` and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">/// Similar to `seq` and `seq_inclusive`, the `enum_seq` and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">/// `enum_seq_inclusive` functions produce sequences of enum values that can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">/// `enum_seq_inclusive` functions produce sequences of enum values that can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">/// iterated over.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">/// iterated over.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">/// To enable iteration with enum types, you need to either mark enums as safe</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">/// To enable iteration with enum types, you need to either mark enums as safe</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">/// to iterate on by specializing `enum_iteration_traits`, or opt into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">/// to iterate on by specializing `enum_iteration_traits`, or opt into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">/// potentially unsafe iteration at every callsite by passing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">/// potentially unsafe iteration at every callsite by passing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">/// `force_iteration_on_noniterable_enum`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">/// `force_iteration_on_noniterable_enum`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">/// Examples with enum types:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">/// Examples with enum types:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">/// namespace X {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">/// namespace X {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">///   enum class MyEnum : unsigned {A = 0, B, C};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">///   enum class MyEnum : unsigned {A = 0, B, C};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">/// } // namespace X</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">/// } // namespace X</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">/// template <> struct enum_iteration_traits<X::MyEnum> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">/// template <> struct enum_iteration_traits<X::MyEnum> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">///   static contexpr bool is_iterable = true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">///   static contexpr bool is_iterable = true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">/// };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">/// };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">/// class MyClass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">/// class MyClass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">/// public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">/// public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">///   enum Safe { D = 3, E, F };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">///   enum Safe { D = 3, E, F };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">///   enum MaybeUnsafe { G = 1, H = 2, I = 4 };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">///   enum MaybeUnsafe { G = 1, H = 2, I = 4 };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">/// };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">/// };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">/// template <> struct enum_iteration_traits<MyClass::Safe> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">/// template <> struct enum_iteration_traits<MyClass::Safe> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">///   static contexpr bool is_iterable = true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">///   static contexpr bool is_iterable = true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">/// };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">/// };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">///   for (auto v : enum_seq(MyClass::Safe::D, MyClass::Safe::F))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">///   for (auto v : enum_seq(MyClass::Safe::D, MyClass::Safe::F))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">///     outs() << int(v) << " ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">///     outs() << int(v) << " ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">/// Prints: `3 4 `.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">/// Prints: `3 4 `.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">///   for (auto v : enum_seq(MyClass::MaybeUnsafe::H, MyClass::MaybeUnsafe::I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">///   for (auto v : enum_seq(MyClass::MaybeUnsafe::H, MyClass::MaybeUnsafe::I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">///                          force_iteration_on_noniterable_enum))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">///                          force_iteration_on_noniterable_enum))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">///     outs() << int(v) << " ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">///     outs() << int(v) << " ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">/// ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">/// Prints: `2 3 `.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">/// Prints: `2 3 `.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">#ifndef LLVM_ADT_SEQUENCE_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">#ifndef LLVM_ADT_SEQUENCE_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">#define LLVM_ADT_SEQUENCE_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">#define LLVM_ADT_SEQUENCE_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">#include <cassert>     // assert</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">#include <cassert>     // assert</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">#include <iterator>    // std::random_access_iterator_tag</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">#include <iterator>    // std::random_access_iterator_tag</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">#include <limits>      // std::numeric_limits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">#include <limits>      // std::numeric_limits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">#include <type_traits> // std::is_integral, std::is_enum, std::underlying_type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">#include <type_traits> // std::is_integral, std::is_enum, std::underlying_type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">                       // std::enable_if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">                       // std::enable_if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h" // AddOverflow / SubOverflow</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h" // AddOverflow / SubOverflow</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">// Enum traits that marks enums as safe or unsafe to iterate over.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">// Enum traits that marks enums as safe or unsafe to iterate over.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">// By default, enum types are *not* considered safe for iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">// By default, enum types are *not* considered safe for iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">// To allow iteration for your enum type, provide a specialization with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">// To allow iteration for your enum type, provide a specialization with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">// `is_iterable` set to `true` in the `llvm` namespace.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">// `is_iterable` set to `true` in the `llvm` namespace.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">// Alternatively, you can pass the `force_iteration_on_noniterable_enum` tag</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">// Alternatively, you can pass the `force_iteration_on_noniterable_enum` tag</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">// to `enum_seq` or `enum_seq_inclusive`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">// to `enum_seq` or `enum_seq_inclusive`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">template <typename EnumT> struct enum_iteration_traits {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">template <typename EnumT> struct enum_iteration_traits {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  static constexpr bool is_iterable = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  static constexpr bool is_iterable = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">struct force_iteration_on_noniterable_enum_t {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">struct force_iteration_on_noniterable_enum_t {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">  explicit force_iteration_on_noniterable_enum_t() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">  explicit force_iteration_on_noniterable_enum_t() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">inline constexpr force_iteration_on_noniterable_enum_t</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">inline constexpr force_iteration_on_noniterable_enum_t</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">    force_iteration_on_noniterable_enum;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">    force_iteration_on_noniterable_enum;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">// Returns whether a value of type U can be represented with type T.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">// Returns whether a value of type U can be represented with type T.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine coveredLine">template <typename T, typename U> bool canTypeFitValue(const U Value) {</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">113</td>
    <td class="codeLine coveredLine">template <typename T, typename U> bool canTypeFitValue(const U Value) {</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine coveredLine">  const intmax_t BotT = intmax_t(std::numeric_limits<T>::min());</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">114</td>
    <td class="codeLine coveredLine">  const intmax_t BotT = intmax_t(std::numeric_limits<T>::min());</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine coveredLine">  const intmax_t BotU = intmax_t(std::numeric_limits<U>::min());</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">115</td>
    <td class="codeLine coveredLine">  const intmax_t BotU = intmax_t(std::numeric_limits<U>::min());</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine coveredLine">  const uintmax_t TopT = uintmax_t(std::numeric_limits<T>::max());</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">116</td>
    <td class="codeLine coveredLine">  const uintmax_t TopT = uintmax_t(std::numeric_limits<T>::max());</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine coveredLine">  const uintmax_t TopU = uintmax_t(std::numeric_limits<U>::max());</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">117</td>
    <td class="codeLine coveredLine">  const uintmax_t TopU = uintmax_t(std::numeric_limits<U>::max());</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine coveredLine">  return !((BotT > BotU && Value < static_cast<U>(BotT)) ||</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">118</td>
    <td class="codeLine coveredLine">  return !((BotT > BotU && Value < static_cast<U>(BotT)) ||</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine coveredLine">           (TopT < TopU && Value > static_cast<U>(TopT)));</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">119</td>
    <td class="codeLine coveredLine">           (TopT < TopU && Value > static_cast<U>(TopT)));</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">// An integer type that asserts when:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">// An integer type that asserts when:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">// - constructed from a value that doesn't fit into intmax_t,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">// - constructed from a value that doesn't fit into intmax_t,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">// - casted to a type that cannot hold the current value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">// - casted to a type that cannot hold the current value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">// - its internal representation overflows.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">// - its internal representation overflows.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">struct CheckedInt {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">struct CheckedInt {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  // Integral constructor, asserts if Value cannot be represented as intmax_t.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  // Integral constructor, asserts if Value cannot be represented as intmax_t.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  template <typename Integral,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  template <typename Integral,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">            std::enable_if_t<std::is_integral<Integral>::value, bool> = 0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">            std::enable_if_t<std::is_integral<Integral>::value, bool> = 0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine coveredLine">  static CheckedInt from(Integral FromValue) {</td>
    <td class="lineNumber">120</td>
    <td class="lineNumber">130</td>
    <td class="codeLine coveredLine">  static CheckedInt from(Integral FromValue) {</td>
    <td class="lineNumber">96</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine coveredLine">    if (!canTypeFitValue<intmax_t>(FromValue))</td>
    <td class="lineNumber">120</td>
    <td class="lineNumber">131</td>
    <td class="codeLine coveredLine">    if (!canTypeFitValue<intmax_t>(FromValue))</td>
    <td class="lineNumber">96</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">      assertOutOfBounds();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">      assertOutOfBounds();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">    CheckedInt Result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">    CheckedInt Result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine coveredLine">    Result.Value = static_cast<intmax_t>(FromValue);</td>
    <td class="lineNumber">120</td>
    <td class="lineNumber">134</td>
    <td class="codeLine coveredLine">    Result.Value = static_cast<intmax_t>(FromValue);</td>
    <td class="lineNumber">96</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine coveredLine">    return Result;</td>
    <td class="lineNumber">120</td>
    <td class="lineNumber">135</td>
    <td class="codeLine coveredLine">    return Result;</td>
    <td class="lineNumber">96</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">  // Enum constructor, asserts if Value cannot be represented as intmax_t.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">  // Enum constructor, asserts if Value cannot be represented as intmax_t.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">  template <typename Enum,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">  template <typename Enum,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">            std::enable_if_t<std::is_enum<Enum>::value, bool> = 0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">            std::enable_if_t<std::is_enum<Enum>::value, bool> = 0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine coveredLine">  static CheckedInt from(Enum FromValue) {</td>
    <td class="lineNumber">110</td>
    <td class="lineNumber">141</td>
    <td class="codeLine coveredLine">  static CheckedInt from(Enum FromValue) {</td>
    <td class="lineNumber">86</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">    using type = std::underlying_type_t<Enum>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">    using type = std::underlying_type_t<Enum>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine coveredLine">    return from<type>(static_cast<type>(FromValue));</td>
    <td class="lineNumber">110</td>
    <td class="lineNumber">143</td>
    <td class="codeLine coveredLine">    return from<type>(static_cast<type>(FromValue));</td>
    <td class="lineNumber">86</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">  // Equality</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">  // Equality</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  bool operator==(const CheckedInt &O) const { return Value == O.Value; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  bool operator==(const CheckedInt &O) const { return Value == O.Value; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine coveredLine">  bool operator!=(const CheckedInt &O) const { return Value != O.Value; }</td>
    <td class="lineNumber">6396</td>
    <td class="lineNumber">148</td>
    <td class="codeLine coveredLine">  bool operator!=(const CheckedInt &O) const { return Value != O.Value; }</td>
    <td class="lineNumber">6348</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine coveredLine">  CheckedInt operator+(intmax_t Offset) const {</td>
    <td class="lineNumber">6391</td>
    <td class="lineNumber">150</td>
    <td class="codeLine coveredLine">  CheckedInt operator+(intmax_t Offset) const {</td>
    <td class="lineNumber">6343</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">    CheckedInt Result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">    CheckedInt Result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine coveredLine">    if (AddOverflow(Value, Offset, Result.Value))</td>
    <td class="lineNumber">6391</td>
    <td class="lineNumber">152</td>
    <td class="codeLine coveredLine">    if (AddOverflow(Value, Offset, Result.Value))</td>
    <td class="lineNumber">6343</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">      assertOutOfBounds();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">      assertOutOfBounds();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine coveredLine">    return Result;</td>
    <td class="lineNumber">6391</td>
    <td class="lineNumber">154</td>
    <td class="codeLine coveredLine">    return Result;</td>
    <td class="lineNumber">6343</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  intmax_t operator-(CheckedInt Other) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  intmax_t operator-(CheckedInt Other) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">    intmax_t Result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">    intmax_t Result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">    if (SubOverflow(Value, Other.Value, Result))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">    if (SubOverflow(Value, Other.Value, Result))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">      assertOutOfBounds();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">      assertOutOfBounds();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">    return Result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">    return Result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  // Convert to integral, asserts if Value cannot be represented as Integral.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  // Convert to integral, asserts if Value cannot be represented as Integral.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">  template <typename Integral,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">  template <typename Integral,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">            std::enable_if_t<std::is_integral<Integral>::value, bool> = 0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">            std::enable_if_t<std::is_integral<Integral>::value, bool> = 0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine coveredLine">  Integral to() const {</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">167</td>
    <td class="codeLine coveredLine">  Integral to() const {</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine coveredLine">    if (!canTypeFitValue<Integral>(Value))</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">168</td>
    <td class="codeLine coveredLine">    if (!canTypeFitValue<Integral>(Value))</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">      assertOutOfBounds();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">      assertOutOfBounds();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine coveredLine">    return static_cast<Integral>(Value);</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">170</td>
    <td class="codeLine coveredLine">    return static_cast<Integral>(Value);</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">  // Convert to enum, asserts if Value cannot be represented as Enum's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">  // Convert to enum, asserts if Value cannot be represented as Enum's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  // underlying type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  // underlying type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">  template <typename Enum,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">  template <typename Enum,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">            std::enable_if_t<std::is_enum<Enum>::value, bool> = 0></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">            std::enable_if_t<std::is_enum<Enum>::value, bool> = 0></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine coveredLine">  Enum to() const {</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">177</td>
    <td class="codeLine coveredLine">  Enum to() const {</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">    using type = std::underlying_type_t<Enum>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">    using type = std::underlying_type_t<Enum>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine coveredLine">    return Enum(to<type>());</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">179</td>
    <td class="codeLine coveredLine">    return Enum(to<type>());</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  static void assertOutOfBounds() { assert(false && "Out of bounds"); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  static void assertOutOfBounds() { assert(false && "Out of bounds"); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  intmax_t Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  intmax_t Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">template <typename T, bool IsReverse> struct SafeIntIterator {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">template <typename T, bool IsReverse> struct SafeIntIterator {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  using iterator_category = std::random_access_iterator_tag;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  using iterator_category = std::random_access_iterator_tag;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  using value_type = T;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  using value_type = T;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  using difference_type = intmax_t;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  using difference_type = intmax_t;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">  using pointer = T *;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">  using pointer = T *;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  using reference = value_type; // The iterator does not reference memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  using reference = value_type; // The iterator does not reference memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">  // Construct from T.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">  // Construct from T.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine coveredLine">  explicit SafeIntIterator(T Value) : SI(CheckedInt::from<T>(Value)) {}</td>
    <td class="lineNumber">110</td>
    <td class="lineNumber">196</td>
    <td class="codeLine coveredLine">  explicit SafeIntIterator(T Value) : SI(CheckedInt::from<T>(Value)) {}</td>
    <td class="lineNumber">86</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  // Construct from other direction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  // Construct from other direction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">  SafeIntIterator(const SafeIntIterator<T, !IsReverse> &O) : SI(O.SI) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">  SafeIntIterator(const SafeIntIterator<T, !IsReverse> &O) : SI(O.SI) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">  // Dereference</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">  // Dereference</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine coveredLine">  reference operator*() const { return SI.to<T>(); }</td>
    <td class="lineNumber">6336</td>
    <td class="lineNumber">201</td>
    <td class="codeLine coveredLine">  reference operator*() const { return SI.to<T>(); }</td>
    <td class="lineNumber">6300</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">  // Indexing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">  // Indexing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">  reference operator[](intmax_t Offset) const { return *(*this + Offset); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">  reference operator[](intmax_t Offset) const { return *(*this + Offset); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  // Can be compared for equivalence using the equality/inequality operators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  // Can be compared for equivalence using the equality/inequality operators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  bool operator==(const SafeIntIterator &O) const { return SI == O.SI; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  bool operator==(const SafeIntIterator &O) const { return SI == O.SI; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine coveredLine">  bool operator!=(const SafeIntIterator &O) const { return SI != O.SI; }</td>
    <td class="lineNumber">6396</td>
    <td class="lineNumber">207</td>
    <td class="codeLine coveredLine">  bool operator!=(const SafeIntIterator &O) const { return SI != O.SI; }</td>
    <td class="lineNumber">6348</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  // Comparison</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  // Comparison</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">  bool operator<(const SafeIntIterator &O) const { return (*this - O) < 0; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">  bool operator<(const SafeIntIterator &O) const { return (*this - O) < 0; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">  bool operator>(const SafeIntIterator &O) const { return (*this - O) > 0; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">  bool operator>(const SafeIntIterator &O) const { return (*this - O) > 0; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  bool operator<=(const SafeIntIterator &O) const { return (*this - O) <= 0; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  bool operator<=(const SafeIntIterator &O) const { return (*this - O) <= 0; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  bool operator>=(const SafeIntIterator &O) const { return (*this - O) >= 0; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  bool operator>=(const SafeIntIterator &O) const { return (*this - O) >= 0; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">  // Pre Increment/Decrement</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">  // Pre Increment/Decrement</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine coveredLine">  void operator++() { offset(1); }</td>
    <td class="lineNumber">6391</td>
    <td class="lineNumber">215</td>
    <td class="codeLine coveredLine">  void operator++() { offset(1); }</td>
    <td class="lineNumber">6343</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">  void operator--() { offset(-1); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">  void operator--() { offset(-1); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">  // Post Increment/Decrement</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">  // Post Increment/Decrement</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  SafeIntIterator operator++(int) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  SafeIntIterator operator++(int) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">    const auto Copy = *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">    const auto Copy = *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">    ++*this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">    ++*this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">    return Copy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">    return Copy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">  SafeIntIterator operator--(int) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">  SafeIntIterator operator--(int) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">    const auto Copy = *this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">    const auto Copy = *this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">    --*this;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">    --*this;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">    return Copy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">    return Copy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  // Compound assignment operators</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  // Compound assignment operators</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  void operator+=(intmax_t Offset) { offset(Offset); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  void operator+=(intmax_t Offset) { offset(Offset); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">  void operator-=(intmax_t Offset) { offset(-Offset); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">  void operator-=(intmax_t Offset) { offset(-Offset); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">  // Arithmetic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">  // Arithmetic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  SafeIntIterator operator+(intmax_t Offset) const { return add(Offset); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  SafeIntIterator operator+(intmax_t Offset) const { return add(Offset); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">  SafeIntIterator operator-(intmax_t Offset) const { return add(-Offset); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">  SafeIntIterator operator-(intmax_t Offset) const { return add(-Offset); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  // Difference</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  // Difference</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  intmax_t operator-(const SafeIntIterator &O) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  intmax_t operator-(const SafeIntIterator &O) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">    return IsReverse ? O.SI - SI : SI - O.SI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">    return IsReverse ? O.SI - SI : SI - O.SI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  SafeIntIterator(const CheckedInt &SI) : SI(SI) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  SafeIntIterator(const CheckedInt &SI) : SI(SI) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine coveredLine">  static intmax_t getOffset(intmax_t Offset) {</td>
    <td class="lineNumber">6391</td>
    <td class="lineNumber">246</td>
    <td class="codeLine coveredLine">  static intmax_t getOffset(intmax_t Offset) {</td>
    <td class="lineNumber">6343</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine coveredLine">    return IsReverse ? -Offset : Offset;</td>
    <td class="lineNumber">6391</td>
    <td class="lineNumber">247</td>
    <td class="codeLine coveredLine">    return IsReverse ? -Offset : Offset;</td>
    <td class="lineNumber">6343</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  CheckedInt add(intmax_t Offset) const { return SI + getOffset(Offset); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  CheckedInt add(intmax_t Offset) const { return SI + getOffset(Offset); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine coveredLine">  void offset(intmax_t Offset) { SI = SI + getOffset(Offset); }</td>
    <td class="lineNumber">6391</td>
    <td class="lineNumber">252</td>
    <td class="codeLine coveredLine">  void offset(intmax_t Offset) { SI = SI + getOffset(Offset); }</td>
    <td class="lineNumber">6343</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  CheckedInt SI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  CheckedInt SI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">  // To allow construction from the other direction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">  // To allow construction from the other direction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  template <typename, bool> friend struct SafeIntIterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  template <typename, bool> friend struct SafeIntIterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">template <typename T> struct iota_range {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">template <typename T> struct iota_range {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">  using value_type = T;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">  using value_type = T;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  using reference = T &;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  using reference = T &;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  using const_reference = const T &;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  using const_reference = const T &;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  using iterator = detail::SafeIntIterator<value_type, false>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  using iterator = detail::SafeIntIterator<value_type, false>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  using const_iterator = iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  using const_iterator = iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">  using reverse_iterator = detail::SafeIntIterator<value_type, true>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">  using reverse_iterator = detail::SafeIntIterator<value_type, true>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  using const_reverse_iterator = reverse_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  using const_reverse_iterator = reverse_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">  using difference_type = intmax_t;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">  using difference_type = intmax_t;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  using size_type = std::size_t;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  using size_type = std::size_t;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine coveredLine">  explicit iota_range(T Begin, T End, bool Inclusive)</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">273</td>
    <td class="codeLine coveredLine">  explicit iota_range(T Begin, T End, bool Inclusive)</td>
    <td class="lineNumber">43</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine coveredLine">      : BeginValue(Begin), PastEndValue(End) {</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">274</td>
    <td class="codeLine coveredLine">      : BeginValue(Begin), PastEndValue(End) {</td>
    <td class="lineNumber">43</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine coveredLine">    assert(Begin <= End && "Begin must be less or equal to End.");</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">275</td>
    <td class="codeLine coveredLine">    assert(Begin <= End && "Begin must be less or equal to End.");</td>
    <td class="lineNumber">43</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine coveredLine">    if (Inclusive)</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">276</td>
    <td class="codeLine coveredLine">    if (Inclusive)</td>
    <td class="lineNumber">43</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine coveredLine">      ++PastEndValue;</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">277</td>
    <td class="codeLine coveredLine">      ++PastEndValue;</td>
    <td class="lineNumber">43</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">278</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">43</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  size_t size() const { return PastEndValue - BeginValue; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  size_t size() const { return PastEndValue - BeginValue; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">  bool empty() const { return BeginValue == PastEndValue; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">  bool empty() const { return BeginValue == PastEndValue; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine coveredLine">  auto begin() const { return const_iterator(BeginValue); }</td>
    <td class="lineNumber">60</td>
    <td class="lineNumber">283</td>
    <td class="codeLine coveredLine">  auto begin() const { return const_iterator(BeginValue); }</td>
    <td class="lineNumber">48</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine coveredLine">  auto end() const { return const_iterator(PastEndValue); }</td>
    <td class="lineNumber">60</td>
    <td class="lineNumber">284</td>
    <td class="codeLine coveredLine">  auto end() const { return const_iterator(PastEndValue); }</td>
    <td class="lineNumber">48</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">  auto rbegin() const { return const_reverse_iterator(PastEndValue - 1); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">  auto rbegin() const { return const_reverse_iterator(PastEndValue - 1); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  auto rend() const { return const_reverse_iterator(BeginValue - 1); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  auto rend() const { return const_reverse_iterator(BeginValue - 1); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">  static_assert(std::is_integral<T>::value || std::is_enum<T>::value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">  static_assert(std::is_integral<T>::value || std::is_enum<T>::value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">                "T must be an integral or enum type");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">                "T must be an integral or enum type");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">  static_assert(std::is_same<T, std::remove_cv_t<T>>::value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">  static_assert(std::is_same<T, std::remove_cv_t<T>>::value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">                "T must not be const nor volatile");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">                "T must not be const nor volatile");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  iterator BeginValue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  iterator BeginValue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">  iterator PastEndValue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">  iterator PastEndValue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">/// Iterate over an integral type from Begin up to - but not including - End.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">/// Iterate over an integral type from Begin up to - but not including - End.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">                                                  !std::is_enum<T>::value>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">                                                  !std::is_enum<T>::value>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">auto seq(T Begin, T End) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">auto seq(T Begin, T End) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">  return iota_range<T>(Begin, End, false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">  return iota_range<T>(Begin, End, false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">/// Iterate over an integral type from 0 up to - but not including - Size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">/// Iterate over an integral type from 0 up to - but not including - Size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">/// Note: Size value has to be within [INTMAX_MIN, INTMAX_MAX - 1] for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">/// Note: Size value has to be within [INTMAX_MIN, INTMAX_MAX - 1] for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">                                                  !std::is_enum<T>::value>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">                                                  !std::is_enum<T>::value>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">auto seq(T Size) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">auto seq(T Size) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">  return seq<T>(0, Size);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">  return seq<T>(0, Size);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">/// Iterate over an integral type from Begin to End inclusive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">/// Iterate over an integral type from Begin to End inclusive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">                                                  !std::is_enum<T>::value>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">                                                  !std::is_enum<T>::value>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">auto seq_inclusive(T Begin, T End) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">auto seq_inclusive(T Begin, T End) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">  return iota_range<T>(Begin, End, true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">  return iota_range<T>(Begin, End, true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">/// Iterate over an enum type from Begin up to - but not including - End.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">/// Iterate over an enum type from Begin up to - but not including - End.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">/// Note: `enum_seq` will generate each consecutive value, even if no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">/// Note: `enum_seq` will generate each consecutive value, even if no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">/// enumerator with that value exists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">/// enumerator with that value exists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">template <typename EnumT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">template <typename EnumT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">auto enum_seq(EnumT Begin, EnumT End) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">auto enum_seq(EnumT Begin, EnumT End) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">  static_assert(enum_iteration_traits<EnumT>::is_iterable,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">  static_assert(enum_iteration_traits<EnumT>::is_iterable,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">                "Enum type is not marked as iterable.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">                "Enum type is not marked as iterable.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">  return iota_range<EnumT>(Begin, End, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">  return iota_range<EnumT>(Begin, End, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">/// Iterate over an enum type from Begin up to - but not including - End, even</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">/// Iterate over an enum type from Begin up to - but not including - End, even</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">/// when `EnumT` is not marked as safely iterable by `enum_iteration_traits`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">/// when `EnumT` is not marked as safely iterable by `enum_iteration_traits`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">/// Note: `enum_seq` will generate each consecutive value, even if no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">/// Note: `enum_seq` will generate each consecutive value, even if no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">/// enumerator with that value exists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">/// enumerator with that value exists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">/// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">template <typename EnumT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">template <typename EnumT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine coveredLine">auto enum_seq(EnumT Begin, EnumT End, force_iteration_on_noniterable_enum_t) {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">352</td>
    <td class="codeLine coveredLine">auto enum_seq(EnumT Begin, EnumT End, force_iteration_on_noniterable_enum_t) {</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine coveredLine">  return iota_range<EnumT>(Begin, End, false);</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">353</td>
    <td class="codeLine coveredLine">  return iota_range<EnumT>(Begin, End, false);</td>
    <td class="lineNumber">5</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">/// Iterate over an enum type from Begin to End inclusive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">/// Iterate over an enum type from Begin to End inclusive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">/// Note: `enum_seq_inclusive` will generate each consecutive value, even if no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">/// Note: `enum_seq_inclusive` will generate each consecutive value, even if no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">/// enumerator with that value exists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">/// enumerator with that value exists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">template <typename EnumT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">template <typename EnumT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">auto enum_seq_inclusive(EnumT Begin, EnumT End) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">auto enum_seq_inclusive(EnumT Begin, EnumT End) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">  static_assert(enum_iteration_traits<EnumT>::is_iterable,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">  static_assert(enum_iteration_traits<EnumT>::is_iterable,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">                "Enum type is not marked as iterable.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">                "Enum type is not marked as iterable.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">  return iota_range<EnumT>(Begin, End, true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">  return iota_range<EnumT>(Begin, End, true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">/// Iterate over an enum type from Begin to End inclusive, even when `EnumT`</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">/// Iterate over an enum type from Begin to End inclusive, even when `EnumT`</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">/// is not marked as safely iterable by `enum_iteration_traits`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">/// is not marked as safely iterable by `enum_iteration_traits`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">/// Note: `enum_seq_inclusive` will generate each consecutive value, even if no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">/// Note: `enum_seq_inclusive` will generate each consecutive value, even if no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">/// enumerator with that value exists.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">/// enumerator with that value exists.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">/// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">/// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">/// iteration).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">template <typename EnumT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">template <typename EnumT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">          typename = std::enable_if_t<std::is_enum<EnumT>::value>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine coveredLine">auto enum_seq_inclusive(EnumT Begin, EnumT End,</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">379</td>
    <td class="codeLine coveredLine">auto enum_seq_inclusive(EnumT Begin, EnumT End,</td>
    <td class="lineNumber">43</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">                        force_iteration_on_noniterable_enum_t) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">                        force_iteration_on_noniterable_enum_t) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine coveredLine">  return iota_range<EnumT>(Begin, End, true);</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">381</td>
    <td class="codeLine coveredLine">  return iota_range<EnumT>(Begin, End, true);</td>
    <td class="lineNumber">43</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">#endif // LLVM_ADT_SEQUENCE_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">#endif // LLVM_ADT_SEQUENCE_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>