<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>NVPTXLowerArgs.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerArgs.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===-- NVPTXLowerArgs.cpp - Lower arguments ------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// Arguments to kernel and device functions are passed via param space,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">// which imposes certain restrictions:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">// http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">// Kernel parameters are read-only and accessible only via ld.param</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">// instruction, directly or via a pointer. Pointers to kernel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">// arguments can't be converted to generic address space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">// Device function parameters are directly accessible via</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">// ld.param/st.param, but taking the address of one returns a pointer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">// to a copy created in local space which *can't* be used with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">// ld.param/st.param.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">// Copying a byval struct into local memory in IR allows us to enforce</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">// the param space restrictions, gives the rest of IR a pointer w/o</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">// param space restrictions, and gives us an opportunity to eliminate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">// the copy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">// Pointer arguments to kernel functions need more work to be lowered:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">// 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">//    global address space. This allows later optimizations to emit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">//    ld.global.*/st.global.* for accessing these pointer arguments. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">//    example,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">//    define void @foo(float* %input) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">//      %v = load float, float* %input, align 4</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">//      ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">//    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">//    becomes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">//    define void @foo(float* %input) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">//      %input2 = addrspacecast float* %input to float addrspace(1)*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">//      %input3 = addrspacecast float addrspace(1)* %input2 to float*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">//      %v = load float, float* %input3, align 4</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">//      ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">//    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">//    Later, NVPTXInferAddressSpaces will optimize it to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">//    define void @foo(float* %input) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">//      %input2 = addrspacecast float* %input to float addrspace(1)*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">//      %v = load float, float addrspace(1)* %input2, align 4</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">//      ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">//    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">// 2. Convert pointers in a byval kernel parameter to pointers in the global</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">//    address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">//    struct S {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">//      int *x;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">//      int *y;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">//    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">//    __global__ void foo(S s) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">//      int *b = s.y;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">//      // use b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">//    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">//    "b" points to the global address space. In the IR level,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">//    define void @foo({i32*, i32*}* byval %input) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">//      %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">//      %b = load i32*, i32** %b_ptr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">//      ; use %b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">//    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">//    becomes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">//    define void @foo({i32*, i32*}* byval %input) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">//      %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">//      %b = load i32*, i32** %b_ptr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">//      %b_global = addrspacecast i32* %b to i32 addrspace(1)*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">//      %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">//      ; use %b_generic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">//    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">// TODO: merge this pass with NVPTXInferAddressSpaces so that other passes don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">// cancel the addrspacecast pair this pass emits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">#include "MCTargetDesc/NVPTXBaseInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">#include "NVPTX.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">#include "NVPTXTargetMachine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">#include "NVPTXUtilities.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">#include "llvm/Analysis/ValueTracking.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">#include "llvm/IR/Module.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">#include "llvm/IR/Type.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">#include <numeric></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">#include <queue></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">#define DEBUG_TYPE "nvptx-lower-args"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">void initializeNVPTXLowerArgsPass(PassRegistry &);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">class NVPTXLowerArgs : public FunctionPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">  bool runOnFunction(Function &F) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">  bool runOnKernelFunction(const NVPTXTargetMachine &TM, Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">  bool runOnDeviceFunction(const NVPTXTargetMachine &TM, Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">  // handle byval parameters</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">  void handleByValParam(const NVPTXTargetMachine &TM, Argument *Arg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">  // Knowing Ptr must point to the global address space, this function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">  // addrspacecasts Ptr to global and then back to generic. This allows</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">  // NVPTXInferAddressSpaces to fold the global-to-generic cast into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">  // loads/stores that appear later.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">  void markPointerAsGlobal(Value *Ptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">  static char ID; // Pass identification, replacement for typeid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="uncoveredLine">  NVPTXLowerArgs() : FunctionPass(ID) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="uncoveredLine">  StringRef getPassName() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="uncoveredLine">    return "Lower pointer arguments of CUDA kernels";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="uncoveredLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="uncoveredLine">    AU.addRequired<TargetPassConfig>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">} // namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">char NVPTXLowerArgs::ID = 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(NVPTXLowerArgs, "nvptx-lower-args",</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">                      "Lower arguments (NVPTX)", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="coveredLine">INITIALIZE_PASS_END(NVPTXLowerArgs, "nvptx-lower-args",</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">                    "Lower arguments (NVPTX)", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">// =============================================================================</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">// If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">// and we can't guarantee that the only accesses are loads,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">// then add the following instructions to the first basic block:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">// %temp = alloca %struct.x, align 8</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">// %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">// %tv = load %struct.x addrspace(101)* %tempd</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">// store %struct.x %tv, %struct.x* %temp, align 8</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">// The above code allocates some space in the stack and copies the incoming</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">// struct from param space to local space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">// Then replace all occurrences of %d by %temp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">// In case we know that all users are GEPs or Loads, replace them with the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">// ones in parameter AS, so we can access them using ld.param.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">// =============================================================================</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">// Replaces the \p OldUser instruction with the same in parameter AS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">// Only Load and GEP are supported.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="uncoveredLine">static void convertToParamAS(Value *OldUser, Value *Param) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="uncoveredLine">  Instruction *I = dyn_cast<Instruction>(OldUser);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="uncoveredLine">  assert(I && "OldUser must be an instruction");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">  struct IP {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">    Instruction *OldInstruction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">    Value *NewParam;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="uncoveredLine">  SmallVector<IP> ItemsToConvert = {{I, Param}};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="uncoveredLine">  SmallVector<Instruction *> InstructionsToDelete;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="uncoveredLine">  auto CloneInstInParamAS = [](const IP &I) -> Value * {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="uncoveredLine">    if (auto *LI = dyn_cast<LoadInst>(I.OldInstruction)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="uncoveredLine">      LI->setOperand(0, I.NewParam);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="uncoveredLine">      return LI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="uncoveredLine">    if (auto *GEP = dyn_cast<GetElementPtrInst>(I.OldInstruction)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="uncoveredLine">      SmallVector<Value *, 4> Indices(GEP->indices());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="uncoveredLine">      auto *NewGEP = GetElementPtrInst::Create(GEP->getSourceElementType(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="uncoveredLine">                                               I.NewParam, Indices,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="uncoveredLine">                                               GEP->getName(), GEP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="uncoveredLine">      NewGEP->setIsInBounds(GEP->isInBounds());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="uncoveredLine">      return NewGEP;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="uncoveredLine">    if (auto *BC = dyn_cast<BitCastInst>(I.OldInstruction)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="uncoveredLine">      auto *NewBCType = PointerType::get(BC->getContext(), ADDRESS_SPACE_PARAM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="uncoveredLine">      return BitCastInst::Create(BC->getOpcode(), I.NewParam, NewBCType,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="uncoveredLine">                                 BC->getName(), BC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="uncoveredLine">    if (auto *ASC = dyn_cast<AddrSpaceCastInst>(I.OldInstruction)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="uncoveredLine">      assert(ASC->getDestAddressSpace() == ADDRESS_SPACE_PARAM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">      (void)ASC;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">      // Just pass through the argument, the old ASC is no longer needed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="uncoveredLine">      return I.NewParam;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">    llvm_unreachable("Unsupported instruction");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="uncoveredLine">  while (!ItemsToConvert.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="uncoveredLine">    IP I = ItemsToConvert.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="uncoveredLine">    Value *NewInst = CloneInstInParamAS(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="uncoveredLine">    if (NewInst && NewInst != I.OldInstruction) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">      // We've created a new instruction. Queue users of the old instruction to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">      // be converted and the instruction itself to be deleted. We can't delete</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">      // the old instruction yet, because it's still in use by a load somewhere.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="uncoveredLine">      for (Value *V : I.OldInstruction->users())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="uncoveredLine">        ItemsToConvert.push_back({cast<Instruction>(V), NewInst});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="uncoveredLine">      InstructionsToDelete.push_back(I.OldInstruction);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">  // Now we know that all argument loads are using addresses in parameter space</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">  // and we can finally remove the old instructions in generic AS.  Instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  // scheduled for removal should be processed in reverse order so the ones</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">  // closest to the load are deleted first. Otherwise they may still be in use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">  // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">  // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">  // the BitCast.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="uncoveredLine">  for (Instruction *I : llvm::reverse(InstructionsToDelete))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">    I->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">// Adjust alignment of arguments passed byval in .param address space. We can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">// increase alignment of such arguments in a way that ensures that we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">// effectively vectorize their loads. We should also traverse all loads from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">// byval pointer and adjust their alignment, if those were using known offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">// Such alignment changes must be conformed with parameter store and load in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">// NVPTXTargetLowering::LowerCall.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="uncoveredLine">static void adjustByValArgAlignment(Argument *Arg, Value *ArgInParamAS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">                                    const NVPTXTargetLowering *TLI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="uncoveredLine">  Function *Func = Arg->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">  Type *StructType = Arg->getParamByValType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="uncoveredLine">  const DataLayout DL(Func->getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  uint64_t NewArgAlign =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="uncoveredLine">      TLI->getFunctionParamOptimizedAlign(Func, StructType, DL).value();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">  uint64_t CurArgAlign =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">      Arg->getAttribute(Attribute::Alignment).getValueAsInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">  if (CurArgAlign >= NewArgAlign)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Try to use alignment " << NewArgAlign << " instead of "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">                    << CurArgAlign << " for " << *Arg << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">  auto NewAlignAttr =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">      Attribute::get(Func->getContext(), Attribute::Alignment, NewArgAlign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="uncoveredLine">  Arg->removeAttr(Attribute::Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">  Arg->addAttr(NewAlignAttr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">  struct Load {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">    LoadInst *Inst;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">    uint64_t Offset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">  struct LoadContext {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">    Value *InitialVal;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">    uint64_t Offset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="uncoveredLine">  SmallVector<Load> Loads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="uncoveredLine">  std::queue<LoadContext> Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="uncoveredLine">  Worklist.push({ArgInParamAS, 0});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="uncoveredLine">    LoadContext Ctx = Worklist.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="uncoveredLine">    Worklist.pop();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="uncoveredLine">    for (User *CurUser : Ctx.InitialVal->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="uncoveredLine">      if (auto *I = dyn_cast<LoadInst>(CurUser)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="uncoveredLine">        Loads.push_back({I, Ctx.Offset});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="uncoveredLine">      if (auto *I = dyn_cast<BitCastInst>(CurUser)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="uncoveredLine">        Worklist.push({I, Ctx.Offset});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="uncoveredLine">      if (auto *I = dyn_cast<GetElementPtrInst>(CurUser)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">        APInt OffsetAccumulated =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="uncoveredLine">            APInt::getZero(DL.getIndexSizeInBits(ADDRESS_SPACE_PARAM));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="uncoveredLine">        if (!I->accumulateConstantOffset(DL, OffsetAccumulated))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="uncoveredLine">        uint64_t OffsetLimit = -1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">        uint64_t Offset = OffsetAccumulated.getLimitedValue(OffsetLimit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="uncoveredLine">        assert(Offset != OffsetLimit && "Expect Offset less than UINT64_MAX");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="uncoveredLine">        Worklist.push({I, Ctx.Offset + Offset});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">      llvm_unreachable("All users must be one of: load, "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">                       "bitcast, getelementptr.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="uncoveredLine">  for (Load &CurLoad : Loads) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="uncoveredLine">    Align NewLoadAlign(std::gcd(NewArgAlign, CurLoad.Offset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="uncoveredLine">    Align CurLoadAlign(CurLoad.Inst->getAlign());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="uncoveredLine">    CurLoad.Inst->setAlignment(std::max(NewLoadAlign, CurLoadAlign));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="uncoveredLine">void NVPTXLowerArgs::handleByValParam(const NVPTXTargetMachine &TM,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">                                      Argument *Arg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="uncoveredLine">  Function *Func = Arg->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="uncoveredLine">  Instruction *FirstInst = &(Func->getEntryBlock().front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="uncoveredLine">  Type *StructType = Arg->getParamByValType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="uncoveredLine">  assert(StructType && "Missing byval type");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="uncoveredLine">  auto IsALoadChain = [&](Value *Start) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="uncoveredLine">    SmallVector<Value *, 16> ValuesToCheck = {Start};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="uncoveredLine">    auto IsALoadChainInstr = [](Value *V) -> bool {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="uncoveredLine">      if (isa<GetElementPtrInst>(V) || isa<BitCastInst>(V) || isa<LoadInst>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">      // ASC to param space are OK, too -- we'll just strip them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="uncoveredLine">      if (auto *ASC = dyn_cast<AddrSpaceCastInst>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="uncoveredLine">        if (ASC->getDestAddressSpace() == ADDRESS_SPACE_PARAM)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="uncoveredLine">    while (!ValuesToCheck.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="uncoveredLine">      Value *V = ValuesToCheck.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="uncoveredLine">      if (!IsALoadChainInstr(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "Need a copy of " << *Arg << " because of " << *V</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">                          << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">        (void)Arg;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="uncoveredLine">      if (!isa<LoadInst>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="uncoveredLine">        llvm::append_range(ValuesToCheck, V->users());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">  if (llvm::all_of(Arg->users(), IsALoadChain)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">    // Convert all loads and intermediate operations to use parameter AS and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">    // skip creation of a local copy of the argument.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="uncoveredLine">    SmallVector<User *, 16> UsersToUpdate(Arg->users());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">    Value *ArgInParamAS = new AddrSpaceCastInst(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="uncoveredLine">        Arg, PointerType::get(StructType, ADDRESS_SPACE_PARAM), Arg->getName(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="uncoveredLine">        FirstInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">    for (Value *V : UsersToUpdate)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">      convertToParamAS(V, ArgInParamAS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "No need to copy " << *Arg << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">    const auto *TLI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="uncoveredLine">        cast<NVPTXTargetLowering>(TM.getSubtargetImpl()->getTargetLowering());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="uncoveredLine">    adjustByValArgAlignment(Arg, ArgInParamAS, TLI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">  // Otherwise we have to create a temporary copy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="uncoveredLine">  const DataLayout &DL = Func->getParent()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="uncoveredLine">  unsigned AS = DL.getAllocaAddrSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="uncoveredLine">  AllocaInst *AllocA = new AllocaInst(StructType, AS, Arg->getName(), FirstInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">  // Set the alignment to alignment of the byval parameter. This is because,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">  // later load/stores assume that alignment, and we are going to replace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">  // the use of the byval parameter with this alloca instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="uncoveredLine">  AllocA->setAlignment(Func->getParamAlign(Arg->getArgNo())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">                           .value_or(DL.getPrefTypeAlign(StructType)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="uncoveredLine">  Arg->replaceAllUsesWith(AllocA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">  Value *ArgInParam = new AddrSpaceCastInst(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">      Arg, PointerType::get(StructType, ADDRESS_SPACE_PARAM), Arg->getName(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">      FirstInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">  // Be sure to propagate alignment to this load; LLVM doesn't know that NVPTX</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">  // addrspacecast preserves alignment.  Since params are constant, this load is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="">  // definitely not volatile.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">  LoadInst *LI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">      new LoadInst(StructType, ArgInParam, Arg->getName(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">                   /*isVolatile=*/false, AllocA->getAlign(), FirstInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">  new StoreInst(LI, AllocA, FirstInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">void NVPTXLowerArgs::markPointerAsGlobal(Value *Ptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="uncoveredLine">  if (Ptr->getType()->getPointerAddressSpace() != ADDRESS_SPACE_GENERIC)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">  // Deciding where to emit the addrspacecast pair.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">  BasicBlock::iterator InsertPt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="uncoveredLine">  if (Argument *Arg = dyn_cast<Argument>(Ptr)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">    // Insert at the functon entry if Ptr is an argument.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="uncoveredLine">    InsertPt = Arg->getParent()->getEntryBlock().begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">    // Insert right after Ptr if Ptr is an instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="uncoveredLine">    InsertPt = ++cast<Instruction>(Ptr)->getIterator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="uncoveredLine">    assert(InsertPt != InsertPt->getParent()->end() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">           "We don't call this function with Ptr being a terminator.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="">  Instruction *PtrInGlobal = new AddrSpaceCastInst(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="uncoveredLine">      Ptr, PointerType::get(Ptr->getContext(), ADDRESS_SPACE_GLOBAL),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="uncoveredLine">      Ptr->getName(), &*InsertPt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="uncoveredLine">  Value *PtrInGeneric = new AddrSpaceCastInst(PtrInGlobal, Ptr->getType(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="uncoveredLine">                                              Ptr->getName(), &*InsertPt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">  // Replace with PtrInGeneric all uses of Ptr except PtrInGlobal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">  Ptr->replaceAllUsesWith(PtrInGeneric);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="uncoveredLine">  PtrInGlobal->setOperand(0, Ptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">// =============================================================================</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">// Main function for this pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">// =============================================================================</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="uncoveredLine">bool NVPTXLowerArgs::runOnKernelFunction(const NVPTXTargetMachine &TM,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">                                         Function &F) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">  // Copying of byval aggregates + SROA may result in pointers being loaded as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">  // integers, followed by intotoptr. We may want to mark those as global, too,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">  // but only if the loaded integer is used exclusively for conversion to a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  // pointer with inttoptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">  auto HandleIntToPtr = [this](Value &V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">    if (llvm::all_of(V.users(), [](User *U) { return isa<IntToPtrInst>(U); })) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="uncoveredLine">      SmallVector<User *, 16> UsersToUpdate(V.users());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="uncoveredLine">      llvm::for_each(UsersToUpdate, [&](User *U) { markPointerAsGlobal(U); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="uncoveredLine">  if (TM.getDrvInterface() == NVPTX::CUDA) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">    // Mark pointers in byval structs as global.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">    for (auto &B : F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="uncoveredLine">      for (auto &I : B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="uncoveredLine">        if (LoadInst *LI = dyn_cast<LoadInst>(&I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="uncoveredLine">          if (LI->getType()->isPointerTy() || LI->getType()->isIntegerTy()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">            Value *UO = getUnderlyingObject(LI->getPointerOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">            if (Argument *Arg = dyn_cast<Argument>(UO)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">              if (Arg->hasByValAttr()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">                // LI is a load from a pointer within a byval kernel parameter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">                if (LI->getType()->isPointerTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="uncoveredLine">                  markPointerAsGlobal(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">                else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="uncoveredLine">                  HandleIntToPtr(*LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">              }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">            }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Lowering kernel args of " << F.getName() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="uncoveredLine">  for (Argument &Arg : F.args()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="uncoveredLine">    if (Arg.getType()->isPointerTy()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="uncoveredLine">      if (Arg.hasByValAttr())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="uncoveredLine">        handleByValParam(TM, &Arg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">      else if (TM.getDrvInterface() == NVPTX::CUDA)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">        markPointerAsGlobal(&Arg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">    } else if (Arg.getType()->isIntegerTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">               TM.getDrvInterface() == NVPTX::CUDA) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">      HandleIntToPtr(Arg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">// Device functions only need to copy byval args into local memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="uncoveredLine">bool NVPTXLowerArgs::runOnDeviceFunction(const NVPTXTargetMachine &TM,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">                                         Function &F) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Lowering function args of " << F.getName() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">  for (Argument &Arg : F.args())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="uncoveredLine">    if (Arg.getType()->isPointerTy() && Arg.hasByValAttr())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="uncoveredLine">      handleByValParam(TM, &Arg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="uncoveredLine">bool NVPTXLowerArgs::runOnFunction(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="uncoveredLine">  auto &TM = getAnalysis<TargetPassConfig>().getTM<NVPTXTargetMachine>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="uncoveredLine">  return isKernelFunction(F) ? runOnKernelFunction(TM, F)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="uncoveredLine">                             : runOnDeviceFunction(TM, F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="uncoveredLine">FunctionPass *llvm::createNVPTXLowerArgsPass() { return new NVPTXLowerArgs(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114NVPTXLowerArgsC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_114NVPTXLowerArgs11getPassNameEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_114NVPTXLowerArgs16getAnalysisUsageERN4llvm13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL32initializeNVPTXLowerArgsPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm28initializeNVPTXLowerArgsPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL16convertToParamASPN4llvm5ValueES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL16convertToParamASPN4llvm5ValueES1_ENKUlRKZL16convertToParamASS1_S1_E2IPE_clES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL23adjustByValArgAlignmentPN4llvm8ArgumentEPNS_5ValueEPKNS_19NVPTXTargetLoweringE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114NVPTXLowerArgs16handleByValParamERKN4llvm18NVPTXTargetMachineEPNS1_8ArgumentE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_114NVPTXLowerArgs16handleByValParamERKN4llvm18NVPTXTargetMachineEPNS1_8ArgumentEENKUlPNS1_5ValueEE_clES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZN12_GLOBAL__N_114NVPTXLowerArgs16handleByValParamERKN4llvm18NVPTXTargetMachineEPNS1_8ArgumentEENKUlPNS1_5ValueEE_clES8_ENKUlS8_E_clES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114NVPTXLowerArgs19markPointerAsGlobalEPN4llvm5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114NVPTXLowerArgs19runOnKernelFunctionERKN4llvm18NVPTXTargetMachineERNS1_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_114NVPTXLowerArgs19runOnKernelFunctionERKN4llvm18NVPTXTargetMachineERNS1_8FunctionEENKUlRNS1_5ValueEE_clES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZN12_GLOBAL__N_114NVPTXLowerArgs19runOnKernelFunctionERKN4llvm18NVPTXTargetMachineERNS1_8FunctionEENKUlRNS1_5ValueEE_clES8_ENKUlPNS1_4UserEE_clESB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZZN12_GLOBAL__N_114NVPTXLowerArgs19runOnKernelFunctionERKN4llvm18NVPTXTargetMachineERNS1_8FunctionEENKUlRNS1_5ValueEE_clES8_ENKUlPNS1_4UserEE0_clESB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114NVPTXLowerArgs19runOnDeviceFunctionERKN4llvm18NVPTXTargetMachineERNS1_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_114NVPTXLowerArgs13runOnFunctionERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm24createNVPTXLowerArgsPassEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- NVPTXLowerArgs.cpp - Lower arguments ------------------------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- NVPTXLowerArgs.cpp - Lower arguments ------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">//</td>
    <td class="lineNumber">9</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// Arguments to kernel and device functions are passed via param space,</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// Arguments to kernel and device functions are passed via param space,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">// which imposes certain restrictions:</td>
    <td class="lineNumber">11</td>
    <td class="codeline">// which imposes certain restrictions:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">// http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces</td>
    <td class="lineNumber">12</td>
    <td class="codeline">// http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">// Kernel parameters are read-only and accessible only via ld.param</td>
    <td class="lineNumber">14</td>
    <td class="codeline">// Kernel parameters are read-only and accessible only via ld.param</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">// instruction, directly or via a pointer. Pointers to kernel</td>
    <td class="lineNumber">15</td>
    <td class="codeline">// instruction, directly or via a pointer. Pointers to kernel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">// arguments can't be converted to generic address space.</td>
    <td class="lineNumber">16</td>
    <td class="codeline">// arguments can't be converted to generic address space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">//</td>
    <td class="lineNumber">17</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">// Device function parameters are directly accessible via</td>
    <td class="lineNumber">18</td>
    <td class="codeline">// Device function parameters are directly accessible via</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">// ld.param/st.param, but taking the address of one returns a pointer</td>
    <td class="lineNumber">19</td>
    <td class="codeline">// ld.param/st.param, but taking the address of one returns a pointer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">// to a copy created in local space which *can't* be used with</td>
    <td class="lineNumber">20</td>
    <td class="codeline">// to a copy created in local space which *can't* be used with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">// ld.param/st.param.</td>
    <td class="lineNumber">21</td>
    <td class="codeline">// ld.param/st.param.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">//</td>
    <td class="lineNumber">22</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">// Copying a byval struct into local memory in IR allows us to enforce</td>
    <td class="lineNumber">23</td>
    <td class="codeline">// Copying a byval struct into local memory in IR allows us to enforce</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">// the param space restrictions, gives the rest of IR a pointer w/o</td>
    <td class="lineNumber">24</td>
    <td class="codeline">// the param space restrictions, gives the rest of IR a pointer w/o</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">// param space restrictions, and gives us an opportunity to eliminate</td>
    <td class="lineNumber">25</td>
    <td class="codeline">// param space restrictions, and gives us an opportunity to eliminate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">// the copy.</td>
    <td class="lineNumber">26</td>
    <td class="codeline">// the copy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">//</td>
    <td class="lineNumber">27</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">// Pointer arguments to kernel functions need more work to be lowered:</td>
    <td class="lineNumber">28</td>
    <td class="codeline">// Pointer arguments to kernel functions need more work to be lowered:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">//</td>
    <td class="lineNumber">29</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">// 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the</td>
    <td class="lineNumber">30</td>
    <td class="codeline">// 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">//    global address space. This allows later optimizations to emit</td>
    <td class="lineNumber">31</td>
    <td class="codeline">//    global address space. This allows later optimizations to emit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">//    ld.global.*/st.global.* for accessing these pointer arguments. For</td>
    <td class="lineNumber">32</td>
    <td class="codeline">//    ld.global.*/st.global.* for accessing these pointer arguments. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">//    example,</td>
    <td class="lineNumber">33</td>
    <td class="codeline">//    example,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">//</td>
    <td class="lineNumber">34</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">//    define void @foo(float* %input) {</td>
    <td class="lineNumber">35</td>
    <td class="codeline">//    define void @foo(float* %input) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">//      %v = load float, float* %input, align 4</td>
    <td class="lineNumber">36</td>
    <td class="codeline">//      %v = load float, float* %input, align 4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">//      ...</td>
    <td class="lineNumber">37</td>
    <td class="codeline">//      ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">//    }</td>
    <td class="lineNumber">38</td>
    <td class="codeline">//    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">//</td>
    <td class="lineNumber">39</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">//    becomes</td>
    <td class="lineNumber">40</td>
    <td class="codeline">//    becomes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">//</td>
    <td class="lineNumber">41</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">//    define void @foo(float* %input) {</td>
    <td class="lineNumber">42</td>
    <td class="codeline">//    define void @foo(float* %input) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">//      %input2 = addrspacecast float* %input to float addrspace(1)*</td>
    <td class="lineNumber">43</td>
    <td class="codeline">//      %input2 = addrspacecast float* %input to float addrspace(1)*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">//      %input3 = addrspacecast float addrspace(1)* %input2 to float*</td>
    <td class="lineNumber">44</td>
    <td class="codeline">//      %input3 = addrspacecast float addrspace(1)* %input2 to float*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">//      %v = load float, float* %input3, align 4</td>
    <td class="lineNumber">45</td>
    <td class="codeline">//      %v = load float, float* %input3, align 4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">//      ...</td>
    <td class="lineNumber">46</td>
    <td class="codeline">//      ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">//    }</td>
    <td class="lineNumber">47</td>
    <td class="codeline">//    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">//</td>
    <td class="lineNumber">48</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">//    Later, NVPTXInferAddressSpaces will optimize it to</td>
    <td class="lineNumber">49</td>
    <td class="codeline">//    Later, NVPTXInferAddressSpaces will optimize it to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">//</td>
    <td class="lineNumber">50</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">//    define void @foo(float* %input) {</td>
    <td class="lineNumber">51</td>
    <td class="codeline">//    define void @foo(float* %input) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">//      %input2 = addrspacecast float* %input to float addrspace(1)*</td>
    <td class="lineNumber">52</td>
    <td class="codeline">//      %input2 = addrspacecast float* %input to float addrspace(1)*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">//      %v = load float, float addrspace(1)* %input2, align 4</td>
    <td class="lineNumber">53</td>
    <td class="codeline">//      %v = load float, float addrspace(1)* %input2, align 4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">//      ...</td>
    <td class="lineNumber">54</td>
    <td class="codeline">//      ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">//    }</td>
    <td class="lineNumber">55</td>
    <td class="codeline">//    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">//</td>
    <td class="lineNumber">56</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">// 2. Convert pointers in a byval kernel parameter to pointers in the global</td>
    <td class="lineNumber">57</td>
    <td class="codeline">// 2. Convert pointers in a byval kernel parameter to pointers in the global</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">//    address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,</td>
    <td class="lineNumber">58</td>
    <td class="codeline">//    address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">//</td>
    <td class="lineNumber">59</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">//    struct S {</td>
    <td class="lineNumber">60</td>
    <td class="codeline">//    struct S {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">//      int *x;</td>
    <td class="lineNumber">61</td>
    <td class="codeline">//      int *x;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">//      int *y;</td>
    <td class="lineNumber">62</td>
    <td class="codeline">//      int *y;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">//    };</td>
    <td class="lineNumber">63</td>
    <td class="codeline">//    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">//    __global__ void foo(S s) {</td>
    <td class="lineNumber">64</td>
    <td class="codeline">//    __global__ void foo(S s) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">//      int *b = s.y;</td>
    <td class="lineNumber">65</td>
    <td class="codeline">//      int *b = s.y;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">//      // use b</td>
    <td class="lineNumber">66</td>
    <td class="codeline">//      // use b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">//    }</td>
    <td class="lineNumber">67</td>
    <td class="codeline">//    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">//</td>
    <td class="lineNumber">68</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">//    "b" points to the global address space. In the IR level,</td>
    <td class="lineNumber">69</td>
    <td class="codeline">//    "b" points to the global address space. In the IR level,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">//</td>
    <td class="lineNumber">70</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">//    define void @foo({i32*, i32*}* byval %input) {</td>
    <td class="lineNumber">71</td>
    <td class="codeline">//    define void @foo({i32*, i32*}* byval %input) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">//      %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1</td>
    <td class="lineNumber">72</td>
    <td class="codeline">//      %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">//      %b = load i32*, i32** %b_ptr</td>
    <td class="lineNumber">73</td>
    <td class="codeline">//      %b = load i32*, i32** %b_ptr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">//      ; use %b</td>
    <td class="lineNumber">74</td>
    <td class="codeline">//      ; use %b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">//    }</td>
    <td class="lineNumber">75</td>
    <td class="codeline">//    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">//</td>
    <td class="lineNumber">76</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">//    becomes</td>
    <td class="lineNumber">77</td>
    <td class="codeline">//    becomes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">//</td>
    <td class="lineNumber">78</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">//    define void @foo({i32*, i32*}* byval %input) {</td>
    <td class="lineNumber">79</td>
    <td class="codeline">//    define void @foo({i32*, i32*}* byval %input) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">//      %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1</td>
    <td class="lineNumber">80</td>
    <td class="codeline">//      %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">//      %b = load i32*, i32** %b_ptr</td>
    <td class="lineNumber">81</td>
    <td class="codeline">//      %b = load i32*, i32** %b_ptr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">//      %b_global = addrspacecast i32* %b to i32 addrspace(1)*</td>
    <td class="lineNumber">82</td>
    <td class="codeline">//      %b_global = addrspacecast i32* %b to i32 addrspace(1)*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">//      %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*</td>
    <td class="lineNumber">83</td>
    <td class="codeline">//      %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">//      ; use %b_generic</td>
    <td class="lineNumber">84</td>
    <td class="codeline">//      ; use %b_generic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">//    }</td>
    <td class="lineNumber">85</td>
    <td class="codeline">//    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">//</td>
    <td class="lineNumber">86</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">// TODO: merge this pass with NVPTXInferAddressSpaces so that other passes don't</td>
    <td class="lineNumber">87</td>
    <td class="codeline">// TODO: merge this pass with NVPTXInferAddressSpaces so that other passes don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">// cancel the addrspacecast pair this pass emits.</td>
    <td class="lineNumber">88</td>
    <td class="codeline">// cancel the addrspacecast pair this pass emits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">89</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline"></td>
    <td class="lineNumber">90</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">#include "MCTargetDesc/NVPTXBaseInfo.h"</td>
    <td class="lineNumber">91</td>
    <td class="codeline">#include "MCTargetDesc/NVPTXBaseInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">#include "NVPTX.h"</td>
    <td class="lineNumber">92</td>
    <td class="codeline">#include "NVPTX.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">#include "NVPTXTargetMachine.h"</td>
    <td class="lineNumber">93</td>
    <td class="codeline">#include "NVPTXTargetMachine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">#include "NVPTXUtilities.h"</td>
    <td class="lineNumber">94</td>
    <td class="codeline">#include "NVPTXUtilities.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">95</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">96</td>
    <td class="codeline">#include "llvm/CodeGen/TargetPassConfig.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">97</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">98</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">99</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">100</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">101</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">102</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">#include <numeric></td>
    <td class="lineNumber">103</td>
    <td class="codeline">#include <numeric></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">#include <queue></td>
    <td class="lineNumber">104</td>
    <td class="codeline">#include <queue></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline"></td>
    <td class="lineNumber">105</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">#define DEBUG_TYPE "nvptx-lower-args"</td>
    <td class="lineNumber">106</td>
    <td class="codeline">#define DEBUG_TYPE "nvptx-lower-args"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline"></td>
    <td class="lineNumber">107</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">108</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline"></td>
    <td class="lineNumber">109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">110</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">void initializeNVPTXLowerArgsPass(PassRegistry &);</td>
    <td class="lineNumber">111</td>
    <td class="codeline">void initializeNVPTXLowerArgsPass(PassRegistry &);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">}</td>
    <td class="lineNumber">112</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline"></td>
    <td class="lineNumber">113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">114</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">class NVPTXLowerArgs : public FunctionPass {</td>
    <td class="lineNumber">115</td>
    <td class="codeline">class NVPTXLowerArgs : public FunctionPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">116</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline"></td>
    <td class="lineNumber">117</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  bool runOnKernelFunction(const NVPTXTargetMachine &TM, Function &F);</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  bool runOnKernelFunction(const NVPTXTargetMachine &TM, Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">  bool runOnDeviceFunction(const NVPTXTargetMachine &TM, Function &F);</td>
    <td class="lineNumber">119</td>
    <td class="codeline">  bool runOnDeviceFunction(const NVPTXTargetMachine &TM, Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline"></td>
    <td class="lineNumber">120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  // handle byval parameters</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  // handle byval parameters</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">  void handleByValParam(const NVPTXTargetMachine &TM, Argument *Arg);</td>
    <td class="lineNumber">122</td>
    <td class="codeline">  void handleByValParam(const NVPTXTargetMachine &TM, Argument *Arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  // Knowing Ptr must point to the global address space, this function</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  // Knowing Ptr must point to the global address space, this function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">  // addrspacecasts Ptr to global and then back to generic. This allows</td>
    <td class="lineNumber">124</td>
    <td class="codeline">  // addrspacecasts Ptr to global and then back to generic. This allows</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">  // NVPTXInferAddressSpaces to fold the global-to-generic cast into</td>
    <td class="lineNumber">125</td>
    <td class="codeline">  // NVPTXInferAddressSpaces to fold the global-to-generic cast into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  // loads/stores that appear later.</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  // loads/stores that appear later.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  void markPointerAsGlobal(Value *Ptr);</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  void markPointerAsGlobal(Value *Ptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline"></td>
    <td class="lineNumber">128</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">129</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  static char ID; // Pass identification, replacement for typeid</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  static char ID; // Pass identification, replacement for typeid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">  NVPTXLowerArgs() : FunctionPass(ID) {}</td>
    <td class="lineNumber">131</td>
    <td class="codeline">  NVPTXLowerArgs() : FunctionPass(ID) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">  StringRef getPassName() const override {</td>
    <td class="lineNumber">132</td>
    <td class="codeline">  StringRef getPassName() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">    return "Lower pointer arguments of CUDA kernels";</td>
    <td class="lineNumber">133</td>
    <td class="codeline">    return "Lower pointer arguments of CUDA kernels";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">134</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">135</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">    AU.addRequired<TargetPassConfig>();</td>
    <td class="lineNumber">136</td>
    <td class="codeline">    AU.addRequired<TargetPassConfig>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">137</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">};</td>
    <td class="lineNumber">138</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">} // namespace</td>
    <td class="lineNumber">139</td>
    <td class="codeline">} // namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline"></td>
    <td class="lineNumber">140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">char NVPTXLowerArgs::ID = 1;</td>
    <td class="lineNumber">141</td>
    <td class="codeline">char NVPTXLowerArgs::ID = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline"></td>
    <td class="lineNumber">142</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(NVPTXLowerArgs, "nvptx-lower-args",</td>
    <td class="lineNumber">143</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(NVPTXLowerArgs, "nvptx-lower-args",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">                      "Lower arguments (NVPTX)", false, false)</td>
    <td class="lineNumber">144</td>
    <td class="codeline">                      "Lower arguments (NVPTX)", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td class="lineNumber">145</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">INITIALIZE_PASS_END(NVPTXLowerArgs, "nvptx-lower-args",</td>
    <td class="lineNumber">146</td>
    <td class="codeline">INITIALIZE_PASS_END(NVPTXLowerArgs, "nvptx-lower-args",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">                    "Lower arguments (NVPTX)", false, false)</td>
    <td class="lineNumber">147</td>
    <td class="codeline">                    "Lower arguments (NVPTX)", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline"></td>
    <td class="lineNumber">148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">// =============================================================================</td>
    <td class="lineNumber">149</td>
    <td class="codeline">// =============================================================================</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">// If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),</td>
    <td class="lineNumber">150</td>
    <td class="codeline">// If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">// and we can't guarantee that the only accesses are loads,</td>
    <td class="lineNumber">151</td>
    <td class="codeline">// and we can't guarantee that the only accesses are loads,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">// then add the following instructions to the first basic block:</td>
    <td class="lineNumber">152</td>
    <td class="codeline">// then add the following instructions to the first basic block:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">//</td>
    <td class="lineNumber">153</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">// %temp = alloca %struct.x, align 8</td>
    <td class="lineNumber">154</td>
    <td class="codeline">// %temp = alloca %struct.x, align 8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">// %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*</td>
    <td class="lineNumber">155</td>
    <td class="codeline">// %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">// %tv = load %struct.x addrspace(101)* %tempd</td>
    <td class="lineNumber">156</td>
    <td class="codeline">// %tv = load %struct.x addrspace(101)* %tempd</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">// store %struct.x %tv, %struct.x* %temp, align 8</td>
    <td class="lineNumber">157</td>
    <td class="codeline">// store %struct.x %tv, %struct.x* %temp, align 8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">//</td>
    <td class="lineNumber">158</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">// The above code allocates some space in the stack and copies the incoming</td>
    <td class="lineNumber">159</td>
    <td class="codeline">// The above code allocates some space in the stack and copies the incoming</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">// struct from param space to local space.</td>
    <td class="lineNumber">160</td>
    <td class="codeline">// struct from param space to local space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">// Then replace all occurrences of %d by %temp.</td>
    <td class="lineNumber">161</td>
    <td class="codeline">// Then replace all occurrences of %d by %temp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">//</td>
    <td class="lineNumber">162</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">// In case we know that all users are GEPs or Loads, replace them with the same</td>
    <td class="lineNumber">163</td>
    <td class="codeline">// In case we know that all users are GEPs or Loads, replace them with the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">// ones in parameter AS, so we can access them using ld.param.</td>
    <td class="lineNumber">164</td>
    <td class="codeline">// ones in parameter AS, so we can access them using ld.param.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">// =============================================================================</td>
    <td class="lineNumber">165</td>
    <td class="codeline">// =============================================================================</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline"></td>
    <td class="lineNumber">166</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">// Replaces the \p OldUser instruction with the same in parameter AS.</td>
    <td class="lineNumber">167</td>
    <td class="codeline">// Replaces the \p OldUser instruction with the same in parameter AS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">// Only Load and GEP are supported.</td>
    <td class="lineNumber">168</td>
    <td class="codeline">// Only Load and GEP are supported.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">static void convertToParamAS(Value *OldUser, Value *Param) {</td>
    <td class="lineNumber">169</td>
    <td class="codeline">static void convertToParamAS(Value *OldUser, Value *Param) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  Instruction *I = dyn_cast<Instruction>(OldUser);</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  Instruction *I = dyn_cast<Instruction>(OldUser);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  assert(I && "OldUser must be an instruction");</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  assert(I && "OldUser must be an instruction");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  struct IP {</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  struct IP {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">    Instruction *OldInstruction;</td>
    <td class="lineNumber">173</td>
    <td class="codeline">    Instruction *OldInstruction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">    Value *NewParam;</td>
    <td class="lineNumber">174</td>
    <td class="codeline">    Value *NewParam;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">  SmallVector<IP> ItemsToConvert = {{I, Param}};</td>
    <td class="lineNumber">176</td>
    <td class="codeline">  SmallVector<IP> ItemsToConvert = {{I, Param}};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">  SmallVector<Instruction *> InstructionsToDelete;</td>
    <td class="lineNumber">177</td>
    <td class="codeline">  SmallVector<Instruction *> InstructionsToDelete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline"></td>
    <td class="lineNumber">178</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  auto CloneInstInParamAS = [](const IP &I) -> Value * {</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  auto CloneInstInParamAS = [](const IP &I) -> Value * {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">    if (auto *LI = dyn_cast<LoadInst>(I.OldInstruction)) {</td>
    <td class="lineNumber">180</td>
    <td class="codeline">    if (auto *LI = dyn_cast<LoadInst>(I.OldInstruction)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">      LI->setOperand(0, I.NewParam);</td>
    <td class="lineNumber">181</td>
    <td class="codeline">      LI->setOperand(0, I.NewParam);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">      return LI;</td>
    <td class="lineNumber">182</td>
    <td class="codeline">      return LI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">183</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">    if (auto *GEP = dyn_cast<GetElementPtrInst>(I.OldInstruction)) {</td>
    <td class="lineNumber">184</td>
    <td class="codeline">    if (auto *GEP = dyn_cast<GetElementPtrInst>(I.OldInstruction)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">      SmallVector<Value *, 4> Indices(GEP->indices());</td>
    <td class="lineNumber">185</td>
    <td class="codeline">      SmallVector<Value *, 4> Indices(GEP->indices());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">      auto *NewGEP = GetElementPtrInst::Create(GEP->getSourceElementType(),</td>
    <td class="lineNumber">186</td>
    <td class="codeline">      auto *NewGEP = GetElementPtrInst::Create(GEP->getSourceElementType(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">                                               I.NewParam, Indices,</td>
    <td class="lineNumber">187</td>
    <td class="codeline">                                               I.NewParam, Indices,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">                                               GEP->getName(), GEP);</td>
    <td class="lineNumber">188</td>
    <td class="codeline">                                               GEP->getName(), GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">      NewGEP->setIsInBounds(GEP->isInBounds());</td>
    <td class="lineNumber">189</td>
    <td class="codeline">      NewGEP->setIsInBounds(GEP->isInBounds());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">      return NewGEP;</td>
    <td class="lineNumber">190</td>
    <td class="codeline">      return NewGEP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">191</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">    if (auto *BC = dyn_cast<BitCastInst>(I.OldInstruction)) {</td>
    <td class="lineNumber">192</td>
    <td class="codeline">    if (auto *BC = dyn_cast<BitCastInst>(I.OldInstruction)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">      auto *NewBCType = PointerType::get(BC->getContext(), ADDRESS_SPACE_PARAM);</td>
    <td class="lineNumber">193</td>
    <td class="codeline">      auto *NewBCType = PointerType::get(BC->getContext(), ADDRESS_SPACE_PARAM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">      return BitCastInst::Create(BC->getOpcode(), I.NewParam, NewBCType,</td>
    <td class="lineNumber">194</td>
    <td class="codeline">      return BitCastInst::Create(BC->getOpcode(), I.NewParam, NewBCType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">                                 BC->getName(), BC);</td>
    <td class="lineNumber">195</td>
    <td class="codeline">                                 BC->getName(), BC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">196</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">    if (auto *ASC = dyn_cast<AddrSpaceCastInst>(I.OldInstruction)) {</td>
    <td class="lineNumber">197</td>
    <td class="codeline">    if (auto *ASC = dyn_cast<AddrSpaceCastInst>(I.OldInstruction)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">      assert(ASC->getDestAddressSpace() == ADDRESS_SPACE_PARAM);</td>
    <td class="lineNumber">198</td>
    <td class="codeline">      assert(ASC->getDestAddressSpace() == ADDRESS_SPACE_PARAM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">      (void)ASC;</td>
    <td class="lineNumber">199</td>
    <td class="codeline">      (void)ASC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">      // Just pass through the argument, the old ASC is no longer needed.</td>
    <td class="lineNumber">200</td>
    <td class="codeline">      // Just pass through the argument, the old ASC is no longer needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">      return I.NewParam;</td>
    <td class="lineNumber">201</td>
    <td class="codeline">      return I.NewParam;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">202</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">    llvm_unreachable("Unsupported instruction");</td>
    <td class="lineNumber">203</td>
    <td class="codeline">    llvm_unreachable("Unsupported instruction");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">204</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline"></td>
    <td class="lineNumber">205</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  while (!ItemsToConvert.empty()) {</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  while (!ItemsToConvert.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">    IP I = ItemsToConvert.pop_back_val();</td>
    <td class="lineNumber">207</td>
    <td class="codeline">    IP I = ItemsToConvert.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">    Value *NewInst = CloneInstInParamAS(I);</td>
    <td class="lineNumber">208</td>
    <td class="codeline">    Value *NewInst = CloneInstInParamAS(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline"></td>
    <td class="lineNumber">209</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">    if (NewInst && NewInst != I.OldInstruction) {</td>
    <td class="lineNumber">210</td>
    <td class="codeline">    if (NewInst && NewInst != I.OldInstruction) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">      // We've created a new instruction. Queue users of the old instruction to</td>
    <td class="lineNumber">211</td>
    <td class="codeline">      // We've created a new instruction. Queue users of the old instruction to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">      // be converted and the instruction itself to be deleted. We can't delete</td>
    <td class="lineNumber">212</td>
    <td class="codeline">      // be converted and the instruction itself to be deleted. We can't delete</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">      // the old instruction yet, because it's still in use by a load somewhere.</td>
    <td class="lineNumber">213</td>
    <td class="codeline">      // the old instruction yet, because it's still in use by a load somewhere.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">      for (Value *V : I.OldInstruction->users())</td>
    <td class="lineNumber">214</td>
    <td class="codeline">      for (Value *V : I.OldInstruction->users())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">        ItemsToConvert.push_back({cast<Instruction>(V), NewInst});</td>
    <td class="lineNumber">215</td>
    <td class="codeline">        ItemsToConvert.push_back({cast<Instruction>(V), NewInst});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline"></td>
    <td class="lineNumber">216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">      InstructionsToDelete.push_back(I.OldInstruction);</td>
    <td class="lineNumber">217</td>
    <td class="codeline">      InstructionsToDelete.push_back(I.OldInstruction);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">218</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  // Now we know that all argument loads are using addresses in parameter space</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  // Now we know that all argument loads are using addresses in parameter space</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">  // and we can finally remove the old instructions in generic AS.  Instructions</td>
    <td class="lineNumber">222</td>
    <td class="codeline">  // and we can finally remove the old instructions in generic AS.  Instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  // scheduled for removal should be processed in reverse order so the ones</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  // scheduled for removal should be processed in reverse order so the ones</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">  // closest to the load are deleted first. Otherwise they may still be in use.</td>
    <td class="lineNumber">224</td>
    <td class="codeline">  // closest to the load are deleted first. Otherwise they may still be in use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">  // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will</td>
    <td class="lineNumber">225</td>
    <td class="codeline">  // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">  // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by</td>
    <td class="lineNumber">226</td>
    <td class="codeline">  // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">  // the BitCast.</td>
    <td class="lineNumber">227</td>
    <td class="codeline">  // the BitCast.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">  for (Instruction *I : llvm::reverse(InstructionsToDelete))</td>
    <td class="lineNumber">228</td>
    <td class="codeline">  for (Instruction *I : llvm::reverse(InstructionsToDelete))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">    I->eraseFromParent();</td>
    <td class="lineNumber">229</td>
    <td class="codeline">    I->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">}</td>
    <td class="lineNumber">230</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline"></td>
    <td class="lineNumber">231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">// Adjust alignment of arguments passed byval in .param address space. We can</td>
    <td class="lineNumber">232</td>
    <td class="codeline">// Adjust alignment of arguments passed byval in .param address space. We can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">// increase alignment of such arguments in a way that ensures that we can</td>
    <td class="lineNumber">233</td>
    <td class="codeline">// increase alignment of such arguments in a way that ensures that we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">// effectively vectorize their loads. We should also traverse all loads from</td>
    <td class="lineNumber">234</td>
    <td class="codeline">// effectively vectorize their loads. We should also traverse all loads from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">// byval pointer and adjust their alignment, if those were using known offset.</td>
    <td class="lineNumber">235</td>
    <td class="codeline">// byval pointer and adjust their alignment, if those were using known offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">// Such alignment changes must be conformed with parameter store and load in</td>
    <td class="lineNumber">236</td>
    <td class="codeline">// Such alignment changes must be conformed with parameter store and load in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">// NVPTXTargetLowering::LowerCall.</td>
    <td class="lineNumber">237</td>
    <td class="codeline">// NVPTXTargetLowering::LowerCall.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">static void adjustByValArgAlignment(Argument *Arg, Value *ArgInParamAS,</td>
    <td class="lineNumber">238</td>
    <td class="codeline">static void adjustByValArgAlignment(Argument *Arg, Value *ArgInParamAS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">                                    const NVPTXTargetLowering *TLI) {</td>
    <td class="lineNumber">239</td>
    <td class="codeline">                                    const NVPTXTargetLowering *TLI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  Function *Func = Arg->getParent();</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  Function *Func = Arg->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  Type *StructType = Arg->getParamByValType();</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  Type *StructType = Arg->getParamByValType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  const DataLayout DL(Func->getParent());</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  const DataLayout DL(Func->getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline"></td>
    <td class="lineNumber">243</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  uint64_t NewArgAlign =</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  uint64_t NewArgAlign =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">      TLI->getFunctionParamOptimizedAlign(Func, StructType, DL).value();</td>
    <td class="lineNumber">245</td>
    <td class="codeline">      TLI->getFunctionParamOptimizedAlign(Func, StructType, DL).value();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  uint64_t CurArgAlign =</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  uint64_t CurArgAlign =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">      Arg->getAttribute(Attribute::Alignment).getValueAsInt();</td>
    <td class="lineNumber">247</td>
    <td class="codeline">      Arg->getAttribute(Attribute::Alignment).getValueAsInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline"></td>
    <td class="lineNumber">248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  if (CurArgAlign >= NewArgAlign)</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  if (CurArgAlign >= NewArgAlign)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">250</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline"></td>
    <td class="lineNumber">251</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Try to use alignment " << NewArgAlign << " instead of "</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Try to use alignment " << NewArgAlign << " instead of "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">                    << CurArgAlign << " for " << *Arg << '\n');</td>
    <td class="lineNumber">253</td>
    <td class="codeline">                    << CurArgAlign << " for " << *Arg << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline"></td>
    <td class="lineNumber">254</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  auto NewAlignAttr =</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  auto NewAlignAttr =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">      Attribute::get(Func->getContext(), Attribute::Alignment, NewArgAlign);</td>
    <td class="lineNumber">256</td>
    <td class="codeline">      Attribute::get(Func->getContext(), Attribute::Alignment, NewArgAlign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  Arg->removeAttr(Attribute::Alignment);</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  Arg->removeAttr(Attribute::Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">  Arg->addAttr(NewAlignAttr);</td>
    <td class="lineNumber">258</td>
    <td class="codeline">  Arg->addAttr(NewAlignAttr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">  struct Load {</td>
    <td class="lineNumber">260</td>
    <td class="codeline">  struct Load {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">    LoadInst *Inst;</td>
    <td class="lineNumber">261</td>
    <td class="codeline">    LoadInst *Inst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">    uint64_t Offset;</td>
    <td class="lineNumber">262</td>
    <td class="codeline">    uint64_t Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">263</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline"></td>
    <td class="lineNumber">264</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  struct LoadContext {</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  struct LoadContext {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">    Value *InitialVal;</td>
    <td class="lineNumber">266</td>
    <td class="codeline">    Value *InitialVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">    uint64_t Offset;</td>
    <td class="lineNumber">267</td>
    <td class="codeline">    uint64_t Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">268</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline"></td>
    <td class="lineNumber">269</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  SmallVector<Load> Loads;</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  SmallVector<Load> Loads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  std::queue<LoadContext> Worklist;</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  std::queue<LoadContext> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  Worklist.push({ArgInParamAS, 0});</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  Worklist.push({ArgInParamAS, 0});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline"></td>
    <td class="lineNumber">273</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">    LoadContext Ctx = Worklist.front();</td>
    <td class="lineNumber">275</td>
    <td class="codeline">    LoadContext Ctx = Worklist.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">    Worklist.pop();</td>
    <td class="lineNumber">276</td>
    <td class="codeline">    Worklist.pop();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline"></td>
    <td class="lineNumber">277</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">    for (User *CurUser : Ctx.InitialVal->users()) {</td>
    <td class="lineNumber">278</td>
    <td class="codeline">    for (User *CurUser : Ctx.InitialVal->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">      if (auto *I = dyn_cast<LoadInst>(CurUser)) {</td>
    <td class="lineNumber">279</td>
    <td class="codeline">      if (auto *I = dyn_cast<LoadInst>(CurUser)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">        Loads.push_back({I, Ctx.Offset});</td>
    <td class="lineNumber">280</td>
    <td class="codeline">        Loads.push_back({I, Ctx.Offset});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">281</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">282</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline"></td>
    <td class="lineNumber">283</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">      if (auto *I = dyn_cast<BitCastInst>(CurUser)) {</td>
    <td class="lineNumber">284</td>
    <td class="codeline">      if (auto *I = dyn_cast<BitCastInst>(CurUser)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">        Worklist.push({I, Ctx.Offset});</td>
    <td class="lineNumber">285</td>
    <td class="codeline">        Worklist.push({I, Ctx.Offset});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">286</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">287</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">      if (auto *I = dyn_cast<GetElementPtrInst>(CurUser)) {</td>
    <td class="lineNumber">289</td>
    <td class="codeline">      if (auto *I = dyn_cast<GetElementPtrInst>(CurUser)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">        APInt OffsetAccumulated =</td>
    <td class="lineNumber">290</td>
    <td class="codeline">        APInt OffsetAccumulated =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">            APInt::getZero(DL.getIndexSizeInBits(ADDRESS_SPACE_PARAM));</td>
    <td class="lineNumber">291</td>
    <td class="codeline">            APInt::getZero(DL.getIndexSizeInBits(ADDRESS_SPACE_PARAM));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">        if (!I->accumulateConstantOffset(DL, OffsetAccumulated))</td>
    <td class="lineNumber">293</td>
    <td class="codeline">        if (!I->accumulateConstantOffset(DL, OffsetAccumulated))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">294</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline"></td>
    <td class="lineNumber">295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">        uint64_t OffsetLimit = -1;</td>
    <td class="lineNumber">296</td>
    <td class="codeline">        uint64_t OffsetLimit = -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">        uint64_t Offset = OffsetAccumulated.getLimitedValue(OffsetLimit);</td>
    <td class="lineNumber">297</td>
    <td class="codeline">        uint64_t Offset = OffsetAccumulated.getLimitedValue(OffsetLimit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">        assert(Offset != OffsetLimit && "Expect Offset less than UINT64_MAX");</td>
    <td class="lineNumber">298</td>
    <td class="codeline">        assert(Offset != OffsetLimit && "Expect Offset less than UINT64_MAX");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline"></td>
    <td class="lineNumber">299</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">        Worklist.push({I, Ctx.Offset + Offset});</td>
    <td class="lineNumber">300</td>
    <td class="codeline">        Worklist.push({I, Ctx.Offset + Offset});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">301</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">302</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline"></td>
    <td class="lineNumber">303</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">      llvm_unreachable("All users must be one of: load, "</td>
    <td class="lineNumber">304</td>
    <td class="codeline">      llvm_unreachable("All users must be one of: load, "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">                       "bitcast, getelementptr.");</td>
    <td class="lineNumber">305</td>
    <td class="codeline">                       "bitcast, getelementptr.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">306</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
    <td class="lineNumber">308</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  for (Load &CurLoad : Loads) {</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  for (Load &CurLoad : Loads) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">    Align NewLoadAlign(std::gcd(NewArgAlign, CurLoad.Offset));</td>
    <td class="lineNumber">310</td>
    <td class="codeline">    Align NewLoadAlign(std::gcd(NewArgAlign, CurLoad.Offset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">    Align CurLoadAlign(CurLoad.Inst->getAlign());</td>
    <td class="lineNumber">311</td>
    <td class="codeline">    Align CurLoadAlign(CurLoad.Inst->getAlign());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    CurLoad.Inst->setAlignment(std::max(NewLoadAlign, CurLoadAlign));</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    CurLoad.Inst->setAlignment(std::max(NewLoadAlign, CurLoadAlign));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">313</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">}</td>
    <td class="lineNumber">314</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">void NVPTXLowerArgs::handleByValParam(const NVPTXTargetMachine &TM,</td>
    <td class="lineNumber">316</td>
    <td class="codeline">void NVPTXLowerArgs::handleByValParam(const NVPTXTargetMachine &TM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">                                      Argument *Arg) {</td>
    <td class="lineNumber">317</td>
    <td class="codeline">                                      Argument *Arg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">  Function *Func = Arg->getParent();</td>
    <td class="lineNumber">318</td>
    <td class="codeline">  Function *Func = Arg->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">  Instruction *FirstInst = &(Func->getEntryBlock().front());</td>
    <td class="lineNumber">319</td>
    <td class="codeline">  Instruction *FirstInst = &(Func->getEntryBlock().front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">  Type *StructType = Arg->getParamByValType();</td>
    <td class="lineNumber">320</td>
    <td class="codeline">  Type *StructType = Arg->getParamByValType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">  assert(StructType && "Missing byval type");</td>
    <td class="lineNumber">321</td>
    <td class="codeline">  assert(StructType && "Missing byval type");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline"></td>
    <td class="lineNumber">322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">  auto IsALoadChain = [&](Value *Start) {</td>
    <td class="lineNumber">323</td>
    <td class="codeline">  auto IsALoadChain = [&](Value *Start) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">    SmallVector<Value *, 16> ValuesToCheck = {Start};</td>
    <td class="lineNumber">324</td>
    <td class="codeline">    SmallVector<Value *, 16> ValuesToCheck = {Start};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">    auto IsALoadChainInstr = [](Value *V) -> bool {</td>
    <td class="lineNumber">325</td>
    <td class="codeline">    auto IsALoadChainInstr = [](Value *V) -> bool {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">      if (isa<GetElementPtrInst>(V) || isa<BitCastInst>(V) || isa<LoadInst>(V))</td>
    <td class="lineNumber">326</td>
    <td class="codeline">      if (isa<GetElementPtrInst>(V) || isa<BitCastInst>(V) || isa<LoadInst>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">327</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">      // ASC to param space are OK, too -- we'll just strip them.</td>
    <td class="lineNumber">328</td>
    <td class="codeline">      // ASC to param space are OK, too -- we'll just strip them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">      if (auto *ASC = dyn_cast<AddrSpaceCastInst>(V)) {</td>
    <td class="lineNumber">329</td>
    <td class="codeline">      if (auto *ASC = dyn_cast<AddrSpaceCastInst>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">        if (ASC->getDestAddressSpace() == ADDRESS_SPACE_PARAM)</td>
    <td class="lineNumber">330</td>
    <td class="codeline">        if (ASC->getDestAddressSpace() == ADDRESS_SPACE_PARAM)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">331</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">332</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">333</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">334</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline"></td>
    <td class="lineNumber">335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">    while (!ValuesToCheck.empty()) {</td>
    <td class="lineNumber">336</td>
    <td class="codeline">    while (!ValuesToCheck.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">      Value *V = ValuesToCheck.pop_back_val();</td>
    <td class="lineNumber">337</td>
    <td class="codeline">      Value *V = ValuesToCheck.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">      if (!IsALoadChainInstr(V)) {</td>
    <td class="lineNumber">338</td>
    <td class="codeline">      if (!IsALoadChainInstr(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "Need a copy of " << *Arg << " because of " << *V</td>
    <td class="lineNumber">339</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "Need a copy of " << *Arg << " because of " << *V</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">                          << "\n");</td>
    <td class="lineNumber">340</td>
    <td class="codeline">                          << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">        (void)Arg;</td>
    <td class="lineNumber">341</td>
    <td class="codeline">        (void)Arg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">342</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">343</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">      if (!isa<LoadInst>(V))</td>
    <td class="lineNumber">344</td>
    <td class="codeline">      if (!isa<LoadInst>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">        llvm::append_range(ValuesToCheck, V->users());</td>
    <td class="lineNumber">345</td>
    <td class="codeline">        llvm::append_range(ValuesToCheck, V->users());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">346</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">347</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">348</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline"></td>
    <td class="lineNumber">349</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">  if (llvm::all_of(Arg->users(), IsALoadChain)) {</td>
    <td class="lineNumber">350</td>
    <td class="codeline">  if (llvm::all_of(Arg->users(), IsALoadChain)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">    // Convert all loads and intermediate operations to use parameter AS and</td>
    <td class="lineNumber">351</td>
    <td class="codeline">    // Convert all loads and intermediate operations to use parameter AS and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">    // skip creation of a local copy of the argument.</td>
    <td class="lineNumber">352</td>
    <td class="codeline">    // skip creation of a local copy of the argument.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">    SmallVector<User *, 16> UsersToUpdate(Arg->users());</td>
    <td class="lineNumber">353</td>
    <td class="codeline">    SmallVector<User *, 16> UsersToUpdate(Arg->users());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">    Value *ArgInParamAS = new AddrSpaceCastInst(</td>
    <td class="lineNumber">354</td>
    <td class="codeline">    Value *ArgInParamAS = new AddrSpaceCastInst(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">        Arg, PointerType::get(StructType, ADDRESS_SPACE_PARAM), Arg->getName(),</td>
    <td class="lineNumber">355</td>
    <td class="codeline">        Arg, PointerType::get(StructType, ADDRESS_SPACE_PARAM), Arg->getName(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">        FirstInst);</td>
    <td class="lineNumber">356</td>
    <td class="codeline">        FirstInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">    for (Value *V : UsersToUpdate)</td>
    <td class="lineNumber">357</td>
    <td class="codeline">    for (Value *V : UsersToUpdate)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">      convertToParamAS(V, ArgInParamAS);</td>
    <td class="lineNumber">358</td>
    <td class="codeline">      convertToParamAS(V, ArgInParamAS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "No need to copy " << *Arg << "\n");</td>
    <td class="lineNumber">359</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "No need to copy " << *Arg << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline"></td>
    <td class="lineNumber">360</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">    const auto *TLI =</td>
    <td class="lineNumber">361</td>
    <td class="codeline">    const auto *TLI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">        cast<NVPTXTargetLowering>(TM.getSubtargetImpl()->getTargetLowering());</td>
    <td class="lineNumber">362</td>
    <td class="codeline">        cast<NVPTXTargetLowering>(TM.getSubtargetImpl()->getTargetLowering());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline"></td>
    <td class="lineNumber">363</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">    adjustByValArgAlignment(Arg, ArgInParamAS, TLI);</td>
    <td class="lineNumber">364</td>
    <td class="codeline">    adjustByValArgAlignment(Arg, ArgInParamAS, TLI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline"></td>
    <td class="lineNumber">365</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">366</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">367</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline"></td>
    <td class="lineNumber">368</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  // Otherwise we have to create a temporary copy.</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  // Otherwise we have to create a temporary copy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  const DataLayout &DL = Func->getParent()->getDataLayout();</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  const DataLayout &DL = Func->getParent()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  unsigned AS = DL.getAllocaAddrSpace();</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  unsigned AS = DL.getAllocaAddrSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">  AllocaInst *AllocA = new AllocaInst(StructType, AS, Arg->getName(), FirstInst);</td>
    <td class="lineNumber">372</td>
    <td class="codeline">  AllocaInst *AllocA = new AllocaInst(StructType, AS, Arg->getName(), FirstInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">  // Set the alignment to alignment of the byval parameter. This is because,</td>
    <td class="lineNumber">373</td>
    <td class="codeline">  // Set the alignment to alignment of the byval parameter. This is because,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">  // later load/stores assume that alignment, and we are going to replace</td>
    <td class="lineNumber">374</td>
    <td class="codeline">  // later load/stores assume that alignment, and we are going to replace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">  // the use of the byval parameter with this alloca instruction.</td>
    <td class="lineNumber">375</td>
    <td class="codeline">  // the use of the byval parameter with this alloca instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">  AllocA->setAlignment(Func->getParamAlign(Arg->getArgNo())</td>
    <td class="lineNumber">376</td>
    <td class="codeline">  AllocA->setAlignment(Func->getParamAlign(Arg->getArgNo())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">                           .value_or(DL.getPrefTypeAlign(StructType)));</td>
    <td class="lineNumber">377</td>
    <td class="codeline">                           .value_or(DL.getPrefTypeAlign(StructType)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">  Arg->replaceAllUsesWith(AllocA);</td>
    <td class="lineNumber">378</td>
    <td class="codeline">  Arg->replaceAllUsesWith(AllocA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline"></td>
    <td class="lineNumber">379</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">  Value *ArgInParam = new AddrSpaceCastInst(</td>
    <td class="lineNumber">380</td>
    <td class="codeline">  Value *ArgInParam = new AddrSpaceCastInst(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">      Arg, PointerType::get(StructType, ADDRESS_SPACE_PARAM), Arg->getName(),</td>
    <td class="lineNumber">381</td>
    <td class="codeline">      Arg, PointerType::get(StructType, ADDRESS_SPACE_PARAM), Arg->getName(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">      FirstInst);</td>
    <td class="lineNumber">382</td>
    <td class="codeline">      FirstInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  // Be sure to propagate alignment to this load; LLVM doesn't know that NVPTX</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  // Be sure to propagate alignment to this load; LLVM doesn't know that NVPTX</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">  // addrspacecast preserves alignment.  Since params are constant, this load is</td>
    <td class="lineNumber">384</td>
    <td class="codeline">  // addrspacecast preserves alignment.  Since params are constant, this load is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  // definitely not volatile.</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  // definitely not volatile.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">  LoadInst *LI =</td>
    <td class="lineNumber">386</td>
    <td class="codeline">  LoadInst *LI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">      new LoadInst(StructType, ArgInParam, Arg->getName(),</td>
    <td class="lineNumber">387</td>
    <td class="codeline">      new LoadInst(StructType, ArgInParam, Arg->getName(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">                   /*isVolatile=*/false, AllocA->getAlign(), FirstInst);</td>
    <td class="lineNumber">388</td>
    <td class="codeline">                   /*isVolatile=*/false, AllocA->getAlign(), FirstInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">  new StoreInst(LI, AllocA, FirstInst);</td>
    <td class="lineNumber">389</td>
    <td class="codeline">  new StoreInst(LI, AllocA, FirstInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">}</td>
    <td class="lineNumber">390</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline"></td>
    <td class="lineNumber">391</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">void NVPTXLowerArgs::markPointerAsGlobal(Value *Ptr) {</td>
    <td class="lineNumber">392</td>
    <td class="codeline">void NVPTXLowerArgs::markPointerAsGlobal(Value *Ptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  if (Ptr->getType()->getPointerAddressSpace() != ADDRESS_SPACE_GENERIC)</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  if (Ptr->getType()->getPointerAddressSpace() != ADDRESS_SPACE_GENERIC)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">394</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  // Deciding where to emit the addrspacecast pair.</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  // Deciding where to emit the addrspacecast pair.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">  BasicBlock::iterator InsertPt;</td>
    <td class="lineNumber">397</td>
    <td class="codeline">  BasicBlock::iterator InsertPt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">  if (Argument *Arg = dyn_cast<Argument>(Ptr)) {</td>
    <td class="lineNumber">398</td>
    <td class="codeline">  if (Argument *Arg = dyn_cast<Argument>(Ptr)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">    // Insert at the functon entry if Ptr is an argument.</td>
    <td class="lineNumber">399</td>
    <td class="codeline">    // Insert at the functon entry if Ptr is an argument.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">    InsertPt = Arg->getParent()->getEntryBlock().begin();</td>
    <td class="lineNumber">400</td>
    <td class="codeline">    InsertPt = Arg->getParent()->getEntryBlock().begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">401</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">    // Insert right after Ptr if Ptr is an instruction.</td>
    <td class="lineNumber">402</td>
    <td class="codeline">    // Insert right after Ptr if Ptr is an instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">    InsertPt = ++cast<Instruction>(Ptr)->getIterator();</td>
    <td class="lineNumber">403</td>
    <td class="codeline">    InsertPt = ++cast<Instruction>(Ptr)->getIterator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">    assert(InsertPt != InsertPt->getParent()->end() &&</td>
    <td class="lineNumber">404</td>
    <td class="codeline">    assert(InsertPt != InsertPt->getParent()->end() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">           "We don't call this function with Ptr being a terminator.");</td>
    <td class="lineNumber">405</td>
    <td class="codeline">           "We don't call this function with Ptr being a terminator.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">406</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline"></td>
    <td class="lineNumber">407</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">  Instruction *PtrInGlobal = new AddrSpaceCastInst(</td>
    <td class="lineNumber">408</td>
    <td class="codeline">  Instruction *PtrInGlobal = new AddrSpaceCastInst(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">      Ptr, PointerType::get(Ptr->getContext(), ADDRESS_SPACE_GLOBAL),</td>
    <td class="lineNumber">409</td>
    <td class="codeline">      Ptr, PointerType::get(Ptr->getContext(), ADDRESS_SPACE_GLOBAL),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">      Ptr->getName(), &*InsertPt);</td>
    <td class="lineNumber">410</td>
    <td class="codeline">      Ptr->getName(), &*InsertPt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  Value *PtrInGeneric = new AddrSpaceCastInst(PtrInGlobal, Ptr->getType(),</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  Value *PtrInGeneric = new AddrSpaceCastInst(PtrInGlobal, Ptr->getType(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">                                              Ptr->getName(), &*InsertPt);</td>
    <td class="lineNumber">412</td>
    <td class="codeline">                                              Ptr->getName(), &*InsertPt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">  // Replace with PtrInGeneric all uses of Ptr except PtrInGlobal.</td>
    <td class="lineNumber">413</td>
    <td class="codeline">  // Replace with PtrInGeneric all uses of Ptr except PtrInGlobal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">  Ptr->replaceAllUsesWith(PtrInGeneric);</td>
    <td class="lineNumber">414</td>
    <td class="codeline">  Ptr->replaceAllUsesWith(PtrInGeneric);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  PtrInGlobal->setOperand(0, Ptr);</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  PtrInGlobal->setOperand(0, Ptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">}</td>
    <td class="lineNumber">416</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline"></td>
    <td class="lineNumber">417</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">// =============================================================================</td>
    <td class="lineNumber">418</td>
    <td class="codeline">// =============================================================================</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">// Main function for this pass.</td>
    <td class="lineNumber">419</td>
    <td class="codeline">// Main function for this pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">// =============================================================================</td>
    <td class="lineNumber">420</td>
    <td class="codeline">// =============================================================================</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">bool NVPTXLowerArgs::runOnKernelFunction(const NVPTXTargetMachine &TM,</td>
    <td class="lineNumber">421</td>
    <td class="codeline">bool NVPTXLowerArgs::runOnKernelFunction(const NVPTXTargetMachine &TM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">                                         Function &F) {</td>
    <td class="lineNumber">422</td>
    <td class="codeline">                                         Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">  // Copying of byval aggregates + SROA may result in pointers being loaded as</td>
    <td class="lineNumber">423</td>
    <td class="codeline">  // Copying of byval aggregates + SROA may result in pointers being loaded as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  // integers, followed by intotoptr. We may want to mark those as global, too,</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  // integers, followed by intotoptr. We may want to mark those as global, too,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  // but only if the loaded integer is used exclusively for conversion to a</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  // but only if the loaded integer is used exclusively for conversion to a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  // pointer with inttoptr.</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  // pointer with inttoptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  auto HandleIntToPtr = [this](Value &V) {</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  auto HandleIntToPtr = [this](Value &V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">    if (llvm::all_of(V.users(), [](User *U) { return isa<IntToPtrInst>(U); })) {</td>
    <td class="lineNumber">428</td>
    <td class="codeline">    if (llvm::all_of(V.users(), [](User *U) { return isa<IntToPtrInst>(U); })) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">      SmallVector<User *, 16> UsersToUpdate(V.users());</td>
    <td class="lineNumber">429</td>
    <td class="codeline">      SmallVector<User *, 16> UsersToUpdate(V.users());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">      llvm::for_each(UsersToUpdate, [&](User *U) { markPointerAsGlobal(U); });</td>
    <td class="lineNumber">430</td>
    <td class="codeline">      llvm::for_each(UsersToUpdate, [&](User *U) { markPointerAsGlobal(U); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">431</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">  if (TM.getDrvInterface() == NVPTX::CUDA) {</td>
    <td class="lineNumber">433</td>
    <td class="codeline">  if (TM.getDrvInterface() == NVPTX::CUDA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">    // Mark pointers in byval structs as global.</td>
    <td class="lineNumber">434</td>
    <td class="codeline">    // Mark pointers in byval structs as global.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">    for (auto &B : F) {</td>
    <td class="lineNumber">435</td>
    <td class="codeline">    for (auto &B : F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">      for (auto &I : B) {</td>
    <td class="lineNumber">436</td>
    <td class="codeline">      for (auto &I : B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">        if (LoadInst *LI = dyn_cast<LoadInst>(&I)) {</td>
    <td class="lineNumber">437</td>
    <td class="codeline">        if (LoadInst *LI = dyn_cast<LoadInst>(&I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">          if (LI->getType()->isPointerTy() || LI->getType()->isIntegerTy()) {</td>
    <td class="lineNumber">438</td>
    <td class="codeline">          if (LI->getType()->isPointerTy() || LI->getType()->isIntegerTy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">            Value *UO = getUnderlyingObject(LI->getPointerOperand());</td>
    <td class="lineNumber">439</td>
    <td class="codeline">            Value *UO = getUnderlyingObject(LI->getPointerOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">            if (Argument *Arg = dyn_cast<Argument>(UO)) {</td>
    <td class="lineNumber">440</td>
    <td class="codeline">            if (Argument *Arg = dyn_cast<Argument>(UO)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">              if (Arg->hasByValAttr()) {</td>
    <td class="lineNumber">441</td>
    <td class="codeline">              if (Arg->hasByValAttr()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">                // LI is a load from a pointer within a byval kernel parameter.</td>
    <td class="lineNumber">442</td>
    <td class="codeline">                // LI is a load from a pointer within a byval kernel parameter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">                if (LI->getType()->isPointerTy())</td>
    <td class="lineNumber">443</td>
    <td class="codeline">                if (LI->getType()->isPointerTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">                  markPointerAsGlobal(LI);</td>
    <td class="lineNumber">444</td>
    <td class="codeline">                  markPointerAsGlobal(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">                else</td>
    <td class="lineNumber">445</td>
    <td class="codeline">                else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">                  HandleIntToPtr(*LI);</td>
    <td class="lineNumber">446</td>
    <td class="codeline">                  HandleIntToPtr(*LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">              }</td>
    <td class="lineNumber">447</td>
    <td class="codeline">              }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">            }</td>
    <td class="lineNumber">448</td>
    <td class="codeline">            }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">449</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">450</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">451</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">452</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline"></td>
    <td class="lineNumber">454</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Lowering kernel args of " << F.getName() << "\n");</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Lowering kernel args of " << F.getName() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">  for (Argument &Arg : F.args()) {</td>
    <td class="lineNumber">456</td>
    <td class="codeline">  for (Argument &Arg : F.args()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">    if (Arg.getType()->isPointerTy()) {</td>
    <td class="lineNumber">457</td>
    <td class="codeline">    if (Arg.getType()->isPointerTy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">      if (Arg.hasByValAttr())</td>
    <td class="lineNumber">458</td>
    <td class="codeline">      if (Arg.hasByValAttr())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">        handleByValParam(TM, &Arg);</td>
    <td class="lineNumber">459</td>
    <td class="codeline">        handleByValParam(TM, &Arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">      else if (TM.getDrvInterface() == NVPTX::CUDA)</td>
    <td class="lineNumber">460</td>
    <td class="codeline">      else if (TM.getDrvInterface() == NVPTX::CUDA)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">        markPointerAsGlobal(&Arg);</td>
    <td class="lineNumber">461</td>
    <td class="codeline">        markPointerAsGlobal(&Arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">    } else if (Arg.getType()->isIntegerTy() &&</td>
    <td class="lineNumber">462</td>
    <td class="codeline">    } else if (Arg.getType()->isIntegerTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">               TM.getDrvInterface() == NVPTX::CUDA) {</td>
    <td class="lineNumber">463</td>
    <td class="codeline">               TM.getDrvInterface() == NVPTX::CUDA) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">      HandleIntToPtr(Arg);</td>
    <td class="lineNumber">464</td>
    <td class="codeline">      HandleIntToPtr(Arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">465</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">466</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">}</td>
    <td class="lineNumber">468</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline"></td>
    <td class="lineNumber">469</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">// Device functions only need to copy byval args into local memory.</td>
    <td class="lineNumber">470</td>
    <td class="codeline">// Device functions only need to copy byval args into local memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">bool NVPTXLowerArgs::runOnDeviceFunction(const NVPTXTargetMachine &TM,</td>
    <td class="lineNumber">471</td>
    <td class="codeline">bool NVPTXLowerArgs::runOnDeviceFunction(const NVPTXTargetMachine &TM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">                                         Function &F) {</td>
    <td class="lineNumber">472</td>
    <td class="codeline">                                         Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Lowering function args of " << F.getName() << "\n");</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Lowering function args of " << F.getName() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  for (Argument &Arg : F.args())</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  for (Argument &Arg : F.args())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">    if (Arg.getType()->isPointerTy() && Arg.hasByValAttr())</td>
    <td class="lineNumber">475</td>
    <td class="codeline">    if (Arg.getType()->isPointerTy() && Arg.hasByValAttr())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">      handleByValParam(TM, &Arg);</td>
    <td class="lineNumber">476</td>
    <td class="codeline">      handleByValParam(TM, &Arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">}</td>
    <td class="lineNumber">478</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline"></td>
    <td class="lineNumber">479</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">bool NVPTXLowerArgs::runOnFunction(Function &F) {</td>
    <td class="lineNumber">480</td>
    <td class="codeline">bool NVPTXLowerArgs::runOnFunction(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">  auto &TM = getAnalysis<TargetPassConfig>().getTM<NVPTXTargetMachine>();</td>
    <td class="lineNumber">481</td>
    <td class="codeline">  auto &TM = getAnalysis<TargetPassConfig>().getTM<NVPTXTargetMachine>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline"></td>
    <td class="lineNumber">482</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">  return isKernelFunction(F) ? runOnKernelFunction(TM, F)</td>
    <td class="lineNumber">483</td>
    <td class="codeline">  return isKernelFunction(F) ? runOnKernelFunction(TM, F)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">                             : runOnDeviceFunction(TM, F);</td>
    <td class="lineNumber">484</td>
    <td class="codeline">                             : runOnDeviceFunction(TM, F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">}</td>
    <td class="lineNumber">485</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline"></td>
    <td class="lineNumber">486</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">FunctionPass *llvm::createNVPTXLowerArgsPass() { return new NVPTXLowerArgs(); }</td>
    <td class="lineNumber">487</td>
    <td class="codeline">FunctionPass *llvm::createNVPTXLowerArgsPass() { return new NVPTXLowerArgs(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- NVPTXLowerArgs.cpp - Lower arguments ------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- NVPTXLowerArgs.cpp - Lower arguments ------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// Arguments to kernel and device functions are passed via param space,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// Arguments to kernel and device functions are passed via param space,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">// which imposes certain restrictions:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">// which imposes certain restrictions:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">// http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">// http://docs.nvidia.com/cuda/parallel-thread-execution/#state-spaces</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">// Kernel parameters are read-only and accessible only via ld.param</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">// Kernel parameters are read-only and accessible only via ld.param</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">// instruction, directly or via a pointer. Pointers to kernel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">// instruction, directly or via a pointer. Pointers to kernel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">// arguments can't be converted to generic address space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">// arguments can't be converted to generic address space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">// Device function parameters are directly accessible via</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">// Device function parameters are directly accessible via</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">// ld.param/st.param, but taking the address of one returns a pointer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">// ld.param/st.param, but taking the address of one returns a pointer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">// to a copy created in local space which *can't* be used with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">// to a copy created in local space which *can't* be used with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">// ld.param/st.param.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">// ld.param/st.param.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">// Copying a byval struct into local memory in IR allows us to enforce</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">// Copying a byval struct into local memory in IR allows us to enforce</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">// the param space restrictions, gives the rest of IR a pointer w/o</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">// the param space restrictions, gives the rest of IR a pointer w/o</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">// param space restrictions, and gives us an opportunity to eliminate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">// param space restrictions, and gives us an opportunity to eliminate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">// the copy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">// the copy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">// Pointer arguments to kernel functions need more work to be lowered:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">// Pointer arguments to kernel functions need more work to be lowered:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">// 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">// 1. Convert non-byval pointer arguments of CUDA kernels to pointers in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">//    global address space. This allows later optimizations to emit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">//    global address space. This allows later optimizations to emit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">//    ld.global.*/st.global.* for accessing these pointer arguments. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">//    ld.global.*/st.global.* for accessing these pointer arguments. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">//    example,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">//    example,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">//    define void @foo(float* %input) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">//    define void @foo(float* %input) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">//      %v = load float, float* %input, align 4</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">//      %v = load float, float* %input, align 4</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">//      ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">//      ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">//    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">//    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">//    becomes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">//    becomes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">//    define void @foo(float* %input) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">//    define void @foo(float* %input) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">//      %input2 = addrspacecast float* %input to float addrspace(1)*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">//      %input2 = addrspacecast float* %input to float addrspace(1)*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">//      %input3 = addrspacecast float addrspace(1)* %input2 to float*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">//      %input3 = addrspacecast float addrspace(1)* %input2 to float*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">//      %v = load float, float* %input3, align 4</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">//      %v = load float, float* %input3, align 4</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">//      ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">//      ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">//    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">//    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">//    Later, NVPTXInferAddressSpaces will optimize it to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">//    Later, NVPTXInferAddressSpaces will optimize it to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">//    define void @foo(float* %input) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">//    define void @foo(float* %input) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">//      %input2 = addrspacecast float* %input to float addrspace(1)*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">//      %input2 = addrspacecast float* %input to float addrspace(1)*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">//      %v = load float, float addrspace(1)* %input2, align 4</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">//      %v = load float, float addrspace(1)* %input2, align 4</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">//      ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">//      ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">//    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">//    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">// 2. Convert pointers in a byval kernel parameter to pointers in the global</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">// 2. Convert pointers in a byval kernel parameter to pointers in the global</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">//    address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">//    address space. As #2, it allows NVPTX to emit more ld/st.global. E.g.,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">//    struct S {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">//    struct S {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">//      int *x;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">//      int *x;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">//      int *y;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">//      int *y;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">//    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">//    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">//    __global__ void foo(S s) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">//    __global__ void foo(S s) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">//      int *b = s.y;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">//      int *b = s.y;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">//      // use b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">//      // use b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">//    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">//    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">//    "b" points to the global address space. In the IR level,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">//    "b" points to the global address space. In the IR level,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">//    define void @foo({i32*, i32*}* byval %input) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">//    define void @foo({i32*, i32*}* byval %input) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">//      %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">//      %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">//      %b = load i32*, i32** %b_ptr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">//      %b = load i32*, i32** %b_ptr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">//      ; use %b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">//      ; use %b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">//    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">//    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">//    becomes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">//    becomes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">//    define void @foo({i32*, i32*}* byval %input) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">//    define void @foo({i32*, i32*}* byval %input) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">//      %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">//      %b_ptr = getelementptr {i32*, i32*}, {i32*, i32*}* %input, i64 0, i32 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">//      %b = load i32*, i32** %b_ptr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">//      %b = load i32*, i32** %b_ptr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">//      %b_global = addrspacecast i32* %b to i32 addrspace(1)*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">//      %b_global = addrspacecast i32* %b to i32 addrspace(1)*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">//      %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">//      %b_generic = addrspacecast i32 addrspace(1)* %b_global to i32*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">//      ; use %b_generic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">//      ; use %b_generic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">//    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">//    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">// TODO: merge this pass with NVPTXInferAddressSpaces so that other passes don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">// TODO: merge this pass with NVPTXInferAddressSpaces so that other passes don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">// cancel the addrspacecast pair this pass emits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">// cancel the addrspacecast pair this pass emits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">#include "MCTargetDesc/NVPTXBaseInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">#include "MCTargetDesc/NVPTXBaseInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">#include "NVPTX.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">#include "NVPTX.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">#include "NVPTXTargetMachine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">#include "NVPTXTargetMachine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">#include "NVPTXUtilities.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">#include "NVPTXUtilities.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetPassConfig.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">#include <numeric></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">#include <numeric></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">#include <queue></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">#include <queue></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">#define DEBUG_TYPE "nvptx-lower-args"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">#define DEBUG_TYPE "nvptx-lower-args"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">void initializeNVPTXLowerArgsPass(PassRegistry &);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">void initializeNVPTXLowerArgsPass(PassRegistry &);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">class NVPTXLowerArgs : public FunctionPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">class NVPTXLowerArgs : public FunctionPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">  bool runOnKernelFunction(const NVPTXTargetMachine &TM, Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">  bool runOnKernelFunction(const NVPTXTargetMachine &TM, Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">  bool runOnDeviceFunction(const NVPTXTargetMachine &TM, Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">  bool runOnDeviceFunction(const NVPTXTargetMachine &TM, Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  // handle byval parameters</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  // handle byval parameters</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">  void handleByValParam(const NVPTXTargetMachine &TM, Argument *Arg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">  void handleByValParam(const NVPTXTargetMachine &TM, Argument *Arg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  // Knowing Ptr must point to the global address space, this function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  // Knowing Ptr must point to the global address space, this function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">  // addrspacecasts Ptr to global and then back to generic. This allows</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">  // addrspacecasts Ptr to global and then back to generic. This allows</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">  // NVPTXInferAddressSpaces to fold the global-to-generic cast into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">  // NVPTXInferAddressSpaces to fold the global-to-generic cast into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">  // loads/stores that appear later.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">  // loads/stores that appear later.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  void markPointerAsGlobal(Value *Ptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  void markPointerAsGlobal(Value *Ptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">  static char ID; // Pass identification, replacement for typeid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">  static char ID; // Pass identification, replacement for typeid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">  NVPTXLowerArgs() : FunctionPass(ID) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">  NVPTXLowerArgs() : FunctionPass(ID) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">  StringRef getPassName() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">  StringRef getPassName() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">    return "Lower pointer arguments of CUDA kernels";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">    return "Lower pointer arguments of CUDA kernels";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">    AU.addRequired<TargetPassConfig>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">    AU.addRequired<TargetPassConfig>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">} // namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">char NVPTXLowerArgs::ID = 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">char NVPTXLowerArgs::ID = 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(NVPTXLowerArgs, "nvptx-lower-args",</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">143</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(NVPTXLowerArgs, "nvptx-lower-args",</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">                      "Lower arguments (NVPTX)", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">                      "Lower arguments (NVPTX)", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">145</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(TargetPassConfig)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(NVPTXLowerArgs, "nvptx-lower-args",</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">146</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(NVPTXLowerArgs, "nvptx-lower-args",</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">                    "Lower arguments (NVPTX)", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">                    "Lower arguments (NVPTX)", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">// =============================================================================</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">// =============================================================================</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">// If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">// If the function had a byval struct ptr arg, say foo(%struct.x* byval %d),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">// and we can't guarantee that the only accesses are loads,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">// and we can't guarantee that the only accesses are loads,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">// then add the following instructions to the first basic block:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">// then add the following instructions to the first basic block:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">// %temp = alloca %struct.x, align 8</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">// %temp = alloca %struct.x, align 8</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">// %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">// %tempd = addrspacecast %struct.x* %d to %struct.x addrspace(101)*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">// %tv = load %struct.x addrspace(101)* %tempd</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">// %tv = load %struct.x addrspace(101)* %tempd</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">// store %struct.x %tv, %struct.x* %temp, align 8</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">// store %struct.x %tv, %struct.x* %temp, align 8</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">// The above code allocates some space in the stack and copies the incoming</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">// The above code allocates some space in the stack and copies the incoming</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">// struct from param space to local space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">// struct from param space to local space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">// Then replace all occurrences of %d by %temp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">// Then replace all occurrences of %d by %temp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">// In case we know that all users are GEPs or Loads, replace them with the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">// In case we know that all users are GEPs or Loads, replace them with the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">// ones in parameter AS, so we can access them using ld.param.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">// ones in parameter AS, so we can access them using ld.param.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">// =============================================================================</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">// =============================================================================</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">// Replaces the \p OldUser instruction with the same in parameter AS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">// Replaces the \p OldUser instruction with the same in parameter AS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">// Only Load and GEP are supported.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">// Only Load and GEP are supported.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">static void convertToParamAS(Value *OldUser, Value *Param) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">static void convertToParamAS(Value *OldUser, Value *Param) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">  Instruction *I = dyn_cast<Instruction>(OldUser);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">  Instruction *I = dyn_cast<Instruction>(OldUser);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  assert(I && "OldUser must be an instruction");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  assert(I && "OldUser must be an instruction");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  struct IP {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  struct IP {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">    Instruction *OldInstruction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">    Instruction *OldInstruction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">    Value *NewParam;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">    Value *NewParam;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">  SmallVector<IP> ItemsToConvert = {{I, Param}};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">  SmallVector<IP> ItemsToConvert = {{I, Param}};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">  SmallVector<Instruction *> InstructionsToDelete;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">  SmallVector<Instruction *> InstructionsToDelete;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  auto CloneInstInParamAS = [](const IP &I) -> Value * {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  auto CloneInstInParamAS = [](const IP &I) -> Value * {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">    if (auto *LI = dyn_cast<LoadInst>(I.OldInstruction)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">    if (auto *LI = dyn_cast<LoadInst>(I.OldInstruction)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">      LI->setOperand(0, I.NewParam);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">      LI->setOperand(0, I.NewParam);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">      return LI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">      return LI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">    if (auto *GEP = dyn_cast<GetElementPtrInst>(I.OldInstruction)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">    if (auto *GEP = dyn_cast<GetElementPtrInst>(I.OldInstruction)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">      SmallVector<Value *, 4> Indices(GEP->indices());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">      SmallVector<Value *, 4> Indices(GEP->indices());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">      auto *NewGEP = GetElementPtrInst::Create(GEP->getSourceElementType(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">      auto *NewGEP = GetElementPtrInst::Create(GEP->getSourceElementType(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">                                               I.NewParam, Indices,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">                                               I.NewParam, Indices,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">                                               GEP->getName(), GEP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">                                               GEP->getName(), GEP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">      NewGEP->setIsInBounds(GEP->isInBounds());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">      NewGEP->setIsInBounds(GEP->isInBounds());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">      return NewGEP;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">      return NewGEP;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">    if (auto *BC = dyn_cast<BitCastInst>(I.OldInstruction)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">    if (auto *BC = dyn_cast<BitCastInst>(I.OldInstruction)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">      auto *NewBCType = PointerType::get(BC->getContext(), ADDRESS_SPACE_PARAM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">      auto *NewBCType = PointerType::get(BC->getContext(), ADDRESS_SPACE_PARAM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">      return BitCastInst::Create(BC->getOpcode(), I.NewParam, NewBCType,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">      return BitCastInst::Create(BC->getOpcode(), I.NewParam, NewBCType,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">                                 BC->getName(), BC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">                                 BC->getName(), BC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">    if (auto *ASC = dyn_cast<AddrSpaceCastInst>(I.OldInstruction)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">    if (auto *ASC = dyn_cast<AddrSpaceCastInst>(I.OldInstruction)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">      assert(ASC->getDestAddressSpace() == ADDRESS_SPACE_PARAM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">      assert(ASC->getDestAddressSpace() == ADDRESS_SPACE_PARAM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">      (void)ASC;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">      (void)ASC;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">      // Just pass through the argument, the old ASC is no longer needed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">      // Just pass through the argument, the old ASC is no longer needed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">      return I.NewParam;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">      return I.NewParam;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">    llvm_unreachable("Unsupported instruction");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">    llvm_unreachable("Unsupported instruction");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  while (!ItemsToConvert.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  while (!ItemsToConvert.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">    IP I = ItemsToConvert.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">    IP I = ItemsToConvert.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">    Value *NewInst = CloneInstInParamAS(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">    Value *NewInst = CloneInstInParamAS(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">    if (NewInst && NewInst != I.OldInstruction) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">    if (NewInst && NewInst != I.OldInstruction) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">      // We've created a new instruction. Queue users of the old instruction to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">      // We've created a new instruction. Queue users of the old instruction to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">      // be converted and the instruction itself to be deleted. We can't delete</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">      // be converted and the instruction itself to be deleted. We can't delete</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">      // the old instruction yet, because it's still in use by a load somewhere.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">      // the old instruction yet, because it's still in use by a load somewhere.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">      for (Value *V : I.OldInstruction->users())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">      for (Value *V : I.OldInstruction->users())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">        ItemsToConvert.push_back({cast<Instruction>(V), NewInst});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">        ItemsToConvert.push_back({cast<Instruction>(V), NewInst});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">      InstructionsToDelete.push_back(I.OldInstruction);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">      InstructionsToDelete.push_back(I.OldInstruction);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">  // Now we know that all argument loads are using addresses in parameter space</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">  // Now we know that all argument loads are using addresses in parameter space</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">  // and we can finally remove the old instructions in generic AS.  Instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">  // and we can finally remove the old instructions in generic AS.  Instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  // scheduled for removal should be processed in reverse order so the ones</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  // scheduled for removal should be processed in reverse order so the ones</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">  // closest to the load are deleted first. Otherwise they may still be in use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">  // closest to the load are deleted first. Otherwise they may still be in use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">  // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">  // E.g if we have Value = Load(BitCast(GEP(arg))), InstructionsToDelete will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">  // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">  // have {GEP,BitCast}. GEP can't be deleted first, because it's still used by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">  // the BitCast.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">  // the BitCast.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">  for (Instruction *I : llvm::reverse(InstructionsToDelete))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">  for (Instruction *I : llvm::reverse(InstructionsToDelete))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">    I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">    I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">// Adjust alignment of arguments passed byval in .param address space. We can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">// Adjust alignment of arguments passed byval in .param address space. We can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">// increase alignment of such arguments in a way that ensures that we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">// increase alignment of such arguments in a way that ensures that we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">// effectively vectorize their loads. We should also traverse all loads from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">// effectively vectorize their loads. We should also traverse all loads from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">// byval pointer and adjust their alignment, if those were using known offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">// byval pointer and adjust their alignment, if those were using known offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">// Such alignment changes must be conformed with parameter store and load in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">// Such alignment changes must be conformed with parameter store and load in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">// NVPTXTargetLowering::LowerCall.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">// NVPTXTargetLowering::LowerCall.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">static void adjustByValArgAlignment(Argument *Arg, Value *ArgInParamAS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">static void adjustByValArgAlignment(Argument *Arg, Value *ArgInParamAS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">                                    const NVPTXTargetLowering *TLI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">                                    const NVPTXTargetLowering *TLI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  Function *Func = Arg->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  Function *Func = Arg->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  Type *StructType = Arg->getParamByValType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  Type *StructType = Arg->getParamByValType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  const DataLayout DL(Func->getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  const DataLayout DL(Func->getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  uint64_t NewArgAlign =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  uint64_t NewArgAlign =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">      TLI->getFunctionParamOptimizedAlign(Func, StructType, DL).value();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">      TLI->getFunctionParamOptimizedAlign(Func, StructType, DL).value();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">  uint64_t CurArgAlign =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">  uint64_t CurArgAlign =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">      Arg->getAttribute(Attribute::Alignment).getValueAsInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">      Arg->getAttribute(Attribute::Alignment).getValueAsInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  if (CurArgAlign >= NewArgAlign)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  if (CurArgAlign >= NewArgAlign)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Try to use alignment " << NewArgAlign << " instead of "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Try to use alignment " << NewArgAlign << " instead of "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">                    << CurArgAlign << " for " << *Arg << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">                    << CurArgAlign << " for " << *Arg << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  auto NewAlignAttr =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  auto NewAlignAttr =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">      Attribute::get(Func->getContext(), Attribute::Alignment, NewArgAlign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">      Attribute::get(Func->getContext(), Attribute::Alignment, NewArgAlign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  Arg->removeAttr(Attribute::Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  Arg->removeAttr(Attribute::Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">  Arg->addAttr(NewAlignAttr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">  Arg->addAttr(NewAlignAttr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">  struct Load {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">  struct Load {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">    LoadInst *Inst;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">    LoadInst *Inst;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">    uint64_t Offset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">    uint64_t Offset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  struct LoadContext {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  struct LoadContext {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">    Value *InitialVal;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">    Value *InitialVal;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">    uint64_t Offset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">    uint64_t Offset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">  SmallVector<Load> Loads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">  SmallVector<Load> Loads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  std::queue<LoadContext> Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  std::queue<LoadContext> Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  Worklist.push({ArgInParamAS, 0});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  Worklist.push({ArgInParamAS, 0});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">    LoadContext Ctx = Worklist.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">    LoadContext Ctx = Worklist.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">    Worklist.pop();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">    Worklist.pop();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">    for (User *CurUser : Ctx.InitialVal->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">    for (User *CurUser : Ctx.InitialVal->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">      if (auto *I = dyn_cast<LoadInst>(CurUser)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">      if (auto *I = dyn_cast<LoadInst>(CurUser)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">        Loads.push_back({I, Ctx.Offset});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">        Loads.push_back({I, Ctx.Offset});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">      if (auto *I = dyn_cast<BitCastInst>(CurUser)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">      if (auto *I = dyn_cast<BitCastInst>(CurUser)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">        Worklist.push({I, Ctx.Offset});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">        Worklist.push({I, Ctx.Offset});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">      if (auto *I = dyn_cast<GetElementPtrInst>(CurUser)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">      if (auto *I = dyn_cast<GetElementPtrInst>(CurUser)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">        APInt OffsetAccumulated =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">        APInt OffsetAccumulated =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">            APInt::getZero(DL.getIndexSizeInBits(ADDRESS_SPACE_PARAM));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">            APInt::getZero(DL.getIndexSizeInBits(ADDRESS_SPACE_PARAM));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">        if (!I->accumulateConstantOffset(DL, OffsetAccumulated))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">        if (!I->accumulateConstantOffset(DL, OffsetAccumulated))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">        uint64_t OffsetLimit = -1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">        uint64_t OffsetLimit = -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">        uint64_t Offset = OffsetAccumulated.getLimitedValue(OffsetLimit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">        uint64_t Offset = OffsetAccumulated.getLimitedValue(OffsetLimit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">        assert(Offset != OffsetLimit && "Expect Offset less than UINT64_MAX");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">        assert(Offset != OffsetLimit && "Expect Offset less than UINT64_MAX");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">        Worklist.push({I, Ctx.Offset + Offset});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">        Worklist.push({I, Ctx.Offset + Offset});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">      llvm_unreachable("All users must be one of: load, "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">      llvm_unreachable("All users must be one of: load, "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">                       "bitcast, getelementptr.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">                       "bitcast, getelementptr.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  for (Load &CurLoad : Loads) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  for (Load &CurLoad : Loads) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">    Align NewLoadAlign(std::gcd(NewArgAlign, CurLoad.Offset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">    Align NewLoadAlign(std::gcd(NewArgAlign, CurLoad.Offset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">    Align CurLoadAlign(CurLoad.Inst->getAlign());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">    Align CurLoadAlign(CurLoad.Inst->getAlign());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">    CurLoad.Inst->setAlignment(std::max(NewLoadAlign, CurLoadAlign));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">    CurLoad.Inst->setAlignment(std::max(NewLoadAlign, CurLoadAlign));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">void NVPTXLowerArgs::handleByValParam(const NVPTXTargetMachine &TM,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">void NVPTXLowerArgs::handleByValParam(const NVPTXTargetMachine &TM,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">                                      Argument *Arg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">                                      Argument *Arg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">  Function *Func = Arg->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">  Function *Func = Arg->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">  Instruction *FirstInst = &(Func->getEntryBlock().front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">  Instruction *FirstInst = &(Func->getEntryBlock().front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">  Type *StructType = Arg->getParamByValType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">  Type *StructType = Arg->getParamByValType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">  assert(StructType && "Missing byval type");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">  assert(StructType && "Missing byval type");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">  auto IsALoadChain = [&](Value *Start) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">  auto IsALoadChain = [&](Value *Start) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">    SmallVector<Value *, 16> ValuesToCheck = {Start};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">    SmallVector<Value *, 16> ValuesToCheck = {Start};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">    auto IsALoadChainInstr = [](Value *V) -> bool {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">    auto IsALoadChainInstr = [](Value *V) -> bool {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">      if (isa<GetElementPtrInst>(V) || isa<BitCastInst>(V) || isa<LoadInst>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">      if (isa<GetElementPtrInst>(V) || isa<BitCastInst>(V) || isa<LoadInst>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">      // ASC to param space are OK, too -- we'll just strip them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">      // ASC to param space are OK, too -- we'll just strip them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">      if (auto *ASC = dyn_cast<AddrSpaceCastInst>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">      if (auto *ASC = dyn_cast<AddrSpaceCastInst>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">        if (ASC->getDestAddressSpace() == ADDRESS_SPACE_PARAM)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">        if (ASC->getDestAddressSpace() == ADDRESS_SPACE_PARAM)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">    while (!ValuesToCheck.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">    while (!ValuesToCheck.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">      Value *V = ValuesToCheck.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">      Value *V = ValuesToCheck.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">      if (!IsALoadChainInstr(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">      if (!IsALoadChainInstr(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "Need a copy of " << *Arg << " because of " << *V</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "Need a copy of " << *Arg << " because of " << *V</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">                          << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">                          << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">        (void)Arg;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">        (void)Arg;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">      if (!isa<LoadInst>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">      if (!isa<LoadInst>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">        llvm::append_range(ValuesToCheck, V->users());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">        llvm::append_range(ValuesToCheck, V->users());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">  if (llvm::all_of(Arg->users(), IsALoadChain)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">  if (llvm::all_of(Arg->users(), IsALoadChain)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">    // Convert all loads and intermediate operations to use parameter AS and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">    // Convert all loads and intermediate operations to use parameter AS and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">    // skip creation of a local copy of the argument.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">    // skip creation of a local copy of the argument.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">    SmallVector<User *, 16> UsersToUpdate(Arg->users());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">    SmallVector<User *, 16> UsersToUpdate(Arg->users());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">    Value *ArgInParamAS = new AddrSpaceCastInst(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">    Value *ArgInParamAS = new AddrSpaceCastInst(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">        Arg, PointerType::get(StructType, ADDRESS_SPACE_PARAM), Arg->getName(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">        Arg, PointerType::get(StructType, ADDRESS_SPACE_PARAM), Arg->getName(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">        FirstInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">        FirstInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">    for (Value *V : UsersToUpdate)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">    for (Value *V : UsersToUpdate)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">      convertToParamAS(V, ArgInParamAS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">      convertToParamAS(V, ArgInParamAS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "No need to copy " << *Arg << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "No need to copy " << *Arg << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">    const auto *TLI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">    const auto *TLI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">        cast<NVPTXTargetLowering>(TM.getSubtargetImpl()->getTargetLowering());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">        cast<NVPTXTargetLowering>(TM.getSubtargetImpl()->getTargetLowering());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">    adjustByValArgAlignment(Arg, ArgInParamAS, TLI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">    adjustByValArgAlignment(Arg, ArgInParamAS, TLI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">  // Otherwise we have to create a temporary copy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">  // Otherwise we have to create a temporary copy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">  const DataLayout &DL = Func->getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">  const DataLayout &DL = Func->getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  unsigned AS = DL.getAllocaAddrSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  unsigned AS = DL.getAllocaAddrSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">  AllocaInst *AllocA = new AllocaInst(StructType, AS, Arg->getName(), FirstInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">  AllocaInst *AllocA = new AllocaInst(StructType, AS, Arg->getName(), FirstInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">  // Set the alignment to alignment of the byval parameter. This is because,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">  // Set the alignment to alignment of the byval parameter. This is because,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">  // later load/stores assume that alignment, and we are going to replace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">  // later load/stores assume that alignment, and we are going to replace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">  // the use of the byval parameter with this alloca instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">  // the use of the byval parameter with this alloca instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">  AllocA->setAlignment(Func->getParamAlign(Arg->getArgNo())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">  AllocA->setAlignment(Func->getParamAlign(Arg->getArgNo())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">                           .value_or(DL.getPrefTypeAlign(StructType)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">                           .value_or(DL.getPrefTypeAlign(StructType)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">  Arg->replaceAllUsesWith(AllocA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">  Arg->replaceAllUsesWith(AllocA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">  Value *ArgInParam = new AddrSpaceCastInst(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">  Value *ArgInParam = new AddrSpaceCastInst(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">      Arg, PointerType::get(StructType, ADDRESS_SPACE_PARAM), Arg->getName(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">      Arg, PointerType::get(StructType, ADDRESS_SPACE_PARAM), Arg->getName(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">      FirstInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">      FirstInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  // Be sure to propagate alignment to this load; LLVM doesn't know that NVPTX</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  // Be sure to propagate alignment to this load; LLVM doesn't know that NVPTX</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">  // addrspacecast preserves alignment.  Since params are constant, this load is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">  // addrspacecast preserves alignment.  Since params are constant, this load is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  // definitely not volatile.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  // definitely not volatile.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">  LoadInst *LI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">  LoadInst *LI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">      new LoadInst(StructType, ArgInParam, Arg->getName(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">      new LoadInst(StructType, ArgInParam, Arg->getName(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">                   /*isVolatile=*/false, AllocA->getAlign(), FirstInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">                   /*isVolatile=*/false, AllocA->getAlign(), FirstInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">  new StoreInst(LI, AllocA, FirstInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">  new StoreInst(LI, AllocA, FirstInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">void NVPTXLowerArgs::markPointerAsGlobal(Value *Ptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">void NVPTXLowerArgs::markPointerAsGlobal(Value *Ptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  if (Ptr->getType()->getPointerAddressSpace() != ADDRESS_SPACE_GENERIC)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  if (Ptr->getType()->getPointerAddressSpace() != ADDRESS_SPACE_GENERIC)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  // Deciding where to emit the addrspacecast pair.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  // Deciding where to emit the addrspacecast pair.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">  BasicBlock::iterator InsertPt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">  BasicBlock::iterator InsertPt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">  if (Argument *Arg = dyn_cast<Argument>(Ptr)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">  if (Argument *Arg = dyn_cast<Argument>(Ptr)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">    // Insert at the functon entry if Ptr is an argument.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">    // Insert at the functon entry if Ptr is an argument.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">    InsertPt = Arg->getParent()->getEntryBlock().begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">    InsertPt = Arg->getParent()->getEntryBlock().begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">    // Insert right after Ptr if Ptr is an instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">    // Insert right after Ptr if Ptr is an instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">    InsertPt = ++cast<Instruction>(Ptr)->getIterator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">    InsertPt = ++cast<Instruction>(Ptr)->getIterator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">    assert(InsertPt != InsertPt->getParent()->end() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">    assert(InsertPt != InsertPt->getParent()->end() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">           "We don't call this function with Ptr being a terminator.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">           "We don't call this function with Ptr being a terminator.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">  Instruction *PtrInGlobal = new AddrSpaceCastInst(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">  Instruction *PtrInGlobal = new AddrSpaceCastInst(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">      Ptr, PointerType::get(Ptr->getContext(), ADDRESS_SPACE_GLOBAL),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">      Ptr, PointerType::get(Ptr->getContext(), ADDRESS_SPACE_GLOBAL),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">      Ptr->getName(), &*InsertPt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">      Ptr->getName(), &*InsertPt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  Value *PtrInGeneric = new AddrSpaceCastInst(PtrInGlobal, Ptr->getType(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  Value *PtrInGeneric = new AddrSpaceCastInst(PtrInGlobal, Ptr->getType(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">                                              Ptr->getName(), &*InsertPt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">                                              Ptr->getName(), &*InsertPt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">  // Replace with PtrInGeneric all uses of Ptr except PtrInGlobal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">  // Replace with PtrInGeneric all uses of Ptr except PtrInGlobal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">  Ptr->replaceAllUsesWith(PtrInGeneric);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">  Ptr->replaceAllUsesWith(PtrInGeneric);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">  PtrInGlobal->setOperand(0, Ptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">  PtrInGlobal->setOperand(0, Ptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">// =============================================================================</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">// =============================================================================</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">// Main function for this pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">// Main function for this pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">// =============================================================================</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">// =============================================================================</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">bool NVPTXLowerArgs::runOnKernelFunction(const NVPTXTargetMachine &TM,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">bool NVPTXLowerArgs::runOnKernelFunction(const NVPTXTargetMachine &TM,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">                                         Function &F) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">                                         Function &F) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">  // Copying of byval aggregates + SROA may result in pointers being loaded as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">  // Copying of byval aggregates + SROA may result in pointers being loaded as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  // integers, followed by intotoptr. We may want to mark those as global, too,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  // integers, followed by intotoptr. We may want to mark those as global, too,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  // but only if the loaded integer is used exclusively for conversion to a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  // but only if the loaded integer is used exclusively for conversion to a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  // pointer with inttoptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  // pointer with inttoptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  auto HandleIntToPtr = [this](Value &V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  auto HandleIntToPtr = [this](Value &V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">    if (llvm::all_of(V.users(), [](User *U) { return isa<IntToPtrInst>(U); })) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">    if (llvm::all_of(V.users(), [](User *U) { return isa<IntToPtrInst>(U); })) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">      SmallVector<User *, 16> UsersToUpdate(V.users());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">      SmallVector<User *, 16> UsersToUpdate(V.users());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">      llvm::for_each(UsersToUpdate, [&](User *U) { markPointerAsGlobal(U); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">      llvm::for_each(UsersToUpdate, [&](User *U) { markPointerAsGlobal(U); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">  if (TM.getDrvInterface() == NVPTX::CUDA) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">  if (TM.getDrvInterface() == NVPTX::CUDA) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">    // Mark pointers in byval structs as global.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">    // Mark pointers in byval structs as global.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">    for (auto &B : F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">    for (auto &B : F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">      for (auto &I : B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">      for (auto &I : B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">        if (LoadInst *LI = dyn_cast<LoadInst>(&I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">        if (LoadInst *LI = dyn_cast<LoadInst>(&I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">          if (LI->getType()->isPointerTy() || LI->getType()->isIntegerTy()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">          if (LI->getType()->isPointerTy() || LI->getType()->isIntegerTy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">            Value *UO = getUnderlyingObject(LI->getPointerOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">            Value *UO = getUnderlyingObject(LI->getPointerOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">            if (Argument *Arg = dyn_cast<Argument>(UO)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">            if (Argument *Arg = dyn_cast<Argument>(UO)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">              if (Arg->hasByValAttr()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">              if (Arg->hasByValAttr()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">                // LI is a load from a pointer within a byval kernel parameter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">                // LI is a load from a pointer within a byval kernel parameter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">                if (LI->getType()->isPointerTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">                if (LI->getType()->isPointerTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">                  markPointerAsGlobal(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">                  markPointerAsGlobal(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">                else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">                else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">                  HandleIntToPtr(*LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">                  HandleIntToPtr(*LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">              }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">              }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Lowering kernel args of " << F.getName() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Lowering kernel args of " << F.getName() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">  for (Argument &Arg : F.args()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">  for (Argument &Arg : F.args()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">    if (Arg.getType()->isPointerTy()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">    if (Arg.getType()->isPointerTy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">      if (Arg.hasByValAttr())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">      if (Arg.hasByValAttr())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">        handleByValParam(TM, &Arg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">        handleByValParam(TM, &Arg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">      else if (TM.getDrvInterface() == NVPTX::CUDA)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">      else if (TM.getDrvInterface() == NVPTX::CUDA)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">        markPointerAsGlobal(&Arg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">        markPointerAsGlobal(&Arg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">    } else if (Arg.getType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">    } else if (Arg.getType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">               TM.getDrvInterface() == NVPTX::CUDA) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">               TM.getDrvInterface() == NVPTX::CUDA) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">      HandleIntToPtr(Arg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">      HandleIntToPtr(Arg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">// Device functions only need to copy byval args into local memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">// Device functions only need to copy byval args into local memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">bool NVPTXLowerArgs::runOnDeviceFunction(const NVPTXTargetMachine &TM,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">bool NVPTXLowerArgs::runOnDeviceFunction(const NVPTXTargetMachine &TM,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">                                         Function &F) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">                                         Function &F) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Lowering function args of " << F.getName() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Lowering function args of " << F.getName() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  for (Argument &Arg : F.args())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  for (Argument &Arg : F.args())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">    if (Arg.getType()->isPointerTy() && Arg.hasByValAttr())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">    if (Arg.getType()->isPointerTy() && Arg.hasByValAttr())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">      handleByValParam(TM, &Arg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">      handleByValParam(TM, &Arg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">bool NVPTXLowerArgs::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">bool NVPTXLowerArgs::runOnFunction(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">  auto &TM = getAnalysis<TargetPassConfig>().getTM<NVPTXTargetMachine>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">  auto &TM = getAnalysis<TargetPassConfig>().getTM<NVPTXTargetMachine>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">  return isKernelFunction(F) ? runOnKernelFunction(TM, F)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">  return isKernelFunction(F) ? runOnKernelFunction(TM, F)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">                             : runOnDeviceFunction(TM, F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">                             : runOnDeviceFunction(TM, F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">FunctionPass *llvm::createNVPTXLowerArgsPass() { return new NVPTXLowerArgs(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">FunctionPass *llvm::createNVPTXLowerArgsPass() { return new NVPTXLowerArgs(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>