<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>X86SpeculativeLoadHardening.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//====- X86SpeculativeLoadHardening.cpp - A Spectre v1 mitigation ---------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">/// \file</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">/// Provide a pass which mitigates speculative execution attacks which operate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">/// by speculating incorrectly past some predicate (a type check, bounds check,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">/// or other condition) to reach a load with invalid inputs and leak the data</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">/// accessed by that load using a side channel out of the speculative domain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">/// For details on the attacks, see the first variant in both the Project Zero</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">/// writeup and the Spectre paper:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">/// https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">/// https://spectreattack.com/spectre.pdf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "X86.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "X86InstrBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "X86InstrInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "X86Subtarget.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/ADT/ArrayRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/ADT/STLExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/ADT/ScopeExit.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/ADT/SmallSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/ADT/SparseBitVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/ADT/Statistic.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/CodeGen/MachineConstantPool.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include "llvm/CodeGen/MachineModuleInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#include "llvm/CodeGen/MachineSSAUpdater.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">#include "llvm/CodeGen/TargetSchedule.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">#include "llvm/IR/DebugLoc.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">#include "llvm/MC/MCSchedule.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">#include "llvm/Target/TargetMachine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">#include <iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">#include <optional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">#define PASS_KEY "x86-slh"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">#define DEBUG_TYPE PASS_KEY</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">STATISTIC(NumCondBranchesTraced, "Number of conditional branches traced");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">STATISTIC(NumBranchesUntraced, "Number of branches unable to trace");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">STATISTIC(NumAddrRegsHardened,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">          "Number of address mode used registers hardaned");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">STATISTIC(NumPostLoadRegsHardened,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">          "Number of post-load register values hardened");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">STATISTIC(NumCallsOrJumpsHardened,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">          "Number of calls or jumps requiring extra hardening");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">STATISTIC(NumInstsInserted, "Number of instructions inserted");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">STATISTIC(NumLFENCEsInserted, "Number of lfence instructions inserted");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">static cl::opt<bool> EnableSpeculativeLoadHardening(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">    "x86-speculative-load-hardening",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">    cl::desc("Force enable speculative load hardening"), cl::init(false),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">    cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">static cl::opt<bool> HardenEdgesWithLFENCE(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">    PASS_KEY "-lfence",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">    cl::desc(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">        "Use LFENCE along each conditional edge to harden against speculative "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">        "loads rather than conditional movs and poisoned pointers."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">    cl::init(false), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">static cl::opt<bool> EnablePostLoadHardening(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">    PASS_KEY "-post-load",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">    cl::desc("Harden the value loaded *after* it is loaded by "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">             "flushing the loaded bits to 1. This is hard to do "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">             "in general but can be done easily for GPRs."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">    cl::init(true), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">static cl::opt<bool> FenceCallAndRet(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">    PASS_KEY "-fence-call-and-ret",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">    cl::desc("Use a full speculation fence to harden both call and ret edges "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">             "rather than a lighter weight mitigation."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">    cl::init(false), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">static cl::opt<bool> HardenInterprocedurally(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">    PASS_KEY "-ip",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">    cl::desc("Harden interprocedurally by passing our state in and out of "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">             "functions in the high bits of the stack pointer."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">    cl::init(true), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">static cl::opt<bool></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">    HardenLoads(PASS_KEY "-loads",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">                cl::desc("Sanitize loads from memory. When disable, no "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">                         "significant security is provided."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">                cl::init(true), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">static cl::opt<bool> HardenIndirectCallsAndJumps(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">    PASS_KEY "-indirect",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">    cl::desc("Harden indirect calls and jumps against using speculatively "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">             "stored attacker controlled addresses. This is designed to "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">             "mitigate Spectre v1.2 style attacks."),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">    cl::init(true), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">class X86SpeculativeLoadHardeningPass : public MachineFunctionPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="uncoveredLine">  X86SpeculativeLoadHardeningPass() : MachineFunctionPass(ID) { }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="uncoveredLine">  StringRef getPassName() const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="uncoveredLine">    return "X86 speculative load hardening";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">  bool runOnMachineFunction(MachineFunction &MF) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">  /// Pass identification, replacement for typeid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">  static char ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">  /// The information about a block's conditional terminators needed to trace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">  /// our predicate state through the exiting edges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">  struct BlockCondInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">    MachineBasicBlock *MBB;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">    // We mostly have one conditional branch, and in extremely rare cases have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">    // two. Three and more are so rare as to be unimportant for compile time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">    SmallVector<MachineInstr *, 2> CondBrs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">    MachineInstr *UncondBr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">  /// Manages the predicate state traced through the program.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">  struct PredState {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">    unsigned InitialReg = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">    unsigned PoisonReg = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">    const TargetRegisterClass *RC;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">    MachineSSAUpdater SSA;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="uncoveredLine">    PredState(MachineFunction &MF, const TargetRegisterClass *RC)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="uncoveredLine">        : RC(RC), SSA(MF) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">  const X86Subtarget *Subtarget = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">  MachineRegisterInfo *MRI = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">  const X86InstrInfo *TII = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">  const TargetRegisterInfo *TRI = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">  std::optional<PredState> PS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">  void hardenEdgesWithLFENCE(MachineFunction &MF);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">  SmallVector<BlockCondInfo, 16> collectBlockCondInfo(MachineFunction &MF);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">  SmallVector<MachineInstr *, 16></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  tracePredStateThroughCFG(MachineFunction &MF, ArrayRef<BlockCondInfo> Infos);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">  void unfoldCallAndJumpLoads(MachineFunction &MF);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">  SmallVector<MachineInstr *, 16></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">  tracePredStateThroughIndirectBranches(MachineFunction &MF);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">  void tracePredStateThroughBlocksAndHarden(MachineFunction &MF);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">  unsigned saveEFLAGS(MachineBasicBlock &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">                      MachineBasicBlock::iterator InsertPt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">                      const DebugLoc &Loc);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">  void restoreEFLAGS(MachineBasicBlock &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">                     MachineBasicBlock::iterator InsertPt, const DebugLoc &Loc,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">                     Register Reg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">  void mergePredStateIntoSP(MachineBasicBlock &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">                            MachineBasicBlock::iterator InsertPt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">                            const DebugLoc &Loc, unsigned PredStateReg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">  unsigned extractPredStateFromSP(MachineBasicBlock &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">                                  MachineBasicBlock::iterator InsertPt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">                                  const DebugLoc &Loc);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">  void</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">  hardenLoadAddr(MachineInstr &MI, MachineOperand &BaseMO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">                 MachineOperand &IndexMO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">                 SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">  MachineInstr *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">  sinkPostLoadHardenedInst(MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">                           SmallPtrSetImpl<MachineInstr *> &HardenedInstrs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">  bool canHardenRegister(Register Reg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  unsigned hardenValueInRegister(Register Reg, MachineBasicBlock &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">                                 MachineBasicBlock::iterator InsertPt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">                                 const DebugLoc &Loc);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">  unsigned hardenPostLoad(MachineInstr &MI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">  void hardenReturnInstr(MachineInstr &MI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">  void tracePredStateThroughCall(MachineInstr &MI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">  void hardenIndirectCallOrJumpInstr(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">      MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">      SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">char X86SpeculativeLoadHardeningPass::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="uncoveredLine">void X86SpeculativeLoadHardeningPass::getAnalysisUsage(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">    AnalysisUsage &AU) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="uncoveredLine">  MachineFunctionPass::getAnalysisUsage(AU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="uncoveredLine">static MachineBasicBlock &splitEdge(MachineBasicBlock &MBB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">                                    MachineBasicBlock &Succ, int SuccCount,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">                                    MachineInstr *Br, MachineInstr *&UncondBr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">                                    const X86InstrInfo &TII) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">  assert(!Succ.isEHPad() && "Shouldn't get edges to EH pads!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">  MachineFunction &MF = *MBB.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">  MachineBasicBlock &NewMBB = *MF.CreateMachineBasicBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">  // We have to insert the new block immediately after the current one as we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">  // don't know what layout-successor relationships the successor has and we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">  // may not be able to (and generally don't want to) try to fix those up.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="uncoveredLine">  MF.insert(std::next(MachineFunction::iterator(&MBB)), &NewMBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">  // Update the branch instruction if necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">  if (Br) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="uncoveredLine">    assert(Br->getOperand(0).getMBB() == &Succ &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">           "Didn't start with the right target!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="uncoveredLine">    Br->getOperand(0).setMBB(&NewMBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">    // If this successor was reached through a branch rather than fallthrough,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">    // we might have *broken* fallthrough and so need to inject a new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">    // unconditional branch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">    if (!UncondBr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">      MachineBasicBlock &OldLayoutSucc =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="uncoveredLine">          *std::next(MachineFunction::iterator(&NewMBB));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="uncoveredLine">      assert(MBB.isSuccessor(&OldLayoutSucc) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">             "Without an unconditional branch, the old layout successor should "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">             "be an actual successor!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">      auto BrBuilder =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">          BuildMI(&MBB, DebugLoc(), TII.get(X86::JMP_1)).addMBB(&OldLayoutSucc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">      // Update the unconditional branch now that we've added one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">      UncondBr = &*BrBuilder;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">    // Insert unconditional "jump Succ" instruction in the new block if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">    // necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="uncoveredLine">    if (!NewMBB.isLayoutSuccessor(&Succ)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="uncoveredLine">      SmallVector<MachineOperand, 4> Cond;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="uncoveredLine">      TII.insertBranch(NewMBB, &Succ, nullptr, Cond, Br->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="uncoveredLine">    assert(!UncondBr &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">           "Cannot have a branchless successor and an unconditional branch!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="uncoveredLine">    assert(NewMBB.isLayoutSuccessor(&Succ) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">           "A non-branch successor must have been a layout successor before "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">           "and now is a layout successor of the new block.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">  // If this is the only edge to the successor, we can just replace it in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">  // CFG. Otherwise we need to add a new entry in the CFG for the new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">  // successor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="uncoveredLine">  if (SuccCount == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="uncoveredLine">    MBB.replaceSuccessor(&Succ, &NewMBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="uncoveredLine">    MBB.splitSuccessor(&Succ, &NewMBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">  // Hook up the edge from the new basic block to the old successor in the CFG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="uncoveredLine">  NewMBB.addSuccessor(&Succ);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  // Fix PHI nodes in Succ so they refer to NewMBB instead of MBB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="uncoveredLine">  for (MachineInstr &MI : Succ) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="uncoveredLine">    if (!MI.isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="uncoveredLine">    for (int OpIdx = 1, NumOps = MI.getNumOperands(); OpIdx < NumOps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="uncoveredLine">         OpIdx += 2) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="uncoveredLine">      MachineOperand &OpV = MI.getOperand(OpIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">      MachineOperand &OpMBB = MI.getOperand(OpIdx + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="uncoveredLine">      assert(OpMBB.isMBB() && "Block operand to a PHI is not a block!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="uncoveredLine">      if (OpMBB.getMBB() != &MBB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">      // If this is the last edge to the succesor, just replace MBB in the PHI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="uncoveredLine">      if (SuccCount == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="uncoveredLine">        OpMBB.setMBB(&NewMBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">      // Otherwise, append a new pair of operands for the new incoming edge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">      MI.addOperand(MF, OpV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">      MI.addOperand(MF, MachineOperand::CreateMBB(&NewMBB));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">  // Inherit live-ins from the successor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="uncoveredLine">  for (auto &LI : Succ.liveins())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="uncoveredLine">    NewMBB.addLiveIn(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "  Split edge from '" << MBB.getName() << "' to '"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">                    << Succ.getName() << "'.\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="uncoveredLine">  return NewMBB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">/// Removing duplicate PHI operands to leave the PHI in a canonical and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">/// predictable form.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">/// FIXME: It's really frustrating that we have to do this, but SSA-form in MIR</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">/// isn't what you might expect. We may have multiple entries in PHI nodes for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">/// a single predecessor. This makes CFG-updating extremely complex, so here we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">/// simplify all PHI nodes to a model even simpler than the IR's model: exactly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">/// one entry per predecessor, regardless of how many edges there are.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="uncoveredLine">static void canonicalizePHIOperands(MachineFunction &MF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="uncoveredLine">  SmallPtrSet<MachineBasicBlock *, 4> Preds;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">  SmallVector<int, 4> DupIndices;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="uncoveredLine">  for (auto &MBB : MF)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="uncoveredLine">    for (auto &MI : MBB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="uncoveredLine">      if (!MI.isPHI())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">      // First we scan the operands of the PHI looking for duplicate entries</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">      // a particular predecessor. We retain the operand index of each duplicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">      // entry found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="uncoveredLine">      for (int OpIdx = 1, NumOps = MI.getNumOperands(); OpIdx < NumOps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="uncoveredLine">           OpIdx += 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="uncoveredLine">        if (!Preds.insert(MI.getOperand(OpIdx + 1).getMBB()).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="uncoveredLine">          DupIndices.push_back(OpIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">      // Now walk the duplicate indices, removing both the block and value. Note</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">      // that these are stored as a vector making this element-wise removal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">      // :w</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">      // potentially quadratic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">      // FIXME: It is really frustrating that we have to use a quadratic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">      // removal algorithm here. There should be a better way, but the use-def</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">      // updates required make that impossible using the public API.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">      // Note that we have to process these backwards so that we don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">      // invalidate other indices with each removal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="uncoveredLine">      while (!DupIndices.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">        int OpIdx = DupIndices.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">        // Remove both the block and value operand, again in reverse order to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">        // preserve indices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">        MI.removeOperand(OpIdx + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">        MI.removeOperand(OpIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="uncoveredLine">      Preds.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">/// Helper to scan a function for loads vulnerable to misspeculation that we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">/// want to harden.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">/// We use this to avoid making changes to functions where there is nothing we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">/// need to do to harden against misspeculation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">static bool hasVulnerableLoad(MachineFunction &MF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">    for (MachineInstr &MI : MBB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">      // Loads within this basic block after an LFENCE are not at risk of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="">      // speculatively executing with invalid predicates from prior control</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">      // flow. So break out of this block but continue scanning the function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="uncoveredLine">      if (MI.getOpcode() == X86::LFENCE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">      // Looking for loads only.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">      if (!MI.mayLoad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">      // An MFENCE is modeled as a load but isn't vulnerable to misspeculation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">      if (MI.getOpcode() == X86::MFENCE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">      // We found a load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">  // No loads found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="uncoveredLine">bool X86SpeculativeLoadHardeningPass::runOnMachineFunction(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">    MachineFunction &MF) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "********** " << getPassName() << " : " << MF.getName()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">                    << " **********\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">  // Only run if this pass is forced enabled or we detect the relevant function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">  // attribute requesting SLH.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">  if (!EnableSpeculativeLoadHardening &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="uncoveredLine">      !MF.getFunction().hasFnAttribute(Attribute::SpeculativeLoadHardening))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="uncoveredLine">  Subtarget = &MF.getSubtarget<X86Subtarget>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="uncoveredLine">  MRI = &MF.getRegInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="uncoveredLine">  TII = Subtarget->getInstrInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">  TRI = Subtarget->getRegisterInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">  // FIXME: Support for 32-bit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="uncoveredLine">  PS.emplace(MF, &X86::GR64_NOSPRegClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="uncoveredLine">  if (MF.begin() == MF.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">    // Nothing to do for a degenerate empty function...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">  // We support an alternative hardening technique based on a debug flag.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="uncoveredLine">  if (HardenEdgesWithLFENCE) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="uncoveredLine">    hardenEdgesWithLFENCE(MF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">  // Create a dummy debug loc to use for all the generated code here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="uncoveredLine">  DebugLoc Loc;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="uncoveredLine">  MachineBasicBlock &Entry = *MF.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="uncoveredLine">  auto EntryInsertPt = Entry.SkipPHIsLabelsAndDebug(Entry.begin());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">  // Do a quick scan to see if we have any checkable loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="uncoveredLine">  bool HasVulnerableLoad = hasVulnerableLoad(MF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">  // See if we have any conditional branching blocks that we will need to trace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">  // predicate state through.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">  SmallVector<BlockCondInfo, 16> Infos = collectBlockCondInfo(MF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">  // If we have no interesting conditions or loads, nothing to do here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">  if (!HasVulnerableLoad && Infos.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">  // The poison value is required to be an all-ones value for many aspects of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">  // this mitigation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="uncoveredLine">  const int PoisonVal = -1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="uncoveredLine">  PS->PoisonReg = MRI->createVirtualRegister(PS->RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="uncoveredLine">  BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::MOV64ri32), PS->PoisonReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="uncoveredLine">      .addImm(PoisonVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">  ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">  // If we have loads being hardened and we've asked for call and ret edges to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">  // get a full fence-based mitigation, inject that fence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="uncoveredLine">  if (HasVulnerableLoad && FenceCallAndRet) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">    // We need to insert an LFENCE at the start of the function to suspend any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">    // incoming misspeculation from the caller. This helps two-fold: the caller</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">    // may not have been protected as this code has been, and this code gets to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">    // not take any specific action to protect across calls.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">    // FIXME: We could skip this for functions which unconditionally return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">    // a constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">    BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::LFENCE));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">    ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">    ++NumLFENCEsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">  // If we guarded the entry with an LFENCE and have no conditionals to protect</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">  // in blocks, then we're done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="uncoveredLine">  if (FenceCallAndRet && Infos.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">    // We may have changed the function's code at this point to insert fences.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">  // For every basic block in the function which can b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">  if (HardenInterprocedurally && !FenceCallAndRet) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">    // Set up the predicate state by extracting it from the incoming stack</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">    // pointer so we pick up any misspeculation in our caller.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="uncoveredLine">    PS->InitialReg = extractPredStateFromSP(Entry, EntryInsertPt, Loc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">    // Otherwise, just build the predicate state itself by zeroing a register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">    // as we don't need any initial state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="uncoveredLine">    PS->InitialReg = MRI->createVirtualRegister(PS->RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="uncoveredLine">    Register PredStateSubReg = MRI->createVirtualRegister(&X86::GR32RegClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="uncoveredLine">    auto ZeroI = BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::MOV32r0),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">                         PredStateSubReg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">    ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">    MachineOperand *ZeroEFLAGSDefOp =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="uncoveredLine">        ZeroI->findRegisterDefOperand(X86::EFLAGS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="uncoveredLine">    assert(ZeroEFLAGSDefOp && ZeroEFLAGSDefOp->isImplicit() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">           "Must have an implicit def of EFLAGS!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="uncoveredLine">    ZeroEFLAGSDefOp->setIsDead(true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="uncoveredLine">    BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::SUBREG_TO_REG),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="uncoveredLine">            PS->InitialReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="uncoveredLine">        .addImm(0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="uncoveredLine">        .addReg(PredStateSubReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="uncoveredLine">        .addImm(X86::sub_32bit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">  // We're going to need to trace predicate state throughout the function's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">  // CFG. Prepare for this by setting up our initial state of PHIs with unique</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">  // predecessor entries and all the initial predicate state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">  canonicalizePHIOperands(MF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">  // Track the updated values in an SSA updater to rewrite into SSA form at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">  // end.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="uncoveredLine">  PS->SSA.Initialize(PS->InitialReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="uncoveredLine">  PS->SSA.AddAvailableValue(&Entry, PS->InitialReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="">  // Trace through the CFG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="uncoveredLine">  auto CMovs = tracePredStateThroughCFG(MF, Infos);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">  // We may also enter basic blocks in this function via exception handling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">  // control flow. Here, if we are hardening interprocedurally, we need to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">  // re-capture the predicate state from the throwing code. In the Itanium ABI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">  // the throw will always look like a call to __cxa_throw and will have the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">  // predicate state in the stack pointer, so extract fresh predicate state from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">  // the stack pointer and make it available in SSA.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">  // FIXME: Handle non-itanium ABI EH models.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="uncoveredLine">  if (HardenInterprocedurally) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="uncoveredLine">    for (MachineBasicBlock &MBB : MF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="uncoveredLine">      assert(!MBB.isEHScopeEntry() && "Only Itanium ABI EH supported!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">      assert(!MBB.isEHFuncletEntry() && "Only Itanium ABI EH supported!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="uncoveredLine">      assert(!MBB.isCleanupFuncletEntry() && "Only Itanium ABI EH supported!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="uncoveredLine">      if (!MBB.isEHPad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">      PS->SSA.AddAvailableValue(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">          &MBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">          extractPredStateFromSP(MBB, MBB.SkipPHIsAndLabels(MBB.begin()), Loc));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">  if (HardenIndirectCallsAndJumps) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">    // If we are going to harden calls and jumps we need to unfold their memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="">    // operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="uncoveredLine">    unfoldCallAndJumpLoads(MF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">    // Then we trace predicate state through the indirect branches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="uncoveredLine">    auto IndirectBrCMovs = tracePredStateThroughIndirectBranches(MF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">    CMovs.append(IndirectBrCMovs.begin(), IndirectBrCMovs.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">  // Now that we have the predicate state available at the start of each block</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">  // in the CFG, trace it through each block, hardening vulnerable instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">  // as we go.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="uncoveredLine">  tracePredStateThroughBlocksAndHarden(MF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">  // Now rewrite all the uses of the pred state using the SSA updater to insert</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">  // PHIs connecting the state between blocks along the CFG edges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="uncoveredLine">  for (MachineInstr *CMovI : CMovs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="uncoveredLine">    for (MachineOperand &Op : CMovI->operands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">      if (!Op.isReg() || Op.getReg() != PS->InitialReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="uncoveredLine">      PS->SSA.RewriteUse(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Final speculative load hardened function:\n"; MF.dump();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">             dbgs() << "\n"; MF.verify(this));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">/// Implements the naive hardening approach of putting an LFENCE after every</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">/// potentially mis-predicted control flow construct.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">/// We include this as an alternative mostly for the purpose of comparison. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">/// performance impact of this is expected to be extremely severe and not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">/// practical for any real-world users.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="uncoveredLine">void X86SpeculativeLoadHardeningPass::hardenEdgesWithLFENCE(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">    MachineFunction &MF) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">  // First, we scan the function looking for blocks that are reached along edges</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">  // that we might want to harden.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="uncoveredLine">  SmallSetVector<MachineBasicBlock *, 8> Blocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="uncoveredLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">    // If there are no or only one successor, nothing to do here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="uncoveredLine">    if (MBB.succ_size() <= 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">    // Skip blocks unless their terminators start with a branch. Other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">    // terminators don't seem interesting for guarding against misspeculation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="uncoveredLine">    auto TermIt = MBB.getFirstTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="uncoveredLine">    if (TermIt == MBB.end() || !TermIt->isBranch())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">    // Add all the non-EH-pad succossors to the blocks we want to harden. We</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">    // skip EH pads because there isn't really a condition of interest on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">    // entering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="uncoveredLine">    for (MachineBasicBlock *SuccMBB : MBB.successors())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="uncoveredLine">      if (!SuccMBB->isEHPad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="uncoveredLine">        Blocks.insert(SuccMBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">  for (MachineBasicBlock *MBB : Blocks) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="uncoveredLine">    auto InsertPt = MBB->SkipPHIsAndLabels(MBB->begin());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">    BuildMI(*MBB, InsertPt, DebugLoc(), TII->get(X86::LFENCE));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">    ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="uncoveredLine">    ++NumLFENCEsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">SmallVector<X86SpeculativeLoadHardeningPass::BlockCondInfo, 16></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="uncoveredLine">X86SpeculativeLoadHardeningPass::collectBlockCondInfo(MachineFunction &MF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="uncoveredLine">  SmallVector<BlockCondInfo, 16> Infos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">  // Walk the function and build up a summary for each block's conditions that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">  // we need to trace through.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="uncoveredLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">    // If there are no or only one successor, nothing to do here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">    if (MBB.succ_size() <= 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">    // We want to reliably handle any conditional branch terminators in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">    // MBB, so we manually analyze the branch. We can handle all of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">    // permutations here, including ones that analyze branch cannot.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">    // The approach is to walk backwards across the terminators, resetting at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">    // any unconditional non-indirect branch, and track all conditional edges</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">    // to basic blocks as well as the fallthrough or unconditional successor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">    // edge. For each conditional edge, we track the target and the opposite</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">    // condition code in order to inject a "no-op" cmov into that successor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">    // that will harden the predicate. For the fallthrough/unconditional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">    // edge, we inject a separate cmov for each conditional branch with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">    // matching condition codes. This effectively implements an "and" of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">    // condition flags, even if there isn't a single condition flag that would</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">    // directly implement that. We don't bother trying to optimize either of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">    // these cases because if such an optimization is possible, LLVM should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">    // have optimized the conditional *branches* in that way already to reduce</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">    // instruction count. This late, we simply assume the minimal number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">    // branch instructions is being emitted and use that to guide our cmov</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="">    // insertion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="uncoveredLine">    BlockCondInfo Info = {&MBB, {}, nullptr};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">    // Now walk backwards through the terminators and build up successors they</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">    // reach and the conditions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">    for (MachineInstr &MI : llvm::reverse(MBB)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">      // Once we've handled all the terminators, we're done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="uncoveredLine">      if (!MI.isTerminator())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">      // If we see a non-branch terminator, we can't handle anything so bail.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="uncoveredLine">      if (!MI.isBranch()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="uncoveredLine">        Info.CondBrs.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">      // If we see an unconditional branch, reset our state, clear any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">      // fallthrough, and set this is the "else" successor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">      if (MI.getOpcode() == X86::JMP_1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="uncoveredLine">        Info.CondBrs.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="uncoveredLine">        Info.UncondBr = &MI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">      // If we get an invalid condition, we have an indirect branch or some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">      // other unanalyzable "fallthrough" case. We model this as a nullptr for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">      // the destination so we can still guard any conditional successors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">      // Consider code sequences like:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">      // ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">      //   jCC L1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">      //   jmpq *%rax</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">      // ```</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">      // We still want to harden the edge to `L1`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">      if (X86::getCondFromBranch(MI) == X86::COND_INVALID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">        Info.CondBrs.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="uncoveredLine">        Info.UncondBr = &MI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">      // We have a vanilla conditional branch, add it to our list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="uncoveredLine">      Info.CondBrs.push_back(&MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="uncoveredLine">    if (Info.CondBrs.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="uncoveredLine">      ++NumBranchesUntraced;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "WARNING: unable to secure successors of block:\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">                 MBB.dump());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">    Infos.push_back(Info);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="uncoveredLine">  return Infos;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">/// Trace the predicate state through the CFG, instrumenting each conditional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">/// branch such that misspeculation through an edge will poison the predicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">/// state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">/// Returns the list of inserted CMov instructions so that they can have their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">/// uses of the predicate state rewritten into proper SSA form once it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="">/// complete.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">SmallVector<MachineInstr *, 16></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">X86SpeculativeLoadHardeningPass::tracePredStateThroughCFG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">    MachineFunction &MF, ArrayRef<BlockCondInfo> Infos) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">  // Collect the inserted cmov instructions so we can rewrite their uses of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">  // predicate state into SSA form.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="uncoveredLine">  SmallVector<MachineInstr *, 16> CMovs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">  // Now walk all of the basic blocks looking for ones that end in conditional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">  // jumps where we need to update this register along each edge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">  for (const BlockCondInfo &Info : Infos) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">    MachineBasicBlock &MBB = *Info.MBB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">    const SmallVectorImpl<MachineInstr *> &CondBrs = Info.CondBrs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">    MachineInstr *UncondBr = Info.UncondBr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Tracing predicate through block: " << MBB.getName()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">                      << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="uncoveredLine">    ++NumCondBranchesTraced;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">    // Compute the non-conditional successor as either the target of any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">    // unconditional branch or the layout successor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">    MachineBasicBlock *UncondSucc =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">        UncondBr ? (UncondBr->getOpcode() == X86::JMP_1</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">                        ? UncondBr->getOperand(0).getMBB()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">                        : nullptr)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="uncoveredLine">                 : &*std::next(MachineFunction::iterator(&MBB));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">    // Count how many edges there are to any given successor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">    SmallDenseMap<MachineBasicBlock *, int> SuccCounts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">    if (UncondSucc)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="uncoveredLine">      ++SuccCounts[UncondSucc];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">    for (auto *CondBr : CondBrs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">      ++SuccCounts[CondBr->getOperand(0).getMBB()];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="">    // A lambda to insert cmov instructions into a block checking all of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">    // condition codes in a sequence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">    auto BuildCheckingBlockForSuccAndConds =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="uncoveredLine">        [&](MachineBasicBlock &MBB, MachineBasicBlock &Succ, int SuccCount,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">            MachineInstr *Br, MachineInstr *&UncondBr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">            ArrayRef<X86::CondCode> Conds) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">          // First, we split the edge to insert the checking block into a safe</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">          // location.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="">          auto &CheckingMBB =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="uncoveredLine">              (SuccCount == 1 && Succ.pred_size() == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="uncoveredLine">                  ? Succ</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="uncoveredLine">                  : splitEdge(MBB, Succ, SuccCount, Br, UncondBr, *TII);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="uncoveredLine">          bool LiveEFLAGS = Succ.isLiveIn(X86::EFLAGS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="uncoveredLine">          if (!LiveEFLAGS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="uncoveredLine">            CheckingMBB.addLiveIn(X86::EFLAGS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">          // Now insert the cmovs to implement the checks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">          auto InsertPt = CheckingMBB.begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">          assert((InsertPt == CheckingMBB.end() || !InsertPt->isPHI()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">                 "Should never have a PHI in the initial checking block as it "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">                 "always has a single predecessor!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">          // We will wire each cmov to each other, but need to start with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">          // incoming pred state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="uncoveredLine">          unsigned CurStateReg = PS->InitialReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="uncoveredLine">          for (X86::CondCode Cond : Conds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">            int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="uncoveredLine">            auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="uncoveredLine">            Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">            // Note that we intentionally use an empty debug location so that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">            // this picks up the preceding location.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">            auto CMovI = BuildMI(CheckingMBB, InsertPt, DebugLoc(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="uncoveredLine">                                 TII->get(CMovOp), UpdatedStateReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="uncoveredLine">                             .addReg(CurStateReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">                             .addReg(PS->PoisonReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="uncoveredLine">                             .addImm(Cond);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">            // If this is the last cmov and the EFLAGS weren't originally</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">            // live-in, mark them as killed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="uncoveredLine">            if (!LiveEFLAGS && Cond == Conds.back())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">              CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="uncoveredLine">            ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">            LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">                       dbgs() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">            // The first one of the cmovs will be using the top level</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">            // `PredStateReg` and need to get rewritten into SSA form.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="uncoveredLine">            if (CurStateReg == PS->InitialReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">              CMovs.push_back(&*CMovI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">            // The next cmov should start from this one's def.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="uncoveredLine">            CurStateReg = UpdatedStateReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">          // And put the last one into the available values for SSA form of our</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">          // predicate state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">          PS->SSA.AddAvailableValue(&CheckingMBB, CurStateReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">        };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="uncoveredLine">    std::vector<X86::CondCode> UncondCodeSeq;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">    for (auto *CondBr : CondBrs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">      MachineBasicBlock &Succ = *CondBr->getOperand(0).getMBB();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">      int &SuccCount = SuccCounts[&Succ];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="uncoveredLine">      X86::CondCode Cond = X86::getCondFromBranch(*CondBr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="uncoveredLine">      X86::CondCode InvCond = X86::GetOppositeBranchCondition(Cond);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="uncoveredLine">      UncondCodeSeq.push_back(Cond);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">      BuildCheckingBlockForSuccAndConds(MBB, Succ, SuccCount, CondBr, UncondBr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">                                        {InvCond});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">      // Decrement the successor count now that we've split one of the edges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">      // We need to keep the count of edges to the successor accurate in order</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">      // to know above when to *replace* the successor in the CFG vs. just</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="">      // adding the new successor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">      --SuccCount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">    // Since we may have split edges and changed the number of successors,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">    // normalize the probabilities. This avoids doing it each time we split an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="">    // edge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">    MBB.normalizeSuccProbs();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">    // Finally, we need to insert cmovs into the "fallthrough" edge. Here, we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">    // need to intersect the other condition codes. We can do this by just</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">    // doing a cmov for each one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="uncoveredLine">    if (!UncondSucc)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">      // If we have no fallthrough to protect (perhaps it is an indirect jump?)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">      // just skip this and continue.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="uncoveredLine">    assert(SuccCounts[UncondSucc] == 1 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">           "We should never have more than one edge to the unconditional "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">           "successor at this point because every other edge must have been "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">           "split above!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">    // Sort and unique the codes to minimize them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">    llvm::sort(UncondCodeSeq);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="uncoveredLine">    UncondCodeSeq.erase(std::unique(UncondCodeSeq.begin(), UncondCodeSeq.end()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="uncoveredLine">                        UncondCodeSeq.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">    // Build a checking version of the successor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">    BuildCheckingBlockForSuccAndConds(MBB, *UncondSucc, /*SuccCount*/ 1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="">                                      UncondBr, UncondBr, UncondCodeSeq);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="uncoveredLine">  return CMovs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">/// Compute the register class for the unfolded load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">/// FIXME: This should probably live in X86InstrInfo, potentially by adding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">/// a way to unfold into a newly created vreg rather than requiring a register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">/// input.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">static const TargetRegisterClass *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">getRegClassForUnfoldedLoad(MachineFunction &MF, const X86InstrInfo &TII,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">                           unsigned Opcode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">  unsigned Index;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">  unsigned UnfoldedOpc = TII.getOpcodeAfterMemoryUnfold(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">      Opcode, /*UnfoldLoad*/ true, /*UnfoldStore*/ false, &Index);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="uncoveredLine">  const MCInstrDesc &MCID = TII.get(UnfoldedOpc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">  return TII.getRegClass(MCID, Index, &TII.getRegisterInfo(), MF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="uncoveredLine">void X86SpeculativeLoadHardeningPass::unfoldCallAndJumpLoads(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">    MachineFunction &MF) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="uncoveredLine">  for (MachineBasicBlock &MBB : MF)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">    // We use make_early_inc_range here so we can remove instructions if needed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">    // without disturbing the iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">    for (MachineInstr &MI : llvm::make_early_inc_range(MBB.instrs())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">      // Must either be a call or a branch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="uncoveredLine">      if (!MI.isCall() && !MI.isBranch())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">      // We only care about loading variants of these instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="uncoveredLine">      if (!MI.mayLoad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="uncoveredLine">      switch (MI.getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">      default: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">        LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">            dbgs() << "ERROR: Found an unexpected loading branch or call "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">                      "instruction:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="">            MI.dump(); dbgs() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">        report_fatal_error("Unexpected loading branch or call!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="uncoveredLine">      case X86::FARCALL16m:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="">      case X86::FARCALL32m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">      case X86::FARCALL64m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">      case X86::FARJMP16m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="">      case X86::FARJMP32m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">      case X86::FARJMP64m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">        // We cannot mitigate far jumps or calls, but we also don't expect them</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="">        // to be vulnerable to Spectre v1.2 style attacks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="uncoveredLine">      case X86::CALL16m:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">      case X86::CALL16m_NT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">      case X86::CALL32m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">      case X86::CALL32m_NT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">      case X86::CALL64m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">      case X86::CALL64m_NT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">      case X86::JMP16m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">      case X86::JMP16m_NT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">      case X86::JMP32m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">      case X86::JMP32m_NT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">      case X86::JMP64m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="">      case X86::JMP64m_NT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">      case X86::TAILJMPm64:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">      case X86::TAILJMPm64_REX:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">      case X86::TAILJMPm:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">      case X86::TCRETURNmi64:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">      case X86::TCRETURNmi: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">        // Use the generic unfold logic now that we know we're dealing with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">        // expected instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="">        // FIXME: We don't have test coverage for all of these!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="uncoveredLine">        auto *UnfoldedRC = getRegClassForUnfoldedLoad(MF, *TII, MI.getOpcode());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="uncoveredLine">        if (!UnfoldedRC) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">                         << "ERROR: Unable to unfold load from instruction:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">                     MI.dump(); dbgs() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="uncoveredLine">          report_fatal_error("Unable to unfold load!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="uncoveredLine">        Register Reg = MRI->createVirtualRegister(UnfoldedRC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">        SmallVector<MachineInstr *, 2> NewMIs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">        // If we were able to compute an unfolded reg class, any failure here</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">        // is just a programming error so just assert.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">        bool Unfolded =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="uncoveredLine">            TII->unfoldMemoryOperand(MF, MI, Reg, /*UnfoldLoad*/ true,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="">                                     /*UnfoldStore*/ false, NewMIs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="">        (void)Unfolded;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">        assert(Unfolded &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="">               "Computed unfolded register class but failed to unfold");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="">        // Now stitch the new instructions into place and erase the old one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">        for (auto *NewMI : NewMIs)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="uncoveredLine">          MBB.insert(MI.getIterator(), NewMI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="">        // Update the call site info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">        if (MI.isCandidateForCallSiteEntry())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="uncoveredLine">          MF.eraseCallSiteInfo(&MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">        MI.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="uncoveredLine">        LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">          dbgs() << "Unfolded load successfully into:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">          for (auto *NewMI : NewMIs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">            NewMI->dump();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">            dbgs() << "\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">        });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">      llvm_unreachable("Escaped switch with default!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">/// Trace the predicate state through indirect branches, instrumenting them to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">/// poison the state if a target is reached that does not match the expected</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">/// target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">/// This is designed to mitigate Spectre variant 1 attacks where an indirect</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">/// branch is trained to predict a particular target and then mispredicts that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">/// target in a way that can leak data. Despite using an indirect branch, this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="">/// is really a variant 1 style attack: it does not steer execution to an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">/// arbitrary or attacker controlled address, and it does not require any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">/// special code executing next to the victim. This attack can also be mitigated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="">/// through retpolines, but those require either replacing indirect branches</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">/// with conditional direct branches or lowering them through a device that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">/// blocks speculation. This mitigation can replace these retpoline-style</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">/// mitigations for jump tables and other indirect branches within a function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">/// when variant 2 isn't a risk while allowing limited speculation. Indirect</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">/// calls, however, cannot be mitigated through this technique without changing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">/// the ABI in a fundamental way.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">SmallVector<MachineInstr *, 16></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">X86SpeculativeLoadHardeningPass::tracePredStateThroughIndirectBranches(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">    MachineFunction &MF) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">  // We use the SSAUpdater to insert PHI nodes for the target addresses of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">  // indirect branches. We don't actually need the full power of the SSA updater</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="">  // in this particular case as we always have immediately available values, but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="">  // this avoids us having to re-implement the PHI construction logic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="uncoveredLine">  MachineSSAUpdater TargetAddrSSA(MF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="uncoveredLine">  TargetAddrSSA.Initialize(MRI->createVirtualRegister(&X86::GR64RegClass));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="">  // Track which blocks were terminated with an indirect branch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="uncoveredLine">  SmallPtrSet<MachineBasicBlock *, 4> IndirectTerminatedMBBs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">  // We need to know what blocks end up reached via indirect branches. We</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="">  // expect this to be a subset of those whose address is taken and so track it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">  // directly via the CFG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">  SmallPtrSet<MachineBasicBlock *, 4> IndirectTargetMBBs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">  // Walk all the blocks which end in an indirect branch and make the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="">  // target address available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="uncoveredLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">    // Find the last terminator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="uncoveredLine">    auto MII = MBB.instr_rbegin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="uncoveredLine">    while (MII != MBB.instr_rend() && MII->isDebugInstr())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="uncoveredLine">      ++MII;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="uncoveredLine">    if (MII == MBB.instr_rend())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="uncoveredLine">    MachineInstr &TI = *MII;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="uncoveredLine">    if (!TI.isTerminator() || !TI.isBranch())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="">      // No terminator or non-branch terminator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">    unsigned TargetReg;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="uncoveredLine">    switch (TI.getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">      // Direct branch or conditional branch (leading to fallthrough).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="uncoveredLine">    case X86::FARJMP16m:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">    case X86::FARJMP32m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="">    case X86::FARJMP64m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">      // We cannot mitigate far jumps or calls, but we also don't expect them</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">      // to be vulnerable to Spectre v1.2 or v2 (self trained) style attacks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="uncoveredLine">    case X86::JMP16m:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">    case X86::JMP16m_NT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">    case X86::JMP32m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="">    case X86::JMP32m_NT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="">    case X86::JMP64m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="">    case X86::JMP64m_NT:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="">      // Mostly as documentation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="uncoveredLine">      report_fatal_error("Memory operand jumps should have been unfolded!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="uncoveredLine">    case X86::JMP16r:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="uncoveredLine">      report_fatal_error(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">          "Support for 16-bit indirect branches is not implemented.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">    case X86::JMP32r:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">      report_fatal_error(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="">          "Support for 32-bit indirect branches is not implemented.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="uncoveredLine">    case X86::JMP64r:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="uncoveredLine">      TargetReg = TI.getOperand(0).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">    // We have definitely found an indirect  branch. Verify that there are no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">    // preceding conditional branches as we don't yet support that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="uncoveredLine">    if (llvm::any_of(MBB.terminators(), [&](MachineInstr &OtherTI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="uncoveredLine">          return !OtherTI.isDebugInstr() && &OtherTI != &TI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="">        })) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">      LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="">        dbgs() << "ERROR: Found other terminators in a block with an indirect "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">                  "branch! This is not yet supported! Terminator sequence:\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">        for (MachineInstr &MI : MBB.terminators()) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">          MI.dump();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">          dbgs() << '\n';</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">      });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">      report_fatal_error("Unimplemented terminator sequence!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="">    // Make the target register an available value for this block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="uncoveredLine">    TargetAddrSSA.AddAvailableValue(&MBB, TargetReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="uncoveredLine">    IndirectTerminatedMBBs.insert(&MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">    // Add all the successors to our target candidates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="uncoveredLine">    for (MachineBasicBlock *Succ : MBB.successors())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="uncoveredLine">      IndirectTargetMBBs.insert(Succ);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">  // Keep track of the cmov instructions we insert so we can return them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="uncoveredLine">  SmallVector<MachineInstr *, 16> CMovs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="">  // If we didn't find any indirect branches with targets, nothing to do here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="uncoveredLine">  if (IndirectTargetMBBs.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="uncoveredLine">    return CMovs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">  // We found indirect branches and targets that need to be instrumented to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">  // harden loads within them. Walk the blocks of the function (to get a stable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  // ordering) and instrument each target of an indirect branch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="uncoveredLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">    // Skip the blocks that aren't candidate targets.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="uncoveredLine">    if (!IndirectTargetMBBs.count(&MBB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="">    // We don't expect EH pads to ever be reached via an indirect branch. If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">    // this is desired for some reason, we could simply skip them here rather</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">    // than asserting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="uncoveredLine">    assert(!MBB.isEHPad() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="">           "Unexpected EH pad as target of an indirect branch!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">    // We should never end up threading EFLAGS into a block to harden</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">    // conditional jumps as there would be an additional successor via the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="">    // indirect branch. As a consequence, all such edges would be split before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">    // reaching here, and the inserted block will handle the EFLAGS-based</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="">    // hardening.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">    assert(!MBB.isLiveIn(X86::EFLAGS) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">           "Cannot check within a block that already has live-in EFLAGS!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">    // We can't handle having non-indirect edges into this block unless this is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="">    // the only successor and we can synthesize the necessary target address.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="uncoveredLine">    for (MachineBasicBlock *Pred : MBB.predecessors()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="">      // If we've already handled this by extracting the target directly,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="">      // nothing to do.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">      if (IndirectTerminatedMBBs.count(Pred))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">      // Otherwise, we have to be the only successor. We generally expect this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="">      // to be true as conditional branches should have had a critical edge</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">      // split already. We don't however need to worry about EH pad successors</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="">      // as they'll happily ignore the target and their hardening strategy is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="">      // resilient to all ways in which they could be reached speculatively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="uncoveredLine">      if (!llvm::all_of(Pred->successors(), [&](MachineBasicBlock *Succ) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">            return Succ->isEHPad() || Succ == &MBB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="">          })) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="uncoveredLine">        LLVM_DEBUG({</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">          dbgs() << "ERROR: Found conditional entry to target of indirect "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="">                    "branch!\n";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="">          Pred->dump();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="">          MBB.dump();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="">        });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="uncoveredLine">        report_fatal_error("Cannot harden a conditional entry to a target of "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="">                           "an indirect branch!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="">      // Now we need to compute the address of this block and install it as a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="">      // synthetic target in the predecessor. We do this at the bottom of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">      // predecessor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">      auto InsertPt = Pred->getFirstTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="uncoveredLine">      Register TargetReg = MRI->createVirtualRegister(&X86::GR64RegClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="uncoveredLine">      if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="uncoveredLine">          !Subtarget->isPositionIndependent()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">        // Directly materialize it into an immediate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="uncoveredLine">        auto AddrI = BuildMI(*Pred, InsertPt, DebugLoc(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="uncoveredLine">                             TII->get(X86::MOV64ri32), TargetReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="uncoveredLine">                         .addMBB(&MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="uncoveredLine">        ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">        (void)AddrI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "  Inserting mov: "; AddrI->dump();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">                   dbgs() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="uncoveredLine">        auto AddrI = BuildMI(*Pred, InsertPt, DebugLoc(), TII->get(X86::LEA64r),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="">                             TargetReg)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="uncoveredLine">                         .addReg(/*Base*/ X86::RIP)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="uncoveredLine">                         .addImm(/*Scale*/ 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="uncoveredLine">                         .addReg(/*Index*/ 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="uncoveredLine">                         .addMBB(&MBB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">                         .addReg(/*Segment*/ 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">        ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="">        (void)AddrI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "  Inserting lea: "; AddrI->dump();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="">                   dbgs() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="">      // And make this available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="uncoveredLine">      TargetAddrSSA.AddAvailableValue(Pred, TargetReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">    // Materialize the needed SSA value of the target. Note that we need the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">    // middle of the block as this block might at the bottom have an indirect</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="">    // branch back to itself. We can do this here because at this point, every</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="">    // predecessor of this block has an available value. This is basically just</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">    // automating the construction of a PHI node for this target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="uncoveredLine">    Register TargetReg = TargetAddrSSA.GetValueInMiddleOfBlock(&MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">    // Insert a comparison of the incoming target register with this block's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">    // address. This also requires us to mark the block as having its address</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">    // taken explicitly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="uncoveredLine">    MBB.setMachineBlockAddressTaken();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">    auto InsertPt = MBB.SkipPHIsLabelsAndDebug(MBB.begin());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="uncoveredLine">    if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">        !Subtarget->isPositionIndependent()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="">      // Check directly against a relocated immediate when we can.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="uncoveredLine">      auto CheckI = BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::CMP64ri32))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="uncoveredLine">                        .addReg(TargetReg, RegState::Kill)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="uncoveredLine">                        .addMBB(&MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">      ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="">      (void)CheckI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Inserting cmp: "; CheckI->dump(); dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="">      // Otherwise compute the address into a register first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="uncoveredLine">      Register AddrReg = MRI->createVirtualRegister(&X86::GR64RegClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="">      auto AddrI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="uncoveredLine">          BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::LEA64r), AddrReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="uncoveredLine">              .addReg(/*Base*/ X86::RIP)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="uncoveredLine">              .addImm(/*Scale*/ 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">              .addReg(/*Index*/ 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="uncoveredLine">              .addMBB(&MBB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">              .addReg(/*Segment*/ 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">      ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="">      (void)AddrI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Inserting lea: "; AddrI->dump(); dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">      auto CheckI = BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::CMP64rr))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="uncoveredLine">                        .addReg(TargetReg, RegState::Kill)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">                        .addReg(AddrReg, RegState::Kill);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="uncoveredLine">      ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="">      (void)CheckI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Inserting cmp: "; CheckI->dump(); dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="">    // Now cmov over the predicate if the comparison wasn't equal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="uncoveredLine">    int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="uncoveredLine">    auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">    Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">    auto CMovI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="uncoveredLine">        BuildMI(MBB, InsertPt, DebugLoc(), TII->get(CMovOp), UpdatedStateReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="uncoveredLine">            .addReg(PS->InitialReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="uncoveredLine">            .addReg(PS->PoisonReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="uncoveredLine">            .addImm(X86::COND_NE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="uncoveredLine">    CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="uncoveredLine">    ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump(); dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="uncoveredLine">    CMovs.push_back(&*CMovI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="">    // And put the new value into the available values for SSA form of our</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="">    // predicate state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">    PS->SSA.AddAvailableValue(&MBB, UpdatedStateReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">  // Return all the newly inserted cmov instructions of the predicate state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="uncoveredLine">  return CMovs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">// Returns true if the MI has EFLAGS as a register def operand and it's live,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="">// otherwise it returns false</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">static bool isEFLAGSDefLive(const MachineInstr &MI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">  if (const MachineOperand *DefOp = MI.findRegisterDefOperand(X86::EFLAGS)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="uncoveredLine">    return !DefOp->isDead();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="uncoveredLine">static bool isEFLAGSLive(MachineBasicBlock &MBB, MachineBasicBlock::iterator I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">                         const TargetRegisterInfo &TRI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">  // Check if EFLAGS are alive by seeing if there is a def of them or they</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">  // live-in, and then seeing if that def is in turn used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="uncoveredLine">  for (MachineInstr &MI : llvm::reverse(llvm::make_range(MBB.begin(), I))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="uncoveredLine">    if (MachineOperand *DefOp = MI.findRegisterDefOperand(X86::EFLAGS)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">      // If the def is dead, then EFLAGS is not live.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="uncoveredLine">      if (DefOp->isDead())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="">      // Otherwise we've def'ed it, and it is live.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="">    // While at this instruction, also check if we use and kill EFLAGS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">    // which means it isn't live.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="uncoveredLine">    if (MI.killsRegister(X86::EFLAGS, &TRI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="">  // If we didn't find anything conclusive (neither definitely alive or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="">  // definitely dead) return whether it lives into the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="uncoveredLine">  return MBB.isLiveIn(X86::EFLAGS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">/// Trace the predicate state through each of the blocks in the function,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">/// hardening everything necessary along the way.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="">/// We call this routine once the initial predicate state has been established</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">/// for each basic block in the function in the SSA updater. This routine traces</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">/// it through the instructions within each basic block, and for non-returning</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="">/// blocks informs the SSA updater about the final state that lives out of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">/// block. Along the way, it hardens any vulnerable instruction using the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">/// currently valid predicate state. We have to do these two things together</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">/// because the SSA updater only works across blocks. Within a block, we track</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">/// the current predicate state directly and update it as it changes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">/// This operates in two passes over each block. First, we analyze the loads in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">/// the block to determine which strategy will be used to harden them: hardening</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">/// the address or hardening the loaded value when loaded into a register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">/// amenable to hardening. We have to process these first because the two</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">/// strategies may interact -- later hardening may change what strategy we wish</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">/// to use. We also will analyze data dependencies between loads and avoid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">/// hardening those loads that are data dependent on a load with a hardened</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">/// address. We also skip hardening loads already behind an LFENCE as that is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">/// sufficient to harden them against misspeculation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">/// Second, we actively trace the predicate state through the block, applying</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">/// the hardening steps we determined necessary in the first pass as we go.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="">/// These two passes are applied to each basic block. We operate one block at a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="">/// time to simplify reasoning about reachability and sequencing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="uncoveredLine">void X86SpeculativeLoadHardeningPass::tracePredStateThroughBlocksAndHarden(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">    MachineFunction &MF) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="uncoveredLine">  SmallPtrSet<MachineInstr *, 16> HardenPostLoad;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="uncoveredLine">  SmallPtrSet<MachineInstr *, 16> HardenLoadAddr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">  SmallSet<unsigned, 16> HardenedAddrRegs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="uncoveredLine">  SmallDenseMap<unsigned, unsigned, 32> AddrRegToHardenedReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="">  // Track the set of load-dependent registers through the basic block. Because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="">  // the values of these registers have an existing data dependency on a loaded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">  // value which we would have checked, we can omit any checks on them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="uncoveredLine">  SparseBitVector<> LoadDepRegs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="uncoveredLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">    // The first pass over the block: collect all the loads which can have their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">    // loaded value hardened and all the loads that instead need their address</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">    // hardened. During this walk we propagate load dependence for address</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">    // hardened loads and also look for LFENCE to stop hardening wherever</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">    // possible. When deciding whether or not to harden the loaded value or not,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">    // we check to see if any registers used in the address will have been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">    // hardened at this point and if so, harden any remaining address registers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="">    // as that often successfully re-uses hardened addresses and minimizes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">    // instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">    // FIXME: We should consider an aggressive mode where we continue to keep as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">    // many loads value hardened even when some address register hardening would</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">    // be free (due to reuse).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">    // Note that we only need this pass if we are actually hardening loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="uncoveredLine">    if (HardenLoads)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="uncoveredLine">      for (MachineInstr &MI : MBB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="">        // We naively assume that all def'ed registers of an instruction have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">        // a data dependency on all of their operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">        // FIXME: Do a more careful analysis of x86 to build a conservative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">        // model here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="uncoveredLine">        if (llvm::any_of(MI.uses(), [&](MachineOperand &Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="uncoveredLine">              return Op.isReg() && LoadDepRegs.test(Op.getReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">            }))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">          for (MachineOperand &Def : MI.defs())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="uncoveredLine">            if (Def.isReg())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="uncoveredLine">              LoadDepRegs.set(Def.getReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">        // Both Intel and AMD are guiding that they will change the semantics of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">        // LFENCE to be a speculation barrier, so if we see an LFENCE, there is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">        // no more need to guard things in this block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="uncoveredLine">        if (MI.getOpcode() == X86::LFENCE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="">        // If this instruction cannot load, nothing to do.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="uncoveredLine">        if (!MI.mayLoad())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">        // Some instructions which "load" are trivially safe or unimportant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="uncoveredLine">        if (MI.getOpcode() == X86::MFENCE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">        // Extract the memory operand information about this instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">        // FIXME: This doesn't handle loading pseudo instructions which we often</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">        // could handle with similarly generic logic. We probably need to add an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">        // MI-layer routine similar to the MC-layer one we use here which maps</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">        // pseudos much like this maps real instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="uncoveredLine">        const MCInstrDesc &Desc = MI.getDesc();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="uncoveredLine">        int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="uncoveredLine">        if (MemRefBeginIdx < 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="">                         << "WARNING: unable to harden loading instruction: ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="">                     MI.dump());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="uncoveredLine">        MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="">        MachineOperand &BaseMO =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="uncoveredLine">            MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="">        MachineOperand &IndexMO =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="uncoveredLine">            MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="">        // If we have at least one (non-frame-index, non-RIP) register operand,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">        // and neither operand is load-dependent, we need to check the load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="uncoveredLine">        unsigned BaseReg = 0, IndexReg = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="uncoveredLine">        if (!BaseMO.isFI() && BaseMO.getReg() != X86::RIP &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="uncoveredLine">            BaseMO.getReg() != X86::NoRegister)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="uncoveredLine">          BaseReg = BaseMO.getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="uncoveredLine">        if (IndexMO.getReg() != X86::NoRegister)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="uncoveredLine">          IndexReg = IndexMO.getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">        if (!BaseReg && !IndexReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="">          // No register operands!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="">        // If any register operand is dependent, this load is dependent and we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="">        // needn't check it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="">        // FIXME: Is this true in the case where we are hardening loads after</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="">        // they complete? Unclear, need to investigate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="uncoveredLine">        if ((BaseReg && LoadDepRegs.test(BaseReg)) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="uncoveredLine">            (IndexReg && LoadDepRegs.test(IndexReg)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="">        // If post-load hardening is enabled, this load is compatible with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">        // post-load hardening, and we aren't already going to harden one of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">        // address registers, queue it up to be hardened post-load. Notably,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">        // even once hardened this won't introduce a useful dependency that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="">        // could prune out subsequent loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="uncoveredLine">        if (EnablePostLoadHardening && X86InstrInfo::isDataInvariantLoad(MI) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="uncoveredLine">            !isEFLAGSDefLive(MI) && MI.getDesc().getNumDefs() == 1 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="uncoveredLine">            MI.getOperand(0).isReg() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="uncoveredLine">            canHardenRegister(MI.getOperand(0).getReg()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">            !HardenedAddrRegs.count(BaseReg) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">            !HardenedAddrRegs.count(IndexReg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="uncoveredLine">          HardenPostLoad.insert(&MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="uncoveredLine">          HardenedAddrRegs.insert(MI.getOperand(0).getReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">        // Record this instruction for address hardening and record its register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="">        // operands as being address-hardened.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="uncoveredLine">        HardenLoadAddr.insert(&MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="uncoveredLine">        if (BaseReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="uncoveredLine">          HardenedAddrRegs.insert(BaseReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="uncoveredLine">        if (IndexReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="uncoveredLine">          HardenedAddrRegs.insert(IndexReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="uncoveredLine">        for (MachineOperand &Def : MI.defs())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="uncoveredLine">          if (Def.isReg())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="uncoveredLine">            LoadDepRegs.set(Def.getReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">    // Now re-walk the instructions in the basic block, and apply whichever</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="">    // hardening strategy we have elected. Note that we do this in a second</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="">    // pass specifically so that we have the complete set of instructions for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">    // which we will do post-load hardening and can defer it in certain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">    // circumstances.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="uncoveredLine">    for (MachineInstr &MI : MBB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="uncoveredLine">      if (HardenLoads) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="">        // We cannot both require hardening the def of a load and its address.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="uncoveredLine">        assert(!(HardenLoadAddr.count(&MI) && HardenPostLoad.count(&MI)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">               "Requested to harden both the address and def of a load!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="">        // Check if this is a load whose address needs to be hardened.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="uncoveredLine">        if (HardenLoadAddr.erase(&MI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="uncoveredLine">          const MCInstrDesc &Desc = MI.getDesc();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="uncoveredLine">          int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="uncoveredLine">          assert(MemRefBeginIdx >= 0 && "Cannot have an invalid index here!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="uncoveredLine">          MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="">          MachineOperand &BaseMO =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="uncoveredLine">              MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="">          MachineOperand &IndexMO =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="uncoveredLine">              MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="uncoveredLine">          hardenLoadAddr(MI, BaseMO, IndexMO, AddrRegToHardenedReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="uncoveredLine">        }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">        // Test if this instruction is one of our post load instructions (and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">        // remove it from the set if so).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="uncoveredLine">        if (HardenPostLoad.erase(&MI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="uncoveredLine">          assert(!MI.isCall() && "Must not try to post-load harden a call!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="">          // If this is a data-invariant load and there is no EFLAGS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">          // interference, we want to try and sink any hardening as far as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="">          // possible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="uncoveredLine">          if (X86InstrInfo::isDataInvariantLoad(MI) && !isEFLAGSDefLive(MI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="">            // Sink the instruction we'll need to harden as far as we can down</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">            // the graph.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="uncoveredLine">            MachineInstr *SunkMI = sinkPostLoadHardenedInst(MI, HardenPostLoad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">            // If we managed to sink this instruction, update everything so we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="">            // harden that instruction when we reach it in the instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">            // sequence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="uncoveredLine">            if (SunkMI != &MI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="">              // If in sinking there was no instruction needing to be hardened,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="">              // we're done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="uncoveredLine">              if (!SunkMI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="uncoveredLine">                continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="">              // Otherwise, add this to the set of defs we harden.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="uncoveredLine">              HardenPostLoad.insert(SunkMI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="">            }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="uncoveredLine">          unsigned HardenedReg = hardenPostLoad(MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="">          // Mark the resulting hardened register as such so we don't re-harden.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="uncoveredLine">          AddrRegToHardenedReg[HardenedReg] = HardenedReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="uncoveredLine">        }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="">        // Check for an indirect call or branch that may need its input hardened</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="">        // even if we couldn't find the specific load used, or were able to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="">        // avoid hardening it for some reason. Note that here we cannot break</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="">        // out afterward as we may still need to handle any call aspect of this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">        // instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="uncoveredLine">        if ((MI.isCall() || MI.isBranch()) && HardenIndirectCallsAndJumps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">          hardenIndirectCallOrJumpInstr(MI, AddrRegToHardenedReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">      // After we finish hardening loads we handle interprocedural hardening if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">      // enabled and relevant for this instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="uncoveredLine">      if (!HardenInterprocedurally)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="uncoveredLine">      if (!MI.isCall() && !MI.isReturn())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="">      // If this is a direct return (IE, not a tail call) just directly harden</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="">      // it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="uncoveredLine">      if (MI.isReturn() && !MI.isCall()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="uncoveredLine">        hardenReturnInstr(MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="">      // Otherwise we have a call. We need to handle transferring the predicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">      // state into a call and recovering it after the call returns (unless this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="">      // is a tail call).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="uncoveredLine">      assert(MI.isCall() && "Should only reach here for calls!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="uncoveredLine">      tracePredStateThroughCall(MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="uncoveredLine">    HardenPostLoad.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="uncoveredLine">    HardenLoadAddr.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="uncoveredLine">    HardenedAddrRegs.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="uncoveredLine">    AddrRegToHardenedReg.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">    // Currently, we only track data-dependent loads within a basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">    // FIXME: We should see if this is necessary or if we could be more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="">    // aggressive here without opening up attack avenues.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="uncoveredLine">    LoadDepRegs.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="">/// Save EFLAGS into the returned GPR. This can in turn be restored with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="">/// `restoreEFLAGS`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="">/// Note that LLVM can only lower very simple patterns of saved and restored</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="">/// EFLAGS registers. The restore should always be within the same basic block</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="">/// as the save so that no PHI nodes are inserted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="uncoveredLine">unsigned X86SpeculativeLoadHardeningPass::saveEFLAGS(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="">    const DebugLoc &Loc) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="">  // FIXME: Hard coding this to a 32-bit register class seems weird, but matches</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">  // what instruction selection does.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="uncoveredLine">  Register Reg = MRI->createVirtualRegister(&X86::GR32RegClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="">  // We directly copy the FLAGS register and rely on later lowering to clean</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="">  // this up into the appropriate setCC instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="uncoveredLine">  BuildMI(MBB, InsertPt, Loc, TII->get(X86::COPY), Reg).addReg(X86::EFLAGS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="uncoveredLine">  ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">  return Reg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">/// Restore EFLAGS from the provided GPR. This should be produced by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="">/// `saveEFLAGS`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="">/// This must be done within the same basic block as the save in order to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="">/// reliably lower.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="uncoveredLine">void X86SpeculativeLoadHardeningPass::restoreEFLAGS(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">    const DebugLoc &Loc, Register Reg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="uncoveredLine">  BuildMI(MBB, InsertPt, Loc, TII->get(X86::COPY), X86::EFLAGS).addReg(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="uncoveredLine">  ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">/// Takes the current predicate state (in a register) and merges it into the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">/// stack pointer. The state is essentially a single bit, but we merge this in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="">/// a way that won't form non-canonical pointers and also will be preserved</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="">/// across normal stack adjustments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="uncoveredLine">void X86SpeculativeLoadHardeningPass::mergePredStateIntoSP(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="">    const DebugLoc &Loc, unsigned PredStateReg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="uncoveredLine">  Register TmpReg = MRI->createVirtualRegister(PS->RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="">  // FIXME: This hard codes a shift distance based on the number of bits needed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="">  // to stay canonical on 64-bit. We should compute this somehow and support</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="">  // 32-bit as part of that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="uncoveredLine">  auto ShiftI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::SHL64ri), TmpReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="uncoveredLine">                    .addReg(PredStateReg, RegState::Kill)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">                    .addImm(47);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="uncoveredLine">  ShiftI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="uncoveredLine">  ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="uncoveredLine">  auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::OR64rr), X86::RSP)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="uncoveredLine">                 .addReg(X86::RSP)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="uncoveredLine">                 .addReg(TmpReg, RegState::Kill);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="uncoveredLine">  OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="uncoveredLine">  ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="">/// Extracts the predicate state stored in the high bits of the stack pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="uncoveredLine">unsigned X86SpeculativeLoadHardeningPass::extractPredStateFromSP(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="">    const DebugLoc &Loc) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="uncoveredLine">  Register PredStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="uncoveredLine">  Register TmpReg = MRI->createVirtualRegister(PS->RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="">  // We know that the stack pointer will have any preserved predicate state in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">  // its high bit. We just want to smear this across the other bits. Turns out,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="">  // this is exactly what an arithmetic right shift does.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="uncoveredLine">  BuildMI(MBB, InsertPt, Loc, TII->get(TargetOpcode::COPY), TmpReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="uncoveredLine">      .addReg(X86::RSP);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="">  auto ShiftI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="uncoveredLine">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::SAR64ri), PredStateReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="uncoveredLine">          .addReg(TmpReg, RegState::Kill)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="uncoveredLine">          .addImm(TRI->getRegSizeInBits(*PS->RC) - 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="uncoveredLine">  ShiftI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="uncoveredLine">  ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="uncoveredLine">  return PredStateReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="uncoveredLine">void X86SpeculativeLoadHardeningPass::hardenLoadAddr(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="">    MachineInstr &MI, MachineOperand &BaseMO, MachineOperand &IndexMO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="">    SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="uncoveredLine">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="uncoveredLine">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="">  // Check if EFLAGS are alive by seeing if there is a def of them or they</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="">  // live-in, and then seeing if that def is in turn used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="uncoveredLine">  bool EFLAGSLive = isEFLAGSLive(MBB, MI.getIterator(), *TRI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="uncoveredLine">  SmallVector<MachineOperand *, 2> HardenOpRegs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="uncoveredLine">  if (BaseMO.isFI()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="">    // A frame index is never a dynamically controllable load, so only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="">    // harden it if we're covering fixed address loads as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="uncoveredLine">    LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="">        dbgs() << "  Skipping hardening base of explicit stack frame load: ";</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="">        MI.dump(); dbgs() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="uncoveredLine">  } else if (BaseMO.getReg() == X86::RSP) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="">    // Some idempotent atomic operations are lowered directly to a locked</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="">    // OR with 0 to the top of stack(or slightly offset from top) which uses an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="">    // explicit RSP register as the base.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="uncoveredLine">    assert(IndexMO.getReg() == X86::NoRegister &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="">           "Explicit RSP access with dynamic index!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="uncoveredLine">    LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="">        dbgs() << "  Cannot harden base of explicit RSP offset in a load!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="uncoveredLine">  } else if (BaseMO.getReg() == X86::RIP ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="uncoveredLine">             BaseMO.getReg() == X86::NoRegister) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="">    // For both RIP-relative addressed loads or absolute loads, we cannot</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="">    // meaningfully harden them because the address being loaded has no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="">    // dynamic component.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="">    // FIXME: When using a segment base (like TLS does) we end up with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="">    // dynamic address being the base plus -1 because we can't mutate the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="">    // segment register here. This allows the signed 32-bit offset to point at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="">    // valid segment-relative addresses and load them successfully.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="uncoveredLine">    LLVM_DEBUG(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="">        dbgs() << "  Cannot harden base of "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="">               << (BaseMO.getReg() == X86::RIP ? "RIP-relative" : "no-base")</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="">               << " address in a load!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="uncoveredLine">    assert(BaseMO.isReg() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="">           "Only allowed to have a frame index or register base.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="uncoveredLine">    HardenOpRegs.push_back(&BaseMO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="uncoveredLine">  if (IndexMO.getReg() != X86::NoRegister &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="uncoveredLine">      (HardenOpRegs.empty() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="uncoveredLine">       HardenOpRegs.front()->getReg() != IndexMO.getReg()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="uncoveredLine">    HardenOpRegs.push_back(&IndexMO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="uncoveredLine">  assert((HardenOpRegs.size() == 1 || HardenOpRegs.size() == 2) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="">         "Should have exactly one or two registers to harden!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="uncoveredLine">  assert((HardenOpRegs.size() == 1 ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="">          HardenOpRegs[0]->getReg() != HardenOpRegs[1]->getReg()) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="">         "Should not have two of the same registers!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="">  // Remove any registers that have alreaded been checked.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="uncoveredLine">  llvm::erase_if(HardenOpRegs, [&](MachineOperand *Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="">    // See if this operand's register has already been checked.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="uncoveredLine">    auto It = AddrRegToHardenedReg.find(Op->getReg());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="uncoveredLine">    if (It == AddrRegToHardenedReg.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="">      // Not checked, so retain this one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="">    // Otherwise, we can directly update this operand and remove it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="uncoveredLine">    Op->setReg(It->second);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="">  // If there are none left, we're done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="uncoveredLine">  if (HardenOpRegs.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="">  // Compute the current predicate state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="uncoveredLine">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="uncoveredLine">  auto InsertPt = MI.getIterator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="">  // If EFLAGS are live and we don't have access to instructions that avoid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="">  // clobbering EFLAGS we need to save and restore them. This in turn makes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="">  // the EFLAGS no longer live.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="uncoveredLine">  unsigned FlagsReg = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">  if (EFLAGSLive && !Subtarget->hasBMI2()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="uncoveredLine">    EFLAGSLive = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="uncoveredLine">    FlagsReg = saveEFLAGS(MBB, InsertPt, Loc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="uncoveredLine">  for (MachineOperand *Op : HardenOpRegs) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="uncoveredLine">    Register OpReg = Op->getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="uncoveredLine">    auto *OpRC = MRI->getRegClass(OpReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="uncoveredLine">    Register TmpReg = MRI->createVirtualRegister(OpRC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="">    // If this is a vector register, we'll need somewhat custom logic to handle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="">    // hardening it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="uncoveredLine">    if (!Subtarget->hasVLX() && (OpRC->hasSuperClassEq(&X86::VR128RegClass) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="uncoveredLine">                                 OpRC->hasSuperClassEq(&X86::VR256RegClass))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="uncoveredLine">      assert(Subtarget->hasAVX2() && "AVX2-specific register classes!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="uncoveredLine">      bool Is128Bit = OpRC->hasSuperClassEq(&X86::VR128RegClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="">      // Move our state into a vector register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="">      // FIXME: We could skip this at the cost of longer encodings with AVX-512</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="">      // but that doesn't seem likely worth it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="uncoveredLine">      Register VStateReg = MRI->createVirtualRegister(&X86::VR128RegClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="">      auto MovI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="uncoveredLine">          BuildMI(MBB, InsertPt, Loc, TII->get(X86::VMOV64toPQIrr), VStateReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="uncoveredLine">              .addReg(StateReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="">      (void)MovI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="uncoveredLine">      ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Inserting mov: "; MovI->dump(); dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="">      // Broadcast it across the vector register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="uncoveredLine">      Register VBStateReg = MRI->createVirtualRegister(OpRC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="uncoveredLine">      auto BroadcastI = BuildMI(MBB, InsertPt, Loc,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="uncoveredLine">                                TII->get(Is128Bit ? X86::VPBROADCASTQrr</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="">                                                  : X86::VPBROADCASTQYrr),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="">                                VBStateReg)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="uncoveredLine">                            .addReg(VStateReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="">      (void)BroadcastI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="uncoveredLine">      ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Inserting broadcast: "; BroadcastI->dump();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="">                 dbgs() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="">      // Merge our potential poison state into the value with a vector or.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">      auto OrI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="uncoveredLine">          BuildMI(MBB, InsertPt, Loc,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="uncoveredLine">                  TII->get(Is128Bit ? X86::VPORrr : X86::VPORYrr), TmpReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="uncoveredLine">              .addReg(VBStateReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="uncoveredLine">              .addReg(OpReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="">      (void)OrI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="uncoveredLine">      ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="uncoveredLine">    } else if (OpRC->hasSuperClassEq(&X86::VR128XRegClass) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="uncoveredLine">               OpRC->hasSuperClassEq(&X86::VR256XRegClass) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="uncoveredLine">               OpRC->hasSuperClassEq(&X86::VR512RegClass)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="uncoveredLine">      assert(Subtarget->hasAVX512() && "AVX512-specific register classes!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="uncoveredLine">      bool Is128Bit = OpRC->hasSuperClassEq(&X86::VR128XRegClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="uncoveredLine">      bool Is256Bit = OpRC->hasSuperClassEq(&X86::VR256XRegClass);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="uncoveredLine">      if (Is128Bit || Is256Bit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="uncoveredLine">        assert(Subtarget->hasVLX() && "AVX512VL-specific register classes!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="">      // Broadcast our state into a vector register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="uncoveredLine">      Register VStateReg = MRI->createVirtualRegister(OpRC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="uncoveredLine">      unsigned BroadcastOp = Is128Bit ? X86::VPBROADCASTQrZ128rr</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="">                                      : Is256Bit ? X86::VPBROADCASTQrZ256rr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="">                                                 : X86::VPBROADCASTQrZrr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="">      auto BroadcastI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="uncoveredLine">          BuildMI(MBB, InsertPt, Loc, TII->get(BroadcastOp), VStateReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="uncoveredLine">              .addReg(StateReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">      (void)BroadcastI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="uncoveredLine">      ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Inserting broadcast: "; BroadcastI->dump();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="">                 dbgs() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="">      // Merge our potential poison state into the value with a vector or.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="uncoveredLine">      unsigned OrOp = Is128Bit ? X86::VPORQZ128rr</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="">                               : Is256Bit ? X86::VPORQZ256rr : X86::VPORQZrr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="uncoveredLine">      auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(OrOp), TmpReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="uncoveredLine">                     .addReg(VStateReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="uncoveredLine">                     .addReg(OpReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="">      (void)OrI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="uncoveredLine">      ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="">      // FIXME: Need to support GR32 here for 32-bit code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="uncoveredLine">      assert(OpRC->hasSuperClassEq(&X86::GR64RegClass) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="">             "Not a supported register class for address hardening!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="uncoveredLine">      if (!EFLAGSLive) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="">        // Merge our potential poison state into the value with an or.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="uncoveredLine">        auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::OR64rr), TmpReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="uncoveredLine">                       .addReg(StateReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="uncoveredLine">                       .addReg(OpReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="uncoveredLine">        OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="uncoveredLine">        ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="">        // We need to avoid touching EFLAGS so shift out all but the least</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="">        // significant bit using the instruction that doesn't update flags.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="">        auto ShiftI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="uncoveredLine">            BuildMI(MBB, InsertPt, Loc, TII->get(X86::SHRX64rr), TmpReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="uncoveredLine">                .addReg(OpReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="uncoveredLine">                .addReg(StateReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="">        (void)ShiftI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="uncoveredLine">        ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "  Inserting shrx: "; ShiftI->dump();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="">                   dbgs() << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="">    // Record this register as checked and update the operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="uncoveredLine">    assert(!AddrRegToHardenedReg.count(Op->getReg()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="">           "Should not have checked this register yet!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="uncoveredLine">    AddrRegToHardenedReg[Op->getReg()] = TmpReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="uncoveredLine">    Op->setReg(TmpReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="uncoveredLine">    ++NumAddrRegsHardened;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="">  // And restore the flags if needed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="uncoveredLine">  if (FlagsReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="uncoveredLine">    restoreEFLAGS(MBB, InsertPt, Loc, FlagsReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="uncoveredLine">MachineInstr *X86SpeculativeLoadHardeningPass::sinkPostLoadHardenedInst(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="">    MachineInstr &InitialMI, SmallPtrSetImpl<MachineInstr *> &HardenedInstrs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="uncoveredLine">  assert(X86InstrInfo::isDataInvariantLoad(InitialMI) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="">         "Cannot get here with a non-invariant load!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="uncoveredLine">  assert(!isEFLAGSDefLive(InitialMI) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="">         "Cannot get here with a data invariant load "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="">         "that interferes with EFLAGS!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">  // See if we can sink hardening the loaded value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">  auto SinkCheckToSingleUse =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="uncoveredLine">      [&](MachineInstr &MI) -> std::optional<MachineInstr *> {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="uncoveredLine">    Register DefReg = MI.getOperand(0).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="">    // We need to find a single use which we can sink the check. We can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="">    // primarily do this because many uses may already end up checked on their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="">    // own.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="uncoveredLine">    MachineInstr *SingleUseMI = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="uncoveredLine">    for (MachineInstr &UseMI : MRI->use_instructions(DefReg)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="">      // If we're already going to harden this use, it is data invariant, it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="">      // does not interfere with EFLAGS, and within our block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="uncoveredLine">      if (HardenedInstrs.count(&UseMI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="uncoveredLine">        if (!X86InstrInfo::isDataInvariantLoad(UseMI) || isEFLAGSDefLive(UseMI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="">          // If we've already decided to harden a non-load, we must have sunk</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="">          // some other post-load hardened instruction to it and it must itself</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="">          // be data-invariant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="uncoveredLine">          assert(X86InstrInfo::isDataInvariant(UseMI) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="">                 "Data variant instruction being hardened!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="">        // Otherwise, this is a load and the load component can't be data</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="">        // invariant so check how this register is being used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="uncoveredLine">        const MCInstrDesc &Desc = UseMI.getDesc();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="uncoveredLine">        int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="uncoveredLine">        assert(MemRefBeginIdx >= 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="">               "Should always have mem references here!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="uncoveredLine">        MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="">        MachineOperand &BaseMO =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="uncoveredLine">            UseMI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="">        MachineOperand &IndexMO =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="uncoveredLine">            UseMI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="uncoveredLine">        if ((BaseMO.isReg() && BaseMO.getReg() == DefReg) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="uncoveredLine">            (IndexMO.isReg() && IndexMO.getReg() == DefReg))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="">          // The load uses the register as part of its address making it not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="">          // invariant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="uncoveredLine">          return {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="uncoveredLine">      if (SingleUseMI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="">        // We already have a single use, this would make two. Bail.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="uncoveredLine">        return {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="">      // If this single use isn't data invariant, isn't in this block, or has</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="">      // interfering EFLAGS, we can't sink the hardening to it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="uncoveredLine">      if (!X86InstrInfo::isDataInvariant(UseMI) || UseMI.getParent() != MI.getParent() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="uncoveredLine">          isEFLAGSDefLive(UseMI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="uncoveredLine">        return {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="">      // If this instruction defines multiple registers bail as we won't harden</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">      // all of them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="uncoveredLine">      if (UseMI.getDesc().getNumDefs() > 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="uncoveredLine">        return {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="">      // If this register isn't a virtual register we can't walk uses of sanely,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="">      // just bail. Also check that its register class is one of the ones we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="">      // can harden.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="uncoveredLine">      Register UseDefReg = UseMI.getOperand(0).getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="uncoveredLine">      if (!UseDefReg.isVirtual() || !canHardenRegister(UseDefReg))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="uncoveredLine">        return {};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="uncoveredLine">      SingleUseMI = &UseMI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="">    // If SingleUseMI is still null, there is no use that needs its own</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="">    // checking. Otherwise, it is the single use that needs checking.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="uncoveredLine">    return {SingleUseMI};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="uncoveredLine">  MachineInstr *MI = &InitialMI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="uncoveredLine">  while (std::optional<MachineInstr *> SingleUse = SinkCheckToSingleUse(*MI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="">    // Update which MI we're checking now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="uncoveredLine">    MI = *SingleUse;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="uncoveredLine">    if (!MI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="uncoveredLine">  return MI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="uncoveredLine">bool X86SpeculativeLoadHardeningPass::canHardenRegister(Register Reg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="uncoveredLine">  auto *RC = MRI->getRegClass(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="uncoveredLine">  int RegBytes = TRI->getRegSizeInBits(*RC) / 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="uncoveredLine">  if (RegBytes > 8)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="">    // We don't support post-load hardening of vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="uncoveredLine">  unsigned RegIdx = Log2_32(RegBytes);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="uncoveredLine">  assert(RegIdx < 4 && "Unsupported register size");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="">  // If this register class is explicitly constrained to a class that doesn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="">  // require REX prefix, we may not be able to satisfy that constraint when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="">  // emitting the hardening instructions, so bail out here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="">  // FIXME: This seems like a pretty lame hack. The way this comes up is when we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="">  // end up both with a NOREX and REX-only register as operands to the hardening</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="">  // instructions. It would be better to fix that code to handle this situation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="">  // rather than hack around it in this way.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="uncoveredLine">  const TargetRegisterClass *NOREXRegClasses[] = {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="">      &X86::GR8_NOREXRegClass, &X86::GR16_NOREXRegClass,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="">      &X86::GR32_NOREXRegClass, &X86::GR64_NOREXRegClass};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="uncoveredLine">  if (RC == NOREXRegClasses[RegIdx])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="uncoveredLine">  const TargetRegisterClass *GPRRegClasses[] = {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="">      &X86::GR8RegClass, &X86::GR16RegClass, &X86::GR32RegClass,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">      &X86::GR64RegClass};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="uncoveredLine">  return RC->hasSuperClassEq(GPRRegClasses[RegIdx]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="">/// Harden a value in a register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="">/// This is the low-level logic to fully harden a value sitting in a register</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="">/// against leaking during speculative execution.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="">/// Unlike hardening an address that is used by a load, this routine is required</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="">/// to hide *all* incoming bits in the register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="">/// `Reg` must be a virtual register. Currently, it is required to be a GPR no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="">/// larger than the predicate state register. FIXME: We should support vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="">/// registers here by broadcasting the predicate state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="">/// The new, hardened virtual register is returned. It will have the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="">/// register class as `Reg`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="uncoveredLine">unsigned X86SpeculativeLoadHardeningPass::hardenValueInRegister(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="">    Register Reg, MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="">    const DebugLoc &Loc) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="uncoveredLine">  assert(canHardenRegister(Reg) && "Cannot harden this register!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="uncoveredLine">  assert(Reg.isVirtual() && "Cannot harden a physical register!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="uncoveredLine">  auto *RC = MRI->getRegClass(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="uncoveredLine">  int Bytes = TRI->getRegSizeInBits(*RC) / 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="uncoveredLine">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="uncoveredLine">  assert((Bytes == 1 || Bytes == 2 || Bytes == 4 || Bytes == 8) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="">         "Unknown register size");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="">  // FIXME: Need to teach this about 32-bit mode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="uncoveredLine">  if (Bytes != 8) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="uncoveredLine">    unsigned SubRegImms[] = {X86::sub_8bit, X86::sub_16bit, X86::sub_32bit};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="uncoveredLine">    unsigned SubRegImm = SubRegImms[Log2_32(Bytes)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="uncoveredLine">    Register NarrowStateReg = MRI->createVirtualRegister(RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="uncoveredLine">    BuildMI(MBB, InsertPt, Loc, TII->get(TargetOpcode::COPY), NarrowStateReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="uncoveredLine">        .addReg(StateReg, 0, SubRegImm);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="uncoveredLine">    StateReg = NarrowStateReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="uncoveredLine">  unsigned FlagsReg = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="uncoveredLine">  if (isEFLAGSLive(MBB, InsertPt, *TRI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="uncoveredLine">    FlagsReg = saveEFLAGS(MBB, InsertPt, Loc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="uncoveredLine">  Register NewReg = MRI->createVirtualRegister(RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="uncoveredLine">  unsigned OrOpCodes[] = {X86::OR8rr, X86::OR16rr, X86::OR32rr, X86::OR64rr};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="uncoveredLine">  unsigned OrOpCode = OrOpCodes[Log2_32(Bytes)];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="uncoveredLine">  auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(OrOpCode), NewReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="uncoveredLine">                 .addReg(StateReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="uncoveredLine">                 .addReg(Reg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="uncoveredLine">  OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="uncoveredLine">  ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="uncoveredLine">  if (FlagsReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="uncoveredLine">    restoreEFLAGS(MBB, InsertPt, Loc, FlagsReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="uncoveredLine">  return NewReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="">/// Harden a load by hardening the loaded value in the defined register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="">/// We can harden a non-leaking load into a register without touching the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">/// address by just hiding all of the loaded bits during misspeculation. We use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">/// an `or` instruction to do this because we set up our poison value as all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="">/// ones. And the goal is just for the loaded bits to not be exposed to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="">/// execution and coercing them to one is sufficient.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="">/// Returns the newly hardened register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="uncoveredLine">unsigned X86SpeculativeLoadHardeningPass::hardenPostLoad(MachineInstr &MI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="uncoveredLine">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="uncoveredLine">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="uncoveredLine">  auto &DefOp = MI.getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="uncoveredLine">  Register OldDefReg = DefOp.getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="uncoveredLine">  auto *DefRC = MRI->getRegClass(OldDefReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="">  // Because we want to completely replace the uses of this def'ed value with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="">  // the hardened value, create a dedicated new register that will only be used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="">  // to communicate the unhardened value to the hardening.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="uncoveredLine">  Register UnhardenedReg = MRI->createVirtualRegister(DefRC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="uncoveredLine">  DefOp.setReg(UnhardenedReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="">  // Now harden this register's value, getting a hardened reg that is safe to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="">  // use. Note that we insert the instructions to compute this *after* the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="">  // defining instruction, not before it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="uncoveredLine">  unsigned HardenedReg = hardenValueInRegister(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="">      UnhardenedReg, MBB, std::next(MI.getIterator()), Loc);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="">  // Finally, replace the old register (which now only has the uses of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="">  // original def) with the hardened register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="uncoveredLine">  MRI->replaceRegWith(/*FromReg*/ OldDefReg, /*ToReg*/ HardenedReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="uncoveredLine">  ++NumPostLoadRegsHardened;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="uncoveredLine">  return HardenedReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="">/// Harden a return instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="">/// Returns implicitly perform a load which we need to harden. Without hardening</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="">/// this load, an attacker my speculatively write over the return address to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="">/// steer speculation of the return to an attacker controlled address. This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">/// called Spectre v1.1 or Bounds Check Bypass Store (BCBS) and is described in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="">/// this paper:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="">/// https://people.csail.mit.edu/vlk/spectre11.pdf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="">/// We can harden this by introducing an LFENCE that will delay any load of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">/// return address until prior instructions have retired (and thus are not being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">/// speculated), or we can harden the address used by the implicit load: the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="">/// stack pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="">/// If we are not using an LFENCE, hardening the stack pointer has an additional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="">/// benefit: it allows us to pass the predicate state accumulated in this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="">/// function back to the caller. In the absence of a BCBS attack on the return,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="">/// the caller will typically be resumed and speculatively executed due to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="">/// Return Stack Buffer (RSB) prediction which is very accurate and has a high</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="">/// priority. It is possible that some code from the caller will be executed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="">/// speculatively even during a BCBS-attacked return until the steering takes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="">/// effect. Whenever this happens, the caller can recover the (poisoned)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="">/// predicate state from the stack pointer and continue to harden loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="uncoveredLine">void X86SpeculativeLoadHardeningPass::hardenReturnInstr(MachineInstr &MI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="uncoveredLine">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="uncoveredLine">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="uncoveredLine">  auto InsertPt = MI.getIterator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="uncoveredLine">  if (FenceCallAndRet)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="">    // No need to fence here as we'll fence at the return site itself. That</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="">    // handles more cases than we can handle here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="">  // Take our predicate state, shift it to the high 17 bits (so that we keep</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="">  // pointers canonical) and merge it into RSP. This will allow the caller to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="">  // extract it when we return (speculatively).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="uncoveredLine">  mergePredStateIntoSP(MBB, InsertPt, Loc, PS->SSA.GetValueAtEndOfBlock(&MBB));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="">/// Trace the predicate state through a call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="">/// There are several layers of this needed to handle the full complexity of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="">/// calls.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="">/// First, we need to send the predicate state into the called function. We do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="">/// this by merging it into the high bits of the stack pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="">/// For tail calls, this is all we need to do.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="">/// For calls where we might return and resume the control flow, we need to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="">/// extract the predicate state from the high bits of the stack pointer after</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="">/// control returns from the called function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="">/// We also need to verify that we intended to return to this location in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="">/// code. An attacker might arrange for the processor to mispredict the return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="">/// to this valid but incorrect return address in the program rather than the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="">/// correct one. See the paper on this attack, called "ret2spec" by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="">/// researchers, here:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="">/// https://christian-rossow.de/publications/ret2spec-ccs2018.pdf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="">/// The way we verify that we returned to the correct location is by preserving</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="">/// the expected return address across the call. One technique involves taking</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="">/// advantage of the red-zone to load the return address from `8(%rsp)` where it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">/// was left by the RET instruction when it popped `%rsp`. Alternatively, we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="">/// directly save the address into a register that will be preserved across the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="">/// call. We compare this intended return address against the address</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="">/// immediately following the call (the observed return address). If these</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="">/// mismatch, we have detected misspeculation and can poison our predicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="">/// state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="uncoveredLine">void X86SpeculativeLoadHardeningPass::tracePredStateThroughCall(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="">    MachineInstr &MI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="uncoveredLine">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="uncoveredLine">  MachineFunction &MF = *MBB.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="uncoveredLine">  auto InsertPt = MI.getIterator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="uncoveredLine">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="uncoveredLine">  if (FenceCallAndRet) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="uncoveredLine">    if (MI.isReturn())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="">      // Tail call, we don't return to this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="">      // FIXME: We should also handle noreturn calls.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="">    // We don't need to fence before the call because the function should fence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="">    // in its entry. However, we do need to fence after the call returns.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="">    // Fencing before the return doesn't correctly handle cases where the return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="">    // itself is mispredicted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="uncoveredLine">    BuildMI(MBB, std::next(InsertPt), Loc, TII->get(X86::LFENCE));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="uncoveredLine">    ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="uncoveredLine">    ++NumLFENCEsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="">  // First, we transfer the predicate state into the called function by merging</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="">  // it into the stack pointer. This will kill the current def of the state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="uncoveredLine">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="uncoveredLine">  mergePredStateIntoSP(MBB, InsertPt, Loc, StateReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="">  // If this call is also a return, it is a tail call and we don't need anything</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="">  // else to handle it so just return. Also, if there are no further</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="">  // instructions and no successors, this call does not return so we can also</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="">  // bail.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="uncoveredLine">  if (MI.isReturn() || (std::next(InsertPt) == MBB.end() && MBB.succ_empty()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="">  // Create a symbol to track the return address and attach it to the call</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="">  // machine instruction. We will lower extra symbols attached to call</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="">  // instructions as label immediately following the call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="">  MCSymbol *RetSymbol =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="uncoveredLine">      MF.getContext().createTempSymbol("slh_ret_addr",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="">                                       /*AlwaysAddSuffix*/ true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="uncoveredLine">  MI.setPostInstrSymbol(MF, RetSymbol);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="uncoveredLine">  const TargetRegisterClass *AddrRC = &X86::GR64RegClass;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="uncoveredLine">  unsigned ExpectedRetAddrReg = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="">  // If we have no red zones or if the function returns twice (possibly without</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="">  // using the `ret` instruction) like setjmp, we need to save the expected</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="">  // return address prior to the call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="uncoveredLine">  if (!Subtarget->getFrameLowering()->has128ByteRedZone(MF) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="uncoveredLine">      MF.exposesReturnsTwice()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="">    // If we don't have red zones, we need to compute the expected return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="">    // address prior to the call and store it in a register that lives across</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="">    // the call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="">    // In some ways, this is doubly satisfying as a mitigation because it will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="">    // also successfully detect stack smashing bugs in some cases (typically,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="">    // when a callee-saved register is used and the callee doesn't push it onto</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="">    // the stack). But that isn't our primary goal, so we only use it as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="">    // a fallback.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="">    // FIXME: It isn't clear that this is reliable in the face of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="">    // rematerialization in the register allocator. We somehow need to force</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="">    // that to not occur for this particular instruction, and instead to spill</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="">    // or otherwise preserve the value computed *prior* to the call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="">    // FIXME: It is even less clear why MachineCSE can't just fold this when we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="">    // end up having to use identical instructions both before and after the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="">    // call to feed the comparison.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="uncoveredLine">    ExpectedRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="uncoveredLine">    if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="uncoveredLine">        !Subtarget->isPositionIndependent()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="uncoveredLine">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::MOV64ri32), ExpectedRetAddrReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="uncoveredLine">          .addSym(RetSymbol);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="uncoveredLine">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::LEA64r), ExpectedRetAddrReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="uncoveredLine">          .addReg(/*Base*/ X86::RIP)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="uncoveredLine">          .addImm(/*Scale*/ 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="uncoveredLine">          .addReg(/*Index*/ 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="uncoveredLine">          .addSym(RetSymbol)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="uncoveredLine">          .addReg(/*Segment*/ 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="">  // Step past the call to handle when it returns.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="uncoveredLine">  ++InsertPt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="">  // If we didn't pre-compute the expected return address into a register, then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="">  // red zones are enabled and the return address is still available on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="">  // stack immediately after the call. As the very first instruction, we load it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="">  // into a register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="uncoveredLine">  if (!ExpectedRetAddrReg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="uncoveredLine">    ExpectedRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="uncoveredLine">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::MOV64rm), ExpectedRetAddrReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="uncoveredLine">        .addReg(/*Base*/ X86::RSP)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="uncoveredLine">        .addImm(/*Scale*/ 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="uncoveredLine">        .addReg(/*Index*/ 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="uncoveredLine">        .addImm(/*Displacement*/ -8) // The stack pointer has been popped, so</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="">                                     // the return address is 8-bytes past it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="uncoveredLine">        .addReg(/*Segment*/ 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="">  // Now we extract the callee's predicate state from the stack pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="uncoveredLine">  unsigned NewStateReg = extractPredStateFromSP(MBB, InsertPt, Loc);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="">  // Test the expected return address against our actual address. If we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="">  // form this basic block's address as an immediate, this is easy. Otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="">  // we compute it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="uncoveredLine">  if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="uncoveredLine">      !Subtarget->isPositionIndependent()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="">    // FIXME: Could we fold this with the load? It would require careful EFLAGS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="">    // management.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="uncoveredLine">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::CMP64ri32))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="uncoveredLine">        .addReg(ExpectedRetAddrReg, RegState::Kill)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="uncoveredLine">        .addSym(RetSymbol);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="uncoveredLine">    Register ActualRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="uncoveredLine">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::LEA64r), ActualRetAddrReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="uncoveredLine">        .addReg(/*Base*/ X86::RIP)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="uncoveredLine">        .addImm(/*Scale*/ 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="uncoveredLine">        .addReg(/*Index*/ 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="uncoveredLine">        .addSym(RetSymbol)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="uncoveredLine">        .addReg(/*Segment*/ 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="uncoveredLine">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::CMP64rr))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="uncoveredLine">        .addReg(ExpectedRetAddrReg, RegState::Kill)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="uncoveredLine">        .addReg(ActualRetAddrReg, RegState::Kill);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="">  // Now conditionally update the predicate state we just extracted if we ended</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="">  // up at a different return address than expected.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="uncoveredLine">  int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="uncoveredLine">  auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="uncoveredLine">  Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="uncoveredLine">  auto CMovI = BuildMI(MBB, InsertPt, Loc, TII->get(CMovOp), UpdatedStateReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="uncoveredLine">                   .addReg(NewStateReg, RegState::Kill)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="uncoveredLine">                   .addReg(PS->PoisonReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="uncoveredLine">                   .addImm(X86::COND_NE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="uncoveredLine">  CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="uncoveredLine">  ++NumInstsInserted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump(); dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="uncoveredLine">  PS->SSA.AddAvailableValue(&MBB, UpdatedStateReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="">/// An attacker may speculatively store over a value that is then speculatively</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="">/// loaded and used as the target of an indirect call or jump instruction. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="">/// is called Spectre v1.2 or Bounds Check Bypass Store (BCBS) and is described</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="">/// in this paper:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="">/// https://people.csail.mit.edu/vlk/spectre11.pdf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="">/// When this happens, the speculative execution of the call or jump will end up</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="">/// being steered to this attacker controlled address. While most such loads</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="">/// will be adequately hardened already, we want to ensure that they are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="">/// definitively treated as needing post-load hardening. While address hardening</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="">/// is sufficient to prevent secret data from leaking to the attacker, it may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="">/// not be sufficient to prevent an attacker from steering speculative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="">/// execution. We forcibly unfolded all relevant loads above and so will always</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="">/// have an opportunity to post-load harden here, we just need to scan for cases</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="">/// not already flagged and add them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="uncoveredLine">void X86SpeculativeLoadHardeningPass::hardenIndirectCallOrJumpInstr(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="">    MachineInstr &MI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="">    SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="uncoveredLine">  switch (MI.getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="uncoveredLine">  case X86::FARCALL16m:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="">  case X86::FARCALL32m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="">  case X86::FARCALL64m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="">  case X86::FARJMP16m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="">  case X86::FARJMP32m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="">  case X86::FARJMP64m:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="">    // We don't need to harden either far calls or far jumps as they are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="">    // safe from Spectre.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="">  // We should never see a loading instruction at this point, as those should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="">  // have been unfolded.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="uncoveredLine">  assert(!MI.mayLoad() && "Found a lingering loading instruction!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="">  // If the first operand isn't a register, this is a branch or call</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="">  // instruction with an immediate operand which doesn't need to be hardened.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="uncoveredLine">  if (!MI.getOperand(0).isReg())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="">  // For all of these, the target register is the first operand of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="">  // instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="uncoveredLine">  auto &TargetOp = MI.getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="uncoveredLine">  Register OldTargetReg = TargetOp.getReg();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="">  // Try to lookup a hardened version of this register. We retain a reference</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="">  // here as we want to update the map to track any newly computed hardened</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">  // register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="uncoveredLine">  unsigned &HardenedTargetReg = AddrRegToHardenedReg[OldTargetReg];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="">  // If we don't have a hardened register yet, compute one. Otherwise, just use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="">  // the already hardened register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="">  // FIXME: It is a little suspect that we use partially hardened registers that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="">  // only feed addresses. The complexity of partial hardening with SHRX</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="">  // continues to pile up. Should definitively measure its value and consider</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="">  // eliminating it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="uncoveredLine">  if (!HardenedTargetReg)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="uncoveredLine">    HardenedTargetReg = hardenValueInRegister(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="uncoveredLine">        OldTargetReg, *MI.getParent(), MI.getIterator(), MI.getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="">  // Set the target operand to the hardened register.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="uncoveredLine">  TargetOp.setReg(HardenedTargetReg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">  ++NumCallsOrJumpsHardened;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(X86SpeculativeLoadHardeningPass, PASS_KEY,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="">                      "X86 speculative load hardener", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="coveredLine">INITIALIZE_PASS_END(X86SpeculativeLoadHardeningPass, PASS_KEY,</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="">                    "X86 speculative load hardener", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="uncoveredLine">FunctionPass *llvm::createX86SpeculativeLoadHardeningPass() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="uncoveredLine">  return new X86SpeculativeLoadHardeningPass();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPassC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_131X86SpeculativeLoadHardeningPass11getPassNameEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass9PredStateC2ERN4llvm15MachineFunctionEPKNS2_19TargetRegisterClassE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_131X86SpeculativeLoadHardeningPass16getAnalysisUsageERN4llvm13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL9splitEdgeRN4llvm17MachineBasicBlockES1_iPNS_12MachineInstrERS3_RKNS_12X86InstrInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL23canonicalizePHIOperandsRN4llvm15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL17hasVulnerableLoadRN4llvm15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass20runOnMachineFunctionERN4llvm15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass21hardenEdgesWithLFENCEERN4llvm15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass20collectBlockCondInfoERN4llvm15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass24tracePredStateThroughCFGERN4llvm15MachineFunctionENS1_8ArrayRefINS0_13BlockCondInfoEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass24tracePredStateThroughCFGERN4llvm15MachineFunctionENS1_8ArrayRefINS0_13BlockCondInfoEEEENKUlRNS1_17MachineBasicBlockES8_iPNS1_12MachineInstrERSA_NS4_INS1_3X868CondCodeEEEE_clES8_S8_iSA_SB_SE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL26getRegClassForUnfoldedLoadRN4llvm15MachineFunctionERKNS_12X86InstrInfoEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass22unfoldCallAndJumpLoadsERN4llvm15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass37tracePredStateThroughIndirectBranchesERN4llvm15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass37tracePredStateThroughIndirectBranchesERN4llvm15MachineFunctionEENKUlRNS1_12MachineInstrEE_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass37tracePredStateThroughIndirectBranchesERN4llvm15MachineFunctionEENKUlPNS1_17MachineBasicBlockEE0_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15isEFLAGSDefLiveRKN4llvm12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL12isEFLAGSLiveRN4llvm17MachineBasicBlockENS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEERKNS_18TargetRegisterInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass36tracePredStateThroughBlocksAndHardenERN4llvm15MachineFunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass36tracePredStateThroughBlocksAndHardenERN4llvm15MachineFunctionEENKUlRNS1_14MachineOperandEE_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass10saveEFLAGSERN4llvm17MachineBasicBlockENS1_26MachineInstrBundleIteratorINS1_12MachineInstrELb0EEERKNS1_8DebugLocE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass13restoreEFLAGSERN4llvm17MachineBasicBlockENS1_26MachineInstrBundleIteratorINS1_12MachineInstrELb0EEERKNS1_8DebugLocENS1_8RegisterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass20mergePredStateIntoSPERN4llvm17MachineBasicBlockENS1_26MachineInstrBundleIteratorINS1_12MachineInstrELb0EEERKNS1_8DebugLocEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass22extractPredStateFromSPERN4llvm17MachineBasicBlockENS1_26MachineInstrBundleIteratorINS1_12MachineInstrELb0EEERKNS1_8DebugLocE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass14hardenLoadAddrERN4llvm12MachineInstrERNS1_14MachineOperandES5_RNS1_13SmallDenseMapIjjLj32ENS1_12DenseMapInfoIjvEENS1_6detail12DenseMapPairIjjEEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass14hardenLoadAddrERN4llvm12MachineInstrERNS1_14MachineOperandES5_RNS1_13SmallDenseMapIjjLj32ENS1_12DenseMapInfoIjvEENS1_6detail12DenseMapPairIjjEEEEENKUlPS4_E_clESE_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass24sinkPostLoadHardenedInstERN4llvm12MachineInstrERNS1_15SmallPtrSetImplIPS2_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass24sinkPostLoadHardenedInstERN4llvm12MachineInstrERNS1_15SmallPtrSetImplIPS2_EEENKUlS3_E_clES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass17canHardenRegisterEN4llvm8RegisterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass21hardenValueInRegisterEN4llvm8RegisterERNS1_17MachineBasicBlockENS1_26MachineInstrBundleIteratorINS1_12MachineInstrELb0EEERKNS1_8DebugLocE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass14hardenPostLoadERN4llvm12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass17hardenReturnInstrERN4llvm12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass25tracePredStateThroughCallERN4llvm12MachineInstrE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass29hardenIndirectCallOrJumpInstrERN4llvm12MachineInstrERNS1_13SmallDenseMapIjjLj32ENS1_12DenseMapInfoIjvEENS1_6detail12DenseMapPairIjjEEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL49initializeX86SpeculativeLoadHardeningPassPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm45initializeX86SpeculativeLoadHardeningPassPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm37createX86SpeculativeLoadHardeningPassEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//====- X86SpeculativeLoadHardening.cpp - A Spectre v1 mitigation ---------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//====- X86SpeculativeLoadHardening.cpp - A Spectre v1 mitigation ---------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">/// \file</td>
    <td class="lineNumber">8</td>
    <td class="codeline">/// \file</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">///</td>
    <td class="lineNumber">9</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">/// Provide a pass which mitigates speculative execution attacks which operate</td>
    <td class="lineNumber">10</td>
    <td class="codeline">/// Provide a pass which mitigates speculative execution attacks which operate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">/// by speculating incorrectly past some predicate (a type check, bounds check,</td>
    <td class="lineNumber">11</td>
    <td class="codeline">/// by speculating incorrectly past some predicate (a type check, bounds check,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">/// or other condition) to reach a load with invalid inputs and leak the data</td>
    <td class="lineNumber">12</td>
    <td class="codeline">/// or other condition) to reach a load with invalid inputs and leak the data</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">/// accessed by that load using a side channel out of the speculative domain.</td>
    <td class="lineNumber">13</td>
    <td class="codeline">/// accessed by that load using a side channel out of the speculative domain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">///</td>
    <td class="lineNumber">14</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">/// For details on the attacks, see the first variant in both the Project Zero</td>
    <td class="lineNumber">15</td>
    <td class="codeline">/// For details on the attacks, see the first variant in both the Project Zero</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">/// writeup and the Spectre paper:</td>
    <td class="lineNumber">16</td>
    <td class="codeline">/// writeup and the Spectre paper:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">/// https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html</td>
    <td class="lineNumber">17</td>
    <td class="codeline">/// https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">/// https://spectreattack.com/spectre.pdf</td>
    <td class="lineNumber">18</td>
    <td class="codeline">/// https://spectreattack.com/spectre.pdf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">///</td>
    <td class="lineNumber">19</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">20</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline"></td>
    <td class="lineNumber">21</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "X86.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "X86.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "X86InstrBuilder.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "X86InstrBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "X86InstrInfo.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "X86InstrInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "X86Subtarget.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "X86Subtarget.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/ADT/ScopeExit.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/ADT/ScopeExit.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/ADT/SmallSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/ADT/SparseBitVector.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/ADT/SparseBitVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/CodeGen/MachineConstantPool.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/CodeGen/MachineConstantPool.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstr.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/CodeGen/MachineModuleInfo.h"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/CodeGen/MachineModuleInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/CodeGen/MachineOperand.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/CodeGen/MachineSSAUpdater.h"</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/CodeGen/MachineSSAUpdater.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSchedule.h"</td>
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSchedule.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/IR/DebugLoc.h"</td>
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/IR/DebugLoc.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/MC/MCSchedule.h"</td>
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/MC/MCSchedule.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">54</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">55</td>
    <td class="codeline">#include "llvm/Target/TargetMachine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">56</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">57</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">#include <iterator></td>
    <td class="lineNumber">58</td>
    <td class="codeline">#include <iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">#include <optional></td>
    <td class="lineNumber">59</td>
    <td class="codeline">#include <optional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">60</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline"></td>
    <td class="lineNumber">61</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">62</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline"></td>
    <td class="lineNumber">63</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">#define PASS_KEY "x86-slh"</td>
    <td class="lineNumber">64</td>
    <td class="codeline">#define PASS_KEY "x86-slh"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">#define DEBUG_TYPE PASS_KEY</td>
    <td class="lineNumber">65</td>
    <td class="codeline">#define DEBUG_TYPE PASS_KEY</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline"></td>
    <td class="lineNumber">66</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">STATISTIC(NumCondBranchesTraced, "Number of conditional branches traced");</td>
    <td class="lineNumber">67</td>
    <td class="codeline">STATISTIC(NumCondBranchesTraced, "Number of conditional branches traced");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">STATISTIC(NumBranchesUntraced, "Number of branches unable to trace");</td>
    <td class="lineNumber">68</td>
    <td class="codeline">STATISTIC(NumBranchesUntraced, "Number of branches unable to trace");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">STATISTIC(NumAddrRegsHardened,</td>
    <td class="lineNumber">69</td>
    <td class="codeline">STATISTIC(NumAddrRegsHardened,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">          "Number of address mode used registers hardaned");</td>
    <td class="lineNumber">70</td>
    <td class="codeline">          "Number of address mode used registers hardaned");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">STATISTIC(NumPostLoadRegsHardened,</td>
    <td class="lineNumber">71</td>
    <td class="codeline">STATISTIC(NumPostLoadRegsHardened,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">          "Number of post-load register values hardened");</td>
    <td class="lineNumber">72</td>
    <td class="codeline">          "Number of post-load register values hardened");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">STATISTIC(NumCallsOrJumpsHardened,</td>
    <td class="lineNumber">73</td>
    <td class="codeline">STATISTIC(NumCallsOrJumpsHardened,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">          "Number of calls or jumps requiring extra hardening");</td>
    <td class="lineNumber">74</td>
    <td class="codeline">          "Number of calls or jumps requiring extra hardening");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">STATISTIC(NumInstsInserted, "Number of instructions inserted");</td>
    <td class="lineNumber">75</td>
    <td class="codeline">STATISTIC(NumInstsInserted, "Number of instructions inserted");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">STATISTIC(NumLFENCEsInserted, "Number of lfence instructions inserted");</td>
    <td class="lineNumber">76</td>
    <td class="codeline">STATISTIC(NumLFENCEsInserted, "Number of lfence instructions inserted");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">static cl::opt<bool> EnableSpeculativeLoadHardening(</td>
    <td class="lineNumber">78</td>
    <td class="codeline">static cl::opt<bool> EnableSpeculativeLoadHardening(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">    "x86-speculative-load-hardening",</td>
    <td class="lineNumber">79</td>
    <td class="codeline">    "x86-speculative-load-hardening",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">    cl::desc("Force enable speculative load hardening"), cl::init(false),</td>
    <td class="lineNumber">80</td>
    <td class="codeline">    cl::desc("Force enable speculative load hardening"), cl::init(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">    cl::Hidden);</td>
    <td class="lineNumber">81</td>
    <td class="codeline">    cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
    <td class="lineNumber">82</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">static cl::opt<bool> HardenEdgesWithLFENCE(</td>
    <td class="lineNumber">83</td>
    <td class="codeline">static cl::opt<bool> HardenEdgesWithLFENCE(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">    PASS_KEY "-lfence",</td>
    <td class="lineNumber">84</td>
    <td class="codeline">    PASS_KEY "-lfence",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">    cl::desc(</td>
    <td class="lineNumber">85</td>
    <td class="codeline">    cl::desc(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">        "Use LFENCE along each conditional edge to harden against speculative "</td>
    <td class="lineNumber">86</td>
    <td class="codeline">        "Use LFENCE along each conditional edge to harden against speculative "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">        "loads rather than conditional movs and poisoned pointers."),</td>
    <td class="lineNumber">87</td>
    <td class="codeline">        "loads rather than conditional movs and poisoned pointers."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">    cl::init(false), cl::Hidden);</td>
    <td class="lineNumber">88</td>
    <td class="codeline">    cl::init(false), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline"></td>
    <td class="lineNumber">89</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">static cl::opt<bool> EnablePostLoadHardening(</td>
    <td class="lineNumber">90</td>
    <td class="codeline">static cl::opt<bool> EnablePostLoadHardening(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">    PASS_KEY "-post-load",</td>
    <td class="lineNumber">91</td>
    <td class="codeline">    PASS_KEY "-post-load",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">    cl::desc("Harden the value loaded *after* it is loaded by "</td>
    <td class="lineNumber">92</td>
    <td class="codeline">    cl::desc("Harden the value loaded *after* it is loaded by "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">             "flushing the loaded bits to 1. This is hard to do "</td>
    <td class="lineNumber">93</td>
    <td class="codeline">             "flushing the loaded bits to 1. This is hard to do "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">             "in general but can be done easily for GPRs."),</td>
    <td class="lineNumber">94</td>
    <td class="codeline">             "in general but can be done easily for GPRs."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">    cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">95</td>
    <td class="codeline">    cl::init(true), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline"></td>
    <td class="lineNumber">96</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">static cl::opt<bool> FenceCallAndRet(</td>
    <td class="lineNumber">97</td>
    <td class="codeline">static cl::opt<bool> FenceCallAndRet(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">    PASS_KEY "-fence-call-and-ret",</td>
    <td class="lineNumber">98</td>
    <td class="codeline">    PASS_KEY "-fence-call-and-ret",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">    cl::desc("Use a full speculation fence to harden both call and ret edges "</td>
    <td class="lineNumber">99</td>
    <td class="codeline">    cl::desc("Use a full speculation fence to harden both call and ret edges "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">             "rather than a lighter weight mitigation."),</td>
    <td class="lineNumber">100</td>
    <td class="codeline">             "rather than a lighter weight mitigation."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">    cl::init(false), cl::Hidden);</td>
    <td class="lineNumber">101</td>
    <td class="codeline">    cl::init(false), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">static cl::opt<bool> HardenInterprocedurally(</td>
    <td class="lineNumber">103</td>
    <td class="codeline">static cl::opt<bool> HardenInterprocedurally(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">    PASS_KEY "-ip",</td>
    <td class="lineNumber">104</td>
    <td class="codeline">    PASS_KEY "-ip",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">    cl::desc("Harden interprocedurally by passing our state in and out of "</td>
    <td class="lineNumber">105</td>
    <td class="codeline">    cl::desc("Harden interprocedurally by passing our state in and out of "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">             "functions in the high bits of the stack pointer."),</td>
    <td class="lineNumber">106</td>
    <td class="codeline">             "functions in the high bits of the stack pointer."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">    cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">107</td>
    <td class="codeline">    cl::init(true), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline"></td>
    <td class="lineNumber">108</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">static cl::opt<bool></td>
    <td class="lineNumber">109</td>
    <td class="codeline">static cl::opt<bool></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">    HardenLoads(PASS_KEY "-loads",</td>
    <td class="lineNumber">110</td>
    <td class="codeline">    HardenLoads(PASS_KEY "-loads",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">                cl::desc("Sanitize loads from memory. When disable, no "</td>
    <td class="lineNumber">111</td>
    <td class="codeline">                cl::desc("Sanitize loads from memory. When disable, no "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">                         "significant security is provided."),</td>
    <td class="lineNumber">112</td>
    <td class="codeline">                         "significant security is provided."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">                cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">113</td>
    <td class="codeline">                cl::init(true), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline"></td>
    <td class="lineNumber">114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">static cl::opt<bool> HardenIndirectCallsAndJumps(</td>
    <td class="lineNumber">115</td>
    <td class="codeline">static cl::opt<bool> HardenIndirectCallsAndJumps(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">    PASS_KEY "-indirect",</td>
    <td class="lineNumber">116</td>
    <td class="codeline">    PASS_KEY "-indirect",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">    cl::desc("Harden indirect calls and jumps against using speculatively "</td>
    <td class="lineNumber">117</td>
    <td class="codeline">    cl::desc("Harden indirect calls and jumps against using speculatively "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">             "stored attacker controlled addresses. This is designed to "</td>
    <td class="lineNumber">118</td>
    <td class="codeline">             "stored attacker controlled addresses. This is designed to "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">             "mitigate Spectre v1.2 style attacks."),</td>
    <td class="lineNumber">119</td>
    <td class="codeline">             "mitigate Spectre v1.2 style attacks."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">    cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">120</td>
    <td class="codeline">    cl::init(true), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">122</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline"></td>
    <td class="lineNumber">123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">class X86SpeculativeLoadHardeningPass : public MachineFunctionPass {</td>
    <td class="lineNumber">124</td>
    <td class="codeline">class X86SpeculativeLoadHardeningPass : public MachineFunctionPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">125</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  X86SpeculativeLoadHardeningPass() : MachineFunctionPass(ID) { }</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  X86SpeculativeLoadHardeningPass() : MachineFunctionPass(ID) { }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline"></td>
    <td class="lineNumber">127</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  StringRef getPassName() const override {</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  StringRef getPassName() const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">    return "X86 speculative load hardening";</td>
    <td class="lineNumber">129</td>
    <td class="codeline">    return "X86 speculative load hardening";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">  bool runOnMachineFunction(MachineFunction &MF) override;</td>
    <td class="lineNumber">131</td>
    <td class="codeline">  bool runOnMachineFunction(MachineFunction &MF) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
    <td class="lineNumber">132</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline"></td>
    <td class="lineNumber">133</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">  /// Pass identification, replacement for typeid.</td>
    <td class="lineNumber">134</td>
    <td class="codeline">  /// Pass identification, replacement for typeid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">  static char ID;</td>
    <td class="lineNumber">135</td>
    <td class="codeline">  static char ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline"></td>
    <td class="lineNumber">136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">137</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">  /// The information about a block's conditional terminators needed to trace</td>
    <td class="lineNumber">138</td>
    <td class="codeline">  /// The information about a block's conditional terminators needed to trace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">  /// our predicate state through the exiting edges.</td>
    <td class="lineNumber">139</td>
    <td class="codeline">  /// our predicate state through the exiting edges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">  struct BlockCondInfo {</td>
    <td class="lineNumber">140</td>
    <td class="codeline">  struct BlockCondInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">    MachineBasicBlock *MBB;</td>
    <td class="lineNumber">141</td>
    <td class="codeline">    MachineBasicBlock *MBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline"></td>
    <td class="lineNumber">142</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">    // We mostly have one conditional branch, and in extremely rare cases have</td>
    <td class="lineNumber">143</td>
    <td class="codeline">    // We mostly have one conditional branch, and in extremely rare cases have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">    // two. Three and more are so rare as to be unimportant for compile time.</td>
    <td class="lineNumber">144</td>
    <td class="codeline">    // two. Three and more are so rare as to be unimportant for compile time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">    SmallVector<MachineInstr *, 2> CondBrs;</td>
    <td class="lineNumber">145</td>
    <td class="codeline">    SmallVector<MachineInstr *, 2> CondBrs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline"></td>
    <td class="lineNumber">146</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">    MachineInstr *UncondBr;</td>
    <td class="lineNumber">147</td>
    <td class="codeline">    MachineInstr *UncondBr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">148</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
    <td class="lineNumber">149</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">  /// Manages the predicate state traced through the program.</td>
    <td class="lineNumber">150</td>
    <td class="codeline">  /// Manages the predicate state traced through the program.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">  struct PredState {</td>
    <td class="lineNumber">151</td>
    <td class="codeline">  struct PredState {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">    unsigned InitialReg = 0;</td>
    <td class="lineNumber">152</td>
    <td class="codeline">    unsigned InitialReg = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">    unsigned PoisonReg = 0;</td>
    <td class="lineNumber">153</td>
    <td class="codeline">    unsigned PoisonReg = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline"></td>
    <td class="lineNumber">154</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">    const TargetRegisterClass *RC;</td>
    <td class="lineNumber">155</td>
    <td class="codeline">    const TargetRegisterClass *RC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">    MachineSSAUpdater SSA;</td>
    <td class="lineNumber">156</td>
    <td class="codeline">    MachineSSAUpdater SSA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline"></td>
    <td class="lineNumber">157</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">    PredState(MachineFunction &MF, const TargetRegisterClass *RC)</td>
    <td class="lineNumber">158</td>
    <td class="codeline">    PredState(MachineFunction &MF, const TargetRegisterClass *RC)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">        : RC(RC), SSA(MF) {}</td>
    <td class="lineNumber">159</td>
    <td class="codeline">        : RC(RC), SSA(MF) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">160</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline"></td>
    <td class="lineNumber">161</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">  const X86Subtarget *Subtarget = nullptr;</td>
    <td class="lineNumber">162</td>
    <td class="codeline">  const X86Subtarget *Subtarget = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">  MachineRegisterInfo *MRI = nullptr;</td>
    <td class="lineNumber">163</td>
    <td class="codeline">  MachineRegisterInfo *MRI = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  const X86InstrInfo *TII = nullptr;</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  const X86InstrInfo *TII = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">  const TargetRegisterInfo *TRI = nullptr;</td>
    <td class="lineNumber">165</td>
    <td class="codeline">  const TargetRegisterInfo *TRI = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline"></td>
    <td class="lineNumber">166</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">  std::optional<PredState> PS;</td>
    <td class="lineNumber">167</td>
    <td class="codeline">  std::optional<PredState> PS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline"></td>
    <td class="lineNumber">168</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  void hardenEdgesWithLFENCE(MachineFunction &MF);</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  void hardenEdgesWithLFENCE(MachineFunction &MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline"></td>
    <td class="lineNumber">170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  SmallVector<BlockCondInfo, 16> collectBlockCondInfo(MachineFunction &MF);</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  SmallVector<BlockCondInfo, 16> collectBlockCondInfo(MachineFunction &MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline"></td>
    <td class="lineNumber">172</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">  SmallVector<MachineInstr *, 16></td>
    <td class="lineNumber">173</td>
    <td class="codeline">  SmallVector<MachineInstr *, 16></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  tracePredStateThroughCFG(MachineFunction &MF, ArrayRef<BlockCondInfo> Infos);</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  tracePredStateThroughCFG(MachineFunction &MF, ArrayRef<BlockCondInfo> Infos);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline"></td>
    <td class="lineNumber">175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">  void unfoldCallAndJumpLoads(MachineFunction &MF);</td>
    <td class="lineNumber">176</td>
    <td class="codeline">  void unfoldCallAndJumpLoads(MachineFunction &MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  SmallVector<MachineInstr *, 16></td>
    <td class="lineNumber">178</td>
    <td class="codeline">  SmallVector<MachineInstr *, 16></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  tracePredStateThroughIndirectBranches(MachineFunction &MF);</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  tracePredStateThroughIndirectBranches(MachineFunction &MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline"></td>
    <td class="lineNumber">180</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">  void tracePredStateThroughBlocksAndHarden(MachineFunction &MF);</td>
    <td class="lineNumber">181</td>
    <td class="codeline">  void tracePredStateThroughBlocksAndHarden(MachineFunction &MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline"></td>
    <td class="lineNumber">182</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  unsigned saveEFLAGS(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  unsigned saveEFLAGS(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">                      MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">184</td>
    <td class="codeline">                      MachineBasicBlock::iterator InsertPt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">                      const DebugLoc &Loc);</td>
    <td class="lineNumber">185</td>
    <td class="codeline">                      const DebugLoc &Loc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">  void restoreEFLAGS(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">186</td>
    <td class="codeline">  void restoreEFLAGS(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">                     MachineBasicBlock::iterator InsertPt, const DebugLoc &Loc,</td>
    <td class="lineNumber">187</td>
    <td class="codeline">                     MachineBasicBlock::iterator InsertPt, const DebugLoc &Loc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">                     Register Reg);</td>
    <td class="lineNumber">188</td>
    <td class="codeline">                     Register Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline"></td>
    <td class="lineNumber">189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  void mergePredStateIntoSP(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  void mergePredStateIntoSP(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">                            MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">191</td>
    <td class="codeline">                            MachineBasicBlock::iterator InsertPt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">                            const DebugLoc &Loc, unsigned PredStateReg);</td>
    <td class="lineNumber">192</td>
    <td class="codeline">                            const DebugLoc &Loc, unsigned PredStateReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  unsigned extractPredStateFromSP(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  unsigned extractPredStateFromSP(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">                                  MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">194</td>
    <td class="codeline">                                  MachineBasicBlock::iterator InsertPt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">                                  const DebugLoc &Loc);</td>
    <td class="lineNumber">195</td>
    <td class="codeline">                                  const DebugLoc &Loc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline"></td>
    <td class="lineNumber">196</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  void</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  void</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">  hardenLoadAddr(MachineInstr &MI, MachineOperand &BaseMO,</td>
    <td class="lineNumber">198</td>
    <td class="codeline">  hardenLoadAddr(MachineInstr &MI, MachineOperand &BaseMO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">                 MachineOperand &IndexMO,</td>
    <td class="lineNumber">199</td>
    <td class="codeline">                 MachineOperand &IndexMO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">                 SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg);</td>
    <td class="lineNumber">200</td>
    <td class="codeline">                 SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  MachineInstr *</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  MachineInstr *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">  sinkPostLoadHardenedInst(MachineInstr &MI,</td>
    <td class="lineNumber">202</td>
    <td class="codeline">  sinkPostLoadHardenedInst(MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">                           SmallPtrSetImpl<MachineInstr *> &HardenedInstrs);</td>
    <td class="lineNumber">203</td>
    <td class="codeline">                           SmallPtrSetImpl<MachineInstr *> &HardenedInstrs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">  bool canHardenRegister(Register Reg);</td>
    <td class="lineNumber">204</td>
    <td class="codeline">  bool canHardenRegister(Register Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  unsigned hardenValueInRegister(Register Reg, MachineBasicBlock &MBB,</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  unsigned hardenValueInRegister(Register Reg, MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">                                 MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">206</td>
    <td class="codeline">                                 MachineBasicBlock::iterator InsertPt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">                                 const DebugLoc &Loc);</td>
    <td class="lineNumber">207</td>
    <td class="codeline">                                 const DebugLoc &Loc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  unsigned hardenPostLoad(MachineInstr &MI);</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  unsigned hardenPostLoad(MachineInstr &MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">  void hardenReturnInstr(MachineInstr &MI);</td>
    <td class="lineNumber">209</td>
    <td class="codeline">  void hardenReturnInstr(MachineInstr &MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">  void tracePredStateThroughCall(MachineInstr &MI);</td>
    <td class="lineNumber">210</td>
    <td class="codeline">  void tracePredStateThroughCall(MachineInstr &MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  void hardenIndirectCallOrJumpInstr(</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  void hardenIndirectCallOrJumpInstr(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">      MachineInstr &MI,</td>
    <td class="lineNumber">212</td>
    <td class="codeline">      MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">      SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg);</td>
    <td class="lineNumber">213</td>
    <td class="codeline">      SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">};</td>
    <td class="lineNumber">214</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">216</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">char X86SpeculativeLoadHardeningPass::ID = 0;</td>
    <td class="lineNumber">218</td>
    <td class="codeline">char X86SpeculativeLoadHardeningPass::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline"></td>
    <td class="lineNumber">219</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::getAnalysisUsage(</td>
    <td class="lineNumber">220</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::getAnalysisUsage(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">    AnalysisUsage &AU) const {</td>
    <td class="lineNumber">221</td>
    <td class="codeline">    AnalysisUsage &AU) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">  MachineFunctionPass::getAnalysisUsage(AU);</td>
    <td class="lineNumber">222</td>
    <td class="codeline">  MachineFunctionPass::getAnalysisUsage(AU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">}</td>
    <td class="lineNumber">223</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline"></td>
    <td class="lineNumber">224</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">static MachineBasicBlock &splitEdge(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">225</td>
    <td class="codeline">static MachineBasicBlock &splitEdge(MachineBasicBlock &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">                                    MachineBasicBlock &Succ, int SuccCount,</td>
    <td class="lineNumber">226</td>
    <td class="codeline">                                    MachineBasicBlock &Succ, int SuccCount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">                                    MachineInstr *Br, MachineInstr *&UncondBr,</td>
    <td class="lineNumber">227</td>
    <td class="codeline">                                    MachineInstr *Br, MachineInstr *&UncondBr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">                                    const X86InstrInfo &TII) {</td>
    <td class="lineNumber">228</td>
    <td class="codeline">                                    const X86InstrInfo &TII) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  assert(!Succ.isEHPad() && "Shouldn't get edges to EH pads!");</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  assert(!Succ.isEHPad() && "Shouldn't get edges to EH pads!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline"></td>
    <td class="lineNumber">230</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  MachineFunction &MF = *MBB.getParent();</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  MachineFunction &MF = *MBB.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  MachineBasicBlock &NewMBB = *MF.CreateMachineBasicBlock();</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  MachineBasicBlock &NewMBB = *MF.CreateMachineBasicBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline"></td>
    <td class="lineNumber">234</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  // We have to insert the new block immediately after the current one as we</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  // We have to insert the new block immediately after the current one as we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">  // don't know what layout-successor relationships the successor has and we</td>
    <td class="lineNumber">236</td>
    <td class="codeline">  // don't know what layout-successor relationships the successor has and we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  // may not be able to (and generally don't want to) try to fix those up.</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  // may not be able to (and generally don't want to) try to fix those up.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  MF.insert(std::next(MachineFunction::iterator(&MBB)), &NewMBB);</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  MF.insert(std::next(MachineFunction::iterator(&MBB)), &NewMBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline"></td>
    <td class="lineNumber">239</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  // Update the branch instruction if necessary.</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  // Update the branch instruction if necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  if (Br) {</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  if (Br) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">    assert(Br->getOperand(0).getMBB() == &Succ &&</td>
    <td class="lineNumber">242</td>
    <td class="codeline">    assert(Br->getOperand(0).getMBB() == &Succ &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">           "Didn't start with the right target!");</td>
    <td class="lineNumber">243</td>
    <td class="codeline">           "Didn't start with the right target!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">    Br->getOperand(0).setMBB(&NewMBB);</td>
    <td class="lineNumber">244</td>
    <td class="codeline">    Br->getOperand(0).setMBB(&NewMBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
    <td class="lineNumber">245</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">    // If this successor was reached through a branch rather than fallthrough,</td>
    <td class="lineNumber">246</td>
    <td class="codeline">    // If this successor was reached through a branch rather than fallthrough,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">    // we might have *broken* fallthrough and so need to inject a new</td>
    <td class="lineNumber">247</td>
    <td class="codeline">    // we might have *broken* fallthrough and so need to inject a new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">    // unconditional branch.</td>
    <td class="lineNumber">248</td>
    <td class="codeline">    // unconditional branch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">    if (!UncondBr) {</td>
    <td class="lineNumber">249</td>
    <td class="codeline">    if (!UncondBr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">      MachineBasicBlock &OldLayoutSucc =</td>
    <td class="lineNumber">250</td>
    <td class="codeline">      MachineBasicBlock &OldLayoutSucc =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">          *std::next(MachineFunction::iterator(&NewMBB));</td>
    <td class="lineNumber">251</td>
    <td class="codeline">          *std::next(MachineFunction::iterator(&NewMBB));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">      assert(MBB.isSuccessor(&OldLayoutSucc) &&</td>
    <td class="lineNumber">252</td>
    <td class="codeline">      assert(MBB.isSuccessor(&OldLayoutSucc) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">             "Without an unconditional branch, the old layout successor should "</td>
    <td class="lineNumber">253</td>
    <td class="codeline">             "Without an unconditional branch, the old layout successor should "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">             "be an actual successor!");</td>
    <td class="lineNumber">254</td>
    <td class="codeline">             "be an actual successor!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">      auto BrBuilder =</td>
    <td class="lineNumber">255</td>
    <td class="codeline">      auto BrBuilder =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">          BuildMI(&MBB, DebugLoc(), TII.get(X86::JMP_1)).addMBB(&OldLayoutSucc);</td>
    <td class="lineNumber">256</td>
    <td class="codeline">          BuildMI(&MBB, DebugLoc(), TII.get(X86::JMP_1)).addMBB(&OldLayoutSucc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">      // Update the unconditional branch now that we've added one.</td>
    <td class="lineNumber">257</td>
    <td class="codeline">      // Update the unconditional branch now that we've added one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">      UncondBr = &*BrBuilder;</td>
    <td class="lineNumber">258</td>
    <td class="codeline">      UncondBr = &*BrBuilder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">259</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline"></td>
    <td class="lineNumber">260</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">    // Insert unconditional "jump Succ" instruction in the new block if</td>
    <td class="lineNumber">261</td>
    <td class="codeline">    // Insert unconditional "jump Succ" instruction in the new block if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">    // necessary.</td>
    <td class="lineNumber">262</td>
    <td class="codeline">    // necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">    if (!NewMBB.isLayoutSuccessor(&Succ)) {</td>
    <td class="lineNumber">263</td>
    <td class="codeline">    if (!NewMBB.isLayoutSuccessor(&Succ)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">      SmallVector<MachineOperand, 4> Cond;</td>
    <td class="lineNumber">264</td>
    <td class="codeline">      SmallVector<MachineOperand, 4> Cond;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">      TII.insertBranch(NewMBB, &Succ, nullptr, Cond, Br->getDebugLoc());</td>
    <td class="lineNumber">265</td>
    <td class="codeline">      TII.insertBranch(NewMBB, &Succ, nullptr, Cond, Br->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">266</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">    assert(!UncondBr &&</td>
    <td class="lineNumber">268</td>
    <td class="codeline">    assert(!UncondBr &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">           "Cannot have a branchless successor and an unconditional branch!");</td>
    <td class="lineNumber">269</td>
    <td class="codeline">           "Cannot have a branchless successor and an unconditional branch!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">    assert(NewMBB.isLayoutSuccessor(&Succ) &&</td>
    <td class="lineNumber">270</td>
    <td class="codeline">    assert(NewMBB.isLayoutSuccessor(&Succ) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">           "A non-branch successor must have been a layout successor before "</td>
    <td class="lineNumber">271</td>
    <td class="codeline">           "A non-branch successor must have been a layout successor before "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">           "and now is a layout successor of the new block.");</td>
    <td class="lineNumber">272</td>
    <td class="codeline">           "and now is a layout successor of the new block.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline"></td>
    <td class="lineNumber">274</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  // If this is the only edge to the successor, we can just replace it in the</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  // If this is the only edge to the successor, we can just replace it in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  // CFG. Otherwise we need to add a new entry in the CFG for the new</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  // CFG. Otherwise we need to add a new entry in the CFG for the new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">  // successor.</td>
    <td class="lineNumber">277</td>
    <td class="codeline">  // successor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  if (SuccCount == 1) {</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  if (SuccCount == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">    MBB.replaceSuccessor(&Succ, &NewMBB);</td>
    <td class="lineNumber">279</td>
    <td class="codeline">    MBB.replaceSuccessor(&Succ, &NewMBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">    MBB.splitSuccessor(&Succ, &NewMBB);</td>
    <td class="lineNumber">281</td>
    <td class="codeline">    MBB.splitSuccessor(&Succ, &NewMBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">282</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline"></td>
    <td class="lineNumber">283</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  // Hook up the edge from the new basic block to the old successor in the CFG.</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  // Hook up the edge from the new basic block to the old successor in the CFG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  NewMBB.addSuccessor(&Succ);</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  NewMBB.addSuccessor(&Succ);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  // Fix PHI nodes in Succ so they refer to NewMBB instead of MBB.</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  // Fix PHI nodes in Succ so they refer to NewMBB instead of MBB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  for (MachineInstr &MI : Succ) {</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  for (MachineInstr &MI : Succ) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">    if (!MI.isPHI())</td>
    <td class="lineNumber">289</td>
    <td class="codeline">    if (!MI.isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">290</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">    for (int OpIdx = 1, NumOps = MI.getNumOperands(); OpIdx < NumOps;</td>
    <td class="lineNumber">291</td>
    <td class="codeline">    for (int OpIdx = 1, NumOps = MI.getNumOperands(); OpIdx < NumOps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">         OpIdx += 2) {</td>
    <td class="lineNumber">292</td>
    <td class="codeline">         OpIdx += 2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">      MachineOperand &OpV = MI.getOperand(OpIdx);</td>
    <td class="lineNumber">293</td>
    <td class="codeline">      MachineOperand &OpV = MI.getOperand(OpIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">      MachineOperand &OpMBB = MI.getOperand(OpIdx + 1);</td>
    <td class="lineNumber">294</td>
    <td class="codeline">      MachineOperand &OpMBB = MI.getOperand(OpIdx + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">      assert(OpMBB.isMBB() && "Block operand to a PHI is not a block!");</td>
    <td class="lineNumber">295</td>
    <td class="codeline">      assert(OpMBB.isMBB() && "Block operand to a PHI is not a block!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">      if (OpMBB.getMBB() != &MBB)</td>
    <td class="lineNumber">296</td>
    <td class="codeline">      if (OpMBB.getMBB() != &MBB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">297</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline"></td>
    <td class="lineNumber">298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">      // If this is the last edge to the succesor, just replace MBB in the PHI</td>
    <td class="lineNumber">299</td>
    <td class="codeline">      // If this is the last edge to the succesor, just replace MBB in the PHI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">      if (SuccCount == 1) {</td>
    <td class="lineNumber">300</td>
    <td class="codeline">      if (SuccCount == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">        OpMBB.setMBB(&NewMBB);</td>
    <td class="lineNumber">301</td>
    <td class="codeline">        OpMBB.setMBB(&NewMBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">302</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">303</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline"></td>
    <td class="lineNumber">304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">      // Otherwise, append a new pair of operands for the new incoming edge.</td>
    <td class="lineNumber">305</td>
    <td class="codeline">      // Otherwise, append a new pair of operands for the new incoming edge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">      MI.addOperand(MF, OpV);</td>
    <td class="lineNumber">306</td>
    <td class="codeline">      MI.addOperand(MF, OpV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">      MI.addOperand(MF, MachineOperand::CreateMBB(&NewMBB));</td>
    <td class="lineNumber">307</td>
    <td class="codeline">      MI.addOperand(MF, MachineOperand::CreateMBB(&NewMBB));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">308</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">309</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">310</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">  // Inherit live-ins from the successor</td>
    <td class="lineNumber">312</td>
    <td class="codeline">  // Inherit live-ins from the successor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">  for (auto &LI : Succ.liveins())</td>
    <td class="lineNumber">313</td>
    <td class="codeline">  for (auto &LI : Succ.liveins())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">    NewMBB.addLiveIn(LI);</td>
    <td class="lineNumber">314</td>
    <td class="codeline">    NewMBB.addLiveIn(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Split edge from '" << MBB.getName() << "' to '"</td>
    <td class="lineNumber">316</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Split edge from '" << MBB.getName() << "' to '"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">                    << Succ.getName() << "'.\n");</td>
    <td class="lineNumber">317</td>
    <td class="codeline">                    << Succ.getName() << "'.\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">  return NewMBB;</td>
    <td class="lineNumber">318</td>
    <td class="codeline">  return NewMBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">}</td>
    <td class="lineNumber">319</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline"></td>
    <td class="lineNumber">320</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">/// Removing duplicate PHI operands to leave the PHI in a canonical and</td>
    <td class="lineNumber">321</td>
    <td class="codeline">/// Removing duplicate PHI operands to leave the PHI in a canonical and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">/// predictable form.</td>
    <td class="lineNumber">322</td>
    <td class="codeline">/// predictable form.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">///</td>
    <td class="lineNumber">323</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">/// FIXME: It's really frustrating that we have to do this, but SSA-form in MIR</td>
    <td class="lineNumber">324</td>
    <td class="codeline">/// FIXME: It's really frustrating that we have to do this, but SSA-form in MIR</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">/// isn't what you might expect. We may have multiple entries in PHI nodes for</td>
    <td class="lineNumber">325</td>
    <td class="codeline">/// isn't what you might expect. We may have multiple entries in PHI nodes for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">/// a single predecessor. This makes CFG-updating extremely complex, so here we</td>
    <td class="lineNumber">326</td>
    <td class="codeline">/// a single predecessor. This makes CFG-updating extremely complex, so here we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">/// simplify all PHI nodes to a model even simpler than the IR's model: exactly</td>
    <td class="lineNumber">327</td>
    <td class="codeline">/// simplify all PHI nodes to a model even simpler than the IR's model: exactly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">/// one entry per predecessor, regardless of how many edges there are.</td>
    <td class="lineNumber">328</td>
    <td class="codeline">/// one entry per predecessor, regardless of how many edges there are.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">static void canonicalizePHIOperands(MachineFunction &MF) {</td>
    <td class="lineNumber">329</td>
    <td class="codeline">static void canonicalizePHIOperands(MachineFunction &MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  SmallPtrSet<MachineBasicBlock *, 4> Preds;</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  SmallPtrSet<MachineBasicBlock *, 4> Preds;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">  SmallVector<int, 4> DupIndices;</td>
    <td class="lineNumber">331</td>
    <td class="codeline">  SmallVector<int, 4> DupIndices;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">  for (auto &MBB : MF)</td>
    <td class="lineNumber">332</td>
    <td class="codeline">  for (auto &MBB : MF)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">    for (auto &MI : MBB) {</td>
    <td class="lineNumber">333</td>
    <td class="codeline">    for (auto &MI : MBB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">      if (!MI.isPHI())</td>
    <td class="lineNumber">334</td>
    <td class="codeline">      if (!MI.isPHI())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">335</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">      // First we scan the operands of the PHI looking for duplicate entries</td>
    <td class="lineNumber">337</td>
    <td class="codeline">      // First we scan the operands of the PHI looking for duplicate entries</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">      // a particular predecessor. We retain the operand index of each duplicate</td>
    <td class="lineNumber">338</td>
    <td class="codeline">      // a particular predecessor. We retain the operand index of each duplicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">      // entry found.</td>
    <td class="lineNumber">339</td>
    <td class="codeline">      // entry found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">      for (int OpIdx = 1, NumOps = MI.getNumOperands(); OpIdx < NumOps;</td>
    <td class="lineNumber">340</td>
    <td class="codeline">      for (int OpIdx = 1, NumOps = MI.getNumOperands(); OpIdx < NumOps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">           OpIdx += 2)</td>
    <td class="lineNumber">341</td>
    <td class="codeline">           OpIdx += 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">        if (!Preds.insert(MI.getOperand(OpIdx + 1).getMBB()).second)</td>
    <td class="lineNumber">342</td>
    <td class="codeline">        if (!Preds.insert(MI.getOperand(OpIdx + 1).getMBB()).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">          DupIndices.push_back(OpIdx);</td>
    <td class="lineNumber">343</td>
    <td class="codeline">          DupIndices.push_back(OpIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">      // Now walk the duplicate indices, removing both the block and value. Note</td>
    <td class="lineNumber">345</td>
    <td class="codeline">      // Now walk the duplicate indices, removing both the block and value. Note</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">      // that these are stored as a vector making this element-wise removal</td>
    <td class="lineNumber">346</td>
    <td class="codeline">      // that these are stored as a vector making this element-wise removal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">      // :w</td>
    <td class="lineNumber">347</td>
    <td class="codeline">      // :w</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">      // potentially quadratic.</td>
    <td class="lineNumber">348</td>
    <td class="codeline">      // potentially quadratic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">349</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">      // FIXME: It is really frustrating that we have to use a quadratic</td>
    <td class="lineNumber">350</td>
    <td class="codeline">      // FIXME: It is really frustrating that we have to use a quadratic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">      // removal algorithm here. There should be a better way, but the use-def</td>
    <td class="lineNumber">351</td>
    <td class="codeline">      // removal algorithm here. There should be a better way, but the use-def</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">      // updates required make that impossible using the public API.</td>
    <td class="lineNumber">352</td>
    <td class="codeline">      // updates required make that impossible using the public API.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">353</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">      // Note that we have to process these backwards so that we don't</td>
    <td class="lineNumber">354</td>
    <td class="codeline">      // Note that we have to process these backwards so that we don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">      // invalidate other indices with each removal.</td>
    <td class="lineNumber">355</td>
    <td class="codeline">      // invalidate other indices with each removal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">      while (!DupIndices.empty()) {</td>
    <td class="lineNumber">356</td>
    <td class="codeline">      while (!DupIndices.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">        int OpIdx = DupIndices.pop_back_val();</td>
    <td class="lineNumber">357</td>
    <td class="codeline">        int OpIdx = DupIndices.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">        // Remove both the block and value operand, again in reverse order to</td>
    <td class="lineNumber">358</td>
    <td class="codeline">        // Remove both the block and value operand, again in reverse order to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">        // preserve indices.</td>
    <td class="lineNumber">359</td>
    <td class="codeline">        // preserve indices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">        MI.removeOperand(OpIdx + 1);</td>
    <td class="lineNumber">360</td>
    <td class="codeline">        MI.removeOperand(OpIdx + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">        MI.removeOperand(OpIdx);</td>
    <td class="lineNumber">361</td>
    <td class="codeline">        MI.removeOperand(OpIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">362</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline"></td>
    <td class="lineNumber">363</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">      Preds.clear();</td>
    <td class="lineNumber">364</td>
    <td class="codeline">      Preds.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">365</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">}</td>
    <td class="lineNumber">366</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">/// Helper to scan a function for loads vulnerable to misspeculation that we</td>
    <td class="lineNumber">368</td>
    <td class="codeline">/// Helper to scan a function for loads vulnerable to misspeculation that we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">/// want to harden.</td>
    <td class="lineNumber">369</td>
    <td class="codeline">/// want to harden.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">///</td>
    <td class="lineNumber">370</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">/// We use this to avoid making changes to functions where there is nothing we</td>
    <td class="lineNumber">371</td>
    <td class="codeline">/// We use this to avoid making changes to functions where there is nothing we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">/// need to do to harden against misspeculation.</td>
    <td class="lineNumber">372</td>
    <td class="codeline">/// need to do to harden against misspeculation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">static bool hasVulnerableLoad(MachineFunction &MF) {</td>
    <td class="lineNumber">373</td>
    <td class="codeline">static bool hasVulnerableLoad(MachineFunction &MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">374</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">    for (MachineInstr &MI : MBB) {</td>
    <td class="lineNumber">375</td>
    <td class="codeline">    for (MachineInstr &MI : MBB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">      // Loads within this basic block after an LFENCE are not at risk of</td>
    <td class="lineNumber">376</td>
    <td class="codeline">      // Loads within this basic block after an LFENCE are not at risk of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">      // speculatively executing with invalid predicates from prior control</td>
    <td class="lineNumber">377</td>
    <td class="codeline">      // speculatively executing with invalid predicates from prior control</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">      // flow. So break out of this block but continue scanning the function.</td>
    <td class="lineNumber">378</td>
    <td class="codeline">      // flow. So break out of this block but continue scanning the function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">      if (MI.getOpcode() == X86::LFENCE)</td>
    <td class="lineNumber">379</td>
    <td class="codeline">      if (MI.getOpcode() == X86::LFENCE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">380</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline"></td>
    <td class="lineNumber">381</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">      // Looking for loads only.</td>
    <td class="lineNumber">382</td>
    <td class="codeline">      // Looking for loads only.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">      if (!MI.mayLoad())</td>
    <td class="lineNumber">383</td>
    <td class="codeline">      if (!MI.mayLoad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">384</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline"></td>
    <td class="lineNumber">385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">      // An MFENCE is modeled as a load but isn't vulnerable to misspeculation.</td>
    <td class="lineNumber">386</td>
    <td class="codeline">      // An MFENCE is modeled as a load but isn't vulnerable to misspeculation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">      if (MI.getOpcode() == X86::MFENCE)</td>
    <td class="lineNumber">387</td>
    <td class="codeline">      if (MI.getOpcode() == X86::MFENCE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">388</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">      // We found a load.</td>
    <td class="lineNumber">390</td>
    <td class="codeline">      // We found a load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">391</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">392</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline"></td>
    <td class="lineNumber">394</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">  // No loads found.</td>
    <td class="lineNumber">395</td>
    <td class="codeline">  // No loads found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">}</td>
    <td class="lineNumber">397</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline"></td>
    <td class="lineNumber">398</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">bool X86SpeculativeLoadHardeningPass::runOnMachineFunction(</td>
    <td class="lineNumber">399</td>
    <td class="codeline">bool X86SpeculativeLoadHardeningPass::runOnMachineFunction(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">    MachineFunction &MF) {</td>
    <td class="lineNumber">400</td>
    <td class="codeline">    MachineFunction &MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "********** " << getPassName() << " : " << MF.getName()</td>
    <td class="lineNumber">401</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "********** " << getPassName() << " : " << MF.getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">                    << " **********\n");</td>
    <td class="lineNumber">402</td>
    <td class="codeline">                    << " **********\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline"></td>
    <td class="lineNumber">403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  // Only run if this pass is forced enabled or we detect the relevant function</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  // Only run if this pass is forced enabled or we detect the relevant function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  // attribute requesting SLH.</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  // attribute requesting SLH.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">  if (!EnableSpeculativeLoadHardening &&</td>
    <td class="lineNumber">406</td>
    <td class="codeline">  if (!EnableSpeculativeLoadHardening &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">      !MF.getFunction().hasFnAttribute(Attribute::SpeculativeLoadHardening))</td>
    <td class="lineNumber">407</td>
    <td class="codeline">      !MF.getFunction().hasFnAttribute(Attribute::SpeculativeLoadHardening))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">408</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">  Subtarget = &MF.getSubtarget<X86Subtarget>();</td>
    <td class="lineNumber">410</td>
    <td class="codeline">  Subtarget = &MF.getSubtarget<X86Subtarget>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  MRI = &MF.getRegInfo();</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  MRI = &MF.getRegInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  TII = Subtarget->getInstrInfo();</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  TII = Subtarget->getInstrInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">  TRI = Subtarget->getRegisterInfo();</td>
    <td class="lineNumber">413</td>
    <td class="codeline">  TRI = Subtarget->getRegisterInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline"></td>
    <td class="lineNumber">414</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  // FIXME: Support for 32-bit.</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  // FIXME: Support for 32-bit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">  PS.emplace(MF, &X86::GR64_NOSPRegClass);</td>
    <td class="lineNumber">416</td>
    <td class="codeline">  PS.emplace(MF, &X86::GR64_NOSPRegClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline"></td>
    <td class="lineNumber">417</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">  if (MF.begin() == MF.end())</td>
    <td class="lineNumber">418</td>
    <td class="codeline">  if (MF.begin() == MF.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">    // Nothing to do for a degenerate empty function...</td>
    <td class="lineNumber">419</td>
    <td class="codeline">    // Nothing to do for a degenerate empty function...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">420</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline"></td>
    <td class="lineNumber">421</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  // We support an alternative hardening technique based on a debug flag.</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  // We support an alternative hardening technique based on a debug flag.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">  if (HardenEdgesWithLFENCE) {</td>
    <td class="lineNumber">423</td>
    <td class="codeline">  if (HardenEdgesWithLFENCE) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">    hardenEdgesWithLFENCE(MF);</td>
    <td class="lineNumber">424</td>
    <td class="codeline">    hardenEdgesWithLFENCE(MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">425</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline"></td>
    <td class="lineNumber">427</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  // Create a dummy debug loc to use for all the generated code here.</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  // Create a dummy debug loc to use for all the generated code here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">  DebugLoc Loc;</td>
    <td class="lineNumber">429</td>
    <td class="codeline">  DebugLoc Loc;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline"></td>
    <td class="lineNumber">430</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  MachineBasicBlock &Entry = *MF.begin();</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  MachineBasicBlock &Entry = *MF.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  auto EntryInsertPt = Entry.SkipPHIsLabelsAndDebug(Entry.begin());</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  auto EntryInsertPt = Entry.SkipPHIsLabelsAndDebug(Entry.begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline"></td>
    <td class="lineNumber">433</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">  // Do a quick scan to see if we have any checkable loads.</td>
    <td class="lineNumber">434</td>
    <td class="codeline">  // Do a quick scan to see if we have any checkable loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  bool HasVulnerableLoad = hasVulnerableLoad(MF);</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  bool HasVulnerableLoad = hasVulnerableLoad(MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline"></td>
    <td class="lineNumber">436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">  // See if we have any conditional branching blocks that we will need to trace</td>
    <td class="lineNumber">437</td>
    <td class="codeline">  // See if we have any conditional branching blocks that we will need to trace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">  // predicate state through.</td>
    <td class="lineNumber">438</td>
    <td class="codeline">  // predicate state through.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  SmallVector<BlockCondInfo, 16> Infos = collectBlockCondInfo(MF);</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  SmallVector<BlockCondInfo, 16> Infos = collectBlockCondInfo(MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline"></td>
    <td class="lineNumber">440</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">  // If we have no interesting conditions or loads, nothing to do here.</td>
    <td class="lineNumber">441</td>
    <td class="codeline">  // If we have no interesting conditions or loads, nothing to do here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">  if (!HasVulnerableLoad && Infos.empty())</td>
    <td class="lineNumber">442</td>
    <td class="codeline">  if (!HasVulnerableLoad && Infos.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">443</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline"></td>
    <td class="lineNumber">444</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">  // The poison value is required to be an all-ones value for many aspects of</td>
    <td class="lineNumber">445</td>
    <td class="codeline">  // The poison value is required to be an all-ones value for many aspects of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">  // this mitigation.</td>
    <td class="lineNumber">446</td>
    <td class="codeline">  // this mitigation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">  const int PoisonVal = -1;</td>
    <td class="lineNumber">447</td>
    <td class="codeline">  const int PoisonVal = -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">  PS->PoisonReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">448</td>
    <td class="codeline">  PS->PoisonReg = MRI->createVirtualRegister(PS->RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">  BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::MOV64ri32), PS->PoisonReg)</td>
    <td class="lineNumber">449</td>
    <td class="codeline">  BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::MOV64ri32), PS->PoisonReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">      .addImm(PoisonVal);</td>
    <td class="lineNumber">450</td>
    <td class="codeline">      .addImm(PoisonVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">  ++NumInstsInserted;</td>
    <td class="lineNumber">451</td>
    <td class="codeline">  ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  // If we have loads being hardened and we've asked for call and ret edges to</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  // If we have loads being hardened and we've asked for call and ret edges to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">  // get a full fence-based mitigation, inject that fence.</td>
    <td class="lineNumber">454</td>
    <td class="codeline">  // get a full fence-based mitigation, inject that fence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  if (HasVulnerableLoad && FenceCallAndRet) {</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  if (HasVulnerableLoad && FenceCallAndRet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">    // We need to insert an LFENCE at the start of the function to suspend any</td>
    <td class="lineNumber">456</td>
    <td class="codeline">    // We need to insert an LFENCE at the start of the function to suspend any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">    // incoming misspeculation from the caller. This helps two-fold: the caller</td>
    <td class="lineNumber">457</td>
    <td class="codeline">    // incoming misspeculation from the caller. This helps two-fold: the caller</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">    // may not have been protected as this code has been, and this code gets to</td>
    <td class="lineNumber">458</td>
    <td class="codeline">    // may not have been protected as this code has been, and this code gets to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">    // not take any specific action to protect across calls.</td>
    <td class="lineNumber">459</td>
    <td class="codeline">    // not take any specific action to protect across calls.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">    // FIXME: We could skip this for functions which unconditionally return</td>
    <td class="lineNumber">460</td>
    <td class="codeline">    // FIXME: We could skip this for functions which unconditionally return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">    // a constant.</td>
    <td class="lineNumber">461</td>
    <td class="codeline">    // a constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">    BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::LFENCE));</td>
    <td class="lineNumber">462</td>
    <td class="codeline">    BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::LFENCE));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">    ++NumInstsInserted;</td>
    <td class="lineNumber">463</td>
    <td class="codeline">    ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">    ++NumLFENCEsInserted;</td>
    <td class="lineNumber">464</td>
    <td class="codeline">    ++NumLFENCEsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  // If we guarded the entry with an LFENCE and have no conditionals to protect</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  // If we guarded the entry with an LFENCE and have no conditionals to protect</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">  // in blocks, then we're done.</td>
    <td class="lineNumber">468</td>
    <td class="codeline">  // in blocks, then we're done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">  if (FenceCallAndRet && Infos.empty())</td>
    <td class="lineNumber">469</td>
    <td class="codeline">  if (FenceCallAndRet && Infos.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">    // We may have changed the function's code at this point to insert fences.</td>
    <td class="lineNumber">470</td>
    <td class="codeline">    // We may have changed the function's code at this point to insert fences.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">471</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline"></td>
    <td class="lineNumber">472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  // For every basic block in the function which can b</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  // For every basic block in the function which can b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  if (HardenInterprocedurally && !FenceCallAndRet) {</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  if (HardenInterprocedurally && !FenceCallAndRet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">    // Set up the predicate state by extracting it from the incoming stack</td>
    <td class="lineNumber">475</td>
    <td class="codeline">    // Set up the predicate state by extracting it from the incoming stack</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">    // pointer so we pick up any misspeculation in our caller.</td>
    <td class="lineNumber">476</td>
    <td class="codeline">    // pointer so we pick up any misspeculation in our caller.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">    PS->InitialReg = extractPredStateFromSP(Entry, EntryInsertPt, Loc);</td>
    <td class="lineNumber">477</td>
    <td class="codeline">    PS->InitialReg = extractPredStateFromSP(Entry, EntryInsertPt, Loc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">    // Otherwise, just build the predicate state itself by zeroing a register</td>
    <td class="lineNumber">479</td>
    <td class="codeline">    // Otherwise, just build the predicate state itself by zeroing a register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">    // as we don't need any initial state.</td>
    <td class="lineNumber">480</td>
    <td class="codeline">    // as we don't need any initial state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">    PS->InitialReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">481</td>
    <td class="codeline">    PS->InitialReg = MRI->createVirtualRegister(PS->RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">    Register PredStateSubReg = MRI->createVirtualRegister(&X86::GR32RegClass);</td>
    <td class="lineNumber">482</td>
    <td class="codeline">    Register PredStateSubReg = MRI->createVirtualRegister(&X86::GR32RegClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">    auto ZeroI = BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::MOV32r0),</td>
    <td class="lineNumber">483</td>
    <td class="codeline">    auto ZeroI = BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::MOV32r0),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">                         PredStateSubReg);</td>
    <td class="lineNumber">484</td>
    <td class="codeline">                         PredStateSubReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">    ++NumInstsInserted;</td>
    <td class="lineNumber">485</td>
    <td class="codeline">    ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">    MachineOperand *ZeroEFLAGSDefOp =</td>
    <td class="lineNumber">486</td>
    <td class="codeline">    MachineOperand *ZeroEFLAGSDefOp =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">        ZeroI->findRegisterDefOperand(X86::EFLAGS);</td>
    <td class="lineNumber">487</td>
    <td class="codeline">        ZeroI->findRegisterDefOperand(X86::EFLAGS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">    assert(ZeroEFLAGSDefOp && ZeroEFLAGSDefOp->isImplicit() &&</td>
    <td class="lineNumber">488</td>
    <td class="codeline">    assert(ZeroEFLAGSDefOp && ZeroEFLAGSDefOp->isImplicit() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">           "Must have an implicit def of EFLAGS!");</td>
    <td class="lineNumber">489</td>
    <td class="codeline">           "Must have an implicit def of EFLAGS!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">    ZeroEFLAGSDefOp->setIsDead(true);</td>
    <td class="lineNumber">490</td>
    <td class="codeline">    ZeroEFLAGSDefOp->setIsDead(true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">    BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::SUBREG_TO_REG),</td>
    <td class="lineNumber">491</td>
    <td class="codeline">    BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::SUBREG_TO_REG),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">            PS->InitialReg)</td>
    <td class="lineNumber">492</td>
    <td class="codeline">            PS->InitialReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">        .addImm(0)</td>
    <td class="lineNumber">493</td>
    <td class="codeline">        .addImm(0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">        .addReg(PredStateSubReg)</td>
    <td class="lineNumber">494</td>
    <td class="codeline">        .addReg(PredStateSubReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">        .addImm(X86::sub_32bit);</td>
    <td class="lineNumber">495</td>
    <td class="codeline">        .addImm(X86::sub_32bit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline"></td>
    <td class="lineNumber">497</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">  // We're going to need to trace predicate state throughout the function's</td>
    <td class="lineNumber">498</td>
    <td class="codeline">  // We're going to need to trace predicate state throughout the function's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">  // CFG. Prepare for this by setting up our initial state of PHIs with unique</td>
    <td class="lineNumber">499</td>
    <td class="codeline">  // CFG. Prepare for this by setting up our initial state of PHIs with unique</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">  // predecessor entries and all the initial predicate state.</td>
    <td class="lineNumber">500</td>
    <td class="codeline">  // predecessor entries and all the initial predicate state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">  canonicalizePHIOperands(MF);</td>
    <td class="lineNumber">501</td>
    <td class="codeline">  canonicalizePHIOperands(MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline"></td>
    <td class="lineNumber">502</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">  // Track the updated values in an SSA updater to rewrite into SSA form at the</td>
    <td class="lineNumber">503</td>
    <td class="codeline">  // Track the updated values in an SSA updater to rewrite into SSA form at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">  // end.</td>
    <td class="lineNumber">504</td>
    <td class="codeline">  // end.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">  PS->SSA.Initialize(PS->InitialReg);</td>
    <td class="lineNumber">505</td>
    <td class="codeline">  PS->SSA.Initialize(PS->InitialReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">  PS->SSA.AddAvailableValue(&Entry, PS->InitialReg);</td>
    <td class="lineNumber">506</td>
    <td class="codeline">  PS->SSA.AddAvailableValue(&Entry, PS->InitialReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline"></td>
    <td class="lineNumber">507</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  // Trace through the CFG.</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  // Trace through the CFG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  auto CMovs = tracePredStateThroughCFG(MF, Infos);</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  auto CMovs = tracePredStateThroughCFG(MF, Infos);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline"></td>
    <td class="lineNumber">510</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">  // We may also enter basic blocks in this function via exception handling</td>
    <td class="lineNumber">511</td>
    <td class="codeline">  // We may also enter basic blocks in this function via exception handling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  // control flow. Here, if we are hardening interprocedurally, we need to</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  // control flow. Here, if we are hardening interprocedurally, we need to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">  // re-capture the predicate state from the throwing code. In the Itanium ABI,</td>
    <td class="lineNumber">513</td>
    <td class="codeline">  // re-capture the predicate state from the throwing code. In the Itanium ABI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">  // the throw will always look like a call to __cxa_throw and will have the</td>
    <td class="lineNumber">514</td>
    <td class="codeline">  // the throw will always look like a call to __cxa_throw and will have the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">  // predicate state in the stack pointer, so extract fresh predicate state from</td>
    <td class="lineNumber">515</td>
    <td class="codeline">  // predicate state in the stack pointer, so extract fresh predicate state from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">  // the stack pointer and make it available in SSA.</td>
    <td class="lineNumber">516</td>
    <td class="codeline">  // the stack pointer and make it available in SSA.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">  // FIXME: Handle non-itanium ABI EH models.</td>
    <td class="lineNumber">517</td>
    <td class="codeline">  // FIXME: Handle non-itanium ABI EH models.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">  if (HardenInterprocedurally) {</td>
    <td class="lineNumber">518</td>
    <td class="codeline">  if (HardenInterprocedurally) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">    for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">519</td>
    <td class="codeline">    for (MachineBasicBlock &MBB : MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">      assert(!MBB.isEHScopeEntry() && "Only Itanium ABI EH supported!");</td>
    <td class="lineNumber">520</td>
    <td class="codeline">      assert(!MBB.isEHScopeEntry() && "Only Itanium ABI EH supported!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">      assert(!MBB.isEHFuncletEntry() && "Only Itanium ABI EH supported!");</td>
    <td class="lineNumber">521</td>
    <td class="codeline">      assert(!MBB.isEHFuncletEntry() && "Only Itanium ABI EH supported!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">      assert(!MBB.isCleanupFuncletEntry() && "Only Itanium ABI EH supported!");</td>
    <td class="lineNumber">522</td>
    <td class="codeline">      assert(!MBB.isCleanupFuncletEntry() && "Only Itanium ABI EH supported!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">      if (!MBB.isEHPad())</td>
    <td class="lineNumber">523</td>
    <td class="codeline">      if (!MBB.isEHPad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">524</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">      PS->SSA.AddAvailableValue(</td>
    <td class="lineNumber">525</td>
    <td class="codeline">      PS->SSA.AddAvailableValue(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">          &MBB,</td>
    <td class="lineNumber">526</td>
    <td class="codeline">          &MBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">          extractPredStateFromSP(MBB, MBB.SkipPHIsAndLabels(MBB.begin()), Loc));</td>
    <td class="lineNumber">527</td>
    <td class="codeline">          extractPredStateFromSP(MBB, MBB.SkipPHIsAndLabels(MBB.begin()), Loc));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">528</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">529</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline"></td>
    <td class="lineNumber">530</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">  if (HardenIndirectCallsAndJumps) {</td>
    <td class="lineNumber">531</td>
    <td class="codeline">  if (HardenIndirectCallsAndJumps) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">    // If we are going to harden calls and jumps we need to unfold their memory</td>
    <td class="lineNumber">532</td>
    <td class="codeline">    // If we are going to harden calls and jumps we need to unfold their memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">    // operands.</td>
    <td class="lineNumber">533</td>
    <td class="codeline">    // operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">    unfoldCallAndJumpLoads(MF);</td>
    <td class="lineNumber">534</td>
    <td class="codeline">    unfoldCallAndJumpLoads(MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline"></td>
    <td class="lineNumber">535</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">    // Then we trace predicate state through the indirect branches.</td>
    <td class="lineNumber">536</td>
    <td class="codeline">    // Then we trace predicate state through the indirect branches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">    auto IndirectBrCMovs = tracePredStateThroughIndirectBranches(MF);</td>
    <td class="lineNumber">537</td>
    <td class="codeline">    auto IndirectBrCMovs = tracePredStateThroughIndirectBranches(MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">    CMovs.append(IndirectBrCMovs.begin(), IndirectBrCMovs.end());</td>
    <td class="lineNumber">538</td>
    <td class="codeline">    CMovs.append(IndirectBrCMovs.begin(), IndirectBrCMovs.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  // Now that we have the predicate state available at the start of each block</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  // Now that we have the predicate state available at the start of each block</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">  // in the CFG, trace it through each block, hardening vulnerable instructions</td>
    <td class="lineNumber">542</td>
    <td class="codeline">  // in the CFG, trace it through each block, hardening vulnerable instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">  // as we go.</td>
    <td class="lineNumber">543</td>
    <td class="codeline">  // as we go.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">  tracePredStateThroughBlocksAndHarden(MF);</td>
    <td class="lineNumber">544</td>
    <td class="codeline">  tracePredStateThroughBlocksAndHarden(MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline"></td>
    <td class="lineNumber">545</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">  // Now rewrite all the uses of the pred state using the SSA updater to insert</td>
    <td class="lineNumber">546</td>
    <td class="codeline">  // Now rewrite all the uses of the pred state using the SSA updater to insert</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  // PHIs connecting the state between blocks along the CFG edges.</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  // PHIs connecting the state between blocks along the CFG edges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  for (MachineInstr *CMovI : CMovs)</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  for (MachineInstr *CMovI : CMovs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">    for (MachineOperand &Op : CMovI->operands()) {</td>
    <td class="lineNumber">549</td>
    <td class="codeline">    for (MachineOperand &Op : CMovI->operands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">      if (!Op.isReg() || Op.getReg() != PS->InitialReg)</td>
    <td class="lineNumber">550</td>
    <td class="codeline">      if (!Op.isReg() || Op.getReg() != PS->InitialReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">551</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline"></td>
    <td class="lineNumber">552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">      PS->SSA.RewriteUse(Op);</td>
    <td class="lineNumber">553</td>
    <td class="codeline">      PS->SSA.RewriteUse(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">554</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline"></td>
    <td class="lineNumber">555</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Final speculative load hardened function:\n"; MF.dump();</td>
    <td class="lineNumber">556</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Final speculative load hardened function:\n"; MF.dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">             dbgs() << "\n"; MF.verify(this));</td>
    <td class="lineNumber">557</td>
    <td class="codeline">             dbgs() << "\n"; MF.verify(this));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">558</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">}</td>
    <td class="lineNumber">559</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline"></td>
    <td class="lineNumber">560</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">/// Implements the naive hardening approach of putting an LFENCE after every</td>
    <td class="lineNumber">561</td>
    <td class="codeline">/// Implements the naive hardening approach of putting an LFENCE after every</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">/// potentially mis-predicted control flow construct.</td>
    <td class="lineNumber">562</td>
    <td class="codeline">/// potentially mis-predicted control flow construct.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">///</td>
    <td class="lineNumber">563</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">/// We include this as an alternative mostly for the purpose of comparison. The</td>
    <td class="lineNumber">564</td>
    <td class="codeline">/// We include this as an alternative mostly for the purpose of comparison. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">/// performance impact of this is expected to be extremely severe and not</td>
    <td class="lineNumber">565</td>
    <td class="codeline">/// performance impact of this is expected to be extremely severe and not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">/// practical for any real-world users.</td>
    <td class="lineNumber">566</td>
    <td class="codeline">/// practical for any real-world users.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::hardenEdgesWithLFENCE(</td>
    <td class="lineNumber">567</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::hardenEdgesWithLFENCE(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">    MachineFunction &MF) {</td>
    <td class="lineNumber">568</td>
    <td class="codeline">    MachineFunction &MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">  // First, we scan the function looking for blocks that are reached along edges</td>
    <td class="lineNumber">569</td>
    <td class="codeline">  // First, we scan the function looking for blocks that are reached along edges</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">  // that we might want to harden.</td>
    <td class="lineNumber">570</td>
    <td class="codeline">  // that we might want to harden.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">  SmallSetVector<MachineBasicBlock *, 8> Blocks;</td>
    <td class="lineNumber">571</td>
    <td class="codeline">  SmallSetVector<MachineBasicBlock *, 8> Blocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">572</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">    // If there are no or only one successor, nothing to do here.</td>
    <td class="lineNumber">573</td>
    <td class="codeline">    // If there are no or only one successor, nothing to do here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">    if (MBB.succ_size() <= 1)</td>
    <td class="lineNumber">574</td>
    <td class="codeline">    if (MBB.succ_size() <= 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">575</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline"></td>
    <td class="lineNumber">576</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">    // Skip blocks unless their terminators start with a branch. Other</td>
    <td class="lineNumber">577</td>
    <td class="codeline">    // Skip blocks unless their terminators start with a branch. Other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">    // terminators don't seem interesting for guarding against misspeculation.</td>
    <td class="lineNumber">578</td>
    <td class="codeline">    // terminators don't seem interesting for guarding against misspeculation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">    auto TermIt = MBB.getFirstTerminator();</td>
    <td class="lineNumber">579</td>
    <td class="codeline">    auto TermIt = MBB.getFirstTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">    if (TermIt == MBB.end() || !TermIt->isBranch())</td>
    <td class="lineNumber">580</td>
    <td class="codeline">    if (TermIt == MBB.end() || !TermIt->isBranch())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">581</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">    // Add all the non-EH-pad succossors to the blocks we want to harden. We</td>
    <td class="lineNumber">583</td>
    <td class="codeline">    // Add all the non-EH-pad succossors to the blocks we want to harden. We</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">    // skip EH pads because there isn't really a condition of interest on</td>
    <td class="lineNumber">584</td>
    <td class="codeline">    // skip EH pads because there isn't really a condition of interest on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">    // entering.</td>
    <td class="lineNumber">585</td>
    <td class="codeline">    // entering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">    for (MachineBasicBlock *SuccMBB : MBB.successors())</td>
    <td class="lineNumber">586</td>
    <td class="codeline">    for (MachineBasicBlock *SuccMBB : MBB.successors())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">      if (!SuccMBB->isEHPad())</td>
    <td class="lineNumber">587</td>
    <td class="codeline">      if (!SuccMBB->isEHPad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">        Blocks.insert(SuccMBB);</td>
    <td class="lineNumber">588</td>
    <td class="codeline">        Blocks.insert(SuccMBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">589</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">  for (MachineBasicBlock *MBB : Blocks) {</td>
    <td class="lineNumber">591</td>
    <td class="codeline">  for (MachineBasicBlock *MBB : Blocks) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">    auto InsertPt = MBB->SkipPHIsAndLabels(MBB->begin());</td>
    <td class="lineNumber">592</td>
    <td class="codeline">    auto InsertPt = MBB->SkipPHIsAndLabels(MBB->begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    BuildMI(*MBB, InsertPt, DebugLoc(), TII->get(X86::LFENCE));</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    BuildMI(*MBB, InsertPt, DebugLoc(), TII->get(X86::LFENCE));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">    ++NumInstsInserted;</td>
    <td class="lineNumber">594</td>
    <td class="codeline">    ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">    ++NumLFENCEsInserted;</td>
    <td class="lineNumber">595</td>
    <td class="codeline">    ++NumLFENCEsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">}</td>
    <td class="lineNumber">597</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline"></td>
    <td class="lineNumber">598</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">SmallVector<X86SpeculativeLoadHardeningPass::BlockCondInfo, 16></td>
    <td class="lineNumber">599</td>
    <td class="codeline">SmallVector<X86SpeculativeLoadHardeningPass::BlockCondInfo, 16></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">X86SpeculativeLoadHardeningPass::collectBlockCondInfo(MachineFunction &MF) {</td>
    <td class="lineNumber">600</td>
    <td class="codeline">X86SpeculativeLoadHardeningPass::collectBlockCondInfo(MachineFunction &MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">  SmallVector<BlockCondInfo, 16> Infos;</td>
    <td class="lineNumber">601</td>
    <td class="codeline">  SmallVector<BlockCondInfo, 16> Infos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline"></td>
    <td class="lineNumber">602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">  // Walk the function and build up a summary for each block's conditions that</td>
    <td class="lineNumber">603</td>
    <td class="codeline">  // Walk the function and build up a summary for each block's conditions that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  // we need to trace through.</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  // we need to trace through.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">605</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">    // If there are no or only one successor, nothing to do here.</td>
    <td class="lineNumber">606</td>
    <td class="codeline">    // If there are no or only one successor, nothing to do here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">    if (MBB.succ_size() <= 1)</td>
    <td class="lineNumber">607</td>
    <td class="codeline">    if (MBB.succ_size() <= 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">608</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline"></td>
    <td class="lineNumber">609</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">    // We want to reliably handle any conditional branch terminators in the</td>
    <td class="lineNumber">610</td>
    <td class="codeline">    // We want to reliably handle any conditional branch terminators in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">    // MBB, so we manually analyze the branch. We can handle all of the</td>
    <td class="lineNumber">611</td>
    <td class="codeline">    // MBB, so we manually analyze the branch. We can handle all of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">    // permutations here, including ones that analyze branch cannot.</td>
    <td class="lineNumber">612</td>
    <td class="codeline">    // permutations here, including ones that analyze branch cannot.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">613</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">    // The approach is to walk backwards across the terminators, resetting at</td>
    <td class="lineNumber">614</td>
    <td class="codeline">    // The approach is to walk backwards across the terminators, resetting at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">    // any unconditional non-indirect branch, and track all conditional edges</td>
    <td class="lineNumber">615</td>
    <td class="codeline">    // any unconditional non-indirect branch, and track all conditional edges</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">    // to basic blocks as well as the fallthrough or unconditional successor</td>
    <td class="lineNumber">616</td>
    <td class="codeline">    // to basic blocks as well as the fallthrough or unconditional successor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">    // edge. For each conditional edge, we track the target and the opposite</td>
    <td class="lineNumber">617</td>
    <td class="codeline">    // edge. For each conditional edge, we track the target and the opposite</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">    // condition code in order to inject a "no-op" cmov into that successor</td>
    <td class="lineNumber">618</td>
    <td class="codeline">    // condition code in order to inject a "no-op" cmov into that successor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">    // that will harden the predicate. For the fallthrough/unconditional</td>
    <td class="lineNumber">619</td>
    <td class="codeline">    // that will harden the predicate. For the fallthrough/unconditional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">    // edge, we inject a separate cmov for each conditional branch with</td>
    <td class="lineNumber">620</td>
    <td class="codeline">    // edge, we inject a separate cmov for each conditional branch with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">    // matching condition codes. This effectively implements an "and" of the</td>
    <td class="lineNumber">621</td>
    <td class="codeline">    // matching condition codes. This effectively implements an "and" of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">    // condition flags, even if there isn't a single condition flag that would</td>
    <td class="lineNumber">622</td>
    <td class="codeline">    // condition flags, even if there isn't a single condition flag that would</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">    // directly implement that. We don't bother trying to optimize either of</td>
    <td class="lineNumber">623</td>
    <td class="codeline">    // directly implement that. We don't bother trying to optimize either of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">    // these cases because if such an optimization is possible, LLVM should</td>
    <td class="lineNumber">624</td>
    <td class="codeline">    // these cases because if such an optimization is possible, LLVM should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">    // have optimized the conditional *branches* in that way already to reduce</td>
    <td class="lineNumber">625</td>
    <td class="codeline">    // have optimized the conditional *branches* in that way already to reduce</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">    // instruction count. This late, we simply assume the minimal number of</td>
    <td class="lineNumber">626</td>
    <td class="codeline">    // instruction count. This late, we simply assume the minimal number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">    // branch instructions is being emitted and use that to guide our cmov</td>
    <td class="lineNumber">627</td>
    <td class="codeline">    // branch instructions is being emitted and use that to guide our cmov</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">    // insertion.</td>
    <td class="lineNumber">628</td>
    <td class="codeline">    // insertion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline"></td>
    <td class="lineNumber">629</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">    BlockCondInfo Info = {&MBB, {}, nullptr};</td>
    <td class="lineNumber">630</td>
    <td class="codeline">    BlockCondInfo Info = {&MBB, {}, nullptr};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline"></td>
    <td class="lineNumber">631</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">    // Now walk backwards through the terminators and build up successors they</td>
    <td class="lineNumber">632</td>
    <td class="codeline">    // Now walk backwards through the terminators and build up successors they</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">    // reach and the conditions.</td>
    <td class="lineNumber">633</td>
    <td class="codeline">    // reach and the conditions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">    for (MachineInstr &MI : llvm::reverse(MBB)) {</td>
    <td class="lineNumber">634</td>
    <td class="codeline">    for (MachineInstr &MI : llvm::reverse(MBB)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">      // Once we've handled all the terminators, we're done.</td>
    <td class="lineNumber">635</td>
    <td class="codeline">      // Once we've handled all the terminators, we're done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">      if (!MI.isTerminator())</td>
    <td class="lineNumber">636</td>
    <td class="codeline">      if (!MI.isTerminator())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">637</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline"></td>
    <td class="lineNumber">638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">      // If we see a non-branch terminator, we can't handle anything so bail.</td>
    <td class="lineNumber">639</td>
    <td class="codeline">      // If we see a non-branch terminator, we can't handle anything so bail.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">      if (!MI.isBranch()) {</td>
    <td class="lineNumber">640</td>
    <td class="codeline">      if (!MI.isBranch()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">        Info.CondBrs.clear();</td>
    <td class="lineNumber">641</td>
    <td class="codeline">        Info.CondBrs.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">642</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">643</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">      // If we see an unconditional branch, reset our state, clear any</td>
    <td class="lineNumber">645</td>
    <td class="codeline">      // If we see an unconditional branch, reset our state, clear any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">      // fallthrough, and set this is the "else" successor.</td>
    <td class="lineNumber">646</td>
    <td class="codeline">      // fallthrough, and set this is the "else" successor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">      if (MI.getOpcode() == X86::JMP_1) {</td>
    <td class="lineNumber">647</td>
    <td class="codeline">      if (MI.getOpcode() == X86::JMP_1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">        Info.CondBrs.clear();</td>
    <td class="lineNumber">648</td>
    <td class="codeline">        Info.CondBrs.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">        Info.UncondBr = &MI;</td>
    <td class="lineNumber">649</td>
    <td class="codeline">        Info.UncondBr = &MI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">650</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">651</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline"></td>
    <td class="lineNumber">652</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">      // If we get an invalid condition, we have an indirect branch or some</td>
    <td class="lineNumber">653</td>
    <td class="codeline">      // If we get an invalid condition, we have an indirect branch or some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">      // other unanalyzable "fallthrough" case. We model this as a nullptr for</td>
    <td class="lineNumber">654</td>
    <td class="codeline">      // other unanalyzable "fallthrough" case. We model this as a nullptr for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">      // the destination so we can still guard any conditional successors.</td>
    <td class="lineNumber">655</td>
    <td class="codeline">      // the destination so we can still guard any conditional successors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">      // Consider code sequences like:</td>
    <td class="lineNumber">656</td>
    <td class="codeline">      // Consider code sequences like:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">      // ```</td>
    <td class="lineNumber">657</td>
    <td class="codeline">      // ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">      //   jCC L1</td>
    <td class="lineNumber">658</td>
    <td class="codeline">      //   jCC L1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">      //   jmpq *%rax</td>
    <td class="lineNumber">659</td>
    <td class="codeline">      //   jmpq *%rax</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">      // ```</td>
    <td class="lineNumber">660</td>
    <td class="codeline">      // ```</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">      // We still want to harden the edge to `L1`.</td>
    <td class="lineNumber">661</td>
    <td class="codeline">      // We still want to harden the edge to `L1`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">      if (X86::getCondFromBranch(MI) == X86::COND_INVALID) {</td>
    <td class="lineNumber">662</td>
    <td class="codeline">      if (X86::getCondFromBranch(MI) == X86::COND_INVALID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">        Info.CondBrs.clear();</td>
    <td class="lineNumber">663</td>
    <td class="codeline">        Info.CondBrs.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">        Info.UncondBr = &MI;</td>
    <td class="lineNumber">664</td>
    <td class="codeline">        Info.UncondBr = &MI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">665</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">666</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline"></td>
    <td class="lineNumber">667</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">      // We have a vanilla conditional branch, add it to our list.</td>
    <td class="lineNumber">668</td>
    <td class="codeline">      // We have a vanilla conditional branch, add it to our list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">      Info.CondBrs.push_back(&MI);</td>
    <td class="lineNumber">669</td>
    <td class="codeline">      Info.CondBrs.push_back(&MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">670</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">    if (Info.CondBrs.empty()) {</td>
    <td class="lineNumber">671</td>
    <td class="codeline">    if (Info.CondBrs.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">      ++NumBranchesUntraced;</td>
    <td class="lineNumber">672</td>
    <td class="codeline">      ++NumBranchesUntraced;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "WARNING: unable to secure successors of block:\n";</td>
    <td class="lineNumber">673</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "WARNING: unable to secure successors of block:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">                 MBB.dump());</td>
    <td class="lineNumber">674</td>
    <td class="codeline">                 MBB.dump());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">675</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">676</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline"></td>
    <td class="lineNumber">677</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">    Infos.push_back(Info);</td>
    <td class="lineNumber">678</td>
    <td class="codeline">    Infos.push_back(Info);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline"></td>
    <td class="lineNumber">680</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">  return Infos;</td>
    <td class="lineNumber">681</td>
    <td class="codeline">  return Infos;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">}</td>
    <td class="lineNumber">682</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">/// Trace the predicate state through the CFG, instrumenting each conditional</td>
    <td class="lineNumber">684</td>
    <td class="codeline">/// Trace the predicate state through the CFG, instrumenting each conditional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">/// branch such that misspeculation through an edge will poison the predicate</td>
    <td class="lineNumber">685</td>
    <td class="codeline">/// branch such that misspeculation through an edge will poison the predicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">/// state.</td>
    <td class="lineNumber">686</td>
    <td class="codeline">/// state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">///</td>
    <td class="lineNumber">687</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">/// Returns the list of inserted CMov instructions so that they can have their</td>
    <td class="lineNumber">688</td>
    <td class="codeline">/// Returns the list of inserted CMov instructions so that they can have their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">/// uses of the predicate state rewritten into proper SSA form once it is</td>
    <td class="lineNumber">689</td>
    <td class="codeline">/// uses of the predicate state rewritten into proper SSA form once it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">/// complete.</td>
    <td class="lineNumber">690</td>
    <td class="codeline">/// complete.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">SmallVector<MachineInstr *, 16></td>
    <td class="lineNumber">691</td>
    <td class="codeline">SmallVector<MachineInstr *, 16></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">X86SpeculativeLoadHardeningPass::tracePredStateThroughCFG(</td>
    <td class="lineNumber">692</td>
    <td class="codeline">X86SpeculativeLoadHardeningPass::tracePredStateThroughCFG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">    MachineFunction &MF, ArrayRef<BlockCondInfo> Infos) {</td>
    <td class="lineNumber">693</td>
    <td class="codeline">    MachineFunction &MF, ArrayRef<BlockCondInfo> Infos) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  // Collect the inserted cmov instructions so we can rewrite their uses of the</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  // Collect the inserted cmov instructions so we can rewrite their uses of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">  // predicate state into SSA form.</td>
    <td class="lineNumber">695</td>
    <td class="codeline">  // predicate state into SSA form.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  SmallVector<MachineInstr *, 16> CMovs;</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  SmallVector<MachineInstr *, 16> CMovs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  // Now walk all of the basic blocks looking for ones that end in conditional</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  // Now walk all of the basic blocks looking for ones that end in conditional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  // jumps where we need to update this register along each edge.</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  // jumps where we need to update this register along each edge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  for (const BlockCondInfo &Info : Infos) {</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  for (const BlockCondInfo &Info : Infos) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">    MachineBasicBlock &MBB = *Info.MBB;</td>
    <td class="lineNumber">701</td>
    <td class="codeline">    MachineBasicBlock &MBB = *Info.MBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">    const SmallVectorImpl<MachineInstr *> &CondBrs = Info.CondBrs;</td>
    <td class="lineNumber">702</td>
    <td class="codeline">    const SmallVectorImpl<MachineInstr *> &CondBrs = Info.CondBrs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">    MachineInstr *UncondBr = Info.UncondBr;</td>
    <td class="lineNumber">703</td>
    <td class="codeline">    MachineInstr *UncondBr = Info.UncondBr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline"></td>
    <td class="lineNumber">704</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Tracing predicate through block: " << MBB.getName()</td>
    <td class="lineNumber">705</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Tracing predicate through block: " << MBB.getName()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">                      << "\n");</td>
    <td class="lineNumber">706</td>
    <td class="codeline">                      << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">    ++NumCondBranchesTraced;</td>
    <td class="lineNumber">707</td>
    <td class="codeline">    ++NumCondBranchesTraced;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline"></td>
    <td class="lineNumber">708</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">    // Compute the non-conditional successor as either the target of any</td>
    <td class="lineNumber">709</td>
    <td class="codeline">    // Compute the non-conditional successor as either the target of any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">    // unconditional branch or the layout successor.</td>
    <td class="lineNumber">710</td>
    <td class="codeline">    // unconditional branch or the layout successor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">    MachineBasicBlock *UncondSucc =</td>
    <td class="lineNumber">711</td>
    <td class="codeline">    MachineBasicBlock *UncondSucc =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">        UncondBr ? (UncondBr->getOpcode() == X86::JMP_1</td>
    <td class="lineNumber">712</td>
    <td class="codeline">        UncondBr ? (UncondBr->getOpcode() == X86::JMP_1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">                        ? UncondBr->getOperand(0).getMBB()</td>
    <td class="lineNumber">713</td>
    <td class="codeline">                        ? UncondBr->getOperand(0).getMBB()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">                        : nullptr)</td>
    <td class="lineNumber">714</td>
    <td class="codeline">                        : nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">                 : &*std::next(MachineFunction::iterator(&MBB));</td>
    <td class="lineNumber">715</td>
    <td class="codeline">                 : &*std::next(MachineFunction::iterator(&MBB));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline"></td>
    <td class="lineNumber">716</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">    // Count how many edges there are to any given successor.</td>
    <td class="lineNumber">717</td>
    <td class="codeline">    // Count how many edges there are to any given successor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">    SmallDenseMap<MachineBasicBlock *, int> SuccCounts;</td>
    <td class="lineNumber">718</td>
    <td class="codeline">    SmallDenseMap<MachineBasicBlock *, int> SuccCounts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">    if (UncondSucc)</td>
    <td class="lineNumber">719</td>
    <td class="codeline">    if (UncondSucc)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">      ++SuccCounts[UncondSucc];</td>
    <td class="lineNumber">720</td>
    <td class="codeline">      ++SuccCounts[UncondSucc];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">    for (auto *CondBr : CondBrs)</td>
    <td class="lineNumber">721</td>
    <td class="codeline">    for (auto *CondBr : CondBrs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">      ++SuccCounts[CondBr->getOperand(0).getMBB()];</td>
    <td class="lineNumber">722</td>
    <td class="codeline">      ++SuccCounts[CondBr->getOperand(0).getMBB()];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline"></td>
    <td class="lineNumber">723</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">    // A lambda to insert cmov instructions into a block checking all of the</td>
    <td class="lineNumber">724</td>
    <td class="codeline">    // A lambda to insert cmov instructions into a block checking all of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">    // condition codes in a sequence.</td>
    <td class="lineNumber">725</td>
    <td class="codeline">    // condition codes in a sequence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">    auto BuildCheckingBlockForSuccAndConds =</td>
    <td class="lineNumber">726</td>
    <td class="codeline">    auto BuildCheckingBlockForSuccAndConds =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">        [&](MachineBasicBlock &MBB, MachineBasicBlock &Succ, int SuccCount,</td>
    <td class="lineNumber">727</td>
    <td class="codeline">        [&](MachineBasicBlock &MBB, MachineBasicBlock &Succ, int SuccCount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">            MachineInstr *Br, MachineInstr *&UncondBr,</td>
    <td class="lineNumber">728</td>
    <td class="codeline">            MachineInstr *Br, MachineInstr *&UncondBr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">            ArrayRef<X86::CondCode> Conds) {</td>
    <td class="lineNumber">729</td>
    <td class="codeline">            ArrayRef<X86::CondCode> Conds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">          // First, we split the edge to insert the checking block into a safe</td>
    <td class="lineNumber">730</td>
    <td class="codeline">          // First, we split the edge to insert the checking block into a safe</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">          // location.</td>
    <td class="lineNumber">731</td>
    <td class="codeline">          // location.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">          auto &CheckingMBB =</td>
    <td class="lineNumber">732</td>
    <td class="codeline">          auto &CheckingMBB =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">              (SuccCount == 1 && Succ.pred_size() == 1)</td>
    <td class="lineNumber">733</td>
    <td class="codeline">              (SuccCount == 1 && Succ.pred_size() == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">                  ? Succ</td>
    <td class="lineNumber">734</td>
    <td class="codeline">                  ? Succ</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">                  : splitEdge(MBB, Succ, SuccCount, Br, UncondBr, *TII);</td>
    <td class="lineNumber">735</td>
    <td class="codeline">                  : splitEdge(MBB, Succ, SuccCount, Br, UncondBr, *TII);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline"></td>
    <td class="lineNumber">736</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">          bool LiveEFLAGS = Succ.isLiveIn(X86::EFLAGS);</td>
    <td class="lineNumber">737</td>
    <td class="codeline">          bool LiveEFLAGS = Succ.isLiveIn(X86::EFLAGS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">          if (!LiveEFLAGS)</td>
    <td class="lineNumber">738</td>
    <td class="codeline">          if (!LiveEFLAGS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">            CheckingMBB.addLiveIn(X86::EFLAGS);</td>
    <td class="lineNumber">739</td>
    <td class="codeline">            CheckingMBB.addLiveIn(X86::EFLAGS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline"></td>
    <td class="lineNumber">740</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">          // Now insert the cmovs to implement the checks.</td>
    <td class="lineNumber">741</td>
    <td class="codeline">          // Now insert the cmovs to implement the checks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">          auto InsertPt = CheckingMBB.begin();</td>
    <td class="lineNumber">742</td>
    <td class="codeline">          auto InsertPt = CheckingMBB.begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">          assert((InsertPt == CheckingMBB.end() || !InsertPt->isPHI()) &&</td>
    <td class="lineNumber">743</td>
    <td class="codeline">          assert((InsertPt == CheckingMBB.end() || !InsertPt->isPHI()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">                 "Should never have a PHI in the initial checking block as it "</td>
    <td class="lineNumber">744</td>
    <td class="codeline">                 "Should never have a PHI in the initial checking block as it "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">                 "always has a single predecessor!");</td>
    <td class="lineNumber">745</td>
    <td class="codeline">                 "always has a single predecessor!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">          // We will wire each cmov to each other, but need to start with the</td>
    <td class="lineNumber">747</td>
    <td class="codeline">          // We will wire each cmov to each other, but need to start with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">          // incoming pred state.</td>
    <td class="lineNumber">748</td>
    <td class="codeline">          // incoming pred state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">          unsigned CurStateReg = PS->InitialReg;</td>
    <td class="lineNumber">749</td>
    <td class="codeline">          unsigned CurStateReg = PS->InitialReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline"></td>
    <td class="lineNumber">750</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">          for (X86::CondCode Cond : Conds) {</td>
    <td class="lineNumber">751</td>
    <td class="codeline">          for (X86::CondCode Cond : Conds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">            int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
    <td class="lineNumber">752</td>
    <td class="codeline">            int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">            auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
    <td class="lineNumber">753</td>
    <td class="codeline">            auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline"></td>
    <td class="lineNumber">754</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">            Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">755</td>
    <td class="codeline">            Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">            // Note that we intentionally use an empty debug location so that</td>
    <td class="lineNumber">756</td>
    <td class="codeline">            // Note that we intentionally use an empty debug location so that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">            // this picks up the preceding location.</td>
    <td class="lineNumber">757</td>
    <td class="codeline">            // this picks up the preceding location.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">            auto CMovI = BuildMI(CheckingMBB, InsertPt, DebugLoc(),</td>
    <td class="lineNumber">758</td>
    <td class="codeline">            auto CMovI = BuildMI(CheckingMBB, InsertPt, DebugLoc(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">                                 TII->get(CMovOp), UpdatedStateReg)</td>
    <td class="lineNumber">759</td>
    <td class="codeline">                                 TII->get(CMovOp), UpdatedStateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">                             .addReg(CurStateReg)</td>
    <td class="lineNumber">760</td>
    <td class="codeline">                             .addReg(CurStateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">                             .addReg(PS->PoisonReg)</td>
    <td class="lineNumber">761</td>
    <td class="codeline">                             .addReg(PS->PoisonReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">                             .addImm(Cond);</td>
    <td class="lineNumber">762</td>
    <td class="codeline">                             .addImm(Cond);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">            // If this is the last cmov and the EFLAGS weren't originally</td>
    <td class="lineNumber">763</td>
    <td class="codeline">            // If this is the last cmov and the EFLAGS weren't originally</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">            // live-in, mark them as killed.</td>
    <td class="lineNumber">764</td>
    <td class="codeline">            // live-in, mark them as killed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">            if (!LiveEFLAGS && Cond == Conds.back())</td>
    <td class="lineNumber">765</td>
    <td class="codeline">            if (!LiveEFLAGS && Cond == Conds.back())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">              CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
    <td class="lineNumber">766</td>
    <td class="codeline">              CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline"></td>
    <td class="lineNumber">767</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">            ++NumInstsInserted;</td>
    <td class="lineNumber">768</td>
    <td class="codeline">            ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">            LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump();</td>
    <td class="lineNumber">769</td>
    <td class="codeline">            LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">                       dbgs() << "\n");</td>
    <td class="lineNumber">770</td>
    <td class="codeline">                       dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">            // The first one of the cmovs will be using the top level</td>
    <td class="lineNumber">772</td>
    <td class="codeline">            // The first one of the cmovs will be using the top level</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">            // `PredStateReg` and need to get rewritten into SSA form.</td>
    <td class="lineNumber">773</td>
    <td class="codeline">            // `PredStateReg` and need to get rewritten into SSA form.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">            if (CurStateReg == PS->InitialReg)</td>
    <td class="lineNumber">774</td>
    <td class="codeline">            if (CurStateReg == PS->InitialReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">              CMovs.push_back(&*CMovI);</td>
    <td class="lineNumber">775</td>
    <td class="codeline">              CMovs.push_back(&*CMovI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline"></td>
    <td class="lineNumber">776</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">            // The next cmov should start from this one's def.</td>
    <td class="lineNumber">777</td>
    <td class="codeline">            // The next cmov should start from this one's def.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">            CurStateReg = UpdatedStateReg;</td>
    <td class="lineNumber">778</td>
    <td class="codeline">            CurStateReg = UpdatedStateReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">779</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline"></td>
    <td class="lineNumber">780</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">          // And put the last one into the available values for SSA form of our</td>
    <td class="lineNumber">781</td>
    <td class="codeline">          // And put the last one into the available values for SSA form of our</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">          // predicate state.</td>
    <td class="lineNumber">782</td>
    <td class="codeline">          // predicate state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">          PS->SSA.AddAvailableValue(&CheckingMBB, CurStateReg);</td>
    <td class="lineNumber">783</td>
    <td class="codeline">          PS->SSA.AddAvailableValue(&CheckingMBB, CurStateReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">        };</td>
    <td class="lineNumber">784</td>
    <td class="codeline">        };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline"></td>
    <td class="lineNumber">785</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">    std::vector<X86::CondCode> UncondCodeSeq;</td>
    <td class="lineNumber">786</td>
    <td class="codeline">    std::vector<X86::CondCode> UncondCodeSeq;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">    for (auto *CondBr : CondBrs) {</td>
    <td class="lineNumber">787</td>
    <td class="codeline">    for (auto *CondBr : CondBrs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">      MachineBasicBlock &Succ = *CondBr->getOperand(0).getMBB();</td>
    <td class="lineNumber">788</td>
    <td class="codeline">      MachineBasicBlock &Succ = *CondBr->getOperand(0).getMBB();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">      int &SuccCount = SuccCounts[&Succ];</td>
    <td class="lineNumber">789</td>
    <td class="codeline">      int &SuccCount = SuccCounts[&Succ];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline"></td>
    <td class="lineNumber">790</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">      X86::CondCode Cond = X86::getCondFromBranch(*CondBr);</td>
    <td class="lineNumber">791</td>
    <td class="codeline">      X86::CondCode Cond = X86::getCondFromBranch(*CondBr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">      X86::CondCode InvCond = X86::GetOppositeBranchCondition(Cond);</td>
    <td class="lineNumber">792</td>
    <td class="codeline">      X86::CondCode InvCond = X86::GetOppositeBranchCondition(Cond);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">      UncondCodeSeq.push_back(Cond);</td>
    <td class="lineNumber">793</td>
    <td class="codeline">      UncondCodeSeq.push_back(Cond);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline"></td>
    <td class="lineNumber">794</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">      BuildCheckingBlockForSuccAndConds(MBB, Succ, SuccCount, CondBr, UncondBr,</td>
    <td class="lineNumber">795</td>
    <td class="codeline">      BuildCheckingBlockForSuccAndConds(MBB, Succ, SuccCount, CondBr, UncondBr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">                                        {InvCond});</td>
    <td class="lineNumber">796</td>
    <td class="codeline">                                        {InvCond});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline"></td>
    <td class="lineNumber">797</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">      // Decrement the successor count now that we've split one of the edges.</td>
    <td class="lineNumber">798</td>
    <td class="codeline">      // Decrement the successor count now that we've split one of the edges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">      // We need to keep the count of edges to the successor accurate in order</td>
    <td class="lineNumber">799</td>
    <td class="codeline">      // We need to keep the count of edges to the successor accurate in order</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">      // to know above when to *replace* the successor in the CFG vs. just</td>
    <td class="lineNumber">800</td>
    <td class="codeline">      // to know above when to *replace* the successor in the CFG vs. just</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">      // adding the new successor.</td>
    <td class="lineNumber">801</td>
    <td class="codeline">      // adding the new successor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">      --SuccCount;</td>
    <td class="lineNumber">802</td>
    <td class="codeline">      --SuccCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">803</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline"></td>
    <td class="lineNumber">804</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">    // Since we may have split edges and changed the number of successors,</td>
    <td class="lineNumber">805</td>
    <td class="codeline">    // Since we may have split edges and changed the number of successors,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">    // normalize the probabilities. This avoids doing it each time we split an</td>
    <td class="lineNumber">806</td>
    <td class="codeline">    // normalize the probabilities. This avoids doing it each time we split an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">    // edge.</td>
    <td class="lineNumber">807</td>
    <td class="codeline">    // edge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">    MBB.normalizeSuccProbs();</td>
    <td class="lineNumber">808</td>
    <td class="codeline">    MBB.normalizeSuccProbs();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline"></td>
    <td class="lineNumber">809</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">    // Finally, we need to insert cmovs into the "fallthrough" edge. Here, we</td>
    <td class="lineNumber">810</td>
    <td class="codeline">    // Finally, we need to insert cmovs into the "fallthrough" edge. Here, we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">    // need to intersect the other condition codes. We can do this by just</td>
    <td class="lineNumber">811</td>
    <td class="codeline">    // need to intersect the other condition codes. We can do this by just</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">    // doing a cmov for each one.</td>
    <td class="lineNumber">812</td>
    <td class="codeline">    // doing a cmov for each one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">    if (!UncondSucc)</td>
    <td class="lineNumber">813</td>
    <td class="codeline">    if (!UncondSucc)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">      // If we have no fallthrough to protect (perhaps it is an indirect jump?)</td>
    <td class="lineNumber">814</td>
    <td class="codeline">      // If we have no fallthrough to protect (perhaps it is an indirect jump?)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">      // just skip this and continue.</td>
    <td class="lineNumber">815</td>
    <td class="codeline">      // just skip this and continue.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">816</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline"></td>
    <td class="lineNumber">817</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">    assert(SuccCounts[UncondSucc] == 1 &&</td>
    <td class="lineNumber">818</td>
    <td class="codeline">    assert(SuccCounts[UncondSucc] == 1 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">           "We should never have more than one edge to the unconditional "</td>
    <td class="lineNumber">819</td>
    <td class="codeline">           "We should never have more than one edge to the unconditional "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">           "successor at this point because every other edge must have been "</td>
    <td class="lineNumber">820</td>
    <td class="codeline">           "successor at this point because every other edge must have been "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">           "split above!");</td>
    <td class="lineNumber">821</td>
    <td class="codeline">           "split above!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline"></td>
    <td class="lineNumber">822</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">    // Sort and unique the codes to minimize them.</td>
    <td class="lineNumber">823</td>
    <td class="codeline">    // Sort and unique the codes to minimize them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">    llvm::sort(UncondCodeSeq);</td>
    <td class="lineNumber">824</td>
    <td class="codeline">    llvm::sort(UncondCodeSeq);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">    UncondCodeSeq.erase(std::unique(UncondCodeSeq.begin(), UncondCodeSeq.end()),</td>
    <td class="lineNumber">825</td>
    <td class="codeline">    UncondCodeSeq.erase(std::unique(UncondCodeSeq.begin(), UncondCodeSeq.end()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">                        UncondCodeSeq.end());</td>
    <td class="lineNumber">826</td>
    <td class="codeline">                        UncondCodeSeq.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline"></td>
    <td class="lineNumber">827</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">    // Build a checking version of the successor.</td>
    <td class="lineNumber">828</td>
    <td class="codeline">    // Build a checking version of the successor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">    BuildCheckingBlockForSuccAndConds(MBB, *UncondSucc, /*SuccCount*/ 1,</td>
    <td class="lineNumber">829</td>
    <td class="codeline">    BuildCheckingBlockForSuccAndConds(MBB, *UncondSucc, /*SuccCount*/ 1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">                                      UncondBr, UncondBr, UncondCodeSeq);</td>
    <td class="lineNumber">830</td>
    <td class="codeline">                                      UncondBr, UncondBr, UncondCodeSeq);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline"></td>
    <td class="lineNumber">832</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">  return CMovs;</td>
    <td class="lineNumber">833</td>
    <td class="codeline">  return CMovs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">}</td>
    <td class="lineNumber">834</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">/// Compute the register class for the unfolded load.</td>
    <td class="lineNumber">836</td>
    <td class="codeline">/// Compute the register class for the unfolded load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">///</td>
    <td class="lineNumber">837</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">/// FIXME: This should probably live in X86InstrInfo, potentially by adding</td>
    <td class="lineNumber">838</td>
    <td class="codeline">/// FIXME: This should probably live in X86InstrInfo, potentially by adding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">/// a way to unfold into a newly created vreg rather than requiring a register</td>
    <td class="lineNumber">839</td>
    <td class="codeline">/// a way to unfold into a newly created vreg rather than requiring a register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">/// input.</td>
    <td class="lineNumber">840</td>
    <td class="codeline">/// input.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">static const TargetRegisterClass *</td>
    <td class="lineNumber">841</td>
    <td class="codeline">static const TargetRegisterClass *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">getRegClassForUnfoldedLoad(MachineFunction &MF, const X86InstrInfo &TII,</td>
    <td class="lineNumber">842</td>
    <td class="codeline">getRegClassForUnfoldedLoad(MachineFunction &MF, const X86InstrInfo &TII,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">                           unsigned Opcode) {</td>
    <td class="lineNumber">843</td>
    <td class="codeline">                           unsigned Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">  unsigned Index;</td>
    <td class="lineNumber">844</td>
    <td class="codeline">  unsigned Index;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">  unsigned UnfoldedOpc = TII.getOpcodeAfterMemoryUnfold(</td>
    <td class="lineNumber">845</td>
    <td class="codeline">  unsigned UnfoldedOpc = TII.getOpcodeAfterMemoryUnfold(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">      Opcode, /*UnfoldLoad*/ true, /*UnfoldStore*/ false, &Index);</td>
    <td class="lineNumber">846</td>
    <td class="codeline">      Opcode, /*UnfoldLoad*/ true, /*UnfoldStore*/ false, &Index);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  const MCInstrDesc &MCID = TII.get(UnfoldedOpc);</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  const MCInstrDesc &MCID = TII.get(UnfoldedOpc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  return TII.getRegClass(MCID, Index, &TII.getRegisterInfo(), MF);</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  return TII.getRegClass(MCID, Index, &TII.getRegisterInfo(), MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">}</td>
    <td class="lineNumber">849</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline"></td>
    <td class="lineNumber">850</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::unfoldCallAndJumpLoads(</td>
    <td class="lineNumber">851</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::unfoldCallAndJumpLoads(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">    MachineFunction &MF) {</td>
    <td class="lineNumber">852</td>
    <td class="codeline">    MachineFunction &MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF)</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">    // We use make_early_inc_range here so we can remove instructions if needed</td>
    <td class="lineNumber">854</td>
    <td class="codeline">    // We use make_early_inc_range here so we can remove instructions if needed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">    // without disturbing the iteration.</td>
    <td class="lineNumber">855</td>
    <td class="codeline">    // without disturbing the iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">    for (MachineInstr &MI : llvm::make_early_inc_range(MBB.instrs())) {</td>
    <td class="lineNumber">856</td>
    <td class="codeline">    for (MachineInstr &MI : llvm::make_early_inc_range(MBB.instrs())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">      // Must either be a call or a branch.</td>
    <td class="lineNumber">857</td>
    <td class="codeline">      // Must either be a call or a branch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">      if (!MI.isCall() && !MI.isBranch())</td>
    <td class="lineNumber">858</td>
    <td class="codeline">      if (!MI.isCall() && !MI.isBranch())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">859</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">      // We only care about loading variants of these instructions.</td>
    <td class="lineNumber">860</td>
    <td class="codeline">      // We only care about loading variants of these instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">      if (!MI.mayLoad())</td>
    <td class="lineNumber">861</td>
    <td class="codeline">      if (!MI.mayLoad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">862</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline"></td>
    <td class="lineNumber">863</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">      switch (MI.getOpcode()) {</td>
    <td class="lineNumber">864</td>
    <td class="codeline">      switch (MI.getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">      default: {</td>
    <td class="lineNumber">865</td>
    <td class="codeline">      default: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">        LLVM_DEBUG(</td>
    <td class="lineNumber">866</td>
    <td class="codeline">        LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">            dbgs() << "ERROR: Found an unexpected loading branch or call "</td>
    <td class="lineNumber">867</td>
    <td class="codeline">            dbgs() << "ERROR: Found an unexpected loading branch or call "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">                      "instruction:\n";</td>
    <td class="lineNumber">868</td>
    <td class="codeline">                      "instruction:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">            MI.dump(); dbgs() << "\n");</td>
    <td class="lineNumber">869</td>
    <td class="codeline">            MI.dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">        report_fatal_error("Unexpected loading branch or call!");</td>
    <td class="lineNumber">870</td>
    <td class="codeline">        report_fatal_error("Unexpected loading branch or call!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">871</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline"></td>
    <td class="lineNumber">872</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">      case X86::FARCALL16m:</td>
    <td class="lineNumber">873</td>
    <td class="codeline">      case X86::FARCALL16m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">      case X86::FARCALL32m:</td>
    <td class="lineNumber">874</td>
    <td class="codeline">      case X86::FARCALL32m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">      case X86::FARCALL64m:</td>
    <td class="lineNumber">875</td>
    <td class="codeline">      case X86::FARCALL64m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">      case X86::FARJMP16m:</td>
    <td class="lineNumber">876</td>
    <td class="codeline">      case X86::FARJMP16m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">      case X86::FARJMP32m:</td>
    <td class="lineNumber">877</td>
    <td class="codeline">      case X86::FARJMP32m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">      case X86::FARJMP64m:</td>
    <td class="lineNumber">878</td>
    <td class="codeline">      case X86::FARJMP64m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">        // We cannot mitigate far jumps or calls, but we also don't expect them</td>
    <td class="lineNumber">879</td>
    <td class="codeline">        // We cannot mitigate far jumps or calls, but we also don't expect them</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">        // to be vulnerable to Spectre v1.2 style attacks.</td>
    <td class="lineNumber">880</td>
    <td class="codeline">        // to be vulnerable to Spectre v1.2 style attacks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">881</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline"></td>
    <td class="lineNumber">882</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">      case X86::CALL16m:</td>
    <td class="lineNumber">883</td>
    <td class="codeline">      case X86::CALL16m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">      case X86::CALL16m_NT:</td>
    <td class="lineNumber">884</td>
    <td class="codeline">      case X86::CALL16m_NT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">      case X86::CALL32m:</td>
    <td class="lineNumber">885</td>
    <td class="codeline">      case X86::CALL32m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">      case X86::CALL32m_NT:</td>
    <td class="lineNumber">886</td>
    <td class="codeline">      case X86::CALL32m_NT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">      case X86::CALL64m:</td>
    <td class="lineNumber">887</td>
    <td class="codeline">      case X86::CALL64m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">      case X86::CALL64m_NT:</td>
    <td class="lineNumber">888</td>
    <td class="codeline">      case X86::CALL64m_NT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">      case X86::JMP16m:</td>
    <td class="lineNumber">889</td>
    <td class="codeline">      case X86::JMP16m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">      case X86::JMP16m_NT:</td>
    <td class="lineNumber">890</td>
    <td class="codeline">      case X86::JMP16m_NT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">      case X86::JMP32m:</td>
    <td class="lineNumber">891</td>
    <td class="codeline">      case X86::JMP32m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">      case X86::JMP32m_NT:</td>
    <td class="lineNumber">892</td>
    <td class="codeline">      case X86::JMP32m_NT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">      case X86::JMP64m:</td>
    <td class="lineNumber">893</td>
    <td class="codeline">      case X86::JMP64m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">      case X86::JMP64m_NT:</td>
    <td class="lineNumber">894</td>
    <td class="codeline">      case X86::JMP64m_NT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">      case X86::TAILJMPm64:</td>
    <td class="lineNumber">895</td>
    <td class="codeline">      case X86::TAILJMPm64:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">      case X86::TAILJMPm64_REX:</td>
    <td class="lineNumber">896</td>
    <td class="codeline">      case X86::TAILJMPm64_REX:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">      case X86::TAILJMPm:</td>
    <td class="lineNumber">897</td>
    <td class="codeline">      case X86::TAILJMPm:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">      case X86::TCRETURNmi64:</td>
    <td class="lineNumber">898</td>
    <td class="codeline">      case X86::TCRETURNmi64:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">      case X86::TCRETURNmi: {</td>
    <td class="lineNumber">899</td>
    <td class="codeline">      case X86::TCRETURNmi: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">        // Use the generic unfold logic now that we know we're dealing with</td>
    <td class="lineNumber">900</td>
    <td class="codeline">        // Use the generic unfold logic now that we know we're dealing with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">        // expected instructions.</td>
    <td class="lineNumber">901</td>
    <td class="codeline">        // expected instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">        // FIXME: We don't have test coverage for all of these!</td>
    <td class="lineNumber">902</td>
    <td class="codeline">        // FIXME: We don't have test coverage for all of these!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">        auto *UnfoldedRC = getRegClassForUnfoldedLoad(MF, *TII, MI.getOpcode());</td>
    <td class="lineNumber">903</td>
    <td class="codeline">        auto *UnfoldedRC = getRegClassForUnfoldedLoad(MF, *TII, MI.getOpcode());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">        if (!UnfoldedRC) {</td>
    <td class="lineNumber">904</td>
    <td class="codeline">        if (!UnfoldedRC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">905</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">                         << "ERROR: Unable to unfold load from instruction:\n";</td>
    <td class="lineNumber">906</td>
    <td class="codeline">                         << "ERROR: Unable to unfold load from instruction:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">                     MI.dump(); dbgs() << "\n");</td>
    <td class="lineNumber">907</td>
    <td class="codeline">                     MI.dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">          report_fatal_error("Unable to unfold load!");</td>
    <td class="lineNumber">908</td>
    <td class="codeline">          report_fatal_error("Unable to unfold load!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">909</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">        Register Reg = MRI->createVirtualRegister(UnfoldedRC);</td>
    <td class="lineNumber">910</td>
    <td class="codeline">        Register Reg = MRI->createVirtualRegister(UnfoldedRC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">        SmallVector<MachineInstr *, 2> NewMIs;</td>
    <td class="lineNumber">911</td>
    <td class="codeline">        SmallVector<MachineInstr *, 2> NewMIs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">        // If we were able to compute an unfolded reg class, any failure here</td>
    <td class="lineNumber">912</td>
    <td class="codeline">        // If we were able to compute an unfolded reg class, any failure here</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">        // is just a programming error so just assert.</td>
    <td class="lineNumber">913</td>
    <td class="codeline">        // is just a programming error so just assert.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">        bool Unfolded =</td>
    <td class="lineNumber">914</td>
    <td class="codeline">        bool Unfolded =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">            TII->unfoldMemoryOperand(MF, MI, Reg, /*UnfoldLoad*/ true,</td>
    <td class="lineNumber">915</td>
    <td class="codeline">            TII->unfoldMemoryOperand(MF, MI, Reg, /*UnfoldLoad*/ true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">                                     /*UnfoldStore*/ false, NewMIs);</td>
    <td class="lineNumber">916</td>
    <td class="codeline">                                     /*UnfoldStore*/ false, NewMIs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">        (void)Unfolded;</td>
    <td class="lineNumber">917</td>
    <td class="codeline">        (void)Unfolded;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">        assert(Unfolded &&</td>
    <td class="lineNumber">918</td>
    <td class="codeline">        assert(Unfolded &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">               "Computed unfolded register class but failed to unfold");</td>
    <td class="lineNumber">919</td>
    <td class="codeline">               "Computed unfolded register class but failed to unfold");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">        // Now stitch the new instructions into place and erase the old one.</td>
    <td class="lineNumber">920</td>
    <td class="codeline">        // Now stitch the new instructions into place and erase the old one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">        for (auto *NewMI : NewMIs)</td>
    <td class="lineNumber">921</td>
    <td class="codeline">        for (auto *NewMI : NewMIs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">          MBB.insert(MI.getIterator(), NewMI);</td>
    <td class="lineNumber">922</td>
    <td class="codeline">          MBB.insert(MI.getIterator(), NewMI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline"></td>
    <td class="lineNumber">923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">        // Update the call site info.</td>
    <td class="lineNumber">924</td>
    <td class="codeline">        // Update the call site info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">        if (MI.isCandidateForCallSiteEntry())</td>
    <td class="lineNumber">925</td>
    <td class="codeline">        if (MI.isCandidateForCallSiteEntry())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">          MF.eraseCallSiteInfo(&MI);</td>
    <td class="lineNumber">926</td>
    <td class="codeline">          MF.eraseCallSiteInfo(&MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline"></td>
    <td class="lineNumber">927</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">        MI.eraseFromParent();</td>
    <td class="lineNumber">928</td>
    <td class="codeline">        MI.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">        LLVM_DEBUG({</td>
    <td class="lineNumber">929</td>
    <td class="codeline">        LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">          dbgs() << "Unfolded load successfully into:\n";</td>
    <td class="lineNumber">930</td>
    <td class="codeline">          dbgs() << "Unfolded load successfully into:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">          for (auto *NewMI : NewMIs) {</td>
    <td class="lineNumber">931</td>
    <td class="codeline">          for (auto *NewMI : NewMIs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">            NewMI->dump();</td>
    <td class="lineNumber">932</td>
    <td class="codeline">            NewMI->dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">            dbgs() << "\n";</td>
    <td class="lineNumber">933</td>
    <td class="codeline">            dbgs() << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">934</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">        });</td>
    <td class="lineNumber">935</td>
    <td class="codeline">        });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">936</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">937</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">938</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">      llvm_unreachable("Escaped switch with default!");</td>
    <td class="lineNumber">939</td>
    <td class="codeline">      llvm_unreachable("Escaped switch with default!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">940</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">}</td>
    <td class="lineNumber">941</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline"></td>
    <td class="lineNumber">942</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">/// Trace the predicate state through indirect branches, instrumenting them to</td>
    <td class="lineNumber">943</td>
    <td class="codeline">/// Trace the predicate state through indirect branches, instrumenting them to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">/// poison the state if a target is reached that does not match the expected</td>
    <td class="lineNumber">944</td>
    <td class="codeline">/// poison the state if a target is reached that does not match the expected</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">/// target.</td>
    <td class="lineNumber">945</td>
    <td class="codeline">/// target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">///</td>
    <td class="lineNumber">946</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">/// This is designed to mitigate Spectre variant 1 attacks where an indirect</td>
    <td class="lineNumber">947</td>
    <td class="codeline">/// This is designed to mitigate Spectre variant 1 attacks where an indirect</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">/// branch is trained to predict a particular target and then mispredicts that</td>
    <td class="lineNumber">948</td>
    <td class="codeline">/// branch is trained to predict a particular target and then mispredicts that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">/// target in a way that can leak data. Despite using an indirect branch, this</td>
    <td class="lineNumber">949</td>
    <td class="codeline">/// target in a way that can leak data. Despite using an indirect branch, this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">/// is really a variant 1 style attack: it does not steer execution to an</td>
    <td class="lineNumber">950</td>
    <td class="codeline">/// is really a variant 1 style attack: it does not steer execution to an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">/// arbitrary or attacker controlled address, and it does not require any</td>
    <td class="lineNumber">951</td>
    <td class="codeline">/// arbitrary or attacker controlled address, and it does not require any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">/// special code executing next to the victim. This attack can also be mitigated</td>
    <td class="lineNumber">952</td>
    <td class="codeline">/// special code executing next to the victim. This attack can also be mitigated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">/// through retpolines, but those require either replacing indirect branches</td>
    <td class="lineNumber">953</td>
    <td class="codeline">/// through retpolines, but those require either replacing indirect branches</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">/// with conditional direct branches or lowering them through a device that</td>
    <td class="lineNumber">954</td>
    <td class="codeline">/// with conditional direct branches or lowering them through a device that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">/// blocks speculation. This mitigation can replace these retpoline-style</td>
    <td class="lineNumber">955</td>
    <td class="codeline">/// blocks speculation. This mitigation can replace these retpoline-style</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">/// mitigations for jump tables and other indirect branches within a function</td>
    <td class="lineNumber">956</td>
    <td class="codeline">/// mitigations for jump tables and other indirect branches within a function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">/// when variant 2 isn't a risk while allowing limited speculation. Indirect</td>
    <td class="lineNumber">957</td>
    <td class="codeline">/// when variant 2 isn't a risk while allowing limited speculation. Indirect</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">/// calls, however, cannot be mitigated through this technique without changing</td>
    <td class="lineNumber">958</td>
    <td class="codeline">/// calls, however, cannot be mitigated through this technique without changing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">/// the ABI in a fundamental way.</td>
    <td class="lineNumber">959</td>
    <td class="codeline">/// the ABI in a fundamental way.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">SmallVector<MachineInstr *, 16></td>
    <td class="lineNumber">960</td>
    <td class="codeline">SmallVector<MachineInstr *, 16></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">X86SpeculativeLoadHardeningPass::tracePredStateThroughIndirectBranches(</td>
    <td class="lineNumber">961</td>
    <td class="codeline">X86SpeculativeLoadHardeningPass::tracePredStateThroughIndirectBranches(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">    MachineFunction &MF) {</td>
    <td class="lineNumber">962</td>
    <td class="codeline">    MachineFunction &MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">  // We use the SSAUpdater to insert PHI nodes for the target addresses of</td>
    <td class="lineNumber">963</td>
    <td class="codeline">  // We use the SSAUpdater to insert PHI nodes for the target addresses of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">  // indirect branches. We don't actually need the full power of the SSA updater</td>
    <td class="lineNumber">964</td>
    <td class="codeline">  // indirect branches. We don't actually need the full power of the SSA updater</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">  // in this particular case as we always have immediately available values, but</td>
    <td class="lineNumber">965</td>
    <td class="codeline">  // in this particular case as we always have immediately available values, but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  // this avoids us having to re-implement the PHI construction logic.</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  // this avoids us having to re-implement the PHI construction logic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  MachineSSAUpdater TargetAddrSSA(MF);</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  MachineSSAUpdater TargetAddrSSA(MF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  TargetAddrSSA.Initialize(MRI->createVirtualRegister(&X86::GR64RegClass));</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  TargetAddrSSA.Initialize(MRI->createVirtualRegister(&X86::GR64RegClass));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline"></td>
    <td class="lineNumber">969</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">  // Track which blocks were terminated with an indirect branch.</td>
    <td class="lineNumber">970</td>
    <td class="codeline">  // Track which blocks were terminated with an indirect branch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">  SmallPtrSet<MachineBasicBlock *, 4> IndirectTerminatedMBBs;</td>
    <td class="lineNumber">971</td>
    <td class="codeline">  SmallPtrSet<MachineBasicBlock *, 4> IndirectTerminatedMBBs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline"></td>
    <td class="lineNumber">972</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">  // We need to know what blocks end up reached via indirect branches. We</td>
    <td class="lineNumber">973</td>
    <td class="codeline">  // We need to know what blocks end up reached via indirect branches. We</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">  // expect this to be a subset of those whose address is taken and so track it</td>
    <td class="lineNumber">974</td>
    <td class="codeline">  // expect this to be a subset of those whose address is taken and so track it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">  // directly via the CFG.</td>
    <td class="lineNumber">975</td>
    <td class="codeline">  // directly via the CFG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">  SmallPtrSet<MachineBasicBlock *, 4> IndirectTargetMBBs;</td>
    <td class="lineNumber">976</td>
    <td class="codeline">  SmallPtrSet<MachineBasicBlock *, 4> IndirectTargetMBBs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline"></td>
    <td class="lineNumber">977</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">  // Walk all the blocks which end in an indirect branch and make the</td>
    <td class="lineNumber">978</td>
    <td class="codeline">  // Walk all the blocks which end in an indirect branch and make the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">  // target address available.</td>
    <td class="lineNumber">979</td>
    <td class="codeline">  // target address available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">980</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">    // Find the last terminator.</td>
    <td class="lineNumber">981</td>
    <td class="codeline">    // Find the last terminator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">    auto MII = MBB.instr_rbegin();</td>
    <td class="lineNumber">982</td>
    <td class="codeline">    auto MII = MBB.instr_rbegin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">    while (MII != MBB.instr_rend() && MII->isDebugInstr())</td>
    <td class="lineNumber">983</td>
    <td class="codeline">    while (MII != MBB.instr_rend() && MII->isDebugInstr())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">      ++MII;</td>
    <td class="lineNumber">984</td>
    <td class="codeline">      ++MII;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">    if (MII == MBB.instr_rend())</td>
    <td class="lineNumber">985</td>
    <td class="codeline">    if (MII == MBB.instr_rend())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">986</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">    MachineInstr &TI = *MII;</td>
    <td class="lineNumber">987</td>
    <td class="codeline">    MachineInstr &TI = *MII;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">    if (!TI.isTerminator() || !TI.isBranch())</td>
    <td class="lineNumber">988</td>
    <td class="codeline">    if (!TI.isTerminator() || !TI.isBranch())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">      // No terminator or non-branch terminator.</td>
    <td class="lineNumber">989</td>
    <td class="codeline">      // No terminator or non-branch terminator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">990</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline"></td>
    <td class="lineNumber">991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">    unsigned TargetReg;</td>
    <td class="lineNumber">992</td>
    <td class="codeline">    unsigned TargetReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline"></td>
    <td class="lineNumber">993</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">    switch (TI.getOpcode()) {</td>
    <td class="lineNumber">994</td>
    <td class="codeline">    switch (TI.getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">995</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">      // Direct branch or conditional branch (leading to fallthrough).</td>
    <td class="lineNumber">996</td>
    <td class="codeline">      // Direct branch or conditional branch (leading to fallthrough).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">997</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline"></td>
    <td class="lineNumber">998</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">    case X86::FARJMP16m:</td>
    <td class="lineNumber">999</td>
    <td class="codeline">    case X86::FARJMP16m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">    case X86::FARJMP32m:</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">    case X86::FARJMP32m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">    case X86::FARJMP64m:</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">    case X86::FARJMP64m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">      // We cannot mitigate far jumps or calls, but we also don't expect them</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">      // We cannot mitigate far jumps or calls, but we also don't expect them</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">      // to be vulnerable to Spectre v1.2 or v2 (self trained) style attacks.</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">      // to be vulnerable to Spectre v1.2 or v2 (self trained) style attacks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline"></td>
    <td class="lineNumber">1005</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">    case X86::JMP16m:</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">    case X86::JMP16m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">    case X86::JMP16m_NT:</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">    case X86::JMP16m_NT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">    case X86::JMP32m:</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">    case X86::JMP32m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">    case X86::JMP32m_NT:</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">    case X86::JMP32m_NT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">    case X86::JMP64m:</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">    case X86::JMP64m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">    case X86::JMP64m_NT:</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">    case X86::JMP64m_NT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">      // Mostly as documentation.</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">      // Mostly as documentation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">      report_fatal_error("Memory operand jumps should have been unfolded!");</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">      report_fatal_error("Memory operand jumps should have been unfolded!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline"></td>
    <td class="lineNumber">1014</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">    case X86::JMP16r:</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">    case X86::JMP16r:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">      report_fatal_error(</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">      report_fatal_error(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">          "Support for 16-bit indirect branches is not implemented.");</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">          "Support for 16-bit indirect branches is not implemented.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">    case X86::JMP32r:</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">    case X86::JMP32r:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">      report_fatal_error(</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">      report_fatal_error(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">          "Support for 32-bit indirect branches is not implemented.");</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">          "Support for 32-bit indirect branches is not implemented.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline"></td>
    <td class="lineNumber">1021</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">    case X86::JMP64r:</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">    case X86::JMP64r:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">      TargetReg = TI.getOperand(0).getReg();</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">      TargetReg = TI.getOperand(0).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline"></td>
    <td class="lineNumber">1025</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">    // We have definitely found an indirect  branch. Verify that there are no</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">    // We have definitely found an indirect  branch. Verify that there are no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">    // preceding conditional branches as we don't yet support that.</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">    // preceding conditional branches as we don't yet support that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">    if (llvm::any_of(MBB.terminators(), [&](MachineInstr &OtherTI) {</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">    if (llvm::any_of(MBB.terminators(), [&](MachineInstr &OtherTI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">          return !OtherTI.isDebugInstr() && &OtherTI != &TI;</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">          return !OtherTI.isDebugInstr() && &OtherTI != &TI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">        })) {</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">        })) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">      LLVM_DEBUG({</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">      LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">        dbgs() << "ERROR: Found other terminators in a block with an indirect "</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">        dbgs() << "ERROR: Found other terminators in a block with an indirect "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">                  "branch! This is not yet supported! Terminator sequence:\n";</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">                  "branch! This is not yet supported! Terminator sequence:\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">        for (MachineInstr &MI : MBB.terminators()) {</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">        for (MachineInstr &MI : MBB.terminators()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">          MI.dump();</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">          MI.dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">          dbgs() << '\n';</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">          dbgs() << '\n';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">      });</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">      });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">      report_fatal_error("Unimplemented terminator sequence!");</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">      report_fatal_error("Unimplemented terminator sequence!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline"></td>
    <td class="lineNumber">1041</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">    // Make the target register an available value for this block.</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">    // Make the target register an available value for this block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">    TargetAddrSSA.AddAvailableValue(&MBB, TargetReg);</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">    TargetAddrSSA.AddAvailableValue(&MBB, TargetReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">    IndirectTerminatedMBBs.insert(&MBB);</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">    IndirectTerminatedMBBs.insert(&MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline"></td>
    <td class="lineNumber">1045</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">    // Add all the successors to our target candidates.</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">    // Add all the successors to our target candidates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">    for (MachineBasicBlock *Succ : MBB.successors())</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">    for (MachineBasicBlock *Succ : MBB.successors())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">      IndirectTargetMBBs.insert(Succ);</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">      IndirectTargetMBBs.insert(Succ);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline"></td>
    <td class="lineNumber">1050</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">  // Keep track of the cmov instructions we insert so we can return them.</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">  // Keep track of the cmov instructions we insert so we can return them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">  SmallVector<MachineInstr *, 16> CMovs;</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">  SmallVector<MachineInstr *, 16> CMovs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline"></td>
    <td class="lineNumber">1053</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">  // If we didn't find any indirect branches with targets, nothing to do here.</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">  // If we didn't find any indirect branches with targets, nothing to do here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  if (IndirectTargetMBBs.empty())</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  if (IndirectTargetMBBs.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">    return CMovs;</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">    return CMovs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline"></td>
    <td class="lineNumber">1057</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">  // We found indirect branches and targets that need to be instrumented to</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">  // We found indirect branches and targets that need to be instrumented to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  // harden loads within them. Walk the blocks of the function (to get a stable</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  // harden loads within them. Walk the blocks of the function (to get a stable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  // ordering) and instrument each target of an indirect branch.</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  // ordering) and instrument each target of an indirect branch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">    // Skip the blocks that aren't candidate targets.</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">    // Skip the blocks that aren't candidate targets.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">    if (!IndirectTargetMBBs.count(&MBB))</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">    if (!IndirectTargetMBBs.count(&MBB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline"></td>
    <td class="lineNumber">1065</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">    // We don't expect EH pads to ever be reached via an indirect branch. If</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">    // We don't expect EH pads to ever be reached via an indirect branch. If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">    // this is desired for some reason, we could simply skip them here rather</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">    // this is desired for some reason, we could simply skip them here rather</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">    // than asserting.</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">    // than asserting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">    assert(!MBB.isEHPad() &&</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">    assert(!MBB.isEHPad() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">           "Unexpected EH pad as target of an indirect branch!");</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">           "Unexpected EH pad as target of an indirect branch!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">    // We should never end up threading EFLAGS into a block to harden</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">    // We should never end up threading EFLAGS into a block to harden</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">    // conditional jumps as there would be an additional successor via the</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">    // conditional jumps as there would be an additional successor via the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">    // indirect branch. As a consequence, all such edges would be split before</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">    // indirect branch. As a consequence, all such edges would be split before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">    // reaching here, and the inserted block will handle the EFLAGS-based</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">    // reaching here, and the inserted block will handle the EFLAGS-based</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">    // hardening.</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">    // hardening.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">    assert(!MBB.isLiveIn(X86::EFLAGS) &&</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">    assert(!MBB.isLiveIn(X86::EFLAGS) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">           "Cannot check within a block that already has live-in EFLAGS!");</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">           "Cannot check within a block that already has live-in EFLAGS!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline"></td>
    <td class="lineNumber">1079</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">    // We can't handle having non-indirect edges into this block unless this is</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">    // We can't handle having non-indirect edges into this block unless this is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">    // the only successor and we can synthesize the necessary target address.</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">    // the only successor and we can synthesize the necessary target address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">    for (MachineBasicBlock *Pred : MBB.predecessors()) {</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">    for (MachineBasicBlock *Pred : MBB.predecessors()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">      // If we've already handled this by extracting the target directly,</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">      // If we've already handled this by extracting the target directly,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">      // nothing to do.</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">      // nothing to do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">      if (IndirectTerminatedMBBs.count(Pred))</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">      if (IndirectTerminatedMBBs.count(Pred))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline"></td>
    <td class="lineNumber">1087</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">      // Otherwise, we have to be the only successor. We generally expect this</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">      // Otherwise, we have to be the only successor. We generally expect this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">      // to be true as conditional branches should have had a critical edge</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">      // to be true as conditional branches should have had a critical edge</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">      // split already. We don't however need to worry about EH pad successors</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">      // split already. We don't however need to worry about EH pad successors</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">      // as they'll happily ignore the target and their hardening strategy is</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">      // as they'll happily ignore the target and their hardening strategy is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">      // resilient to all ways in which they could be reached speculatively.</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">      // resilient to all ways in which they could be reached speculatively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">      if (!llvm::all_of(Pred->successors(), [&](MachineBasicBlock *Succ) {</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">      if (!llvm::all_of(Pred->successors(), [&](MachineBasicBlock *Succ) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">            return Succ->isEHPad() || Succ == &MBB;</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">            return Succ->isEHPad() || Succ == &MBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">          })) {</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">          })) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">        LLVM_DEBUG({</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">        LLVM_DEBUG({</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">          dbgs() << "ERROR: Found conditional entry to target of indirect "</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">          dbgs() << "ERROR: Found conditional entry to target of indirect "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">                    "branch!\n";</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">                    "branch!\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">          Pred->dump();</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">          Pred->dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">          MBB.dump();</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">          MBB.dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">        });</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">        });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">        report_fatal_error("Cannot harden a conditional entry to a target of "</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">        report_fatal_error("Cannot harden a conditional entry to a target of "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">                           "an indirect branch!");</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">                           "an indirect branch!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline"></td>
    <td class="lineNumber">1105</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">      // Now we need to compute the address of this block and install it as a</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">      // Now we need to compute the address of this block and install it as a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">      // synthetic target in the predecessor. We do this at the bottom of the</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">      // synthetic target in the predecessor. We do this at the bottom of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">      // predecessor.</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">      // predecessor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">      auto InsertPt = Pred->getFirstTerminator();</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">      auto InsertPt = Pred->getFirstTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">      Register TargetReg = MRI->createVirtualRegister(&X86::GR64RegClass);</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">      Register TargetReg = MRI->createVirtualRegister(&X86::GR64RegClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">      if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">      if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">          !Subtarget->isPositionIndependent()) {</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">          !Subtarget->isPositionIndependent()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">        // Directly materialize it into an immediate.</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">        // Directly materialize it into an immediate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">        auto AddrI = BuildMI(*Pred, InsertPt, DebugLoc(),</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">        auto AddrI = BuildMI(*Pred, InsertPt, DebugLoc(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">                             TII->get(X86::MOV64ri32), TargetReg)</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">                             TII->get(X86::MOV64ri32), TargetReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">                         .addMBB(&MBB);</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">                         .addMBB(&MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">        ++NumInstsInserted;</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">        ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">        (void)AddrI;</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">        (void)AddrI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "  Inserting mov: "; AddrI->dump();</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "  Inserting mov: "; AddrI->dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">                   dbgs() << "\n");</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">                   dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">        auto AddrI = BuildMI(*Pred, InsertPt, DebugLoc(), TII->get(X86::LEA64r),</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">        auto AddrI = BuildMI(*Pred, InsertPt, DebugLoc(), TII->get(X86::LEA64r),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">                             TargetReg)</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">                             TargetReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">                         .addReg(/*Base*/ X86::RIP)</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">                         .addReg(/*Base*/ X86::RIP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">                         .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">                         .addImm(/*Scale*/ 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">                         .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">                         .addReg(/*Index*/ 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">                         .addMBB(&MBB)</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">                         .addMBB(&MBB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">                         .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">                         .addReg(/*Segment*/ 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">        ++NumInstsInserted;</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">        ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">        (void)AddrI;</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">        (void)AddrI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "  Inserting lea: "; AddrI->dump();</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "  Inserting lea: "; AddrI->dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">                   dbgs() << "\n");</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">                   dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">      // And make this available.</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">      // And make this available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">      TargetAddrSSA.AddAvailableValue(Pred, TargetReg);</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">      TargetAddrSSA.AddAvailableValue(Pred, TargetReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline"></td>
    <td class="lineNumber">1137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">    // Materialize the needed SSA value of the target. Note that we need the</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">    // Materialize the needed SSA value of the target. Note that we need the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">    // middle of the block as this block might at the bottom have an indirect</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">    // middle of the block as this block might at the bottom have an indirect</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">    // branch back to itself. We can do this here because at this point, every</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">    // branch back to itself. We can do this here because at this point, every</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">    // predecessor of this block has an available value. This is basically just</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">    // predecessor of this block has an available value. This is basically just</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">    // automating the construction of a PHI node for this target.</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">    // automating the construction of a PHI node for this target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">    Register TargetReg = TargetAddrSSA.GetValueInMiddleOfBlock(&MBB);</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">    Register TargetReg = TargetAddrSSA.GetValueInMiddleOfBlock(&MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline"></td>
    <td class="lineNumber">1144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">    // Insert a comparison of the incoming target register with this block's</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">    // Insert a comparison of the incoming target register with this block's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">    // address. This also requires us to mark the block as having its address</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">    // address. This also requires us to mark the block as having its address</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">    // taken explicitly.</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">    // taken explicitly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">    MBB.setMachineBlockAddressTaken();</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">    MBB.setMachineBlockAddressTaken();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">    auto InsertPt = MBB.SkipPHIsLabelsAndDebug(MBB.begin());</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">    auto InsertPt = MBB.SkipPHIsLabelsAndDebug(MBB.begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">    if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">    if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">        !Subtarget->isPositionIndependent()) {</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">        !Subtarget->isPositionIndependent()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">      // Check directly against a relocated immediate when we can.</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">      // Check directly against a relocated immediate when we can.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">      auto CheckI = BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::CMP64ri32))</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">      auto CheckI = BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::CMP64ri32))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">                        .addReg(TargetReg, RegState::Kill)</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">                        .addReg(TargetReg, RegState::Kill)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">                        .addMBB(&MBB);</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">                        .addMBB(&MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">      ++NumInstsInserted;</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">      ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">      (void)CheckI;</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">      (void)CheckI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting cmp: "; CheckI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting cmp: "; CheckI->dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">      // Otherwise compute the address into a register first.</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">      // Otherwise compute the address into a register first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">      Register AddrReg = MRI->createVirtualRegister(&X86::GR64RegClass);</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">      Register AddrReg = MRI->createVirtualRegister(&X86::GR64RegClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">      auto AddrI =</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">      auto AddrI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">          BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::LEA64r), AddrReg)</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">          BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::LEA64r), AddrReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">              .addReg(/*Base*/ X86::RIP)</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">              .addReg(/*Base*/ X86::RIP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">              .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">              .addImm(/*Scale*/ 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">              .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">              .addReg(/*Index*/ 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">              .addMBB(&MBB)</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">              .addMBB(&MBB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">              .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">              .addReg(/*Segment*/ 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">      ++NumInstsInserted;</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">      ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">      (void)AddrI;</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">      (void)AddrI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting lea: "; AddrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting lea: "; AddrI->dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">      auto CheckI = BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::CMP64rr))</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">      auto CheckI = BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::CMP64rr))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">                        .addReg(TargetReg, RegState::Kill)</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">                        .addReg(TargetReg, RegState::Kill)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">                        .addReg(AddrReg, RegState::Kill);</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">                        .addReg(AddrReg, RegState::Kill);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">      ++NumInstsInserted;</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">      ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">      (void)CheckI;</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">      (void)CheckI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting cmp: "; CheckI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting cmp: "; CheckI->dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline"></td>
    <td class="lineNumber">1179</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">    // Now cmov over the predicate if the comparison wasn't equal.</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">    // Now cmov over the predicate if the comparison wasn't equal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">    int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">    int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">    auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">    auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">    Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">    Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">    auto CMovI =</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">    auto CMovI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">        BuildMI(MBB, InsertPt, DebugLoc(), TII->get(CMovOp), UpdatedStateReg)</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">        BuildMI(MBB, InsertPt, DebugLoc(), TII->get(CMovOp), UpdatedStateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">            .addReg(PS->InitialReg)</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">            .addReg(PS->InitialReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">            .addReg(PS->PoisonReg)</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">            .addReg(PS->PoisonReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">            .addImm(X86::COND_NE);</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">            .addImm(X86::COND_NE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">    CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">    CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">    ++NumInstsInserted;</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">    ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">    CMovs.push_back(&*CMovI);</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">    CMovs.push_back(&*CMovI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline"></td>
    <td class="lineNumber">1193</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">    // And put the new value into the available values for SSA form of our</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">    // And put the new value into the available values for SSA form of our</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">    // predicate state.</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">    // predicate state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">    PS->SSA.AddAvailableValue(&MBB, UpdatedStateReg);</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">    PS->SSA.AddAvailableValue(&MBB, UpdatedStateReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline"></td>
    <td class="lineNumber">1198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">  // Return all the newly inserted cmov instructions of the predicate state.</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">  // Return all the newly inserted cmov instructions of the predicate state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">  return CMovs;</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">  return CMovs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline"></td>
    <td class="lineNumber">1202</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">// Returns true if the MI has EFLAGS as a register def operand and it's live,</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">// Returns true if the MI has EFLAGS as a register def operand and it's live,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">// otherwise it returns false</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">// otherwise it returns false</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">static bool isEFLAGSDefLive(const MachineInstr &MI) {</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">static bool isEFLAGSDefLive(const MachineInstr &MI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">  if (const MachineOperand *DefOp = MI.findRegisterDefOperand(X86::EFLAGS)) {</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">  if (const MachineOperand *DefOp = MI.findRegisterDefOperand(X86::EFLAGS)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">    return !DefOp->isDead();</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">    return !DefOp->isDead();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline"></td>
    <td class="lineNumber">1211</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">static bool isEFLAGSLive(MachineBasicBlock &MBB, MachineBasicBlock::iterator I,</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">static bool isEFLAGSLive(MachineBasicBlock &MBB, MachineBasicBlock::iterator I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">                         const TargetRegisterInfo &TRI) {</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">                         const TargetRegisterInfo &TRI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  // Check if EFLAGS are alive by seeing if there is a def of them or they</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  // Check if EFLAGS are alive by seeing if there is a def of them or they</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">  // live-in, and then seeing if that def is in turn used.</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">  // live-in, and then seeing if that def is in turn used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">  for (MachineInstr &MI : llvm::reverse(llvm::make_range(MBB.begin(), I))) {</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">  for (MachineInstr &MI : llvm::reverse(llvm::make_range(MBB.begin(), I))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">    if (MachineOperand *DefOp = MI.findRegisterDefOperand(X86::EFLAGS)) {</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">    if (MachineOperand *DefOp = MI.findRegisterDefOperand(X86::EFLAGS)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">      // If the def is dead, then EFLAGS is not live.</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">      // If the def is dead, then EFLAGS is not live.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">      if (DefOp->isDead())</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">      if (DefOp->isDead())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">      // Otherwise we've def'ed it, and it is live.</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">      // Otherwise we've def'ed it, and it is live.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">    // While at this instruction, also check if we use and kill EFLAGS</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">    // While at this instruction, also check if we use and kill EFLAGS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">    // which means it isn't live.</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">    // which means it isn't live.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">    if (MI.killsRegister(X86::EFLAGS, &TRI))</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">    if (MI.killsRegister(X86::EFLAGS, &TRI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline"></td>
    <td class="lineNumber">1230</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">  // If we didn't find anything conclusive (neither definitely alive or</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">  // If we didn't find anything conclusive (neither definitely alive or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  // definitely dead) return whether it lives into the block.</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  // definitely dead) return whether it lives into the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">  return MBB.isLiveIn(X86::EFLAGS);</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">  return MBB.isLiveIn(X86::EFLAGS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline"></td>
    <td class="lineNumber">1235</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">/// Trace the predicate state through each of the blocks in the function,</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">/// Trace the predicate state through each of the blocks in the function,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">/// hardening everything necessary along the way.</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">/// hardening everything necessary along the way.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">/// We call this routine once the initial predicate state has been established</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">/// We call this routine once the initial predicate state has been established</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">/// for each basic block in the function in the SSA updater. This routine traces</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">/// for each basic block in the function in the SSA updater. This routine traces</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">/// it through the instructions within each basic block, and for non-returning</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">/// it through the instructions within each basic block, and for non-returning</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">/// blocks informs the SSA updater about the final state that lives out of the</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">/// blocks informs the SSA updater about the final state that lives out of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">/// block. Along the way, it hardens any vulnerable instruction using the</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">/// block. Along the way, it hardens any vulnerable instruction using the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">/// currently valid predicate state. We have to do these two things together</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">/// currently valid predicate state. We have to do these two things together</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">/// because the SSA updater only works across blocks. Within a block, we track</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">/// because the SSA updater only works across blocks. Within a block, we track</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">/// the current predicate state directly and update it as it changes.</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">/// the current predicate state directly and update it as it changes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">/// This operates in two passes over each block. First, we analyze the loads in</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">/// This operates in two passes over each block. First, we analyze the loads in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">/// the block to determine which strategy will be used to harden them: hardening</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">/// the block to determine which strategy will be used to harden them: hardening</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">/// the address or hardening the loaded value when loaded into a register</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">/// the address or hardening the loaded value when loaded into a register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">/// amenable to hardening. We have to process these first because the two</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">/// amenable to hardening. We have to process these first because the two</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">/// strategies may interact -- later hardening may change what strategy we wish</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">/// strategies may interact -- later hardening may change what strategy we wish</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">/// to use. We also will analyze data dependencies between loads and avoid</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">/// to use. We also will analyze data dependencies between loads and avoid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">/// hardening those loads that are data dependent on a load with a hardened</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">/// hardening those loads that are data dependent on a load with a hardened</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">/// address. We also skip hardening loads already behind an LFENCE as that is</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">/// address. We also skip hardening loads already behind an LFENCE as that is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">/// sufficient to harden them against misspeculation.</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">/// sufficient to harden them against misspeculation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">/// Second, we actively trace the predicate state through the block, applying</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">/// Second, we actively trace the predicate state through the block, applying</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">/// the hardening steps we determined necessary in the first pass as we go.</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">/// the hardening steps we determined necessary in the first pass as we go.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">/// These two passes are applied to each basic block. We operate one block at a</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">/// These two passes are applied to each basic block. We operate one block at a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">/// time to simplify reasoning about reachability and sequencing.</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">/// time to simplify reasoning about reachability and sequencing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::tracePredStateThroughBlocksAndHarden(</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::tracePredStateThroughBlocksAndHarden(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">    MachineFunction &MF) {</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">    MachineFunction &MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">  SmallPtrSet<MachineInstr *, 16> HardenPostLoad;</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">  SmallPtrSet<MachineInstr *, 16> HardenPostLoad;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">  SmallPtrSet<MachineInstr *, 16> HardenLoadAddr;</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">  SmallPtrSet<MachineInstr *, 16> HardenLoadAddr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline"></td>
    <td class="lineNumber">1267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">  SmallSet<unsigned, 16> HardenedAddrRegs;</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">  SmallSet<unsigned, 16> HardenedAddrRegs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
    <td class="lineNumber">1269</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">  SmallDenseMap<unsigned, unsigned, 32> AddrRegToHardenedReg;</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">  SmallDenseMap<unsigned, unsigned, 32> AddrRegToHardenedReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline"></td>
    <td class="lineNumber">1271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">  // Track the set of load-dependent registers through the basic block. Because</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">  // Track the set of load-dependent registers through the basic block. Because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">  // the values of these registers have an existing data dependency on a loaded</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">  // the values of these registers have an existing data dependency on a loaded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  // value which we would have checked, we can omit any checks on them.</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  // value which we would have checked, we can omit any checks on them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">  SparseBitVector<> LoadDepRegs;</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">  SparseBitVector<> LoadDepRegs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">  for (MachineBasicBlock &MBB : MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">    // The first pass over the block: collect all the loads which can have their</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">    // The first pass over the block: collect all the loads which can have their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">    // loaded value hardened and all the loads that instead need their address</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">    // loaded value hardened and all the loads that instead need their address</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">    // hardened. During this walk we propagate load dependence for address</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">    // hardened. During this walk we propagate load dependence for address</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">    // hardened loads and also look for LFENCE to stop hardening wherever</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">    // hardened loads and also look for LFENCE to stop hardening wherever</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">    // possible. When deciding whether or not to harden the loaded value or not,</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">    // possible. When deciding whether or not to harden the loaded value or not,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">    // we check to see if any registers used in the address will have been</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">    // we check to see if any registers used in the address will have been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">    // hardened at this point and if so, harden any remaining address registers</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">    // hardened at this point and if so, harden any remaining address registers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">    // as that often successfully re-uses hardened addresses and minimizes</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">    // as that often successfully re-uses hardened addresses and minimizes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">    // instructions.</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">    // instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">    // FIXME: We should consider an aggressive mode where we continue to keep as</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">    // FIXME: We should consider an aggressive mode where we continue to keep as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">    // many loads value hardened even when some address register hardening would</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">    // many loads value hardened even when some address register hardening would</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">    // be free (due to reuse).</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">    // be free (due to reuse).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">    // Note that we only need this pass if we are actually hardening loads.</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">    // Note that we only need this pass if we are actually hardening loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">    if (HardenLoads)</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">    if (HardenLoads)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">      for (MachineInstr &MI : MBB) {</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">      for (MachineInstr &MI : MBB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">        // We naively assume that all def'ed registers of an instruction have</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">        // We naively assume that all def'ed registers of an instruction have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">        // a data dependency on all of their operands.</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">        // a data dependency on all of their operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">        // FIXME: Do a more careful analysis of x86 to build a conservative</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">        // FIXME: Do a more careful analysis of x86 to build a conservative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">        // model here.</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">        // model here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">        if (llvm::any_of(MI.uses(), [&](MachineOperand &Op) {</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">        if (llvm::any_of(MI.uses(), [&](MachineOperand &Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">              return Op.isReg() && LoadDepRegs.test(Op.getReg());</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">              return Op.isReg() && LoadDepRegs.test(Op.getReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">            }))</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">            }))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">          for (MachineOperand &Def : MI.defs())</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">          for (MachineOperand &Def : MI.defs())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">            if (Def.isReg())</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">            if (Def.isReg())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">              LoadDepRegs.set(Def.getReg());</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">              LoadDepRegs.set(Def.getReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline"></td>
    <td class="lineNumber">1305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">        // Both Intel and AMD are guiding that they will change the semantics of</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">        // Both Intel and AMD are guiding that they will change the semantics of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">        // LFENCE to be a speculation barrier, so if we see an LFENCE, there is</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">        // LFENCE to be a speculation barrier, so if we see an LFENCE, there is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">        // no more need to guard things in this block.</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">        // no more need to guard things in this block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">        if (MI.getOpcode() == X86::LFENCE)</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">        if (MI.getOpcode() == X86::LFENCE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">        // If this instruction cannot load, nothing to do.</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">        // If this instruction cannot load, nothing to do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">        if (!MI.mayLoad())</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">        if (!MI.mayLoad())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">        // Some instructions which "load" are trivially safe or unimportant.</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">        // Some instructions which "load" are trivially safe or unimportant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">        if (MI.getOpcode() == X86::MFENCE)</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">        if (MI.getOpcode() == X86::MFENCE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline"></td>
    <td class="lineNumber">1319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">        // Extract the memory operand information about this instruction.</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">        // Extract the memory operand information about this instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">        // FIXME: This doesn't handle loading pseudo instructions which we often</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">        // FIXME: This doesn't handle loading pseudo instructions which we often</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">        // could handle with similarly generic logic. We probably need to add an</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">        // could handle with similarly generic logic. We probably need to add an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">        // MI-layer routine similar to the MC-layer one we use here which maps</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">        // MI-layer routine similar to the MC-layer one we use here which maps</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">        // pseudos much like this maps real instructions.</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">        // pseudos much like this maps real instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">        const MCInstrDesc &Desc = MI.getDesc();</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">        const MCInstrDesc &Desc = MI.getDesc();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">        int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">        int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">        if (MemRefBeginIdx < 0) {</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">        if (MemRefBeginIdx < 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">                         << "WARNING: unable to harden loading instruction: ";</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">                         << "WARNING: unable to harden loading instruction: ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">                     MI.dump());</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">                     MI.dump());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline"></td>
    <td class="lineNumber">1333</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">        MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">        MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline"></td>
    <td class="lineNumber">1335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">        MachineOperand &BaseMO =</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">        MachineOperand &BaseMO =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">            MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">            MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">        MachineOperand &IndexMO =</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">        MachineOperand &IndexMO =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">            MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">            MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline"></td>
    <td class="lineNumber">1340</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">        // If we have at least one (non-frame-index, non-RIP) register operand,</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">        // If we have at least one (non-frame-index, non-RIP) register operand,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">        // and neither operand is load-dependent, we need to check the load.</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">        // and neither operand is load-dependent, we need to check the load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">        unsigned BaseReg = 0, IndexReg = 0;</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">        unsigned BaseReg = 0, IndexReg = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">        if (!BaseMO.isFI() && BaseMO.getReg() != X86::RIP &&</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">        if (!BaseMO.isFI() && BaseMO.getReg() != X86::RIP &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">            BaseMO.getReg() != X86::NoRegister)</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">            BaseMO.getReg() != X86::NoRegister)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">          BaseReg = BaseMO.getReg();</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">          BaseReg = BaseMO.getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">        if (IndexMO.getReg() != X86::NoRegister)</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">        if (IndexMO.getReg() != X86::NoRegister)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">          IndexReg = IndexMO.getReg();</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">          IndexReg = IndexMO.getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">        if (!BaseReg && !IndexReg)</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">        if (!BaseReg && !IndexReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">          // No register operands!</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">          // No register operands!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline"></td>
    <td class="lineNumber">1353</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">        // If any register operand is dependent, this load is dependent and we</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">        // If any register operand is dependent, this load is dependent and we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">        // needn't check it.</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">        // needn't check it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">        // FIXME: Is this true in the case where we are hardening loads after</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">        // FIXME: Is this true in the case where we are hardening loads after</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">        // they complete? Unclear, need to investigate.</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">        // they complete? Unclear, need to investigate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">        if ((BaseReg && LoadDepRegs.test(BaseReg)) ||</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">        if ((BaseReg && LoadDepRegs.test(BaseReg)) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">            (IndexReg && LoadDepRegs.test(IndexReg)))</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">            (IndexReg && LoadDepRegs.test(IndexReg)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline"></td>
    <td class="lineNumber">1361</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">        // If post-load hardening is enabled, this load is compatible with</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">        // If post-load hardening is enabled, this load is compatible with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">        // post-load hardening, and we aren't already going to harden one of the</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">        // post-load hardening, and we aren't already going to harden one of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">        // address registers, queue it up to be hardened post-load. Notably,</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">        // address registers, queue it up to be hardened post-load. Notably,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">        // even once hardened this won't introduce a useful dependency that</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">        // even once hardened this won't introduce a useful dependency that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">        // could prune out subsequent loads.</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">        // could prune out subsequent loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">        if (EnablePostLoadHardening && X86InstrInfo::isDataInvariantLoad(MI) &&</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">        if (EnablePostLoadHardening && X86InstrInfo::isDataInvariantLoad(MI) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">            !isEFLAGSDefLive(MI) && MI.getDesc().getNumDefs() == 1 &&</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">            !isEFLAGSDefLive(MI) && MI.getDesc().getNumDefs() == 1 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">            MI.getOperand(0).isReg() &&</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">            MI.getOperand(0).isReg() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">            canHardenRegister(MI.getOperand(0).getReg()) &&</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">            canHardenRegister(MI.getOperand(0).getReg()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">            !HardenedAddrRegs.count(BaseReg) &&</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">            !HardenedAddrRegs.count(BaseReg) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">            !HardenedAddrRegs.count(IndexReg)) {</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">            !HardenedAddrRegs.count(IndexReg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">          HardenPostLoad.insert(&MI);</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">          HardenPostLoad.insert(&MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">          HardenedAddrRegs.insert(MI.getOperand(0).getReg());</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">          HardenedAddrRegs.insert(MI.getOperand(0).getReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline"></td>
    <td class="lineNumber">1377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">        // Record this instruction for address hardening and record its register</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">        // Record this instruction for address hardening and record its register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">        // operands as being address-hardened.</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">        // operands as being address-hardened.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">        HardenLoadAddr.insert(&MI);</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">        HardenLoadAddr.insert(&MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">        if (BaseReg)</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">        if (BaseReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">          HardenedAddrRegs.insert(BaseReg);</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">          HardenedAddrRegs.insert(BaseReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">        if (IndexReg)</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">        if (IndexReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">          HardenedAddrRegs.insert(IndexReg);</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">          HardenedAddrRegs.insert(IndexReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline"></td>
    <td class="lineNumber">1385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">        for (MachineOperand &Def : MI.defs())</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">        for (MachineOperand &Def : MI.defs())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">          if (Def.isReg())</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">          if (Def.isReg())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">            LoadDepRegs.set(Def.getReg());</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">            LoadDepRegs.set(Def.getReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline"></td>
    <td class="lineNumber">1390</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">    // Now re-walk the instructions in the basic block, and apply whichever</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">    // Now re-walk the instructions in the basic block, and apply whichever</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">    // hardening strategy we have elected. Note that we do this in a second</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">    // hardening strategy we have elected. Note that we do this in a second</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">    // pass specifically so that we have the complete set of instructions for</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">    // pass specifically so that we have the complete set of instructions for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">    // which we will do post-load hardening and can defer it in certain</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">    // which we will do post-load hardening and can defer it in certain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">    // circumstances.</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">    // circumstances.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">    for (MachineInstr &MI : MBB) {</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">    for (MachineInstr &MI : MBB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">      if (HardenLoads) {</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">      if (HardenLoads) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">        // We cannot both require hardening the def of a load and its address.</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">        // We cannot both require hardening the def of a load and its address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">        assert(!(HardenLoadAddr.count(&MI) && HardenPostLoad.count(&MI)) &&</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">        assert(!(HardenLoadAddr.count(&MI) && HardenPostLoad.count(&MI)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">               "Requested to harden both the address and def of a load!");</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">               "Requested to harden both the address and def of a load!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline"></td>
    <td class="lineNumber">1401</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">        // Check if this is a load whose address needs to be hardened.</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">        // Check if this is a load whose address needs to be hardened.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">        if (HardenLoadAddr.erase(&MI)) {</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">        if (HardenLoadAddr.erase(&MI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">          const MCInstrDesc &Desc = MI.getDesc();</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">          const MCInstrDesc &Desc = MI.getDesc();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">          int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">          int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">          assert(MemRefBeginIdx >= 0 && "Cannot have an invalid index here!");</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">          assert(MemRefBeginIdx >= 0 && "Cannot have an invalid index here!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline"></td>
    <td class="lineNumber">1407</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">          MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">          MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline"></td>
    <td class="lineNumber">1409</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">          MachineOperand &BaseMO =</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">          MachineOperand &BaseMO =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">              MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">              MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">          MachineOperand &IndexMO =</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">          MachineOperand &IndexMO =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">              MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">              MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">          hardenLoadAddr(MI, BaseMO, IndexMO, AddrRegToHardenedReg);</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">          hardenLoadAddr(MI, BaseMO, IndexMO, AddrRegToHardenedReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline"></td>
    <td class="lineNumber">1417</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">        // Test if this instruction is one of our post load instructions (and</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">        // Test if this instruction is one of our post load instructions (and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">        // remove it from the set if so).</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">        // remove it from the set if so).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">        if (HardenPostLoad.erase(&MI)) {</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">        if (HardenPostLoad.erase(&MI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">          assert(!MI.isCall() && "Must not try to post-load harden a call!");</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">          assert(!MI.isCall() && "Must not try to post-load harden a call!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline"></td>
    <td class="lineNumber">1422</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">          // If this is a data-invariant load and there is no EFLAGS</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">          // If this is a data-invariant load and there is no EFLAGS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">          // interference, we want to try and sink any hardening as far as</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">          // interference, we want to try and sink any hardening as far as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">          // possible.</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">          // possible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">          if (X86InstrInfo::isDataInvariantLoad(MI) && !isEFLAGSDefLive(MI)) {</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">          if (X86InstrInfo::isDataInvariantLoad(MI) && !isEFLAGSDefLive(MI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">            // Sink the instruction we'll need to harden as far as we can down</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">            // Sink the instruction we'll need to harden as far as we can down</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">            // the graph.</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">            // the graph.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">            MachineInstr *SunkMI = sinkPostLoadHardenedInst(MI, HardenPostLoad);</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">            MachineInstr *SunkMI = sinkPostLoadHardenedInst(MI, HardenPostLoad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline"></td>
    <td class="lineNumber">1430</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">            // If we managed to sink this instruction, update everything so we</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">            // If we managed to sink this instruction, update everything so we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">            // harden that instruction when we reach it in the instruction</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">            // harden that instruction when we reach it in the instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">            // sequence.</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">            // sequence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">            if (SunkMI != &MI) {</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">            if (SunkMI != &MI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">              // If in sinking there was no instruction needing to be hardened,</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">              // If in sinking there was no instruction needing to be hardened,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">              // we're done.</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">              // we're done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">              if (!SunkMI)</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">              if (!SunkMI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">                continue;</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">                continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline"></td>
    <td class="lineNumber">1439</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">              // Otherwise, add this to the set of defs we harden.</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">              // Otherwise, add this to the set of defs we harden.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">              HardenPostLoad.insert(SunkMI);</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">              HardenPostLoad.insert(SunkMI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">            }</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">            }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline"></td>
    <td class="lineNumber">1445</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">          unsigned HardenedReg = hardenPostLoad(MI);</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">          unsigned HardenedReg = hardenPostLoad(MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline"></td>
    <td class="lineNumber">1447</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">          // Mark the resulting hardened register as such so we don't re-harden.</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">          // Mark the resulting hardened register as such so we don't re-harden.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">          AddrRegToHardenedReg[HardenedReg] = HardenedReg;</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">          AddrRegToHardenedReg[HardenedReg] = HardenedReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline"></td>
    <td class="lineNumber">1450</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline"></td>
    <td class="lineNumber">1453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">        // Check for an indirect call or branch that may need its input hardened</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">        // Check for an indirect call or branch that may need its input hardened</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">        // even if we couldn't find the specific load used, or were able to</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">        // even if we couldn't find the specific load used, or were able to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">        // avoid hardening it for some reason. Note that here we cannot break</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">        // avoid hardening it for some reason. Note that here we cannot break</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">        // out afterward as we may still need to handle any call aspect of this</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">        // out afterward as we may still need to handle any call aspect of this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">        // instruction.</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">        // instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">        if ((MI.isCall() || MI.isBranch()) && HardenIndirectCallsAndJumps)</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">        if ((MI.isCall() || MI.isBranch()) && HardenIndirectCallsAndJumps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">          hardenIndirectCallOrJumpInstr(MI, AddrRegToHardenedReg);</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">          hardenIndirectCallOrJumpInstr(MI, AddrRegToHardenedReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline"></td>
    <td class="lineNumber">1462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">      // After we finish hardening loads we handle interprocedural hardening if</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">      // After we finish hardening loads we handle interprocedural hardening if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">      // enabled and relevant for this instruction.</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">      // enabled and relevant for this instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">      if (!HardenInterprocedurally)</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">      if (!HardenInterprocedurally)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">      if (!MI.isCall() && !MI.isReturn())</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">      if (!MI.isCall() && !MI.isReturn())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline"></td>
    <td class="lineNumber">1469</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">      // If this is a direct return (IE, not a tail call) just directly harden</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">      // If this is a direct return (IE, not a tail call) just directly harden</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">      // it.</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">      // it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">      if (MI.isReturn() && !MI.isCall()) {</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">      if (MI.isReturn() && !MI.isCall()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">        hardenReturnInstr(MI);</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">        hardenReturnInstr(MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline"></td>
    <td class="lineNumber">1476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">      // Otherwise we have a call. We need to handle transferring the predicate</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">      // Otherwise we have a call. We need to handle transferring the predicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">      // state into a call and recovering it after the call returns (unless this</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">      // state into a call and recovering it after the call returns (unless this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">      // is a tail call).</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">      // is a tail call).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">      assert(MI.isCall() && "Should only reach here for calls!");</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">      assert(MI.isCall() && "Should only reach here for calls!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">      tracePredStateThroughCall(MI);</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">      tracePredStateThroughCall(MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline"></td>
    <td class="lineNumber">1483</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">    HardenPostLoad.clear();</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">    HardenPostLoad.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">    HardenLoadAddr.clear();</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">    HardenLoadAddr.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">    HardenedAddrRegs.clear();</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">    HardenedAddrRegs.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">    AddrRegToHardenedReg.clear();</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">    AddrRegToHardenedReg.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline"></td>
    <td class="lineNumber">1488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">    // Currently, we only track data-dependent loads within a basic block.</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">    // Currently, we only track data-dependent loads within a basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">    // FIXME: We should see if this is necessary or if we could be more</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">    // FIXME: We should see if this is necessary or if we could be more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">    // aggressive here without opening up attack avenues.</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">    // aggressive here without opening up attack avenues.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">    LoadDepRegs.clear();</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">    LoadDepRegs.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline"></td>
    <td class="lineNumber">1495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">/// Save EFLAGS into the returned GPR. This can in turn be restored with</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">/// Save EFLAGS into the returned GPR. This can in turn be restored with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">/// `restoreEFLAGS`.</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">/// `restoreEFLAGS`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">/// Note that LLVM can only lower very simple patterns of saved and restored</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">/// Note that LLVM can only lower very simple patterns of saved and restored</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">/// EFLAGS registers. The restore should always be within the same basic block</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">/// EFLAGS registers. The restore should always be within the same basic block</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">/// as the save so that no PHI nodes are inserted.</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">/// as the save so that no PHI nodes are inserted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">unsigned X86SpeculativeLoadHardeningPass::saveEFLAGS(</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">unsigned X86SpeculativeLoadHardeningPass::saveEFLAGS(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">    const DebugLoc &Loc) {</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">    const DebugLoc &Loc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">  // FIXME: Hard coding this to a 32-bit register class seems weird, but matches</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">  // FIXME: Hard coding this to a 32-bit register class seems weird, but matches</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">  // what instruction selection does.</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">  // what instruction selection does.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">  Register Reg = MRI->createVirtualRegister(&X86::GR32RegClass);</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">  Register Reg = MRI->createVirtualRegister(&X86::GR32RegClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">  // We directly copy the FLAGS register and rely on later lowering to clean</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">  // We directly copy the FLAGS register and rely on later lowering to clean</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">  // this up into the appropriate setCC instructions.</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">  // this up into the appropriate setCC instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">  BuildMI(MBB, InsertPt, Loc, TII->get(X86::COPY), Reg).addReg(X86::EFLAGS);</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">  BuildMI(MBB, InsertPt, Loc, TII->get(X86::COPY), Reg).addReg(X86::EFLAGS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">  ++NumInstsInserted;</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">  ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">  return Reg;</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">  return Reg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline"></td>
    <td class="lineNumber">1514</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">/// Restore EFLAGS from the provided GPR. This should be produced by</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">/// Restore EFLAGS from the provided GPR. This should be produced by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">/// `saveEFLAGS`.</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">/// `saveEFLAGS`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">/// This must be done within the same basic block as the save in order to</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">/// This must be done within the same basic block as the save in order to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">/// reliably lower.</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">/// reliably lower.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::restoreEFLAGS(</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::restoreEFLAGS(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">    const DebugLoc &Loc, Register Reg) {</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">    const DebugLoc &Loc, Register Reg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">  BuildMI(MBB, InsertPt, Loc, TII->get(X86::COPY), X86::EFLAGS).addReg(Reg);</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">  BuildMI(MBB, InsertPt, Loc, TII->get(X86::COPY), X86::EFLAGS).addReg(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">  ++NumInstsInserted;</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">  ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline"></td>
    <td class="lineNumber">1526</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">/// Takes the current predicate state (in a register) and merges it into the</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">/// Takes the current predicate state (in a register) and merges it into the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">/// stack pointer. The state is essentially a single bit, but we merge this in</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">/// stack pointer. The state is essentially a single bit, but we merge this in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">/// a way that won't form non-canonical pointers and also will be preserved</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">/// a way that won't form non-canonical pointers and also will be preserved</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">/// across normal stack adjustments.</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">/// across normal stack adjustments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::mergePredStateIntoSP(</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::mergePredStateIntoSP(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">    const DebugLoc &Loc, unsigned PredStateReg) {</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">    const DebugLoc &Loc, unsigned PredStateReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">  Register TmpReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">  Register TmpReg = MRI->createVirtualRegister(PS->RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">  // FIXME: This hard codes a shift distance based on the number of bits needed</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">  // FIXME: This hard codes a shift distance based on the number of bits needed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">  // to stay canonical on 64-bit. We should compute this somehow and support</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">  // to stay canonical on 64-bit. We should compute this somehow and support</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">  // 32-bit as part of that.</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">  // 32-bit as part of that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">  auto ShiftI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::SHL64ri), TmpReg)</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">  auto ShiftI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::SHL64ri), TmpReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">                    .addReg(PredStateReg, RegState::Kill)</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">                    .addReg(PredStateReg, RegState::Kill)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">                    .addImm(47);</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">                    .addImm(47);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">  ShiftI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">  ShiftI->addRegisterDead(X86::EFLAGS, TRI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">  ++NumInstsInserted;</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">  ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">  auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::OR64rr), X86::RSP)</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">  auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::OR64rr), X86::RSP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">                 .addReg(X86::RSP)</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">                 .addReg(X86::RSP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">                 .addReg(TmpReg, RegState::Kill);</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">                 .addReg(TmpReg, RegState::Kill);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">  OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">  OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">  ++NumInstsInserted;</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">  ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline"></td>
    <td class="lineNumber">1549</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">/// Extracts the predicate state stored in the high bits of the stack pointer.</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">/// Extracts the predicate state stored in the high bits of the stack pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">unsigned X86SpeculativeLoadHardeningPass::extractPredStateFromSP(</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">unsigned X86SpeculativeLoadHardeningPass::extractPredStateFromSP(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">1552</td>
    <td class="codeline">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">    const DebugLoc &Loc) {</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">    const DebugLoc &Loc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">  Register PredStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">  Register PredStateReg = MRI->createVirtualRegister(PS->RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">  Register TmpReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">  Register TmpReg = MRI->createVirtualRegister(PS->RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline"></td>
    <td class="lineNumber">1556</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">  // We know that the stack pointer will have any preserved predicate state in</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">  // We know that the stack pointer will have any preserved predicate state in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">  // its high bit. We just want to smear this across the other bits. Turns out,</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">  // its high bit. We just want to smear this across the other bits. Turns out,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">  // this is exactly what an arithmetic right shift does.</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">  // this is exactly what an arithmetic right shift does.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">  BuildMI(MBB, InsertPt, Loc, TII->get(TargetOpcode::COPY), TmpReg)</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">  BuildMI(MBB, InsertPt, Loc, TII->get(TargetOpcode::COPY), TmpReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">      .addReg(X86::RSP);</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">      .addReg(X86::RSP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">  auto ShiftI =</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">  auto ShiftI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::SAR64ri), PredStateReg)</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::SAR64ri), PredStateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">          .addReg(TmpReg, RegState::Kill)</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">          .addReg(TmpReg, RegState::Kill)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">          .addImm(TRI->getRegSizeInBits(*PS->RC) - 1);</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">          .addImm(TRI->getRegSizeInBits(*PS->RC) - 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">  ShiftI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">  ShiftI->addRegisterDead(X86::EFLAGS, TRI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">  ++NumInstsInserted;</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">  ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline"></td>
    <td class="lineNumber">1568</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">  return PredStateReg;</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">  return PredStateReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline"></td>
    <td class="lineNumber">1571</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::hardenLoadAddr(</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::hardenLoadAddr(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">    MachineInstr &MI, MachineOperand &BaseMO, MachineOperand &IndexMO,</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">    MachineInstr &MI, MachineOperand &BaseMO, MachineOperand &IndexMO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">    SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg) {</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">    SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">  MachineBasicBlock &MBB = *MI.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">  const DebugLoc &Loc = MI.getDebugLoc();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline"></td>
    <td class="lineNumber">1577</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">  // Check if EFLAGS are alive by seeing if there is a def of them or they</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">  // Check if EFLAGS are alive by seeing if there is a def of them or they</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">  // live-in, and then seeing if that def is in turn used.</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">  // live-in, and then seeing if that def is in turn used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">  bool EFLAGSLive = isEFLAGSLive(MBB, MI.getIterator(), *TRI);</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">  bool EFLAGSLive = isEFLAGSLive(MBB, MI.getIterator(), *TRI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline"></td>
    <td class="lineNumber">1581</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">  SmallVector<MachineOperand *, 2> HardenOpRegs;</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">  SmallVector<MachineOperand *, 2> HardenOpRegs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline"></td>
    <td class="lineNumber">1583</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">  if (BaseMO.isFI()) {</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">  if (BaseMO.isFI()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">    // A frame index is never a dynamically controllable load, so only</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">    // A frame index is never a dynamically controllable load, so only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">    // harden it if we're covering fixed address loads as well.</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">    // harden it if we're covering fixed address loads as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">    LLVM_DEBUG(</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">    LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">        dbgs() << "  Skipping hardening base of explicit stack frame load: ";</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">        dbgs() << "  Skipping hardening base of explicit stack frame load: ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">        MI.dump(); dbgs() << "\n");</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">        MI.dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">  } else if (BaseMO.getReg() == X86::RSP) {</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">  } else if (BaseMO.getReg() == X86::RSP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">    // Some idempotent atomic operations are lowered directly to a locked</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">    // Some idempotent atomic operations are lowered directly to a locked</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">    // OR with 0 to the top of stack(or slightly offset from top) which uses an</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">    // OR with 0 to the top of stack(or slightly offset from top) which uses an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">    // explicit RSP register as the base.</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">    // explicit RSP register as the base.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">    assert(IndexMO.getReg() == X86::NoRegister &&</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">    assert(IndexMO.getReg() == X86::NoRegister &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">           "Explicit RSP access with dynamic index!");</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">           "Explicit RSP access with dynamic index!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">    LLVM_DEBUG(</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">    LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">        dbgs() << "  Cannot harden base of explicit RSP offset in a load!");</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">        dbgs() << "  Cannot harden base of explicit RSP offset in a load!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">  } else if (BaseMO.getReg() == X86::RIP ||</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">  } else if (BaseMO.getReg() == X86::RIP ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">             BaseMO.getReg() == X86::NoRegister) {</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">             BaseMO.getReg() == X86::NoRegister) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">    // For both RIP-relative addressed loads or absolute loads, we cannot</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">    // For both RIP-relative addressed loads or absolute loads, we cannot</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">    // meaningfully harden them because the address being loaded has no</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">    // meaningfully harden them because the address being loaded has no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">    // dynamic component.</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">    // dynamic component.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">    // FIXME: When using a segment base (like TLS does) we end up with the</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">    // FIXME: When using a segment base (like TLS does) we end up with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">    // dynamic address being the base plus -1 because we can't mutate the</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">    // dynamic address being the base plus -1 because we can't mutate the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">    // segment register here. This allows the signed 32-bit offset to point at</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">    // segment register here. This allows the signed 32-bit offset to point at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">    // valid segment-relative addresses and load them successfully.</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">    // valid segment-relative addresses and load them successfully.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">    LLVM_DEBUG(</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">    LLVM_DEBUG(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">        dbgs() << "  Cannot harden base of "</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">        dbgs() << "  Cannot harden base of "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">               << (BaseMO.getReg() == X86::RIP ? "RIP-relative" : "no-base")</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">               << (BaseMO.getReg() == X86::RIP ? "RIP-relative" : "no-base")</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">               << " address in a load!");</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">               << " address in a load!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">    assert(BaseMO.isReg() &&</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">    assert(BaseMO.isReg() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">           "Only allowed to have a frame index or register base.");</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">           "Only allowed to have a frame index or register base.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">    HardenOpRegs.push_back(&BaseMO);</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">    HardenOpRegs.push_back(&BaseMO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline"></td>
    <td class="lineNumber">1617</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">  if (IndexMO.getReg() != X86::NoRegister &&</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">  if (IndexMO.getReg() != X86::NoRegister &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">      (HardenOpRegs.empty() ||</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">      (HardenOpRegs.empty() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">       HardenOpRegs.front()->getReg() != IndexMO.getReg()))</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">       HardenOpRegs.front()->getReg() != IndexMO.getReg()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">    HardenOpRegs.push_back(&IndexMO);</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">    HardenOpRegs.push_back(&IndexMO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline"></td>
    <td class="lineNumber">1622</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">  assert((HardenOpRegs.size() == 1 || HardenOpRegs.size() == 2) &&</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">  assert((HardenOpRegs.size() == 1 || HardenOpRegs.size() == 2) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">         "Should have exactly one or two registers to harden!");</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">         "Should have exactly one or two registers to harden!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">  assert((HardenOpRegs.size() == 1 ||</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">  assert((HardenOpRegs.size() == 1 ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">          HardenOpRegs[0]->getReg() != HardenOpRegs[1]->getReg()) &&</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">          HardenOpRegs[0]->getReg() != HardenOpRegs[1]->getReg()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">         "Should not have two of the same registers!");</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">         "Should not have two of the same registers!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline"></td>
    <td class="lineNumber">1628</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">  // Remove any registers that have alreaded been checked.</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">  // Remove any registers that have alreaded been checked.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">  llvm::erase_if(HardenOpRegs, [&](MachineOperand *Op) {</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">  llvm::erase_if(HardenOpRegs, [&](MachineOperand *Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">    // See if this operand's register has already been checked.</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">    // See if this operand's register has already been checked.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">    auto It = AddrRegToHardenedReg.find(Op->getReg());</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">    auto It = AddrRegToHardenedReg.find(Op->getReg());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">    if (It == AddrRegToHardenedReg.end())</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">    if (It == AddrRegToHardenedReg.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">      // Not checked, so retain this one.</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">      // Not checked, so retain this one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline"></td>
    <td class="lineNumber">1636</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">    // Otherwise, we can directly update this operand and remove it.</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">    // Otherwise, we can directly update this operand and remove it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">    Op->setReg(It->second);</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">    Op->setReg(It->second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">  // If there are none left, we're done.</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">  // If there are none left, we're done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">  if (HardenOpRegs.empty())</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">  if (HardenOpRegs.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline"></td>
    <td class="lineNumber">1644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">  // Compute the current predicate state.</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">  // Compute the current predicate state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline"></td>
    <td class="lineNumber">1647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">  auto InsertPt = MI.getIterator();</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">  auto InsertPt = MI.getIterator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline"></td>
    <td class="lineNumber">1649</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">  // If EFLAGS are live and we don't have access to instructions that avoid</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">  // If EFLAGS are live and we don't have access to instructions that avoid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">  // clobbering EFLAGS we need to save and restore them. This in turn makes</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">  // clobbering EFLAGS we need to save and restore them. This in turn makes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">  // the EFLAGS no longer live.</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">  // the EFLAGS no longer live.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">  unsigned FlagsReg = 0;</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">  unsigned FlagsReg = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">  if (EFLAGSLive && !Subtarget->hasBMI2()) {</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">  if (EFLAGSLive && !Subtarget->hasBMI2()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">    EFLAGSLive = false;</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">    EFLAGSLive = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">    FlagsReg = saveEFLAGS(MBB, InsertPt, Loc);</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">    FlagsReg = saveEFLAGS(MBB, InsertPt, Loc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline"></td>
    <td class="lineNumber">1658</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">  for (MachineOperand *Op : HardenOpRegs) {</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">  for (MachineOperand *Op : HardenOpRegs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">    Register OpReg = Op->getReg();</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">    Register OpReg = Op->getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">    auto *OpRC = MRI->getRegClass(OpReg);</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">    auto *OpRC = MRI->getRegClass(OpReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">    Register TmpReg = MRI->createVirtualRegister(OpRC);</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">    Register TmpReg = MRI->createVirtualRegister(OpRC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline"></td>
    <td class="lineNumber">1663</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">    // If this is a vector register, we'll need somewhat custom logic to handle</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">    // If this is a vector register, we'll need somewhat custom logic to handle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">    // hardening it.</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">    // hardening it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">    if (!Subtarget->hasVLX() && (OpRC->hasSuperClassEq(&X86::VR128RegClass) ||</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">    if (!Subtarget->hasVLX() && (OpRC->hasSuperClassEq(&X86::VR128RegClass) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">                                 OpRC->hasSuperClassEq(&X86::VR256RegClass))) {</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">                                 OpRC->hasSuperClassEq(&X86::VR256RegClass))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">      assert(Subtarget->hasAVX2() && "AVX2-specific register classes!");</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">      assert(Subtarget->hasAVX2() && "AVX2-specific register classes!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">      bool Is128Bit = OpRC->hasSuperClassEq(&X86::VR128RegClass);</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">      bool Is128Bit = OpRC->hasSuperClassEq(&X86::VR128RegClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline"></td>
    <td class="lineNumber">1670</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">      // Move our state into a vector register.</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">      // Move our state into a vector register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">      // FIXME: We could skip this at the cost of longer encodings with AVX-512</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">      // FIXME: We could skip this at the cost of longer encodings with AVX-512</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">      // but that doesn't seem likely worth it.</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">      // but that doesn't seem likely worth it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">      Register VStateReg = MRI->createVirtualRegister(&X86::VR128RegClass);</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">      Register VStateReg = MRI->createVirtualRegister(&X86::VR128RegClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">      auto MovI =</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">      auto MovI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">          BuildMI(MBB, InsertPt, Loc, TII->get(X86::VMOV64toPQIrr), VStateReg)</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">          BuildMI(MBB, InsertPt, Loc, TII->get(X86::VMOV64toPQIrr), VStateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">              .addReg(StateReg);</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">              .addReg(StateReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">      (void)MovI;</td>
    <td class="lineNumber">1678</td>
    <td class="codeline">      (void)MovI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">      ++NumInstsInserted;</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">      ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting mov: "; MovI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting mov: "; MovI->dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline"></td>
    <td class="lineNumber">1681</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">      // Broadcast it across the vector register.</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">      // Broadcast it across the vector register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">      Register VBStateReg = MRI->createVirtualRegister(OpRC);</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">      Register VBStateReg = MRI->createVirtualRegister(OpRC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">      auto BroadcastI = BuildMI(MBB, InsertPt, Loc,</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">      auto BroadcastI = BuildMI(MBB, InsertPt, Loc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">                                TII->get(Is128Bit ? X86::VPBROADCASTQrr</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">                                TII->get(Is128Bit ? X86::VPBROADCASTQrr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">                                                  : X86::VPBROADCASTQYrr),</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">                                                  : X86::VPBROADCASTQYrr),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">                                VBStateReg)</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">                                VBStateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">                            .addReg(VStateReg);</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">                            .addReg(VStateReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">      (void)BroadcastI;</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">      (void)BroadcastI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">      ++NumInstsInserted;</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">      ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting broadcast: "; BroadcastI->dump();</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting broadcast: "; BroadcastI->dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">                 dbgs() << "\n");</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">                 dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline"></td>
    <td class="lineNumber">1693</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">      // Merge our potential poison state into the value with a vector or.</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">      // Merge our potential poison state into the value with a vector or.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">      auto OrI =</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">      auto OrI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline">          BuildMI(MBB, InsertPt, Loc,</td>
    <td class="lineNumber">1696</td>
    <td class="codeline">          BuildMI(MBB, InsertPt, Loc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">                  TII->get(Is128Bit ? X86::VPORrr : X86::VPORYrr), TmpReg)</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">                  TII->get(Is128Bit ? X86::VPORrr : X86::VPORYrr), TmpReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">              .addReg(VBStateReg)</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">              .addReg(VBStateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">              .addReg(OpReg);</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">              .addReg(OpReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">      (void)OrI;</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">      (void)OrI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">      ++NumInstsInserted;</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">      ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">    } else if (OpRC->hasSuperClassEq(&X86::VR128XRegClass) ||</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">    } else if (OpRC->hasSuperClassEq(&X86::VR128XRegClass) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">               OpRC->hasSuperClassEq(&X86::VR256XRegClass) ||</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">               OpRC->hasSuperClassEq(&X86::VR256XRegClass) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">               OpRC->hasSuperClassEq(&X86::VR512RegClass)) {</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">               OpRC->hasSuperClassEq(&X86::VR512RegClass)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">      assert(Subtarget->hasAVX512() && "AVX512-specific register classes!");</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">      assert(Subtarget->hasAVX512() && "AVX512-specific register classes!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">      bool Is128Bit = OpRC->hasSuperClassEq(&X86::VR128XRegClass);</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">      bool Is128Bit = OpRC->hasSuperClassEq(&X86::VR128XRegClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">      bool Is256Bit = OpRC->hasSuperClassEq(&X86::VR256XRegClass);</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">      bool Is256Bit = OpRC->hasSuperClassEq(&X86::VR256XRegClass);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">      if (Is128Bit || Is256Bit)</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">      if (Is128Bit || Is256Bit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">        assert(Subtarget->hasVLX() && "AVX512VL-specific register classes!");</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">        assert(Subtarget->hasVLX() && "AVX512VL-specific register classes!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline"></td>
    <td class="lineNumber">1711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">      // Broadcast our state into a vector register.</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">      // Broadcast our state into a vector register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">      Register VStateReg = MRI->createVirtualRegister(OpRC);</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">      Register VStateReg = MRI->createVirtualRegister(OpRC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">      unsigned BroadcastOp = Is128Bit ? X86::VPBROADCASTQrZ128rr</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">      unsigned BroadcastOp = Is128Bit ? X86::VPBROADCASTQrZ128rr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">                                      : Is256Bit ? X86::VPBROADCASTQrZ256rr</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">                                      : Is256Bit ? X86::VPBROADCASTQrZ256rr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">                                                 : X86::VPBROADCASTQrZrr;</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">                                                 : X86::VPBROADCASTQrZrr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">      auto BroadcastI =</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">      auto BroadcastI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">          BuildMI(MBB, InsertPt, Loc, TII->get(BroadcastOp), VStateReg)</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">          BuildMI(MBB, InsertPt, Loc, TII->get(BroadcastOp), VStateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">              .addReg(StateReg);</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">              .addReg(StateReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">      (void)BroadcastI;</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">      (void)BroadcastI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">      ++NumInstsInserted;</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">      ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting broadcast: "; BroadcastI->dump();</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting broadcast: "; BroadcastI->dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">                 dbgs() << "\n");</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">                 dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline"></td>
    <td class="lineNumber">1724</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">      // Merge our potential poison state into the value with a vector or.</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">      // Merge our potential poison state into the value with a vector or.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">      unsigned OrOp = Is128Bit ? X86::VPORQZ128rr</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">      unsigned OrOp = Is128Bit ? X86::VPORQZ128rr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">                               : Is256Bit ? X86::VPORQZ256rr : X86::VPORQZrr;</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">                               : Is256Bit ? X86::VPORQZ256rr : X86::VPORQZrr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">      auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(OrOp), TmpReg)</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">      auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(OrOp), TmpReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">                     .addReg(VStateReg)</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">                     .addReg(VStateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">                     .addReg(OpReg);</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">                     .addReg(OpReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">      (void)OrI;</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">      (void)OrI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">      ++NumInstsInserted;</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">      ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">      // FIXME: Need to support GR32 here for 32-bit code.</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">      // FIXME: Need to support GR32 here for 32-bit code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">      assert(OpRC->hasSuperClassEq(&X86::GR64RegClass) &&</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">      assert(OpRC->hasSuperClassEq(&X86::GR64RegClass) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">             "Not a supported register class for address hardening!");</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">             "Not a supported register class for address hardening!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline"></td>
    <td class="lineNumber">1738</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">      if (!EFLAGSLive) {</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">      if (!EFLAGSLive) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">        // Merge our potential poison state into the value with an or.</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">        // Merge our potential poison state into the value with an or.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">        auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::OR64rr), TmpReg)</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">        auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::OR64rr), TmpReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">                       .addReg(StateReg)</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">                       .addReg(StateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">                       .addReg(OpReg);</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">                       .addReg(OpReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">        OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">        OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">        ++NumInstsInserted;</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">        ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">        // We need to avoid touching EFLAGS so shift out all but the least</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">        // We need to avoid touching EFLAGS so shift out all but the least</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">        // significant bit using the instruction that doesn't update flags.</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">        // significant bit using the instruction that doesn't update flags.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">        auto ShiftI =</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">        auto ShiftI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">            BuildMI(MBB, InsertPt, Loc, TII->get(X86::SHRX64rr), TmpReg)</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">            BuildMI(MBB, InsertPt, Loc, TII->get(X86::SHRX64rr), TmpReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">                .addReg(OpReg)</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">                .addReg(OpReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">                .addReg(StateReg);</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">                .addReg(StateReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">        (void)ShiftI;</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">        (void)ShiftI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">        ++NumInstsInserted;</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">        ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "  Inserting shrx: "; ShiftI->dump();</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "  Inserting shrx: "; ShiftI->dump();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">                   dbgs() << "\n");</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">                   dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline"></td>
    <td class="lineNumber">1760</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">    // Record this register as checked and update the operand.</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">    // Record this register as checked and update the operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">    assert(!AddrRegToHardenedReg.count(Op->getReg()) &&</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">    assert(!AddrRegToHardenedReg.count(Op->getReg()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">           "Should not have checked this register yet!");</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">           "Should not have checked this register yet!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">    AddrRegToHardenedReg[Op->getReg()] = TmpReg;</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">    AddrRegToHardenedReg[Op->getReg()] = TmpReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">    Op->setReg(TmpReg);</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">    Op->setReg(TmpReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">    ++NumAddrRegsHardened;</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">    ++NumAddrRegsHardened;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1767</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline"></td>
    <td class="lineNumber">1768</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">  // And restore the flags if needed.</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">  // And restore the flags if needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">  if (FlagsReg)</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">  if (FlagsReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">    restoreEFLAGS(MBB, InsertPt, Loc, FlagsReg);</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">    restoreEFLAGS(MBB, InsertPt, Loc, FlagsReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline"></td>
    <td class="lineNumber">1773</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">MachineInstr *X86SpeculativeLoadHardeningPass::sinkPostLoadHardenedInst(</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">MachineInstr *X86SpeculativeLoadHardeningPass::sinkPostLoadHardenedInst(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">    MachineInstr &InitialMI, SmallPtrSetImpl<MachineInstr *> &HardenedInstrs) {</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">    MachineInstr &InitialMI, SmallPtrSetImpl<MachineInstr *> &HardenedInstrs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">  assert(X86InstrInfo::isDataInvariantLoad(InitialMI) &&</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">  assert(X86InstrInfo::isDataInvariantLoad(InitialMI) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">         "Cannot get here with a non-invariant load!");</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">         "Cannot get here with a non-invariant load!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">  assert(!isEFLAGSDefLive(InitialMI) &&</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">  assert(!isEFLAGSDefLive(InitialMI) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">         "Cannot get here with a data invariant load "</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">         "Cannot get here with a data invariant load "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">         "that interferes with EFLAGS!");</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">         "that interferes with EFLAGS!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline"></td>
    <td class="lineNumber">1781</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">  // See if we can sink hardening the loaded value.</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">  // See if we can sink hardening the loaded value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">  auto SinkCheckToSingleUse =</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">  auto SinkCheckToSingleUse =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">      [&](MachineInstr &MI) -> std::optional<MachineInstr *> {</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">      [&](MachineInstr &MI) -> std::optional<MachineInstr *> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">    Register DefReg = MI.getOperand(0).getReg();</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">    Register DefReg = MI.getOperand(0).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline"></td>
    <td class="lineNumber">1786</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">    // We need to find a single use which we can sink the check. We can</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">    // We need to find a single use which we can sink the check. We can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">    // primarily do this because many uses may already end up checked on their</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">    // primarily do this because many uses may already end up checked on their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">    // own.</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">    // own.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">    MachineInstr *SingleUseMI = nullptr;</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">    MachineInstr *SingleUseMI = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">    for (MachineInstr &UseMI : MRI->use_instructions(DefReg)) {</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">    for (MachineInstr &UseMI : MRI->use_instructions(DefReg)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">      // If we're already going to harden this use, it is data invariant, it</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">      // If we're already going to harden this use, it is data invariant, it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">      // does not interfere with EFLAGS, and within our block.</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">      // does not interfere with EFLAGS, and within our block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">      if (HardenedInstrs.count(&UseMI)) {</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">      if (HardenedInstrs.count(&UseMI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">        if (!X86InstrInfo::isDataInvariantLoad(UseMI) || isEFLAGSDefLive(UseMI)) {</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">        if (!X86InstrInfo::isDataInvariantLoad(UseMI) || isEFLAGSDefLive(UseMI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">          // If we've already decided to harden a non-load, we must have sunk</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">          // If we've already decided to harden a non-load, we must have sunk</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">          // some other post-load hardened instruction to it and it must itself</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">          // some other post-load hardened instruction to it and it must itself</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">          // be data-invariant.</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">          // be data-invariant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">          assert(X86InstrInfo::isDataInvariant(UseMI) &&</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">          assert(X86InstrInfo::isDataInvariant(UseMI) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">                 "Data variant instruction being hardened!");</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">                 "Data variant instruction being hardened!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline"></td>
    <td class="lineNumber">1803</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">        // Otherwise, this is a load and the load component can't be data</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">        // Otherwise, this is a load and the load component can't be data</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">        // invariant so check how this register is being used.</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">        // invariant so check how this register is being used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">        const MCInstrDesc &Desc = UseMI.getDesc();</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">        const MCInstrDesc &Desc = UseMI.getDesc();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">        int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">        int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">        assert(MemRefBeginIdx >= 0 &&</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">        assert(MemRefBeginIdx >= 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">               "Should always have mem references here!");</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">               "Should always have mem references here!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">        MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">        MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline"></td>
    <td class="lineNumber">1811</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">        MachineOperand &BaseMO =</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">        MachineOperand &BaseMO =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">            UseMI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">            UseMI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">        MachineOperand &IndexMO =</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">        MachineOperand &IndexMO =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">            UseMI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">            UseMI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">        if ((BaseMO.isReg() && BaseMO.getReg() == DefReg) ||</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">        if ((BaseMO.isReg() && BaseMO.getReg() == DefReg) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">            (IndexMO.isReg() && IndexMO.getReg() == DefReg))</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">            (IndexMO.isReg() && IndexMO.getReg() == DefReg))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">          // The load uses the register as part of its address making it not</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">          // The load uses the register as part of its address making it not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">          // invariant.</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">          // invariant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">          return {};</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">          return {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline"></td>
    <td class="lineNumber">1821</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline"></td>
    <td class="lineNumber">1824</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">      if (SingleUseMI)</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">      if (SingleUseMI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">        // We already have a single use, this would make two. Bail.</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">        // We already have a single use, this would make two. Bail.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">        return {};</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">        return {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline"></td>
    <td class="lineNumber">1828</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">      // If this single use isn't data invariant, isn't in this block, or has</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">      // If this single use isn't data invariant, isn't in this block, or has</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">      // interfering EFLAGS, we can't sink the hardening to it.</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">      // interfering EFLAGS, we can't sink the hardening to it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">      if (!X86InstrInfo::isDataInvariant(UseMI) || UseMI.getParent() != MI.getParent() ||</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">      if (!X86InstrInfo::isDataInvariant(UseMI) || UseMI.getParent() != MI.getParent() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">          isEFLAGSDefLive(UseMI))</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">          isEFLAGSDefLive(UseMI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">        return {};</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">        return {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline"></td>
    <td class="lineNumber">1834</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">      // If this instruction defines multiple registers bail as we won't harden</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">      // If this instruction defines multiple registers bail as we won't harden</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">      // all of them.</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">      // all of them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">      if (UseMI.getDesc().getNumDefs() > 1)</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">      if (UseMI.getDesc().getNumDefs() > 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">        return {};</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">        return {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline"></td>
    <td class="lineNumber">1839</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">      // If this register isn't a virtual register we can't walk uses of sanely,</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">      // If this register isn't a virtual register we can't walk uses of sanely,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">      // just bail. Also check that its register class is one of the ones we</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">      // just bail. Also check that its register class is one of the ones we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">      // can harden.</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">      // can harden.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">      Register UseDefReg = UseMI.getOperand(0).getReg();</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">      Register UseDefReg = UseMI.getOperand(0).getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">      if (!UseDefReg.isVirtual() || !canHardenRegister(UseDefReg))</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">      if (!UseDefReg.isVirtual() || !canHardenRegister(UseDefReg))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">        return {};</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">        return {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline"></td>
    <td class="lineNumber">1846</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">      SingleUseMI = &UseMI;</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">      SingleUseMI = &UseMI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline"></td>
    <td class="lineNumber">1849</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">    // If SingleUseMI is still null, there is no use that needs its own</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">    // If SingleUseMI is still null, there is no use that needs its own</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">    // checking. Otherwise, it is the single use that needs checking.</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">    // checking. Otherwise, it is the single use that needs checking.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">    return {SingleUseMI};</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">    return {SingleUseMI};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline"></td>
    <td class="lineNumber">1854</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">  MachineInstr *MI = &InitialMI;</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">  MachineInstr *MI = &InitialMI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">  while (std::optional<MachineInstr *> SingleUse = SinkCheckToSingleUse(*MI)) {</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">  while (std::optional<MachineInstr *> SingleUse = SinkCheckToSingleUse(*MI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">    // Update which MI we're checking now.</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">    // Update which MI we're checking now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">    MI = *SingleUse;</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">    MI = *SingleUse;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">    if (!MI)</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">    if (!MI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline"></td>
    <td class="lineNumber">1862</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">  return MI;</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">  return MI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline"></td>
    <td class="lineNumber">1865</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">bool X86SpeculativeLoadHardeningPass::canHardenRegister(Register Reg) {</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">bool X86SpeculativeLoadHardeningPass::canHardenRegister(Register Reg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">  auto *RC = MRI->getRegClass(Reg);</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">  auto *RC = MRI->getRegClass(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">  int RegBytes = TRI->getRegSizeInBits(*RC) / 8;</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">  int RegBytes = TRI->getRegSizeInBits(*RC) / 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">  if (RegBytes > 8)</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">  if (RegBytes > 8)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">    // We don't support post-load hardening of vectors.</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">    // We don't support post-load hardening of vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline"></td>
    <td class="lineNumber">1872</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">  unsigned RegIdx = Log2_32(RegBytes);</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">  unsigned RegIdx = Log2_32(RegBytes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">  assert(RegIdx < 4 && "Unsupported register size");</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">  assert(RegIdx < 4 && "Unsupported register size");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline"></td>
    <td class="lineNumber">1875</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">  // If this register class is explicitly constrained to a class that doesn't</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">  // If this register class is explicitly constrained to a class that doesn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">  // require REX prefix, we may not be able to satisfy that constraint when</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">  // require REX prefix, we may not be able to satisfy that constraint when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">  // emitting the hardening instructions, so bail out here.</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">  // emitting the hardening instructions, so bail out here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">  // FIXME: This seems like a pretty lame hack. The way this comes up is when we</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">  // FIXME: This seems like a pretty lame hack. The way this comes up is when we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">  // end up both with a NOREX and REX-only register as operands to the hardening</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">  // end up both with a NOREX and REX-only register as operands to the hardening</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">  // instructions. It would be better to fix that code to handle this situation</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">  // instructions. It would be better to fix that code to handle this situation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">  // rather than hack around it in this way.</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">  // rather than hack around it in this way.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">  const TargetRegisterClass *NOREXRegClasses[] = {</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">  const TargetRegisterClass *NOREXRegClasses[] = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">      &X86::GR8_NOREXRegClass, &X86::GR16_NOREXRegClass,</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">      &X86::GR8_NOREXRegClass, &X86::GR16_NOREXRegClass,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">      &X86::GR32_NOREXRegClass, &X86::GR64_NOREXRegClass};</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">      &X86::GR32_NOREXRegClass, &X86::GR64_NOREXRegClass};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">  if (RC == NOREXRegClasses[RegIdx])</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">  if (RC == NOREXRegClasses[RegIdx])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline"></td>
    <td class="lineNumber">1888</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">  const TargetRegisterClass *GPRRegClasses[] = {</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">  const TargetRegisterClass *GPRRegClasses[] = {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">      &X86::GR8RegClass, &X86::GR16RegClass, &X86::GR32RegClass,</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">      &X86::GR8RegClass, &X86::GR16RegClass, &X86::GR32RegClass,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">      &X86::GR64RegClass};</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">      &X86::GR64RegClass};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">  return RC->hasSuperClassEq(GPRRegClasses[RegIdx]);</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">  return RC->hasSuperClassEq(GPRRegClasses[RegIdx]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline"></td>
    <td class="lineNumber">1894</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">/// Harden a value in a register.</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">/// Harden a value in a register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">/// This is the low-level logic to fully harden a value sitting in a register</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">/// This is the low-level logic to fully harden a value sitting in a register</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">/// against leaking during speculative execution.</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">/// against leaking during speculative execution.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">/// Unlike hardening an address that is used by a load, this routine is required</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">/// Unlike hardening an address that is used by a load, this routine is required</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">/// to hide *all* incoming bits in the register.</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">/// to hide *all* incoming bits in the register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">/// `Reg` must be a virtual register. Currently, it is required to be a GPR no</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">/// `Reg` must be a virtual register. Currently, it is required to be a GPR no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">/// larger than the predicate state register. FIXME: We should support vector</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">/// larger than the predicate state register. FIXME: We should support vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">/// registers here by broadcasting the predicate state.</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">/// registers here by broadcasting the predicate state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">/// The new, hardened virtual register is returned. It will have the same</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">/// The new, hardened virtual register is returned. It will have the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">/// register class as `Reg`.</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">/// register class as `Reg`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">unsigned X86SpeculativeLoadHardeningPass::hardenValueInRegister(</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">unsigned X86SpeculativeLoadHardeningPass::hardenValueInRegister(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">    Register Reg, MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">    Register Reg, MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">    const DebugLoc &Loc) {</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">    const DebugLoc &Loc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">  assert(canHardenRegister(Reg) && "Cannot harden this register!");</td>
    <td class="lineNumber">1912</td>
    <td class="codeline">  assert(canHardenRegister(Reg) && "Cannot harden this register!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">  assert(Reg.isVirtual() && "Cannot harden a physical register!");</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">  assert(Reg.isVirtual() && "Cannot harden a physical register!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline"></td>
    <td class="lineNumber">1914</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">  auto *RC = MRI->getRegClass(Reg);</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">  auto *RC = MRI->getRegClass(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">  int Bytes = TRI->getRegSizeInBits(*RC) / 8;</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">  int Bytes = TRI->getRegSizeInBits(*RC) / 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">  assert((Bytes == 1 || Bytes == 2 || Bytes == 4 || Bytes == 8) &&</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">  assert((Bytes == 1 || Bytes == 2 || Bytes == 4 || Bytes == 8) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">         "Unknown register size");</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">         "Unknown register size");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline"></td>
    <td class="lineNumber">1920</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">  // FIXME: Need to teach this about 32-bit mode.</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">  // FIXME: Need to teach this about 32-bit mode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">  if (Bytes != 8) {</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">  if (Bytes != 8) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">    unsigned SubRegImms[] = {X86::sub_8bit, X86::sub_16bit, X86::sub_32bit};</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">    unsigned SubRegImms[] = {X86::sub_8bit, X86::sub_16bit, X86::sub_32bit};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">    unsigned SubRegImm = SubRegImms[Log2_32(Bytes)];</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">    unsigned SubRegImm = SubRegImms[Log2_32(Bytes)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">    Register NarrowStateReg = MRI->createVirtualRegister(RC);</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">    Register NarrowStateReg = MRI->createVirtualRegister(RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">    BuildMI(MBB, InsertPt, Loc, TII->get(TargetOpcode::COPY), NarrowStateReg)</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">    BuildMI(MBB, InsertPt, Loc, TII->get(TargetOpcode::COPY), NarrowStateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">        .addReg(StateReg, 0, SubRegImm);</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">        .addReg(StateReg, 0, SubRegImm);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">    StateReg = NarrowStateReg;</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">    StateReg = NarrowStateReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline"></td>
    <td class="lineNumber">1930</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">  unsigned FlagsReg = 0;</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">  unsigned FlagsReg = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline">  if (isEFLAGSLive(MBB, InsertPt, *TRI))</td>
    <td class="lineNumber">1932</td>
    <td class="codeline">  if (isEFLAGSLive(MBB, InsertPt, *TRI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">    FlagsReg = saveEFLAGS(MBB, InsertPt, Loc);</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">    FlagsReg = saveEFLAGS(MBB, InsertPt, Loc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline"></td>
    <td class="lineNumber">1934</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">  Register NewReg = MRI->createVirtualRegister(RC);</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">  Register NewReg = MRI->createVirtualRegister(RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">  unsigned OrOpCodes[] = {X86::OR8rr, X86::OR16rr, X86::OR32rr, X86::OR64rr};</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">  unsigned OrOpCodes[] = {X86::OR8rr, X86::OR16rr, X86::OR32rr, X86::OR64rr};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">  unsigned OrOpCode = OrOpCodes[Log2_32(Bytes)];</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">  unsigned OrOpCode = OrOpCodes[Log2_32(Bytes)];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">  auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(OrOpCode), NewReg)</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">  auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(OrOpCode), NewReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">                 .addReg(StateReg)</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">                 .addReg(StateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">                 .addReg(Reg);</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">                 .addReg(Reg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">  OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">  OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">  ++NumInstsInserted;</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">  ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline"></td>
    <td class="lineNumber">1944</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">  if (FlagsReg)</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">  if (FlagsReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">    restoreEFLAGS(MBB, InsertPt, Loc, FlagsReg);</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">    restoreEFLAGS(MBB, InsertPt, Loc, FlagsReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline"></td>
    <td class="lineNumber">1947</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">  return NewReg;</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">  return NewReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline"></td>
    <td class="lineNumber">1950</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">/// Harden a load by hardening the loaded value in the defined register.</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">/// Harden a load by hardening the loaded value in the defined register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">/// We can harden a non-leaking load into a register without touching the</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">/// We can harden a non-leaking load into a register without touching the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">/// address by just hiding all of the loaded bits during misspeculation. We use</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">/// address by just hiding all of the loaded bits during misspeculation. We use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">/// an `or` instruction to do this because we set up our poison value as all</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">/// an `or` instruction to do this because we set up our poison value as all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">/// ones. And the goal is just for the loaded bits to not be exposed to</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">/// ones. And the goal is just for the loaded bits to not be exposed to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">/// execution and coercing them to one is sufficient.</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">/// execution and coercing them to one is sufficient.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">/// Returns the newly hardened register.</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">/// Returns the newly hardened register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">unsigned X86SpeculativeLoadHardeningPass::hardenPostLoad(MachineInstr &MI) {</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">unsigned X86SpeculativeLoadHardeningPass::hardenPostLoad(MachineInstr &MI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">  MachineBasicBlock &MBB = *MI.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">  const DebugLoc &Loc = MI.getDebugLoc();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline"></td>
    <td class="lineNumber">1963</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">  auto &DefOp = MI.getOperand(0);</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">  auto &DefOp = MI.getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">  Register OldDefReg = DefOp.getReg();</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">  Register OldDefReg = DefOp.getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">  auto *DefRC = MRI->getRegClass(OldDefReg);</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">  auto *DefRC = MRI->getRegClass(OldDefReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline"></td>
    <td class="lineNumber">1967</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">  // Because we want to completely replace the uses of this def'ed value with</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">  // Because we want to completely replace the uses of this def'ed value with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">  // the hardened value, create a dedicated new register that will only be used</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">  // the hardened value, create a dedicated new register that will only be used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">  // to communicate the unhardened value to the hardening.</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">  // to communicate the unhardened value to the hardening.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">  Register UnhardenedReg = MRI->createVirtualRegister(DefRC);</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">  Register UnhardenedReg = MRI->createVirtualRegister(DefRC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">  DefOp.setReg(UnhardenedReg);</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">  DefOp.setReg(UnhardenedReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline"></td>
    <td class="lineNumber">1973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">  // Now harden this register's value, getting a hardened reg that is safe to</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">  // Now harden this register's value, getting a hardened reg that is safe to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">  // use. Note that we insert the instructions to compute this *after* the</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">  // use. Note that we insert the instructions to compute this *after* the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">  // defining instruction, not before it.</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">  // defining instruction, not before it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">  unsigned HardenedReg = hardenValueInRegister(</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">  unsigned HardenedReg = hardenValueInRegister(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">      UnhardenedReg, MBB, std::next(MI.getIterator()), Loc);</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">      UnhardenedReg, MBB, std::next(MI.getIterator()), Loc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline"></td>
    <td class="lineNumber">1979</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">  // Finally, replace the old register (which now only has the uses of the</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">  // Finally, replace the old register (which now only has the uses of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">  // original def) with the hardened register.</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">  // original def) with the hardened register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">  MRI->replaceRegWith(/*FromReg*/ OldDefReg, /*ToReg*/ HardenedReg);</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">  MRI->replaceRegWith(/*FromReg*/ OldDefReg, /*ToReg*/ HardenedReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline"></td>
    <td class="lineNumber">1983</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">  ++NumPostLoadRegsHardened;</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">  ++NumPostLoadRegsHardened;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">  return HardenedReg;</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">  return HardenedReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline"></td>
    <td class="lineNumber">1987</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">/// Harden a return instruction.</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">/// Harden a return instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">/// Returns implicitly perform a load which we need to harden. Without hardening</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">/// Returns implicitly perform a load which we need to harden. Without hardening</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">/// this load, an attacker my speculatively write over the return address to</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">/// this load, an attacker my speculatively write over the return address to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">/// steer speculation of the return to an attacker controlled address. This is</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">/// steer speculation of the return to an attacker controlled address. This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">/// called Spectre v1.1 or Bounds Check Bypass Store (BCBS) and is described in</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">/// called Spectre v1.1 or Bounds Check Bypass Store (BCBS) and is described in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">/// this paper:</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">/// this paper:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">/// https://people.csail.mit.edu/vlk/spectre11.pdf</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">/// https://people.csail.mit.edu/vlk/spectre11.pdf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">/// We can harden this by introducing an LFENCE that will delay any load of the</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">/// We can harden this by introducing an LFENCE that will delay any load of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">/// return address until prior instructions have retired (and thus are not being</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">/// return address until prior instructions have retired (and thus are not being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">/// speculated), or we can harden the address used by the implicit load: the</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">/// speculated), or we can harden the address used by the implicit load: the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">/// stack pointer.</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">/// stack pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">/// If we are not using an LFENCE, hardening the stack pointer has an additional</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">/// If we are not using an LFENCE, hardening the stack pointer has an additional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">/// benefit: it allows us to pass the predicate state accumulated in this</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">/// benefit: it allows us to pass the predicate state accumulated in this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">/// function back to the caller. In the absence of a BCBS attack on the return,</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">/// function back to the caller. In the absence of a BCBS attack on the return,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">/// the caller will typically be resumed and speculatively executed due to the</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">/// the caller will typically be resumed and speculatively executed due to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">/// Return Stack Buffer (RSB) prediction which is very accurate and has a high</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">/// Return Stack Buffer (RSB) prediction which is very accurate and has a high</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">/// priority. It is possible that some code from the caller will be executed</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">/// priority. It is possible that some code from the caller will be executed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">/// speculatively even during a BCBS-attacked return until the steering takes</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">/// speculatively even during a BCBS-attacked return until the steering takes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">/// effect. Whenever this happens, the caller can recover the (poisoned)</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">/// effect. Whenever this happens, the caller can recover the (poisoned)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">/// predicate state from the stack pointer and continue to harden loads.</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">/// predicate state from the stack pointer and continue to harden loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::hardenReturnInstr(MachineInstr &MI) {</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::hardenReturnInstr(MachineInstr &MI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">  MachineBasicBlock &MBB = *MI.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">  const DebugLoc &Loc = MI.getDebugLoc();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">  auto InsertPt = MI.getIterator();</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">  auto InsertPt = MI.getIterator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline"></td>
    <td class="lineNumber">2015</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">  if (FenceCallAndRet)</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">  if (FenceCallAndRet)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">    // No need to fence here as we'll fence at the return site itself. That</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">    // No need to fence here as we'll fence at the return site itself. That</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">    // handles more cases than we can handle here.</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">    // handles more cases than we can handle here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline"></td>
    <td class="lineNumber">2020</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">  // Take our predicate state, shift it to the high 17 bits (so that we keep</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">  // Take our predicate state, shift it to the high 17 bits (so that we keep</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">  // pointers canonical) and merge it into RSP. This will allow the caller to</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">  // pointers canonical) and merge it into RSP. This will allow the caller to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">  // extract it when we return (speculatively).</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">  // extract it when we return (speculatively).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">  mergePredStateIntoSP(MBB, InsertPt, Loc, PS->SSA.GetValueAtEndOfBlock(&MBB));</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">  mergePredStateIntoSP(MBB, InsertPt, Loc, PS->SSA.GetValueAtEndOfBlock(&MBB));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline"></td>
    <td class="lineNumber">2026</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">/// Trace the predicate state through a call.</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">/// Trace the predicate state through a call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">/// There are several layers of this needed to handle the full complexity of</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">/// There are several layers of this needed to handle the full complexity of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">/// calls.</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">/// calls.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">/// First, we need to send the predicate state into the called function. We do</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">/// First, we need to send the predicate state into the called function. We do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">/// this by merging it into the high bits of the stack pointer.</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">/// this by merging it into the high bits of the stack pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">/// For tail calls, this is all we need to do.</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">/// For tail calls, this is all we need to do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">/// For calls where we might return and resume the control flow, we need to</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">/// For calls where we might return and resume the control flow, we need to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">/// extract the predicate state from the high bits of the stack pointer after</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">/// extract the predicate state from the high bits of the stack pointer after</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">/// control returns from the called function.</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">/// control returns from the called function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">/// We also need to verify that we intended to return to this location in the</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">/// We also need to verify that we intended to return to this location in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">/// code. An attacker might arrange for the processor to mispredict the return</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">/// code. An attacker might arrange for the processor to mispredict the return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">/// to this valid but incorrect return address in the program rather than the</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">/// to this valid but incorrect return address in the program rather than the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">/// correct one. See the paper on this attack, called "ret2spec" by the</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">/// correct one. See the paper on this attack, called "ret2spec" by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">/// researchers, here:</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">/// researchers, here:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">/// https://christian-rossow.de/publications/ret2spec-ccs2018.pdf</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">/// https://christian-rossow.de/publications/ret2spec-ccs2018.pdf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">/// The way we verify that we returned to the correct location is by preserving</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">/// The way we verify that we returned to the correct location is by preserving</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">/// the expected return address across the call. One technique involves taking</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">/// the expected return address across the call. One technique involves taking</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">/// advantage of the red-zone to load the return address from `8(%rsp)` where it</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">/// advantage of the red-zone to load the return address from `8(%rsp)` where it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">/// was left by the RET instruction when it popped `%rsp`. Alternatively, we can</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">/// was left by the RET instruction when it popped `%rsp`. Alternatively, we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">/// directly save the address into a register that will be preserved across the</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">/// directly save the address into a register that will be preserved across the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">/// call. We compare this intended return address against the address</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">/// call. We compare this intended return address against the address</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">/// immediately following the call (the observed return address). If these</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">/// immediately following the call (the observed return address). If these</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">/// mismatch, we have detected misspeculation and can poison our predicate</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">/// mismatch, we have detected misspeculation and can poison our predicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">/// state.</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">/// state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::tracePredStateThroughCall(</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::tracePredStateThroughCall(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">    MachineInstr &MI) {</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">    MachineInstr &MI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td class="lineNumber">2059</td>
    <td class="codeline">  MachineBasicBlock &MBB = *MI.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">  MachineFunction &MF = *MBB.getParent();</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">  MachineFunction &MF = *MBB.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">  auto InsertPt = MI.getIterator();</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">  auto InsertPt = MI.getIterator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">  const DebugLoc &Loc = MI.getDebugLoc();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline"></td>
    <td class="lineNumber">2063</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">  if (FenceCallAndRet) {</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">  if (FenceCallAndRet) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">    if (MI.isReturn())</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">    if (MI.isReturn())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">      // Tail call, we don't return to this function.</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">      // Tail call, we don't return to this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">      // FIXME: We should also handle noreturn calls.</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">      // FIXME: We should also handle noreturn calls.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline"></td>
    <td class="lineNumber">2069</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">    // We don't need to fence before the call because the function should fence</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">    // We don't need to fence before the call because the function should fence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">    // in its entry. However, we do need to fence after the call returns.</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">    // in its entry. However, we do need to fence after the call returns.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">    // Fencing before the return doesn't correctly handle cases where the return</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">    // Fencing before the return doesn't correctly handle cases where the return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">    // itself is mispredicted.</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">    // itself is mispredicted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">    BuildMI(MBB, std::next(InsertPt), Loc, TII->get(X86::LFENCE));</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">    BuildMI(MBB, std::next(InsertPt), Loc, TII->get(X86::LFENCE));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">    ++NumInstsInserted;</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">    ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">    ++NumLFENCEsInserted;</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">    ++NumLFENCEsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline"></td>
    <td class="lineNumber">2079</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">  // First, we transfer the predicate state into the called function by merging</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">  // First, we transfer the predicate state into the called function by merging</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">  // it into the stack pointer. This will kill the current def of the state.</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">  // it into the stack pointer. This will kill the current def of the state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">  mergePredStateIntoSP(MBB, InsertPt, Loc, StateReg);</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">  mergePredStateIntoSP(MBB, InsertPt, Loc, StateReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline"></td>
    <td class="lineNumber">2084</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">  // If this call is also a return, it is a tail call and we don't need anything</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">  // If this call is also a return, it is a tail call and we don't need anything</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">  // else to handle it so just return. Also, if there are no further</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">  // else to handle it so just return. Also, if there are no further</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">  // instructions and no successors, this call does not return so we can also</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">  // instructions and no successors, this call does not return so we can also</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">  // bail.</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">  // bail.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">  if (MI.isReturn() || (std::next(InsertPt) == MBB.end() && MBB.succ_empty()))</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">  if (MI.isReturn() || (std::next(InsertPt) == MBB.end() && MBB.succ_empty()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline"></td>
    <td class="lineNumber">2091</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">  // Create a symbol to track the return address and attach it to the call</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">  // Create a symbol to track the return address and attach it to the call</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">  // machine instruction. We will lower extra symbols attached to call</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">  // machine instruction. We will lower extra symbols attached to call</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">  // instructions as label immediately following the call.</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">  // instructions as label immediately following the call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">  MCSymbol *RetSymbol =</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">  MCSymbol *RetSymbol =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">      MF.getContext().createTempSymbol("slh_ret_addr",</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">      MF.getContext().createTempSymbol("slh_ret_addr",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">                                       /*AlwaysAddSuffix*/ true);</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">                                       /*AlwaysAddSuffix*/ true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">  MI.setPostInstrSymbol(MF, RetSymbol);</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">  MI.setPostInstrSymbol(MF, RetSymbol);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline"></td>
    <td class="lineNumber">2099</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">  const TargetRegisterClass *AddrRC = &X86::GR64RegClass;</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">  const TargetRegisterClass *AddrRC = &X86::GR64RegClass;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">  unsigned ExpectedRetAddrReg = 0;</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">  unsigned ExpectedRetAddrReg = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline"></td>
    <td class="lineNumber">2102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">  // If we have no red zones or if the function returns twice (possibly without</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">  // If we have no red zones or if the function returns twice (possibly without</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">  // using the `ret` instruction) like setjmp, we need to save the expected</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">  // using the `ret` instruction) like setjmp, we need to save the expected</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">  // return address prior to the call.</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">  // return address prior to the call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">  if (!Subtarget->getFrameLowering()->has128ByteRedZone(MF) ||</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">  if (!Subtarget->getFrameLowering()->has128ByteRedZone(MF) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">      MF.exposesReturnsTwice()) {</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">      MF.exposesReturnsTwice()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">    // If we don't have red zones, we need to compute the expected return</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">    // If we don't have red zones, we need to compute the expected return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">    // address prior to the call and store it in a register that lives across</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">    // address prior to the call and store it in a register that lives across</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">    // the call.</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">    // the call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">    // In some ways, this is doubly satisfying as a mitigation because it will</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">    // In some ways, this is doubly satisfying as a mitigation because it will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">    // also successfully detect stack smashing bugs in some cases (typically,</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">    // also successfully detect stack smashing bugs in some cases (typically,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">    // when a callee-saved register is used and the callee doesn't push it onto</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">    // when a callee-saved register is used and the callee doesn't push it onto</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">    // the stack). But that isn't our primary goal, so we only use it as</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">    // the stack). But that isn't our primary goal, so we only use it as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">    // a fallback.</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">    // a fallback.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">    // FIXME: It isn't clear that this is reliable in the face of</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">    // FIXME: It isn't clear that this is reliable in the face of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">    // rematerialization in the register allocator. We somehow need to force</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">    // rematerialization in the register allocator. We somehow need to force</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">    // that to not occur for this particular instruction, and instead to spill</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">    // that to not occur for this particular instruction, and instead to spill</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">    // or otherwise preserve the value computed *prior* to the call.</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">    // or otherwise preserve the value computed *prior* to the call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">    // FIXME: It is even less clear why MachineCSE can't just fold this when we</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">    // FIXME: It is even less clear why MachineCSE can't just fold this when we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">    // end up having to use identical instructions both before and after the</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">    // end up having to use identical instructions both before and after the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">    // call to feed the comparison.</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">    // call to feed the comparison.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">    ExpectedRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">    ExpectedRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">    if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">    if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">        !Subtarget->isPositionIndependent()) {</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">        !Subtarget->isPositionIndependent()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::MOV64ri32), ExpectedRetAddrReg)</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::MOV64ri32), ExpectedRetAddrReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">          .addSym(RetSymbol);</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">          .addSym(RetSymbol);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::LEA64r), ExpectedRetAddrReg)</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::LEA64r), ExpectedRetAddrReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">          .addReg(/*Base*/ X86::RIP)</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">          .addReg(/*Base*/ X86::RIP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">          .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">          .addImm(/*Scale*/ 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">          .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">          .addReg(/*Index*/ 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">          .addSym(RetSymbol)</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">          .addSym(RetSymbol)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">          .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">          .addReg(/*Segment*/ 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline"></td>
    <td class="lineNumber">2140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">  // Step past the call to handle when it returns.</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">  // Step past the call to handle when it returns.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">  ++InsertPt;</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">  ++InsertPt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline"></td>
    <td class="lineNumber">2143</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">  // If we didn't pre-compute the expected return address into a register, then</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">  // If we didn't pre-compute the expected return address into a register, then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">  // red zones are enabled and the return address is still available on the</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">  // red zones are enabled and the return address is still available on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">  // stack immediately after the call. As the very first instruction, we load it</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">  // stack immediately after the call. As the very first instruction, we load it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">  // into a register.</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">  // into a register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">  if (!ExpectedRetAddrReg) {</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">  if (!ExpectedRetAddrReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">    ExpectedRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">    ExpectedRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::MOV64rm), ExpectedRetAddrReg)</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::MOV64rm), ExpectedRetAddrReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">        .addReg(/*Base*/ X86::RSP)</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">        .addReg(/*Base*/ X86::RSP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">        .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">        .addImm(/*Scale*/ 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">        .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">        .addReg(/*Index*/ 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">        .addImm(/*Displacement*/ -8) // The stack pointer has been popped, so</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">        .addImm(/*Displacement*/ -8) // The stack pointer has been popped, so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">                                     // the return address is 8-bytes past it.</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">                                     // the return address is 8-bytes past it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">        .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">        .addReg(/*Segment*/ 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline"></td>
    <td class="lineNumber">2158</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">  // Now we extract the callee's predicate state from the stack pointer.</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">  // Now we extract the callee's predicate state from the stack pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">  unsigned NewStateReg = extractPredStateFromSP(MBB, InsertPt, Loc);</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">  unsigned NewStateReg = extractPredStateFromSP(MBB, InsertPt, Loc);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline"></td>
    <td class="lineNumber">2161</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">  // Test the expected return address against our actual address. If we can</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">  // Test the expected return address against our actual address. If we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">  // form this basic block's address as an immediate, this is easy. Otherwise</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">  // form this basic block's address as an immediate, this is easy. Otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">  // we compute it.</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">  // we compute it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">  if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">  if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">      !Subtarget->isPositionIndependent()) {</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">      !Subtarget->isPositionIndependent()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">    // FIXME: Could we fold this with the load? It would require careful EFLAGS</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">    // FIXME: Could we fold this with the load? It would require careful EFLAGS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">    // management.</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">    // management.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::CMP64ri32))</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::CMP64ri32))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">        .addReg(ExpectedRetAddrReg, RegState::Kill)</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">        .addReg(ExpectedRetAddrReg, RegState::Kill)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">        .addSym(RetSymbol);</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">        .addSym(RetSymbol);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">    Register ActualRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">    Register ActualRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::LEA64r), ActualRetAddrReg)</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::LEA64r), ActualRetAddrReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">        .addReg(/*Base*/ X86::RIP)</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">        .addReg(/*Base*/ X86::RIP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">        .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">        .addImm(/*Scale*/ 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">        .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">        .addReg(/*Index*/ 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">        .addSym(RetSymbol)</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">        .addSym(RetSymbol)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">        .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">        .addReg(/*Segment*/ 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::CMP64rr))</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::CMP64rr))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">        .addReg(ExpectedRetAddrReg, RegState::Kill)</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">        .addReg(ExpectedRetAddrReg, RegState::Kill)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">        .addReg(ActualRetAddrReg, RegState::Kill);</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">        .addReg(ActualRetAddrReg, RegState::Kill);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline"></td>
    <td class="lineNumber">2184</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">  // Now conditionally update the predicate state we just extracted if we ended</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">  // Now conditionally update the predicate state we just extracted if we ended</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">  // up at a different return address than expected.</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">  // up at a different return address than expected.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">  int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">  int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">  auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">  auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline"></td>
    <td class="lineNumber">2189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">  Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">  Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">  auto CMovI = BuildMI(MBB, InsertPt, Loc, TII->get(CMovOp), UpdatedStateReg)</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">  auto CMovI = BuildMI(MBB, InsertPt, Loc, TII->get(CMovOp), UpdatedStateReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">                   .addReg(NewStateReg, RegState::Kill)</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">                   .addReg(NewStateReg, RegState::Kill)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">                   .addReg(PS->PoisonReg)</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">                   .addReg(PS->PoisonReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">                   .addImm(X86::COND_NE);</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">                   .addImm(X86::COND_NE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">  CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">  CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">  ++NumInstsInserted;</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">  ++NumInstsInserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump(); dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline"></td>
    <td class="lineNumber">2198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">  PS->SSA.AddAvailableValue(&MBB, UpdatedStateReg);</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">  PS->SSA.AddAvailableValue(&MBB, UpdatedStateReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline"></td>
    <td class="lineNumber">2201</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">/// An attacker may speculatively store over a value that is then speculatively</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">/// An attacker may speculatively store over a value that is then speculatively</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">/// loaded and used as the target of an indirect call or jump instruction. This</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">/// loaded and used as the target of an indirect call or jump instruction. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">/// is called Spectre v1.2 or Bounds Check Bypass Store (BCBS) and is described</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">/// is called Spectre v1.2 or Bounds Check Bypass Store (BCBS) and is described</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">/// in this paper:</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">/// in this paper:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">/// https://people.csail.mit.edu/vlk/spectre11.pdf</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">/// https://people.csail.mit.edu/vlk/spectre11.pdf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">/// When this happens, the speculative execution of the call or jump will end up</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">/// When this happens, the speculative execution of the call or jump will end up</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">/// being steered to this attacker controlled address. While most such loads</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">/// being steered to this attacker controlled address. While most such loads</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">/// will be adequately hardened already, we want to ensure that they are</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">/// will be adequately hardened already, we want to ensure that they are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">/// definitively treated as needing post-load hardening. While address hardening</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">/// definitively treated as needing post-load hardening. While address hardening</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">/// is sufficient to prevent secret data from leaking to the attacker, it may</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">/// is sufficient to prevent secret data from leaking to the attacker, it may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">/// not be sufficient to prevent an attacker from steering speculative</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">/// not be sufficient to prevent an attacker from steering speculative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">/// execution. We forcibly unfolded all relevant loads above and so will always</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">/// execution. We forcibly unfolded all relevant loads above and so will always</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">/// have an opportunity to post-load harden here, we just need to scan for cases</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">/// have an opportunity to post-load harden here, we just need to scan for cases</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">/// not already flagged and add them.</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">/// not already flagged and add them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::hardenIndirectCallOrJumpInstr(</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">void X86SpeculativeLoadHardeningPass::hardenIndirectCallOrJumpInstr(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">    MachineInstr &MI,</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">    MachineInstr &MI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">    SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg) {</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">    SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">  switch (MI.getOpcode()) {</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">  switch (MI.getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">  case X86::FARCALL16m:</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">  case X86::FARCALL16m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">  case X86::FARCALL32m:</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">  case X86::FARCALL32m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">  case X86::FARCALL64m:</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">  case X86::FARCALL64m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">  case X86::FARJMP16m:</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">  case X86::FARJMP16m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline">  case X86::FARJMP32m:</td>
    <td class="lineNumber">2225</td>
    <td class="codeline">  case X86::FARJMP32m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">  case X86::FARJMP64m:</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">  case X86::FARJMP64m:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">    // We don't need to harden either far calls or far jumps as they are</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">    // We don't need to harden either far calls or far jumps as they are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">    // safe from Spectre.</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">    // safe from Spectre.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline"></td>
    <td class="lineNumber">2230</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline"></td>
    <td class="lineNumber">2234</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">  // We should never see a loading instruction at this point, as those should</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">  // We should never see a loading instruction at this point, as those should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">  // have been unfolded.</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">  // have been unfolded.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">  assert(!MI.mayLoad() && "Found a lingering loading instruction!");</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">  assert(!MI.mayLoad() && "Found a lingering loading instruction!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline"></td>
    <td class="lineNumber">2238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">  // If the first operand isn't a register, this is a branch or call</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">  // If the first operand isn't a register, this is a branch or call</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">  // instruction with an immediate operand which doesn't need to be hardened.</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">  // instruction with an immediate operand which doesn't need to be hardened.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">  if (!MI.getOperand(0).isReg())</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">  if (!MI.getOperand(0).isReg())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline"></td>
    <td class="lineNumber">2243</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">  // For all of these, the target register is the first operand of the</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">  // For all of these, the target register is the first operand of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">  // instruction.</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">  // instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">  auto &TargetOp = MI.getOperand(0);</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">  auto &TargetOp = MI.getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">  Register OldTargetReg = TargetOp.getReg();</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">  Register OldTargetReg = TargetOp.getReg();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline"></td>
    <td class="lineNumber">2248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">  // Try to lookup a hardened version of this register. We retain a reference</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">  // Try to lookup a hardened version of this register. We retain a reference</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">  // here as we want to update the map to track any newly computed hardened</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">  // here as we want to update the map to track any newly computed hardened</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">  // register.</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">  // register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">  unsigned &HardenedTargetReg = AddrRegToHardenedReg[OldTargetReg];</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">  unsigned &HardenedTargetReg = AddrRegToHardenedReg[OldTargetReg];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline"></td>
    <td class="lineNumber">2253</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">  // If we don't have a hardened register yet, compute one. Otherwise, just use</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">  // If we don't have a hardened register yet, compute one. Otherwise, just use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">  // the already hardened register.</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">  // the already hardened register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">  // FIXME: It is a little suspect that we use partially hardened registers that</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">  // FIXME: It is a little suspect that we use partially hardened registers that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">  // only feed addresses. The complexity of partial hardening with SHRX</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">  // only feed addresses. The complexity of partial hardening with SHRX</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">  // continues to pile up. Should definitively measure its value and consider</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">  // continues to pile up. Should definitively measure its value and consider</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">  // eliminating it.</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">  // eliminating it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">  if (!HardenedTargetReg)</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">  if (!HardenedTargetReg)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">    HardenedTargetReg = hardenValueInRegister(</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">    HardenedTargetReg = hardenValueInRegister(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">        OldTargetReg, *MI.getParent(), MI.getIterator(), MI.getDebugLoc());</td>
    <td class="lineNumber">2263</td>
    <td class="codeline">        OldTargetReg, *MI.getParent(), MI.getIterator(), MI.getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline"></td>
    <td class="lineNumber">2264</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">  // Set the target operand to the hardened register.</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">  // Set the target operand to the hardened register.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">  TargetOp.setReg(HardenedTargetReg);</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">  TargetOp.setReg(HardenedTargetReg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline"></td>
    <td class="lineNumber">2267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">  ++NumCallsOrJumpsHardened;</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">  ++NumCallsOrJumpsHardened;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline"></td>
    <td class="lineNumber">2270</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(X86SpeculativeLoadHardeningPass, PASS_KEY,</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(X86SpeculativeLoadHardeningPass, PASS_KEY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">                      "X86 speculative load hardener", false, false)</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">                      "X86 speculative load hardener", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">INITIALIZE_PASS_END(X86SpeculativeLoadHardeningPass, PASS_KEY,</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">INITIALIZE_PASS_END(X86SpeculativeLoadHardeningPass, PASS_KEY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">                    "X86 speculative load hardener", false, false)</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">                    "X86 speculative load hardener", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline"></td>
    <td class="lineNumber">2275</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">FunctionPass *llvm::createX86SpeculativeLoadHardeningPass() {</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">FunctionPass *llvm::createX86SpeculativeLoadHardeningPass() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">  return new X86SpeculativeLoadHardeningPass();</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">  return new X86SpeculativeLoadHardeningPass();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline"></td>
    <td class="lineNumber">2279</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//====- X86SpeculativeLoadHardening.cpp - A Spectre v1 mitigation ---------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//====- X86SpeculativeLoadHardening.cpp - A Spectre v1 mitigation ---------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">/// Provide a pass which mitigates speculative execution attacks which operate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">/// Provide a pass which mitigates speculative execution attacks which operate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">/// by speculating incorrectly past some predicate (a type check, bounds check,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">/// by speculating incorrectly past some predicate (a type check, bounds check,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">/// or other condition) to reach a load with invalid inputs and leak the data</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">/// or other condition) to reach a load with invalid inputs and leak the data</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">/// accessed by that load using a side channel out of the speculative domain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">/// accessed by that load using a side channel out of the speculative domain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">/// For details on the attacks, see the first variant in both the Project Zero</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">/// For details on the attacks, see the first variant in both the Project Zero</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">/// writeup and the Spectre paper:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">/// writeup and the Spectre paper:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">/// https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">/// https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">/// https://spectreattack.com/spectre.pdf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">/// https://spectreattack.com/spectre.pdf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "X86.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "X86.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "X86InstrBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "X86InstrBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "X86InstrInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "X86InstrInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "X86Subtarget.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "X86Subtarget.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/ADT/ScopeExit.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/ADT/ScopeExit.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/ADT/SparseBitVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/ADT/SparseBitVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineBasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineConstantPool.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineConstantPool.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunctionPass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstr.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineInstrBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineModuleInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineModuleInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineOperand.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineSSAUpdater.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineSSAUpdater.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetRegisterInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSchedule.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSchedule.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/IR/DebugLoc.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/IR/DebugLoc.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/MC/MCSchedule.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/MC/MCSchedule.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">#define PASS_KEY "x86-slh"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">#define PASS_KEY "x86-slh"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">#define DEBUG_TYPE PASS_KEY</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">#define DEBUG_TYPE PASS_KEY</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">STATISTIC(NumCondBranchesTraced, "Number of conditional branches traced");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">STATISTIC(NumCondBranchesTraced, "Number of conditional branches traced");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">STATISTIC(NumBranchesUntraced, "Number of branches unable to trace");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">STATISTIC(NumBranchesUntraced, "Number of branches unable to trace");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">STATISTIC(NumAddrRegsHardened,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">STATISTIC(NumAddrRegsHardened,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">          "Number of address mode used registers hardaned");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">          "Number of address mode used registers hardaned");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">STATISTIC(NumPostLoadRegsHardened,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">STATISTIC(NumPostLoadRegsHardened,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">          "Number of post-load register values hardened");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">          "Number of post-load register values hardened");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">STATISTIC(NumCallsOrJumpsHardened,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">STATISTIC(NumCallsOrJumpsHardened,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">          "Number of calls or jumps requiring extra hardening");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">          "Number of calls or jumps requiring extra hardening");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">STATISTIC(NumInstsInserted, "Number of instructions inserted");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">STATISTIC(NumInstsInserted, "Number of instructions inserted");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">STATISTIC(NumLFENCEsInserted, "Number of lfence instructions inserted");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">STATISTIC(NumLFENCEsInserted, "Number of lfence instructions inserted");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">static cl::opt<bool> EnableSpeculativeLoadHardening(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">static cl::opt<bool> EnableSpeculativeLoadHardening(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">    "x86-speculative-load-hardening",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">    "x86-speculative-load-hardening",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">    cl::desc("Force enable speculative load hardening"), cl::init(false),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">    cl::desc("Force enable speculative load hardening"), cl::init(false),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">    cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">    cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">static cl::opt<bool> HardenEdgesWithLFENCE(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">static cl::opt<bool> HardenEdgesWithLFENCE(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">    PASS_KEY "-lfence",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">    PASS_KEY "-lfence",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">    cl::desc(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">    cl::desc(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">        "Use LFENCE along each conditional edge to harden against speculative "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">        "Use LFENCE along each conditional edge to harden against speculative "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">        "loads rather than conditional movs and poisoned pointers."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">        "loads rather than conditional movs and poisoned pointers."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">    cl::init(false), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">    cl::init(false), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">static cl::opt<bool> EnablePostLoadHardening(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">static cl::opt<bool> EnablePostLoadHardening(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">    PASS_KEY "-post-load",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">    PASS_KEY "-post-load",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">    cl::desc("Harden the value loaded *after* it is loaded by "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">    cl::desc("Harden the value loaded *after* it is loaded by "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">             "flushing the loaded bits to 1. This is hard to do "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">             "flushing the loaded bits to 1. This is hard to do "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">             "in general but can be done easily for GPRs."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">             "in general but can be done easily for GPRs."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">    cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">    cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">static cl::opt<bool> FenceCallAndRet(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">static cl::opt<bool> FenceCallAndRet(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">    PASS_KEY "-fence-call-and-ret",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">    PASS_KEY "-fence-call-and-ret",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">    cl::desc("Use a full speculation fence to harden both call and ret edges "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">    cl::desc("Use a full speculation fence to harden both call and ret edges "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">             "rather than a lighter weight mitigation."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">             "rather than a lighter weight mitigation."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">    cl::init(false), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">    cl::init(false), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">static cl::opt<bool> HardenInterprocedurally(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">static cl::opt<bool> HardenInterprocedurally(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">    PASS_KEY "-ip",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">    PASS_KEY "-ip",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">    cl::desc("Harden interprocedurally by passing our state in and out of "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">    cl::desc("Harden interprocedurally by passing our state in and out of "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">             "functions in the high bits of the stack pointer."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">             "functions in the high bits of the stack pointer."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">    cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">    cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">    HardenLoads(PASS_KEY "-loads",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">    HardenLoads(PASS_KEY "-loads",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">                cl::desc("Sanitize loads from memory. When disable, no "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">                cl::desc("Sanitize loads from memory. When disable, no "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">                         "significant security is provided."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">                         "significant security is provided."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">                cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">                cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">static cl::opt<bool> HardenIndirectCallsAndJumps(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">static cl::opt<bool> HardenIndirectCallsAndJumps(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">    PASS_KEY "-indirect",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">    PASS_KEY "-indirect",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">    cl::desc("Harden indirect calls and jumps against using speculatively "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">    cl::desc("Harden indirect calls and jumps against using speculatively "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">             "stored attacker controlled addresses. This is designed to "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">             "stored attacker controlled addresses. This is designed to "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">             "mitigate Spectre v1.2 style attacks."),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">             "mitigate Spectre v1.2 style attacks."),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">    cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">    cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">class X86SpeculativeLoadHardeningPass : public MachineFunctionPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">class X86SpeculativeLoadHardeningPass : public MachineFunctionPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">  X86SpeculativeLoadHardeningPass() : MachineFunctionPass(ID) { }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">  X86SpeculativeLoadHardeningPass() : MachineFunctionPass(ID) { }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  StringRef getPassName() const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  StringRef getPassName() const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">    return "X86 speculative load hardening";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">    return "X86 speculative load hardening";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">  bool runOnMachineFunction(MachineFunction &MF) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">  bool runOnMachineFunction(MachineFunction &MF) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">  /// Pass identification, replacement for typeid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">  /// Pass identification, replacement for typeid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">  /// The information about a block's conditional terminators needed to trace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">  /// The information about a block's conditional terminators needed to trace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">  /// our predicate state through the exiting edges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">  /// our predicate state through the exiting edges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">  struct BlockCondInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">  struct BlockCondInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">    MachineBasicBlock *MBB;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">    MachineBasicBlock *MBB;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">    // We mostly have one conditional branch, and in extremely rare cases have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">    // We mostly have one conditional branch, and in extremely rare cases have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">    // two. Three and more are so rare as to be unimportant for compile time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">    // two. Three and more are so rare as to be unimportant for compile time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">    SmallVector<MachineInstr *, 2> CondBrs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">    SmallVector<MachineInstr *, 2> CondBrs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">    MachineInstr *UncondBr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">    MachineInstr *UncondBr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">  /// Manages the predicate state traced through the program.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">  /// Manages the predicate state traced through the program.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">  struct PredState {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">  struct PredState {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">    unsigned InitialReg = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">    unsigned InitialReg = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">    unsigned PoisonReg = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">    unsigned PoisonReg = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">    const TargetRegisterClass *RC;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">    const TargetRegisterClass *RC;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">    MachineSSAUpdater SSA;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">    MachineSSAUpdater SSA;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">    PredState(MachineFunction &MF, const TargetRegisterClass *RC)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">    PredState(MachineFunction &MF, const TargetRegisterClass *RC)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">        : RC(RC), SSA(MF) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">        : RC(RC), SSA(MF) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">  const X86Subtarget *Subtarget = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">  const X86Subtarget *Subtarget = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">  MachineRegisterInfo *MRI = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">  MachineRegisterInfo *MRI = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  const X86InstrInfo *TII = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  const X86InstrInfo *TII = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">  const TargetRegisterInfo *TRI = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">  const TargetRegisterInfo *TRI = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">  std::optional<PredState> PS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">  std::optional<PredState> PS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  void hardenEdgesWithLFENCE(MachineFunction &MF);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  void hardenEdgesWithLFENCE(MachineFunction &MF);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  SmallVector<BlockCondInfo, 16> collectBlockCondInfo(MachineFunction &MF);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  SmallVector<BlockCondInfo, 16> collectBlockCondInfo(MachineFunction &MF);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">  SmallVector<MachineInstr *, 16></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">  SmallVector<MachineInstr *, 16></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  tracePredStateThroughCFG(MachineFunction &MF, ArrayRef<BlockCondInfo> Infos);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  tracePredStateThroughCFG(MachineFunction &MF, ArrayRef<BlockCondInfo> Infos);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">  void unfoldCallAndJumpLoads(MachineFunction &MF);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">  void unfoldCallAndJumpLoads(MachineFunction &MF);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  SmallVector<MachineInstr *, 16></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  SmallVector<MachineInstr *, 16></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  tracePredStateThroughIndirectBranches(MachineFunction &MF);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  tracePredStateThroughIndirectBranches(MachineFunction &MF);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">  void tracePredStateThroughBlocksAndHarden(MachineFunction &MF);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">  void tracePredStateThroughBlocksAndHarden(MachineFunction &MF);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  unsigned saveEFLAGS(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  unsigned saveEFLAGS(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">                      MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">                      MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">                      const DebugLoc &Loc);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">                      const DebugLoc &Loc);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">  void restoreEFLAGS(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">  void restoreEFLAGS(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">                     MachineBasicBlock::iterator InsertPt, const DebugLoc &Loc,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">                     MachineBasicBlock::iterator InsertPt, const DebugLoc &Loc,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">                     Register Reg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">                     Register Reg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  void mergePredStateIntoSP(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  void mergePredStateIntoSP(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">                            MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">                            MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">                            const DebugLoc &Loc, unsigned PredStateReg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">                            const DebugLoc &Loc, unsigned PredStateReg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  unsigned extractPredStateFromSP(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  unsigned extractPredStateFromSP(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">                                  MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">                                  MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">                                  const DebugLoc &Loc);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">                                  const DebugLoc &Loc);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  void</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  void</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">  hardenLoadAddr(MachineInstr &MI, MachineOperand &BaseMO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">  hardenLoadAddr(MachineInstr &MI, MachineOperand &BaseMO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">                 MachineOperand &IndexMO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">                 MachineOperand &IndexMO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">                 SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">                 SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">  MachineInstr *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">  MachineInstr *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">  sinkPostLoadHardenedInst(MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">  sinkPostLoadHardenedInst(MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">                           SmallPtrSetImpl<MachineInstr *> &HardenedInstrs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">                           SmallPtrSetImpl<MachineInstr *> &HardenedInstrs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">  bool canHardenRegister(Register Reg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">  bool canHardenRegister(Register Reg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  unsigned hardenValueInRegister(Register Reg, MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  unsigned hardenValueInRegister(Register Reg, MachineBasicBlock &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">                                 MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">                                 MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">                                 const DebugLoc &Loc);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">                                 const DebugLoc &Loc);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  unsigned hardenPostLoad(MachineInstr &MI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  unsigned hardenPostLoad(MachineInstr &MI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">  void hardenReturnInstr(MachineInstr &MI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">  void hardenReturnInstr(MachineInstr &MI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">  void tracePredStateThroughCall(MachineInstr &MI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">  void tracePredStateThroughCall(MachineInstr &MI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  void hardenIndirectCallOrJumpInstr(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  void hardenIndirectCallOrJumpInstr(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">      MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">      MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">      SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">      SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">char X86SpeculativeLoadHardeningPass::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">char X86SpeculativeLoadHardeningPass::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::getAnalysisUsage(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::getAnalysisUsage(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">    AnalysisUsage &AU) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">    AnalysisUsage &AU) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">  MachineFunctionPass::getAnalysisUsage(AU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">  MachineFunctionPass::getAnalysisUsage(AU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">static MachineBasicBlock &splitEdge(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">static MachineBasicBlock &splitEdge(MachineBasicBlock &MBB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">                                    MachineBasicBlock &Succ, int SuccCount,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">                                    MachineBasicBlock &Succ, int SuccCount,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">                                    MachineInstr *Br, MachineInstr *&UncondBr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">                                    MachineInstr *Br, MachineInstr *&UncondBr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">                                    const X86InstrInfo &TII) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">                                    const X86InstrInfo &TII) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">  assert(!Succ.isEHPad() && "Shouldn't get edges to EH pads!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">  assert(!Succ.isEHPad() && "Shouldn't get edges to EH pads!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  MachineFunction &MF = *MBB.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  MachineFunction &MF = *MBB.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  MachineBasicBlock &NewMBB = *MF.CreateMachineBasicBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  MachineBasicBlock &NewMBB = *MF.CreateMachineBasicBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  // We have to insert the new block immediately after the current one as we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  // We have to insert the new block immediately after the current one as we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">  // don't know what layout-successor relationships the successor has and we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">  // don't know what layout-successor relationships the successor has and we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">  // may not be able to (and generally don't want to) try to fix those up.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">  // may not be able to (and generally don't want to) try to fix those up.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  MF.insert(std::next(MachineFunction::iterator(&MBB)), &NewMBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  MF.insert(std::next(MachineFunction::iterator(&MBB)), &NewMBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  // Update the branch instruction if necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  // Update the branch instruction if necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  if (Br) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  if (Br) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">    assert(Br->getOperand(0).getMBB() == &Succ &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">    assert(Br->getOperand(0).getMBB() == &Succ &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">           "Didn't start with the right target!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">           "Didn't start with the right target!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">    Br->getOperand(0).setMBB(&NewMBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">    Br->getOperand(0).setMBB(&NewMBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">    // If this successor was reached through a branch rather than fallthrough,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">    // If this successor was reached through a branch rather than fallthrough,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">    // we might have *broken* fallthrough and so need to inject a new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">    // we might have *broken* fallthrough and so need to inject a new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">    // unconditional branch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">    // unconditional branch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">    if (!UncondBr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">    if (!UncondBr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">      MachineBasicBlock &OldLayoutSucc =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">      MachineBasicBlock &OldLayoutSucc =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">          *std::next(MachineFunction::iterator(&NewMBB));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">          *std::next(MachineFunction::iterator(&NewMBB));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">      assert(MBB.isSuccessor(&OldLayoutSucc) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">      assert(MBB.isSuccessor(&OldLayoutSucc) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">             "Without an unconditional branch, the old layout successor should "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">             "Without an unconditional branch, the old layout successor should "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">             "be an actual successor!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">             "be an actual successor!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">      auto BrBuilder =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">      auto BrBuilder =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">          BuildMI(&MBB, DebugLoc(), TII.get(X86::JMP_1)).addMBB(&OldLayoutSucc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">          BuildMI(&MBB, DebugLoc(), TII.get(X86::JMP_1)).addMBB(&OldLayoutSucc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">      // Update the unconditional branch now that we've added one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">      // Update the unconditional branch now that we've added one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">      UncondBr = &*BrBuilder;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">      UncondBr = &*BrBuilder;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">    // Insert unconditional "jump Succ" instruction in the new block if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">    // Insert unconditional "jump Succ" instruction in the new block if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">    // necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">    // necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">    if (!NewMBB.isLayoutSuccessor(&Succ)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">    if (!NewMBB.isLayoutSuccessor(&Succ)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">      SmallVector<MachineOperand, 4> Cond;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">      SmallVector<MachineOperand, 4> Cond;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">      TII.insertBranch(NewMBB, &Succ, nullptr, Cond, Br->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">      TII.insertBranch(NewMBB, &Succ, nullptr, Cond, Br->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">    assert(!UncondBr &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">    assert(!UncondBr &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">           "Cannot have a branchless successor and an unconditional branch!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">           "Cannot have a branchless successor and an unconditional branch!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">    assert(NewMBB.isLayoutSuccessor(&Succ) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">    assert(NewMBB.isLayoutSuccessor(&Succ) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">           "A non-branch successor must have been a layout successor before "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">           "A non-branch successor must have been a layout successor before "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">           "and now is a layout successor of the new block.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">           "and now is a layout successor of the new block.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">  // If this is the only edge to the successor, we can just replace it in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  // If this is the only edge to the successor, we can just replace it in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  // CFG. Otherwise we need to add a new entry in the CFG for the new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  // CFG. Otherwise we need to add a new entry in the CFG for the new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">  // successor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">  // successor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">  if (SuccCount == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">  if (SuccCount == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">    MBB.replaceSuccessor(&Succ, &NewMBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">    MBB.replaceSuccessor(&Succ, &NewMBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">    MBB.splitSuccessor(&Succ, &NewMBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">    MBB.splitSuccessor(&Succ, &NewMBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  // Hook up the edge from the new basic block to the old successor in the CFG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  // Hook up the edge from the new basic block to the old successor in the CFG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  NewMBB.addSuccessor(&Succ);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  NewMBB.addSuccessor(&Succ);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  // Fix PHI nodes in Succ so they refer to NewMBB instead of MBB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  // Fix PHI nodes in Succ so they refer to NewMBB instead of MBB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  for (MachineInstr &MI : Succ) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  for (MachineInstr &MI : Succ) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">    if (!MI.isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">    if (!MI.isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">    for (int OpIdx = 1, NumOps = MI.getNumOperands(); OpIdx < NumOps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">    for (int OpIdx = 1, NumOps = MI.getNumOperands(); OpIdx < NumOps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">         OpIdx += 2) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">         OpIdx += 2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">      MachineOperand &OpV = MI.getOperand(OpIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">      MachineOperand &OpV = MI.getOperand(OpIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">      MachineOperand &OpMBB = MI.getOperand(OpIdx + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">      MachineOperand &OpMBB = MI.getOperand(OpIdx + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">      assert(OpMBB.isMBB() && "Block operand to a PHI is not a block!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">      assert(OpMBB.isMBB() && "Block operand to a PHI is not a block!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">      if (OpMBB.getMBB() != &MBB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">      if (OpMBB.getMBB() != &MBB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">      // If this is the last edge to the succesor, just replace MBB in the PHI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">      // If this is the last edge to the succesor, just replace MBB in the PHI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">      if (SuccCount == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">      if (SuccCount == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">        OpMBB.setMBB(&NewMBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">        OpMBB.setMBB(&NewMBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">      // Otherwise, append a new pair of operands for the new incoming edge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">      // Otherwise, append a new pair of operands for the new incoming edge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">      MI.addOperand(MF, OpV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">      MI.addOperand(MF, OpV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">      MI.addOperand(MF, MachineOperand::CreateMBB(&NewMBB));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">      MI.addOperand(MF, MachineOperand::CreateMBB(&NewMBB));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">  // Inherit live-ins from the successor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">  // Inherit live-ins from the successor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">  for (auto &LI : Succ.liveins())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">  for (auto &LI : Succ.liveins())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">    NewMBB.addLiveIn(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">    NewMBB.addLiveIn(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Split edge from '" << MBB.getName() << "' to '"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Split edge from '" << MBB.getName() << "' to '"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">                    << Succ.getName() << "'.\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">                    << Succ.getName() << "'.\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">  return NewMBB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">  return NewMBB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">/// Removing duplicate PHI operands to leave the PHI in a canonical and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">/// Removing duplicate PHI operands to leave the PHI in a canonical and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">/// predictable form.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">/// predictable form.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">/// FIXME: It's really frustrating that we have to do this, but SSA-form in MIR</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">/// FIXME: It's really frustrating that we have to do this, but SSA-form in MIR</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">/// isn't what you might expect. We may have multiple entries in PHI nodes for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">/// isn't what you might expect. We may have multiple entries in PHI nodes for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">/// a single predecessor. This makes CFG-updating extremely complex, so here we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">/// a single predecessor. This makes CFG-updating extremely complex, so here we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">/// simplify all PHI nodes to a model even simpler than the IR's model: exactly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">/// simplify all PHI nodes to a model even simpler than the IR's model: exactly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">/// one entry per predecessor, regardless of how many edges there are.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">/// one entry per predecessor, regardless of how many edges there are.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">static void canonicalizePHIOperands(MachineFunction &MF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">static void canonicalizePHIOperands(MachineFunction &MF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  SmallPtrSet<MachineBasicBlock *, 4> Preds;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  SmallPtrSet<MachineBasicBlock *, 4> Preds;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">  SmallVector<int, 4> DupIndices;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">  SmallVector<int, 4> DupIndices;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">  for (auto &MBB : MF)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">  for (auto &MBB : MF)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">    for (auto &MI : MBB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">    for (auto &MI : MBB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">      if (!MI.isPHI())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">      if (!MI.isPHI())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">      // First we scan the operands of the PHI looking for duplicate entries</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">      // First we scan the operands of the PHI looking for duplicate entries</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">      // a particular predecessor. We retain the operand index of each duplicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">      // a particular predecessor. We retain the operand index of each duplicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">      // entry found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">      // entry found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">      for (int OpIdx = 1, NumOps = MI.getNumOperands(); OpIdx < NumOps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">      for (int OpIdx = 1, NumOps = MI.getNumOperands(); OpIdx < NumOps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">           OpIdx += 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">           OpIdx += 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">        if (!Preds.insert(MI.getOperand(OpIdx + 1).getMBB()).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">        if (!Preds.insert(MI.getOperand(OpIdx + 1).getMBB()).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">          DupIndices.push_back(OpIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">          DupIndices.push_back(OpIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">      // Now walk the duplicate indices, removing both the block and value. Note</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">      // Now walk the duplicate indices, removing both the block and value. Note</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">      // that these are stored as a vector making this element-wise removal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">      // that these are stored as a vector making this element-wise removal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">      // :w</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">      // :w</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">      // potentially quadratic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">      // potentially quadratic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">      // FIXME: It is really frustrating that we have to use a quadratic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">      // FIXME: It is really frustrating that we have to use a quadratic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">      // removal algorithm here. There should be a better way, but the use-def</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">      // removal algorithm here. There should be a better way, but the use-def</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">      // updates required make that impossible using the public API.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">      // updates required make that impossible using the public API.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">      // Note that we have to process these backwards so that we don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">      // Note that we have to process these backwards so that we don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">      // invalidate other indices with each removal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">      // invalidate other indices with each removal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">      while (!DupIndices.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">      while (!DupIndices.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">        int OpIdx = DupIndices.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">        int OpIdx = DupIndices.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">        // Remove both the block and value operand, again in reverse order to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">        // Remove both the block and value operand, again in reverse order to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">        // preserve indices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">        // preserve indices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">        MI.removeOperand(OpIdx + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">        MI.removeOperand(OpIdx + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">        MI.removeOperand(OpIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">        MI.removeOperand(OpIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">      Preds.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">      Preds.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">/// Helper to scan a function for loads vulnerable to misspeculation that we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">/// Helper to scan a function for loads vulnerable to misspeculation that we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">/// want to harden.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">/// want to harden.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">/// We use this to avoid making changes to functions where there is nothing we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">/// We use this to avoid making changes to functions where there is nothing we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">/// need to do to harden against misspeculation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">/// need to do to harden against misspeculation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">static bool hasVulnerableLoad(MachineFunction &MF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">static bool hasVulnerableLoad(MachineFunction &MF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">    for (MachineInstr &MI : MBB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">    for (MachineInstr &MI : MBB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">      // Loads within this basic block after an LFENCE are not at risk of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">      // Loads within this basic block after an LFENCE are not at risk of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">      // speculatively executing with invalid predicates from prior control</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">      // speculatively executing with invalid predicates from prior control</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">      // flow. So break out of this block but continue scanning the function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">      // flow. So break out of this block but continue scanning the function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">      if (MI.getOpcode() == X86::LFENCE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">      if (MI.getOpcode() == X86::LFENCE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">      // Looking for loads only.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">      // Looking for loads only.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">      if (!MI.mayLoad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">      if (!MI.mayLoad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">      // An MFENCE is modeled as a load but isn't vulnerable to misspeculation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">      // An MFENCE is modeled as a load but isn't vulnerable to misspeculation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">      if (MI.getOpcode() == X86::MFENCE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">      if (MI.getOpcode() == X86::MFENCE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">      // We found a load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">      // We found a load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">  // No loads found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">  // No loads found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">bool X86SpeculativeLoadHardeningPass::runOnMachineFunction(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">bool X86SpeculativeLoadHardeningPass::runOnMachineFunction(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">    MachineFunction &MF) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">    MachineFunction &MF) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "********** " << getPassName() << " : " << MF.getName()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "********** " << getPassName() << " : " << MF.getName()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">                    << " **********\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">                    << " **********\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  // Only run if this pass is forced enabled or we detect the relevant function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  // Only run if this pass is forced enabled or we detect the relevant function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">  // attribute requesting SLH.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">  // attribute requesting SLH.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">  if (!EnableSpeculativeLoadHardening &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">  if (!EnableSpeculativeLoadHardening &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">      !MF.getFunction().hasFnAttribute(Attribute::SpeculativeLoadHardening))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">      !MF.getFunction().hasFnAttribute(Attribute::SpeculativeLoadHardening))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">  Subtarget = &MF.getSubtarget<X86Subtarget>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">  Subtarget = &MF.getSubtarget<X86Subtarget>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  MRI = &MF.getRegInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  MRI = &MF.getRegInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  TII = Subtarget->getInstrInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  TII = Subtarget->getInstrInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">  TRI = Subtarget->getRegisterInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">  TRI = Subtarget->getRegisterInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">  // FIXME: Support for 32-bit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">  // FIXME: Support for 32-bit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">  PS.emplace(MF, &X86::GR64_NOSPRegClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">  PS.emplace(MF, &X86::GR64_NOSPRegClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">  if (MF.begin() == MF.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">  if (MF.begin() == MF.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">    // Nothing to do for a degenerate empty function...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">    // Nothing to do for a degenerate empty function...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  // We support an alternative hardening technique based on a debug flag.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  // We support an alternative hardening technique based on a debug flag.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">  if (HardenEdgesWithLFENCE) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">  if (HardenEdgesWithLFENCE) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">    hardenEdgesWithLFENCE(MF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">    hardenEdgesWithLFENCE(MF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  // Create a dummy debug loc to use for all the generated code here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  // Create a dummy debug loc to use for all the generated code here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">  DebugLoc Loc;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">  DebugLoc Loc;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">  MachineBasicBlock &Entry = *MF.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">  MachineBasicBlock &Entry = *MF.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  auto EntryInsertPt = Entry.SkipPHIsLabelsAndDebug(Entry.begin());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  auto EntryInsertPt = Entry.SkipPHIsLabelsAndDebug(Entry.begin());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">  // Do a quick scan to see if we have any checkable loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">  // Do a quick scan to see if we have any checkable loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  bool HasVulnerableLoad = hasVulnerableLoad(MF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  bool HasVulnerableLoad = hasVulnerableLoad(MF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">  // See if we have any conditional branching blocks that we will need to trace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">  // See if we have any conditional branching blocks that we will need to trace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">  // predicate state through.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">  // predicate state through.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">  SmallVector<BlockCondInfo, 16> Infos = collectBlockCondInfo(MF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">  SmallVector<BlockCondInfo, 16> Infos = collectBlockCondInfo(MF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">  // If we have no interesting conditions or loads, nothing to do here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">  // If we have no interesting conditions or loads, nothing to do here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">  if (!HasVulnerableLoad && Infos.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">  if (!HasVulnerableLoad && Infos.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">  // The poison value is required to be an all-ones value for many aspects of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">  // The poison value is required to be an all-ones value for many aspects of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">  // this mitigation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">  // this mitigation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">  const int PoisonVal = -1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">  const int PoisonVal = -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">  PS->PoisonReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">  PS->PoisonReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">  BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::MOV64ri32), PS->PoisonReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">  BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::MOV64ri32), PS->PoisonReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">      .addImm(PoisonVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">      .addImm(PoisonVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  // If we have loads being hardened and we've asked for call and ret edges to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  // If we have loads being hardened and we've asked for call and ret edges to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">  // get a full fence-based mitigation, inject that fence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">  // get a full fence-based mitigation, inject that fence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  if (HasVulnerableLoad && FenceCallAndRet) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  if (HasVulnerableLoad && FenceCallAndRet) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">    // We need to insert an LFENCE at the start of the function to suspend any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">    // We need to insert an LFENCE at the start of the function to suspend any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">    // incoming misspeculation from the caller. This helps two-fold: the caller</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">    // incoming misspeculation from the caller. This helps two-fold: the caller</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">    // may not have been protected as this code has been, and this code gets to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">    // may not have been protected as this code has been, and this code gets to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">    // not take any specific action to protect across calls.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">    // not take any specific action to protect across calls.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">    // FIXME: We could skip this for functions which unconditionally return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">    // FIXME: We could skip this for functions which unconditionally return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">    // a constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">    // a constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">    BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::LFENCE));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">    BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::LFENCE));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">    ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">    ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">    ++NumLFENCEsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">    ++NumLFENCEsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  // If we guarded the entry with an LFENCE and have no conditionals to protect</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  // If we guarded the entry with an LFENCE and have no conditionals to protect</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">  // in blocks, then we're done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">  // in blocks, then we're done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">  if (FenceCallAndRet && Infos.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">  if (FenceCallAndRet && Infos.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">    // We may have changed the function's code at this point to insert fences.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">    // We may have changed the function's code at this point to insert fences.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  // For every basic block in the function which can b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  // For every basic block in the function which can b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  if (HardenInterprocedurally && !FenceCallAndRet) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  if (HardenInterprocedurally && !FenceCallAndRet) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">    // Set up the predicate state by extracting it from the incoming stack</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">    // Set up the predicate state by extracting it from the incoming stack</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">    // pointer so we pick up any misspeculation in our caller.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">    // pointer so we pick up any misspeculation in our caller.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">    PS->InitialReg = extractPredStateFromSP(Entry, EntryInsertPt, Loc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">    PS->InitialReg = extractPredStateFromSP(Entry, EntryInsertPt, Loc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">    // Otherwise, just build the predicate state itself by zeroing a register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">    // Otherwise, just build the predicate state itself by zeroing a register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">    // as we don't need any initial state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">    // as we don't need any initial state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">    PS->InitialReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">    PS->InitialReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">    Register PredStateSubReg = MRI->createVirtualRegister(&X86::GR32RegClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">    Register PredStateSubReg = MRI->createVirtualRegister(&X86::GR32RegClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">    auto ZeroI = BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::MOV32r0),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">    auto ZeroI = BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::MOV32r0),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">                         PredStateSubReg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">                         PredStateSubReg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">    ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">    ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">    MachineOperand *ZeroEFLAGSDefOp =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">    MachineOperand *ZeroEFLAGSDefOp =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">        ZeroI->findRegisterDefOperand(X86::EFLAGS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">        ZeroI->findRegisterDefOperand(X86::EFLAGS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">    assert(ZeroEFLAGSDefOp && ZeroEFLAGSDefOp->isImplicit() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">    assert(ZeroEFLAGSDefOp && ZeroEFLAGSDefOp->isImplicit() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">           "Must have an implicit def of EFLAGS!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">           "Must have an implicit def of EFLAGS!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">    ZeroEFLAGSDefOp->setIsDead(true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">    ZeroEFLAGSDefOp->setIsDead(true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">    BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::SUBREG_TO_REG),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">    BuildMI(Entry, EntryInsertPt, Loc, TII->get(X86::SUBREG_TO_REG),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">            PS->InitialReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">            PS->InitialReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">        .addImm(0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">        .addImm(0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">        .addReg(PredStateSubReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">        .addReg(PredStateSubReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">        .addImm(X86::sub_32bit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">        .addImm(X86::sub_32bit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">  // We're going to need to trace predicate state throughout the function's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">  // We're going to need to trace predicate state throughout the function's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">  // CFG. Prepare for this by setting up our initial state of PHIs with unique</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">  // CFG. Prepare for this by setting up our initial state of PHIs with unique</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">  // predecessor entries and all the initial predicate state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">  // predecessor entries and all the initial predicate state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">  canonicalizePHIOperands(MF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">  canonicalizePHIOperands(MF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">  // Track the updated values in an SSA updater to rewrite into SSA form at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">  // Track the updated values in an SSA updater to rewrite into SSA form at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">  // end.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">  // end.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">  PS->SSA.Initialize(PS->InitialReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">  PS->SSA.Initialize(PS->InitialReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">  PS->SSA.AddAvailableValue(&Entry, PS->InitialReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">  PS->SSA.AddAvailableValue(&Entry, PS->InitialReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">  // Trace through the CFG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">  // Trace through the CFG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  auto CMovs = tracePredStateThroughCFG(MF, Infos);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  auto CMovs = tracePredStateThroughCFG(MF, Infos);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">  // We may also enter basic blocks in this function via exception handling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">  // We may also enter basic blocks in this function via exception handling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  // control flow. Here, if we are hardening interprocedurally, we need to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  // control flow. Here, if we are hardening interprocedurally, we need to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">  // re-capture the predicate state from the throwing code. In the Itanium ABI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">  // re-capture the predicate state from the throwing code. In the Itanium ABI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">  // the throw will always look like a call to __cxa_throw and will have the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">  // the throw will always look like a call to __cxa_throw and will have the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">  // predicate state in the stack pointer, so extract fresh predicate state from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">  // predicate state in the stack pointer, so extract fresh predicate state from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">  // the stack pointer and make it available in SSA.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">  // the stack pointer and make it available in SSA.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">  // FIXME: Handle non-itanium ABI EH models.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">  // FIXME: Handle non-itanium ABI EH models.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">  if (HardenInterprocedurally) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">  if (HardenInterprocedurally) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">    for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">    for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">      assert(!MBB.isEHScopeEntry() && "Only Itanium ABI EH supported!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">      assert(!MBB.isEHScopeEntry() && "Only Itanium ABI EH supported!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">      assert(!MBB.isEHFuncletEntry() && "Only Itanium ABI EH supported!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">      assert(!MBB.isEHFuncletEntry() && "Only Itanium ABI EH supported!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">      assert(!MBB.isCleanupFuncletEntry() && "Only Itanium ABI EH supported!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">      assert(!MBB.isCleanupFuncletEntry() && "Only Itanium ABI EH supported!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">      if (!MBB.isEHPad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">      if (!MBB.isEHPad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">      PS->SSA.AddAvailableValue(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">      PS->SSA.AddAvailableValue(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">          &MBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">          &MBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">          extractPredStateFromSP(MBB, MBB.SkipPHIsAndLabels(MBB.begin()), Loc));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">          extractPredStateFromSP(MBB, MBB.SkipPHIsAndLabels(MBB.begin()), Loc));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">  if (HardenIndirectCallsAndJumps) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">  if (HardenIndirectCallsAndJumps) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">    // If we are going to harden calls and jumps we need to unfold their memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">    // If we are going to harden calls and jumps we need to unfold their memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">    // operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">    // operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">    unfoldCallAndJumpLoads(MF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">    unfoldCallAndJumpLoads(MF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">    // Then we trace predicate state through the indirect branches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">    // Then we trace predicate state through the indirect branches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">    auto IndirectBrCMovs = tracePredStateThroughIndirectBranches(MF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">    auto IndirectBrCMovs = tracePredStateThroughIndirectBranches(MF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">    CMovs.append(IndirectBrCMovs.begin(), IndirectBrCMovs.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">    CMovs.append(IndirectBrCMovs.begin(), IndirectBrCMovs.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  // Now that we have the predicate state available at the start of each block</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  // Now that we have the predicate state available at the start of each block</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">  // in the CFG, trace it through each block, hardening vulnerable instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">  // in the CFG, trace it through each block, hardening vulnerable instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">  // as we go.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">  // as we go.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">  tracePredStateThroughBlocksAndHarden(MF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">  tracePredStateThroughBlocksAndHarden(MF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">  // Now rewrite all the uses of the pred state using the SSA updater to insert</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">  // Now rewrite all the uses of the pred state using the SSA updater to insert</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  // PHIs connecting the state between blocks along the CFG edges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  // PHIs connecting the state between blocks along the CFG edges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  for (MachineInstr *CMovI : CMovs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  for (MachineInstr *CMovI : CMovs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">    for (MachineOperand &Op : CMovI->operands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">    for (MachineOperand &Op : CMovI->operands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">      if (!Op.isReg() || Op.getReg() != PS->InitialReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">      if (!Op.isReg() || Op.getReg() != PS->InitialReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">      PS->SSA.RewriteUse(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">      PS->SSA.RewriteUse(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Final speculative load hardened function:\n"; MF.dump();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Final speculative load hardened function:\n"; MF.dump();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">             dbgs() << "\n"; MF.verify(this));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">             dbgs() << "\n"; MF.verify(this));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">/// Implements the naive hardening approach of putting an LFENCE after every</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">/// Implements the naive hardening approach of putting an LFENCE after every</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">/// potentially mis-predicted control flow construct.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">/// potentially mis-predicted control flow construct.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">/// We include this as an alternative mostly for the purpose of comparison. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">/// We include this as an alternative mostly for the purpose of comparison. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">/// performance impact of this is expected to be extremely severe and not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">/// performance impact of this is expected to be extremely severe and not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">/// practical for any real-world users.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">/// practical for any real-world users.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::hardenEdgesWithLFENCE(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::hardenEdgesWithLFENCE(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">    MachineFunction &MF) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">    MachineFunction &MF) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">  // First, we scan the function looking for blocks that are reached along edges</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">  // First, we scan the function looking for blocks that are reached along edges</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">  // that we might want to harden.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">  // that we might want to harden.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">  SmallSetVector<MachineBasicBlock *, 8> Blocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">  SmallSetVector<MachineBasicBlock *, 8> Blocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">    // If there are no or only one successor, nothing to do here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">    // If there are no or only one successor, nothing to do here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">    if (MBB.succ_size() <= 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">    if (MBB.succ_size() <= 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">    // Skip blocks unless their terminators start with a branch. Other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">    // Skip blocks unless their terminators start with a branch. Other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">    // terminators don't seem interesting for guarding against misspeculation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">    // terminators don't seem interesting for guarding against misspeculation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">    auto TermIt = MBB.getFirstTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">    auto TermIt = MBB.getFirstTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">    if (TermIt == MBB.end() || !TermIt->isBranch())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">    if (TermIt == MBB.end() || !TermIt->isBranch())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">    // Add all the non-EH-pad succossors to the blocks we want to harden. We</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">    // Add all the non-EH-pad succossors to the blocks we want to harden. We</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">    // skip EH pads because there isn't really a condition of interest on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">    // skip EH pads because there isn't really a condition of interest on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">    // entering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">    // entering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">    for (MachineBasicBlock *SuccMBB : MBB.successors())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">    for (MachineBasicBlock *SuccMBB : MBB.successors())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">      if (!SuccMBB->isEHPad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">      if (!SuccMBB->isEHPad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">        Blocks.insert(SuccMBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">        Blocks.insert(SuccMBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">  for (MachineBasicBlock *MBB : Blocks) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">  for (MachineBasicBlock *MBB : Blocks) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">    auto InsertPt = MBB->SkipPHIsAndLabels(MBB->begin());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">    auto InsertPt = MBB->SkipPHIsAndLabels(MBB->begin());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    BuildMI(*MBB, InsertPt, DebugLoc(), TII->get(X86::LFENCE));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    BuildMI(*MBB, InsertPt, DebugLoc(), TII->get(X86::LFENCE));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">    ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">    ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">    ++NumLFENCEsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">    ++NumLFENCEsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">SmallVector<X86SpeculativeLoadHardeningPass::BlockCondInfo, 16></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">SmallVector<X86SpeculativeLoadHardeningPass::BlockCondInfo, 16></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">X86SpeculativeLoadHardeningPass::collectBlockCondInfo(MachineFunction &MF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">X86SpeculativeLoadHardeningPass::collectBlockCondInfo(MachineFunction &MF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">  SmallVector<BlockCondInfo, 16> Infos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">  SmallVector<BlockCondInfo, 16> Infos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">  // Walk the function and build up a summary for each block's conditions that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">  // Walk the function and build up a summary for each block's conditions that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  // we need to trace through.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  // we need to trace through.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">    // If there are no or only one successor, nothing to do here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">    // If there are no or only one successor, nothing to do here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">    if (MBB.succ_size() <= 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">    if (MBB.succ_size() <= 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">    // We want to reliably handle any conditional branch terminators in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">    // We want to reliably handle any conditional branch terminators in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">    // MBB, so we manually analyze the branch. We can handle all of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">    // MBB, so we manually analyze the branch. We can handle all of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">    // permutations here, including ones that analyze branch cannot.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">    // permutations here, including ones that analyze branch cannot.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">    // The approach is to walk backwards across the terminators, resetting at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">    // The approach is to walk backwards across the terminators, resetting at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">    // any unconditional non-indirect branch, and track all conditional edges</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">    // any unconditional non-indirect branch, and track all conditional edges</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">    // to basic blocks as well as the fallthrough or unconditional successor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">    // to basic blocks as well as the fallthrough or unconditional successor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">    // edge. For each conditional edge, we track the target and the opposite</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">    // edge. For each conditional edge, we track the target and the opposite</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">    // condition code in order to inject a "no-op" cmov into that successor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">    // condition code in order to inject a "no-op" cmov into that successor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">    // that will harden the predicate. For the fallthrough/unconditional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">    // that will harden the predicate. For the fallthrough/unconditional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">    // edge, we inject a separate cmov for each conditional branch with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">    // edge, we inject a separate cmov for each conditional branch with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">    // matching condition codes. This effectively implements an "and" of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">    // matching condition codes. This effectively implements an "and" of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">    // condition flags, even if there isn't a single condition flag that would</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">    // condition flags, even if there isn't a single condition flag that would</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">    // directly implement that. We don't bother trying to optimize either of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">    // directly implement that. We don't bother trying to optimize either of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">    // these cases because if such an optimization is possible, LLVM should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">    // these cases because if such an optimization is possible, LLVM should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">    // have optimized the conditional *branches* in that way already to reduce</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">    // have optimized the conditional *branches* in that way already to reduce</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">    // instruction count. This late, we simply assume the minimal number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">    // instruction count. This late, we simply assume the minimal number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">    // branch instructions is being emitted and use that to guide our cmov</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">    // branch instructions is being emitted and use that to guide our cmov</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">    // insertion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">    // insertion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">    BlockCondInfo Info = {&MBB, {}, nullptr};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">    BlockCondInfo Info = {&MBB, {}, nullptr};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">    // Now walk backwards through the terminators and build up successors they</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">    // Now walk backwards through the terminators and build up successors they</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">    // reach and the conditions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">    // reach and the conditions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">    for (MachineInstr &MI : llvm::reverse(MBB)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">    for (MachineInstr &MI : llvm::reverse(MBB)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">      // Once we've handled all the terminators, we're done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">      // Once we've handled all the terminators, we're done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">      if (!MI.isTerminator())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">      if (!MI.isTerminator())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">      // If we see a non-branch terminator, we can't handle anything so bail.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">      // If we see a non-branch terminator, we can't handle anything so bail.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">      if (!MI.isBranch()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">      if (!MI.isBranch()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">        Info.CondBrs.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">        Info.CondBrs.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">      // If we see an unconditional branch, reset our state, clear any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">      // If we see an unconditional branch, reset our state, clear any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">      // fallthrough, and set this is the "else" successor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">      // fallthrough, and set this is the "else" successor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">      if (MI.getOpcode() == X86::JMP_1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">      if (MI.getOpcode() == X86::JMP_1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">        Info.CondBrs.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">        Info.CondBrs.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">        Info.UncondBr = &MI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">        Info.UncondBr = &MI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">      // If we get an invalid condition, we have an indirect branch or some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">      // If we get an invalid condition, we have an indirect branch or some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">      // other unanalyzable "fallthrough" case. We model this as a nullptr for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">      // other unanalyzable "fallthrough" case. We model this as a nullptr for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">      // the destination so we can still guard any conditional successors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">      // the destination so we can still guard any conditional successors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">      // Consider code sequences like:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">      // Consider code sequences like:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">      // ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">      // ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">      //   jCC L1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">      //   jCC L1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">      //   jmpq *%rax</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">      //   jmpq *%rax</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">      // ```</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">      // ```</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">      // We still want to harden the edge to `L1`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">      // We still want to harden the edge to `L1`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">      if (X86::getCondFromBranch(MI) == X86::COND_INVALID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">      if (X86::getCondFromBranch(MI) == X86::COND_INVALID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">        Info.CondBrs.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">        Info.CondBrs.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">        Info.UncondBr = &MI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">        Info.UncondBr = &MI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">      // We have a vanilla conditional branch, add it to our list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">      // We have a vanilla conditional branch, add it to our list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">      Info.CondBrs.push_back(&MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">      Info.CondBrs.push_back(&MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">    if (Info.CondBrs.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">    if (Info.CondBrs.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">      ++NumBranchesUntraced;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">      ++NumBranchesUntraced;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "WARNING: unable to secure successors of block:\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "WARNING: unable to secure successors of block:\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">                 MBB.dump());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">                 MBB.dump());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">    Infos.push_back(Info);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">    Infos.push_back(Info);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">  return Infos;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">  return Infos;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">/// Trace the predicate state through the CFG, instrumenting each conditional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">/// Trace the predicate state through the CFG, instrumenting each conditional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">/// branch such that misspeculation through an edge will poison the predicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">/// branch such that misspeculation through an edge will poison the predicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">/// state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">/// state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">/// Returns the list of inserted CMov instructions so that they can have their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">/// Returns the list of inserted CMov instructions so that they can have their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">/// uses of the predicate state rewritten into proper SSA form once it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">/// uses of the predicate state rewritten into proper SSA form once it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">/// complete.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">/// complete.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">SmallVector<MachineInstr *, 16></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">SmallVector<MachineInstr *, 16></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">X86SpeculativeLoadHardeningPass::tracePredStateThroughCFG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">X86SpeculativeLoadHardeningPass::tracePredStateThroughCFG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">    MachineFunction &MF, ArrayRef<BlockCondInfo> Infos) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">    MachineFunction &MF, ArrayRef<BlockCondInfo> Infos) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  // Collect the inserted cmov instructions so we can rewrite their uses of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  // Collect the inserted cmov instructions so we can rewrite their uses of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">  // predicate state into SSA form.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">  // predicate state into SSA form.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">  SmallVector<MachineInstr *, 16> CMovs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">  SmallVector<MachineInstr *, 16> CMovs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  // Now walk all of the basic blocks looking for ones that end in conditional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  // Now walk all of the basic blocks looking for ones that end in conditional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  // jumps where we need to update this register along each edge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  // jumps where we need to update this register along each edge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  for (const BlockCondInfo &Info : Infos) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  for (const BlockCondInfo &Info : Infos) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">    MachineBasicBlock &MBB = *Info.MBB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">    MachineBasicBlock &MBB = *Info.MBB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">    const SmallVectorImpl<MachineInstr *> &CondBrs = Info.CondBrs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">    const SmallVectorImpl<MachineInstr *> &CondBrs = Info.CondBrs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">    MachineInstr *UncondBr = Info.UncondBr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">    MachineInstr *UncondBr = Info.UncondBr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Tracing predicate through block: " << MBB.getName()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Tracing predicate through block: " << MBB.getName()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">    ++NumCondBranchesTraced;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">    ++NumCondBranchesTraced;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">    // Compute the non-conditional successor as either the target of any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">    // Compute the non-conditional successor as either the target of any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">    // unconditional branch or the layout successor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">    // unconditional branch or the layout successor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">    MachineBasicBlock *UncondSucc =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">    MachineBasicBlock *UncondSucc =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">        UncondBr ? (UncondBr->getOpcode() == X86::JMP_1</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">        UncondBr ? (UncondBr->getOpcode() == X86::JMP_1</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">                        ? UncondBr->getOperand(0).getMBB()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">                        ? UncondBr->getOperand(0).getMBB()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">                        : nullptr)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">                        : nullptr)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">                 : &*std::next(MachineFunction::iterator(&MBB));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">                 : &*std::next(MachineFunction::iterator(&MBB));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">    // Count how many edges there are to any given successor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">    // Count how many edges there are to any given successor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">    SmallDenseMap<MachineBasicBlock *, int> SuccCounts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">    SmallDenseMap<MachineBasicBlock *, int> SuccCounts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">    if (UncondSucc)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">    if (UncondSucc)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">      ++SuccCounts[UncondSucc];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">      ++SuccCounts[UncondSucc];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">    for (auto *CondBr : CondBrs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">    for (auto *CondBr : CondBrs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">      ++SuccCounts[CondBr->getOperand(0).getMBB()];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">      ++SuccCounts[CondBr->getOperand(0).getMBB()];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">    // A lambda to insert cmov instructions into a block checking all of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">    // A lambda to insert cmov instructions into a block checking all of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">    // condition codes in a sequence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">    // condition codes in a sequence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">    auto BuildCheckingBlockForSuccAndConds =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">    auto BuildCheckingBlockForSuccAndConds =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">        [&](MachineBasicBlock &MBB, MachineBasicBlock &Succ, int SuccCount,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">        [&](MachineBasicBlock &MBB, MachineBasicBlock &Succ, int SuccCount,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">            MachineInstr *Br, MachineInstr *&UncondBr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">            MachineInstr *Br, MachineInstr *&UncondBr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">            ArrayRef<X86::CondCode> Conds) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">            ArrayRef<X86::CondCode> Conds) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">          // First, we split the edge to insert the checking block into a safe</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">          // First, we split the edge to insert the checking block into a safe</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">          // location.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">          // location.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">          auto &CheckingMBB =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">          auto &CheckingMBB =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">              (SuccCount == 1 && Succ.pred_size() == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">              (SuccCount == 1 && Succ.pred_size() == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">                  ? Succ</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">                  ? Succ</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">                  : splitEdge(MBB, Succ, SuccCount, Br, UncondBr, *TII);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">                  : splitEdge(MBB, Succ, SuccCount, Br, UncondBr, *TII);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">          bool LiveEFLAGS = Succ.isLiveIn(X86::EFLAGS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">          bool LiveEFLAGS = Succ.isLiveIn(X86::EFLAGS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">          if (!LiveEFLAGS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">          if (!LiveEFLAGS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">            CheckingMBB.addLiveIn(X86::EFLAGS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">            CheckingMBB.addLiveIn(X86::EFLAGS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">          // Now insert the cmovs to implement the checks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">          // Now insert the cmovs to implement the checks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">          auto InsertPt = CheckingMBB.begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">          auto InsertPt = CheckingMBB.begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">          assert((InsertPt == CheckingMBB.end() || !InsertPt->isPHI()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">          assert((InsertPt == CheckingMBB.end() || !InsertPt->isPHI()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">                 "Should never have a PHI in the initial checking block as it "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">                 "Should never have a PHI in the initial checking block as it "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">                 "always has a single predecessor!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">                 "always has a single predecessor!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">          // We will wire each cmov to each other, but need to start with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">          // We will wire each cmov to each other, but need to start with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">          // incoming pred state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">          // incoming pred state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">          unsigned CurStateReg = PS->InitialReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">          unsigned CurStateReg = PS->InitialReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">          for (X86::CondCode Cond : Conds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">          for (X86::CondCode Cond : Conds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">            int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">            int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">            auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">            auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">            Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">            Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">            // Note that we intentionally use an empty debug location so that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">            // Note that we intentionally use an empty debug location so that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">            // this picks up the preceding location.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">            // this picks up the preceding location.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">            auto CMovI = BuildMI(CheckingMBB, InsertPt, DebugLoc(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">            auto CMovI = BuildMI(CheckingMBB, InsertPt, DebugLoc(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">                                 TII->get(CMovOp), UpdatedStateReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">                                 TII->get(CMovOp), UpdatedStateReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">                             .addReg(CurStateReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">                             .addReg(CurStateReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">                             .addReg(PS->PoisonReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">                             .addReg(PS->PoisonReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">                             .addImm(Cond);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">                             .addImm(Cond);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">            // If this is the last cmov and the EFLAGS weren't originally</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">            // If this is the last cmov and the EFLAGS weren't originally</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">            // live-in, mark them as killed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">            // live-in, mark them as killed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">            if (!LiveEFLAGS && Cond == Conds.back())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">            if (!LiveEFLAGS && Cond == Conds.back())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">              CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">              CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">            ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">            ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">            LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">            LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">                       dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">                       dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">            // The first one of the cmovs will be using the top level</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">            // The first one of the cmovs will be using the top level</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">            // `PredStateReg` and need to get rewritten into SSA form.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">            // `PredStateReg` and need to get rewritten into SSA form.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">            if (CurStateReg == PS->InitialReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">            if (CurStateReg == PS->InitialReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">              CMovs.push_back(&*CMovI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">              CMovs.push_back(&*CMovI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">            // The next cmov should start from this one's def.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">            // The next cmov should start from this one's def.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">            CurStateReg = UpdatedStateReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">            CurStateReg = UpdatedStateReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">          // And put the last one into the available values for SSA form of our</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">          // And put the last one into the available values for SSA form of our</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">          // predicate state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">          // predicate state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">          PS->SSA.AddAvailableValue(&CheckingMBB, CurStateReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">          PS->SSA.AddAvailableValue(&CheckingMBB, CurStateReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">        };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">        };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">    std::vector<X86::CondCode> UncondCodeSeq;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">    std::vector<X86::CondCode> UncondCodeSeq;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">    for (auto *CondBr : CondBrs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">    for (auto *CondBr : CondBrs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">      MachineBasicBlock &Succ = *CondBr->getOperand(0).getMBB();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">      MachineBasicBlock &Succ = *CondBr->getOperand(0).getMBB();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">      int &SuccCount = SuccCounts[&Succ];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">      int &SuccCount = SuccCounts[&Succ];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">      X86::CondCode Cond = X86::getCondFromBranch(*CondBr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">      X86::CondCode Cond = X86::getCondFromBranch(*CondBr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">      X86::CondCode InvCond = X86::GetOppositeBranchCondition(Cond);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">      X86::CondCode InvCond = X86::GetOppositeBranchCondition(Cond);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">      UncondCodeSeq.push_back(Cond);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">      UncondCodeSeq.push_back(Cond);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">      BuildCheckingBlockForSuccAndConds(MBB, Succ, SuccCount, CondBr, UncondBr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">      BuildCheckingBlockForSuccAndConds(MBB, Succ, SuccCount, CondBr, UncondBr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">                                        {InvCond});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">                                        {InvCond});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">      // Decrement the successor count now that we've split one of the edges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">      // Decrement the successor count now that we've split one of the edges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">      // We need to keep the count of edges to the successor accurate in order</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">      // We need to keep the count of edges to the successor accurate in order</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">      // to know above when to *replace* the successor in the CFG vs. just</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">      // to know above when to *replace* the successor in the CFG vs. just</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">      // adding the new successor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">      // adding the new successor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">      --SuccCount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">      --SuccCount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">    // Since we may have split edges and changed the number of successors,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">    // Since we may have split edges and changed the number of successors,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">    // normalize the probabilities. This avoids doing it each time we split an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">    // normalize the probabilities. This avoids doing it each time we split an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">    // edge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">    // edge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">    MBB.normalizeSuccProbs();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">    MBB.normalizeSuccProbs();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">    // Finally, we need to insert cmovs into the "fallthrough" edge. Here, we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">    // Finally, we need to insert cmovs into the "fallthrough" edge. Here, we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">    // need to intersect the other condition codes. We can do this by just</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">    // need to intersect the other condition codes. We can do this by just</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">    // doing a cmov for each one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">    // doing a cmov for each one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">    if (!UncondSucc)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">    if (!UncondSucc)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">      // If we have no fallthrough to protect (perhaps it is an indirect jump?)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">      // If we have no fallthrough to protect (perhaps it is an indirect jump?)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">      // just skip this and continue.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">      // just skip this and continue.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">    assert(SuccCounts[UncondSucc] == 1 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">    assert(SuccCounts[UncondSucc] == 1 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">           "We should never have more than one edge to the unconditional "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">           "We should never have more than one edge to the unconditional "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">           "successor at this point because every other edge must have been "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">           "successor at this point because every other edge must have been "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">           "split above!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">           "split above!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">    // Sort and unique the codes to minimize them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">    // Sort and unique the codes to minimize them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">    llvm::sort(UncondCodeSeq);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">    llvm::sort(UncondCodeSeq);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">    UncondCodeSeq.erase(std::unique(UncondCodeSeq.begin(), UncondCodeSeq.end()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">    UncondCodeSeq.erase(std::unique(UncondCodeSeq.begin(), UncondCodeSeq.end()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">                        UncondCodeSeq.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">                        UncondCodeSeq.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">    // Build a checking version of the successor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">    // Build a checking version of the successor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">    BuildCheckingBlockForSuccAndConds(MBB, *UncondSucc, /*SuccCount*/ 1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">    BuildCheckingBlockForSuccAndConds(MBB, *UncondSucc, /*SuccCount*/ 1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">                                      UncondBr, UncondBr, UncondCodeSeq);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">                                      UncondBr, UncondBr, UncondCodeSeq);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">  return CMovs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">  return CMovs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">/// Compute the register class for the unfolded load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">/// Compute the register class for the unfolded load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">/// FIXME: This should probably live in X86InstrInfo, potentially by adding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">/// FIXME: This should probably live in X86InstrInfo, potentially by adding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">/// a way to unfold into a newly created vreg rather than requiring a register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">/// a way to unfold into a newly created vreg rather than requiring a register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">/// input.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">/// input.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">static const TargetRegisterClass *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">static const TargetRegisterClass *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">getRegClassForUnfoldedLoad(MachineFunction &MF, const X86InstrInfo &TII,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">getRegClassForUnfoldedLoad(MachineFunction &MF, const X86InstrInfo &TII,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">                           unsigned Opcode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">                           unsigned Opcode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">  unsigned Index;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">  unsigned Index;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">  unsigned UnfoldedOpc = TII.getOpcodeAfterMemoryUnfold(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">  unsigned UnfoldedOpc = TII.getOpcodeAfterMemoryUnfold(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">      Opcode, /*UnfoldLoad*/ true, /*UnfoldStore*/ false, &Index);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">      Opcode, /*UnfoldLoad*/ true, /*UnfoldStore*/ false, &Index);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  const MCInstrDesc &MCID = TII.get(UnfoldedOpc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  const MCInstrDesc &MCID = TII.get(UnfoldedOpc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  return TII.getRegClass(MCID, Index, &TII.getRegisterInfo(), MF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  return TII.getRegClass(MCID, Index, &TII.getRegisterInfo(), MF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::unfoldCallAndJumpLoads(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::unfoldCallAndJumpLoads(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">    MachineFunction &MF) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">    MachineFunction &MF) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">    // We use make_early_inc_range here so we can remove instructions if needed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">    // We use make_early_inc_range here so we can remove instructions if needed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">    // without disturbing the iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">    // without disturbing the iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">    for (MachineInstr &MI : llvm::make_early_inc_range(MBB.instrs())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">    for (MachineInstr &MI : llvm::make_early_inc_range(MBB.instrs())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">      // Must either be a call or a branch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">      // Must either be a call or a branch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">      if (!MI.isCall() && !MI.isBranch())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">      if (!MI.isCall() && !MI.isBranch())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">      // We only care about loading variants of these instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">      // We only care about loading variants of these instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">      if (!MI.mayLoad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">      if (!MI.mayLoad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">      switch (MI.getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">      switch (MI.getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">      default: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">      default: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">        LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">            dbgs() << "ERROR: Found an unexpected loading branch or call "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">            dbgs() << "ERROR: Found an unexpected loading branch or call "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">                      "instruction:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">                      "instruction:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">            MI.dump(); dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">            MI.dump(); dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">        report_fatal_error("Unexpected loading branch or call!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">        report_fatal_error("Unexpected loading branch or call!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">      case X86::FARCALL16m:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">      case X86::FARCALL16m:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">      case X86::FARCALL32m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">      case X86::FARCALL32m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">      case X86::FARCALL64m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">      case X86::FARCALL64m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">      case X86::FARJMP16m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">      case X86::FARJMP16m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">      case X86::FARJMP32m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">      case X86::FARJMP32m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">      case X86::FARJMP64m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">      case X86::FARJMP64m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">        // We cannot mitigate far jumps or calls, but we also don't expect them</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">        // We cannot mitigate far jumps or calls, but we also don't expect them</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">        // to be vulnerable to Spectre v1.2 style attacks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">        // to be vulnerable to Spectre v1.2 style attacks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">      case X86::CALL16m:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">      case X86::CALL16m:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">      case X86::CALL16m_NT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">      case X86::CALL16m_NT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">      case X86::CALL32m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">      case X86::CALL32m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">      case X86::CALL32m_NT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">      case X86::CALL32m_NT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">      case X86::CALL64m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">      case X86::CALL64m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">      case X86::CALL64m_NT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">      case X86::CALL64m_NT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">      case X86::JMP16m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">      case X86::JMP16m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">      case X86::JMP16m_NT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">      case X86::JMP16m_NT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">      case X86::JMP32m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">      case X86::JMP32m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">      case X86::JMP32m_NT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">      case X86::JMP32m_NT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">      case X86::JMP64m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">      case X86::JMP64m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">      case X86::JMP64m_NT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">      case X86::JMP64m_NT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">      case X86::TAILJMPm64:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">      case X86::TAILJMPm64:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">      case X86::TAILJMPm64_REX:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">      case X86::TAILJMPm64_REX:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">      case X86::TAILJMPm:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">      case X86::TAILJMPm:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">      case X86::TCRETURNmi64:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">      case X86::TCRETURNmi64:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">      case X86::TCRETURNmi: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">      case X86::TCRETURNmi: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">        // Use the generic unfold logic now that we know we're dealing with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">        // Use the generic unfold logic now that we know we're dealing with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">        // expected instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">        // expected instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">        // FIXME: We don't have test coverage for all of these!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">        // FIXME: We don't have test coverage for all of these!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">        auto *UnfoldedRC = getRegClassForUnfoldedLoad(MF, *TII, MI.getOpcode());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">        auto *UnfoldedRC = getRegClassForUnfoldedLoad(MF, *TII, MI.getOpcode());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">        if (!UnfoldedRC) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">        if (!UnfoldedRC) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">                         << "ERROR: Unable to unfold load from instruction:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">                         << "ERROR: Unable to unfold load from instruction:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">                     MI.dump(); dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">                     MI.dump(); dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">          report_fatal_error("Unable to unfold load!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">          report_fatal_error("Unable to unfold load!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">        Register Reg = MRI->createVirtualRegister(UnfoldedRC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">        Register Reg = MRI->createVirtualRegister(UnfoldedRC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">        SmallVector<MachineInstr *, 2> NewMIs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">        SmallVector<MachineInstr *, 2> NewMIs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">        // If we were able to compute an unfolded reg class, any failure here</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">        // If we were able to compute an unfolded reg class, any failure here</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">        // is just a programming error so just assert.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">        // is just a programming error so just assert.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">        bool Unfolded =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">        bool Unfolded =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">            TII->unfoldMemoryOperand(MF, MI, Reg, /*UnfoldLoad*/ true,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">            TII->unfoldMemoryOperand(MF, MI, Reg, /*UnfoldLoad*/ true,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">                                     /*UnfoldStore*/ false, NewMIs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">                                     /*UnfoldStore*/ false, NewMIs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">        (void)Unfolded;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">        (void)Unfolded;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">        assert(Unfolded &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">        assert(Unfolded &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">               "Computed unfolded register class but failed to unfold");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">               "Computed unfolded register class but failed to unfold");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">        // Now stitch the new instructions into place and erase the old one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">        // Now stitch the new instructions into place and erase the old one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">        for (auto *NewMI : NewMIs)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">        for (auto *NewMI : NewMIs)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">          MBB.insert(MI.getIterator(), NewMI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">          MBB.insert(MI.getIterator(), NewMI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">        // Update the call site info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">        // Update the call site info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">        if (MI.isCandidateForCallSiteEntry())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">        if (MI.isCandidateForCallSiteEntry())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">          MF.eraseCallSiteInfo(&MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">          MF.eraseCallSiteInfo(&MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">        MI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">        MI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">        LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">        LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">          dbgs() << "Unfolded load successfully into:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">          dbgs() << "Unfolded load successfully into:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">          for (auto *NewMI : NewMIs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">          for (auto *NewMI : NewMIs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">            NewMI->dump();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">            NewMI->dump();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">            dbgs() << "\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">            dbgs() << "\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">      llvm_unreachable("Escaped switch with default!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">      llvm_unreachable("Escaped switch with default!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">/// Trace the predicate state through indirect branches, instrumenting them to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">/// Trace the predicate state through indirect branches, instrumenting them to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">/// poison the state if a target is reached that does not match the expected</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">/// poison the state if a target is reached that does not match the expected</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">/// target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">/// target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">/// This is designed to mitigate Spectre variant 1 attacks where an indirect</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">/// This is designed to mitigate Spectre variant 1 attacks where an indirect</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">/// branch is trained to predict a particular target and then mispredicts that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">/// branch is trained to predict a particular target and then mispredicts that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">/// target in a way that can leak data. Despite using an indirect branch, this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">/// target in a way that can leak data. Despite using an indirect branch, this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">/// is really a variant 1 style attack: it does not steer execution to an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">/// is really a variant 1 style attack: it does not steer execution to an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">/// arbitrary or attacker controlled address, and it does not require any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">/// arbitrary or attacker controlled address, and it does not require any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">/// special code executing next to the victim. This attack can also be mitigated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">/// special code executing next to the victim. This attack can also be mitigated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">/// through retpolines, but those require either replacing indirect branches</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">/// through retpolines, but those require either replacing indirect branches</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">/// with conditional direct branches or lowering them through a device that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">/// with conditional direct branches or lowering them through a device that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">/// blocks speculation. This mitigation can replace these retpoline-style</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">/// blocks speculation. This mitigation can replace these retpoline-style</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">/// mitigations for jump tables and other indirect branches within a function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">/// mitigations for jump tables and other indirect branches within a function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">/// when variant 2 isn't a risk while allowing limited speculation. Indirect</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">/// when variant 2 isn't a risk while allowing limited speculation. Indirect</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">/// calls, however, cannot be mitigated through this technique without changing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">/// calls, however, cannot be mitigated through this technique without changing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">/// the ABI in a fundamental way.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">/// the ABI in a fundamental way.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">SmallVector<MachineInstr *, 16></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">SmallVector<MachineInstr *, 16></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">X86SpeculativeLoadHardeningPass::tracePredStateThroughIndirectBranches(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">X86SpeculativeLoadHardeningPass::tracePredStateThroughIndirectBranches(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">    MachineFunction &MF) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">    MachineFunction &MF) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">  // We use the SSAUpdater to insert PHI nodes for the target addresses of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">  // We use the SSAUpdater to insert PHI nodes for the target addresses of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">  // indirect branches. We don't actually need the full power of the SSA updater</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">  // indirect branches. We don't actually need the full power of the SSA updater</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">  // in this particular case as we always have immediately available values, but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">  // in this particular case as we always have immediately available values, but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  // this avoids us having to re-implement the PHI construction logic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  // this avoids us having to re-implement the PHI construction logic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">  MachineSSAUpdater TargetAddrSSA(MF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">  MachineSSAUpdater TargetAddrSSA(MF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">  TargetAddrSSA.Initialize(MRI->createVirtualRegister(&X86::GR64RegClass));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">  TargetAddrSSA.Initialize(MRI->createVirtualRegister(&X86::GR64RegClass));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">  // Track which blocks were terminated with an indirect branch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">  // Track which blocks were terminated with an indirect branch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">  SmallPtrSet<MachineBasicBlock *, 4> IndirectTerminatedMBBs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">  SmallPtrSet<MachineBasicBlock *, 4> IndirectTerminatedMBBs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">  // We need to know what blocks end up reached via indirect branches. We</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">  // We need to know what blocks end up reached via indirect branches. We</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">  // expect this to be a subset of those whose address is taken and so track it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">  // expect this to be a subset of those whose address is taken and so track it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">  // directly via the CFG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">  // directly via the CFG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">  SmallPtrSet<MachineBasicBlock *, 4> IndirectTargetMBBs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">  SmallPtrSet<MachineBasicBlock *, 4> IndirectTargetMBBs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">  // Walk all the blocks which end in an indirect branch and make the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">  // Walk all the blocks which end in an indirect branch and make the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">  // target address available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">  // target address available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">    // Find the last terminator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">    // Find the last terminator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">    auto MII = MBB.instr_rbegin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">    auto MII = MBB.instr_rbegin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">    while (MII != MBB.instr_rend() && MII->isDebugInstr())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">    while (MII != MBB.instr_rend() && MII->isDebugInstr())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">      ++MII;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">      ++MII;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">    if (MII == MBB.instr_rend())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">    if (MII == MBB.instr_rend())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">    MachineInstr &TI = *MII;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">    MachineInstr &TI = *MII;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">    if (!TI.isTerminator() || !TI.isBranch())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">    if (!TI.isTerminator() || !TI.isBranch())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">      // No terminator or non-branch terminator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">      // No terminator or non-branch terminator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">    unsigned TargetReg;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">    unsigned TargetReg;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">    switch (TI.getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">    switch (TI.getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">      // Direct branch or conditional branch (leading to fallthrough).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">      // Direct branch or conditional branch (leading to fallthrough).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">    case X86::FARJMP16m:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">    case X86::FARJMP16m:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">    case X86::FARJMP32m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">    case X86::FARJMP32m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">    case X86::FARJMP64m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">    case X86::FARJMP64m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">      // We cannot mitigate far jumps or calls, but we also don't expect them</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">      // We cannot mitigate far jumps or calls, but we also don't expect them</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">      // to be vulnerable to Spectre v1.2 or v2 (self trained) style attacks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">      // to be vulnerable to Spectre v1.2 or v2 (self trained) style attacks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">    case X86::JMP16m:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">    case X86::JMP16m:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">    case X86::JMP16m_NT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">    case X86::JMP16m_NT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">    case X86::JMP32m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">    case X86::JMP32m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">    case X86::JMP32m_NT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">    case X86::JMP32m_NT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">    case X86::JMP64m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">    case X86::JMP64m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">    case X86::JMP64m_NT:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">    case X86::JMP64m_NT:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">      // Mostly as documentation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">      // Mostly as documentation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">      report_fatal_error("Memory operand jumps should have been unfolded!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">      report_fatal_error("Memory operand jumps should have been unfolded!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">    case X86::JMP16r:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">    case X86::JMP16r:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">      report_fatal_error(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">      report_fatal_error(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">          "Support for 16-bit indirect branches is not implemented.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">          "Support for 16-bit indirect branches is not implemented.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">    case X86::JMP32r:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">    case X86::JMP32r:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">      report_fatal_error(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">      report_fatal_error(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">          "Support for 32-bit indirect branches is not implemented.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">          "Support for 32-bit indirect branches is not implemented.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">    case X86::JMP64r:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">    case X86::JMP64r:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">      TargetReg = TI.getOperand(0).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">      TargetReg = TI.getOperand(0).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">    // We have definitely found an indirect  branch. Verify that there are no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">    // We have definitely found an indirect  branch. Verify that there are no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">    // preceding conditional branches as we don't yet support that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">    // preceding conditional branches as we don't yet support that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">    if (llvm::any_of(MBB.terminators(), [&](MachineInstr &OtherTI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">    if (llvm::any_of(MBB.terminators(), [&](MachineInstr &OtherTI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">          return !OtherTI.isDebugInstr() && &OtherTI != &TI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">          return !OtherTI.isDebugInstr() && &OtherTI != &TI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">        })) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">        })) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">      LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">        dbgs() << "ERROR: Found other terminators in a block with an indirect "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">        dbgs() << "ERROR: Found other terminators in a block with an indirect "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">                  "branch! This is not yet supported! Terminator sequence:\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">                  "branch! This is not yet supported! Terminator sequence:\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">        for (MachineInstr &MI : MBB.terminators()) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">        for (MachineInstr &MI : MBB.terminators()) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">          MI.dump();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">          MI.dump();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">          dbgs() << '\n';</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">          dbgs() << '\n';</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">      });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">      report_fatal_error("Unimplemented terminator sequence!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">      report_fatal_error("Unimplemented terminator sequence!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">    // Make the target register an available value for this block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">    // Make the target register an available value for this block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">    TargetAddrSSA.AddAvailableValue(&MBB, TargetReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">    TargetAddrSSA.AddAvailableValue(&MBB, TargetReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">    IndirectTerminatedMBBs.insert(&MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">    IndirectTerminatedMBBs.insert(&MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">    // Add all the successors to our target candidates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">    // Add all the successors to our target candidates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">    for (MachineBasicBlock *Succ : MBB.successors())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">    for (MachineBasicBlock *Succ : MBB.successors())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">      IndirectTargetMBBs.insert(Succ);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">      IndirectTargetMBBs.insert(Succ);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">  // Keep track of the cmov instructions we insert so we can return them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">  // Keep track of the cmov instructions we insert so we can return them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">  SmallVector<MachineInstr *, 16> CMovs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">  SmallVector<MachineInstr *, 16> CMovs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">  // If we didn't find any indirect branches with targets, nothing to do here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">  // If we didn't find any indirect branches with targets, nothing to do here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  if (IndirectTargetMBBs.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  if (IndirectTargetMBBs.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">    return CMovs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">    return CMovs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">  // We found indirect branches and targets that need to be instrumented to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">  // We found indirect branches and targets that need to be instrumented to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  // harden loads within them. Walk the blocks of the function (to get a stable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  // harden loads within them. Walk the blocks of the function (to get a stable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  // ordering) and instrument each target of an indirect branch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  // ordering) and instrument each target of an indirect branch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">    // Skip the blocks that aren't candidate targets.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">    // Skip the blocks that aren't candidate targets.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">    if (!IndirectTargetMBBs.count(&MBB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">    if (!IndirectTargetMBBs.count(&MBB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">    // We don't expect EH pads to ever be reached via an indirect branch. If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">    // We don't expect EH pads to ever be reached via an indirect branch. If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">    // this is desired for some reason, we could simply skip them here rather</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">    // this is desired for some reason, we could simply skip them here rather</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">    // than asserting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">    // than asserting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">    assert(!MBB.isEHPad() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">    assert(!MBB.isEHPad() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">           "Unexpected EH pad as target of an indirect branch!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">           "Unexpected EH pad as target of an indirect branch!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">    // We should never end up threading EFLAGS into a block to harden</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">    // We should never end up threading EFLAGS into a block to harden</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">    // conditional jumps as there would be an additional successor via the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">    // conditional jumps as there would be an additional successor via the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">    // indirect branch. As a consequence, all such edges would be split before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">    // indirect branch. As a consequence, all such edges would be split before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">    // reaching here, and the inserted block will handle the EFLAGS-based</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">    // reaching here, and the inserted block will handle the EFLAGS-based</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">    // hardening.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">    // hardening.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">    assert(!MBB.isLiveIn(X86::EFLAGS) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">    assert(!MBB.isLiveIn(X86::EFLAGS) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">           "Cannot check within a block that already has live-in EFLAGS!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">           "Cannot check within a block that already has live-in EFLAGS!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">    // We can't handle having non-indirect edges into this block unless this is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">    // We can't handle having non-indirect edges into this block unless this is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">    // the only successor and we can synthesize the necessary target address.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">    // the only successor and we can synthesize the necessary target address.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">    for (MachineBasicBlock *Pred : MBB.predecessors()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">    for (MachineBasicBlock *Pred : MBB.predecessors()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">      // If we've already handled this by extracting the target directly,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">      // If we've already handled this by extracting the target directly,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">      // nothing to do.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">      // nothing to do.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">      if (IndirectTerminatedMBBs.count(Pred))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">      if (IndirectTerminatedMBBs.count(Pred))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">      // Otherwise, we have to be the only successor. We generally expect this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">      // Otherwise, we have to be the only successor. We generally expect this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">      // to be true as conditional branches should have had a critical edge</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">      // to be true as conditional branches should have had a critical edge</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">      // split already. We don't however need to worry about EH pad successors</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">      // split already. We don't however need to worry about EH pad successors</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">      // as they'll happily ignore the target and their hardening strategy is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">      // as they'll happily ignore the target and their hardening strategy is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">      // resilient to all ways in which they could be reached speculatively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">      // resilient to all ways in which they could be reached speculatively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">      if (!llvm::all_of(Pred->successors(), [&](MachineBasicBlock *Succ) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">      if (!llvm::all_of(Pred->successors(), [&](MachineBasicBlock *Succ) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">            return Succ->isEHPad() || Succ == &MBB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">            return Succ->isEHPad() || Succ == &MBB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">          })) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">          })) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">        LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">        LLVM_DEBUG({</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">          dbgs() << "ERROR: Found conditional entry to target of indirect "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">          dbgs() << "ERROR: Found conditional entry to target of indirect "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">                    "branch!\n";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">                    "branch!\n";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">          Pred->dump();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">          Pred->dump();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">          MBB.dump();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">          MBB.dump();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">        });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">        report_fatal_error("Cannot harden a conditional entry to a target of "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">        report_fatal_error("Cannot harden a conditional entry to a target of "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">                           "an indirect branch!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">                           "an indirect branch!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">      // Now we need to compute the address of this block and install it as a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">      // Now we need to compute the address of this block and install it as a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">      // synthetic target in the predecessor. We do this at the bottom of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">      // synthetic target in the predecessor. We do this at the bottom of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">      // predecessor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">      // predecessor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">      auto InsertPt = Pred->getFirstTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">      auto InsertPt = Pred->getFirstTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">      Register TargetReg = MRI->createVirtualRegister(&X86::GR64RegClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">      Register TargetReg = MRI->createVirtualRegister(&X86::GR64RegClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">      if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">      if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">          !Subtarget->isPositionIndependent()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">          !Subtarget->isPositionIndependent()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">        // Directly materialize it into an immediate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">        // Directly materialize it into an immediate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">        auto AddrI = BuildMI(*Pred, InsertPt, DebugLoc(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">        auto AddrI = BuildMI(*Pred, InsertPt, DebugLoc(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">                             TII->get(X86::MOV64ri32), TargetReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">                             TII->get(X86::MOV64ri32), TargetReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">                         .addMBB(&MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">                         .addMBB(&MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">        ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">        ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">        (void)AddrI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">        (void)AddrI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "  Inserting mov: "; AddrI->dump();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "  Inserting mov: "; AddrI->dump();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">                   dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">                   dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">        auto AddrI = BuildMI(*Pred, InsertPt, DebugLoc(), TII->get(X86::LEA64r),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">        auto AddrI = BuildMI(*Pred, InsertPt, DebugLoc(), TII->get(X86::LEA64r),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">                             TargetReg)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">                             TargetReg)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">                         .addReg(/*Base*/ X86::RIP)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">                         .addReg(/*Base*/ X86::RIP)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">                         .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">                         .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">                         .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">                         .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">                         .addMBB(&MBB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">                         .addMBB(&MBB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">                         .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">                         .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">        ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">        ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">        (void)AddrI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">        (void)AddrI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "  Inserting lea: "; AddrI->dump();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "  Inserting lea: "; AddrI->dump();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">                   dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">                   dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">      // And make this available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">      // And make this available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">      TargetAddrSSA.AddAvailableValue(Pred, TargetReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">      TargetAddrSSA.AddAvailableValue(Pred, TargetReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">    // Materialize the needed SSA value of the target. Note that we need the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">    // Materialize the needed SSA value of the target. Note that we need the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">    // middle of the block as this block might at the bottom have an indirect</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">    // middle of the block as this block might at the bottom have an indirect</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">    // branch back to itself. We can do this here because at this point, every</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">    // branch back to itself. We can do this here because at this point, every</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">    // predecessor of this block has an available value. This is basically just</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">    // predecessor of this block has an available value. This is basically just</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">    // automating the construction of a PHI node for this target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">    // automating the construction of a PHI node for this target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">    Register TargetReg = TargetAddrSSA.GetValueInMiddleOfBlock(&MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">    Register TargetReg = TargetAddrSSA.GetValueInMiddleOfBlock(&MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">    // Insert a comparison of the incoming target register with this block's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">    // Insert a comparison of the incoming target register with this block's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">    // address. This also requires us to mark the block as having its address</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">    // address. This also requires us to mark the block as having its address</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">    // taken explicitly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">    // taken explicitly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">    MBB.setMachineBlockAddressTaken();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">    MBB.setMachineBlockAddressTaken();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">    auto InsertPt = MBB.SkipPHIsLabelsAndDebug(MBB.begin());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">    auto InsertPt = MBB.SkipPHIsLabelsAndDebug(MBB.begin());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">    if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">    if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">        !Subtarget->isPositionIndependent()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">        !Subtarget->isPositionIndependent()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">      // Check directly against a relocated immediate when we can.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">      // Check directly against a relocated immediate when we can.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">      auto CheckI = BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::CMP64ri32))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">      auto CheckI = BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::CMP64ri32))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">                        .addReg(TargetReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">                        .addReg(TargetReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">                        .addMBB(&MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">                        .addMBB(&MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">      (void)CheckI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">      (void)CheckI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting cmp: "; CheckI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting cmp: "; CheckI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">      // Otherwise compute the address into a register first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">      // Otherwise compute the address into a register first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">      Register AddrReg = MRI->createVirtualRegister(&X86::GR64RegClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">      Register AddrReg = MRI->createVirtualRegister(&X86::GR64RegClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">      auto AddrI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">      auto AddrI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">          BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::LEA64r), AddrReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">          BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::LEA64r), AddrReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">              .addReg(/*Base*/ X86::RIP)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">              .addReg(/*Base*/ X86::RIP)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">              .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">              .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">              .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">              .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">              .addMBB(&MBB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">              .addMBB(&MBB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">              .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">              .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">      (void)AddrI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">      (void)AddrI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting lea: "; AddrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting lea: "; AddrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">      auto CheckI = BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::CMP64rr))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">      auto CheckI = BuildMI(MBB, InsertPt, DebugLoc(), TII->get(X86::CMP64rr))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">                        .addReg(TargetReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">                        .addReg(TargetReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">                        .addReg(AddrReg, RegState::Kill);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">                        .addReg(AddrReg, RegState::Kill);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">      (void)CheckI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">      (void)CheckI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting cmp: "; CheckI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting cmp: "; CheckI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">    // Now cmov over the predicate if the comparison wasn't equal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">    // Now cmov over the predicate if the comparison wasn't equal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">    int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">    int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">    auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">    auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">    Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">    Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">    auto CMovI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">    auto CMovI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">        BuildMI(MBB, InsertPt, DebugLoc(), TII->get(CMovOp), UpdatedStateReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">        BuildMI(MBB, InsertPt, DebugLoc(), TII->get(CMovOp), UpdatedStateReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">            .addReg(PS->InitialReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">            .addReg(PS->InitialReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">            .addReg(PS->PoisonReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">            .addReg(PS->PoisonReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">            .addImm(X86::COND_NE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">            .addImm(X86::COND_NE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">    CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">    CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">    ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">    ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">    CMovs.push_back(&*CMovI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">    CMovs.push_back(&*CMovI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">    // And put the new value into the available values for SSA form of our</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">    // And put the new value into the available values for SSA form of our</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">    // predicate state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">    // predicate state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">    PS->SSA.AddAvailableValue(&MBB, UpdatedStateReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">    PS->SSA.AddAvailableValue(&MBB, UpdatedStateReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">  // Return all the newly inserted cmov instructions of the predicate state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">  // Return all the newly inserted cmov instructions of the predicate state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">  return CMovs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">  return CMovs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">// Returns true if the MI has EFLAGS as a register def operand and it's live,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">// Returns true if the MI has EFLAGS as a register def operand and it's live,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">// otherwise it returns false</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">// otherwise it returns false</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">static bool isEFLAGSDefLive(const MachineInstr &MI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">static bool isEFLAGSDefLive(const MachineInstr &MI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">  if (const MachineOperand *DefOp = MI.findRegisterDefOperand(X86::EFLAGS)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">  if (const MachineOperand *DefOp = MI.findRegisterDefOperand(X86::EFLAGS)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">    return !DefOp->isDead();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">    return !DefOp->isDead();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">static bool isEFLAGSLive(MachineBasicBlock &MBB, MachineBasicBlock::iterator I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">static bool isEFLAGSLive(MachineBasicBlock &MBB, MachineBasicBlock::iterator I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">                         const TargetRegisterInfo &TRI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">                         const TargetRegisterInfo &TRI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  // Check if EFLAGS are alive by seeing if there is a def of them or they</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  // Check if EFLAGS are alive by seeing if there is a def of them or they</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">  // live-in, and then seeing if that def is in turn used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">  // live-in, and then seeing if that def is in turn used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">  for (MachineInstr &MI : llvm::reverse(llvm::make_range(MBB.begin(), I))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">  for (MachineInstr &MI : llvm::reverse(llvm::make_range(MBB.begin(), I))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">    if (MachineOperand *DefOp = MI.findRegisterDefOperand(X86::EFLAGS)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">    if (MachineOperand *DefOp = MI.findRegisterDefOperand(X86::EFLAGS)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">      // If the def is dead, then EFLAGS is not live.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">      // If the def is dead, then EFLAGS is not live.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">      if (DefOp->isDead())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">      if (DefOp->isDead())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">      // Otherwise we've def'ed it, and it is live.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">      // Otherwise we've def'ed it, and it is live.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">    // While at this instruction, also check if we use and kill EFLAGS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">    // While at this instruction, also check if we use and kill EFLAGS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">    // which means it isn't live.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">    // which means it isn't live.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">    if (MI.killsRegister(X86::EFLAGS, &TRI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">    if (MI.killsRegister(X86::EFLAGS, &TRI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">  // If we didn't find anything conclusive (neither definitely alive or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">  // If we didn't find anything conclusive (neither definitely alive or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  // definitely dead) return whether it lives into the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  // definitely dead) return whether it lives into the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">  return MBB.isLiveIn(X86::EFLAGS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">  return MBB.isLiveIn(X86::EFLAGS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">/// Trace the predicate state through each of the blocks in the function,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">/// Trace the predicate state through each of the blocks in the function,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">/// hardening everything necessary along the way.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">/// hardening everything necessary along the way.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">/// We call this routine once the initial predicate state has been established</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">/// We call this routine once the initial predicate state has been established</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">/// for each basic block in the function in the SSA updater. This routine traces</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">/// for each basic block in the function in the SSA updater. This routine traces</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">/// it through the instructions within each basic block, and for non-returning</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">/// it through the instructions within each basic block, and for non-returning</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">/// blocks informs the SSA updater about the final state that lives out of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">/// blocks informs the SSA updater about the final state that lives out of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">/// block. Along the way, it hardens any vulnerable instruction using the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">/// block. Along the way, it hardens any vulnerable instruction using the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">/// currently valid predicate state. We have to do these two things together</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">/// currently valid predicate state. We have to do these two things together</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">/// because the SSA updater only works across blocks. Within a block, we track</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">/// because the SSA updater only works across blocks. Within a block, we track</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">/// the current predicate state directly and update it as it changes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">/// the current predicate state directly and update it as it changes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">/// This operates in two passes over each block. First, we analyze the loads in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">/// This operates in two passes over each block. First, we analyze the loads in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">/// the block to determine which strategy will be used to harden them: hardening</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">/// the block to determine which strategy will be used to harden them: hardening</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">/// the address or hardening the loaded value when loaded into a register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">/// the address or hardening the loaded value when loaded into a register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">/// amenable to hardening. We have to process these first because the two</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">/// amenable to hardening. We have to process these first because the two</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">/// strategies may interact -- later hardening may change what strategy we wish</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">/// strategies may interact -- later hardening may change what strategy we wish</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">/// to use. We also will analyze data dependencies between loads and avoid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">/// to use. We also will analyze data dependencies between loads and avoid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">/// hardening those loads that are data dependent on a load with a hardened</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">/// hardening those loads that are data dependent on a load with a hardened</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">/// address. We also skip hardening loads already behind an LFENCE as that is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">/// address. We also skip hardening loads already behind an LFENCE as that is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">/// sufficient to harden them against misspeculation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">/// sufficient to harden them against misspeculation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">/// Second, we actively trace the predicate state through the block, applying</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">/// Second, we actively trace the predicate state through the block, applying</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">/// the hardening steps we determined necessary in the first pass as we go.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">/// the hardening steps we determined necessary in the first pass as we go.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">/// These two passes are applied to each basic block. We operate one block at a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">/// These two passes are applied to each basic block. We operate one block at a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">/// time to simplify reasoning about reachability and sequencing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">/// time to simplify reasoning about reachability and sequencing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::tracePredStateThroughBlocksAndHarden(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::tracePredStateThroughBlocksAndHarden(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">    MachineFunction &MF) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">    MachineFunction &MF) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">  SmallPtrSet<MachineInstr *, 16> HardenPostLoad;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">  SmallPtrSet<MachineInstr *, 16> HardenPostLoad;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">  SmallPtrSet<MachineInstr *, 16> HardenLoadAddr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">  SmallPtrSet<MachineInstr *, 16> HardenLoadAddr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">  SmallSet<unsigned, 16> HardenedAddrRegs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">  SmallSet<unsigned, 16> HardenedAddrRegs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">  SmallDenseMap<unsigned, unsigned, 32> AddrRegToHardenedReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">  SmallDenseMap<unsigned, unsigned, 32> AddrRegToHardenedReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">  // Track the set of load-dependent registers through the basic block. Because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">  // Track the set of load-dependent registers through the basic block. Because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">  // the values of these registers have an existing data dependency on a loaded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">  // the values of these registers have an existing data dependency on a loaded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  // value which we would have checked, we can omit any checks on them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  // value which we would have checked, we can omit any checks on them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">  SparseBitVector<> LoadDepRegs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">  SparseBitVector<> LoadDepRegs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">  for (MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">    // The first pass over the block: collect all the loads which can have their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">    // The first pass over the block: collect all the loads which can have their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">    // loaded value hardened and all the loads that instead need their address</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">    // loaded value hardened and all the loads that instead need their address</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">    // hardened. During this walk we propagate load dependence for address</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">    // hardened. During this walk we propagate load dependence for address</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">    // hardened loads and also look for LFENCE to stop hardening wherever</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">    // hardened loads and also look for LFENCE to stop hardening wherever</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">    // possible. When deciding whether or not to harden the loaded value or not,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">    // possible. When deciding whether or not to harden the loaded value or not,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">    // we check to see if any registers used in the address will have been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">    // we check to see if any registers used in the address will have been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">    // hardened at this point and if so, harden any remaining address registers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">    // hardened at this point and if so, harden any remaining address registers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">    // as that often successfully re-uses hardened addresses and minimizes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">    // as that often successfully re-uses hardened addresses and minimizes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">    // instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">    // instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">    // FIXME: We should consider an aggressive mode where we continue to keep as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">    // FIXME: We should consider an aggressive mode where we continue to keep as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">    // many loads value hardened even when some address register hardening would</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">    // many loads value hardened even when some address register hardening would</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">    // be free (due to reuse).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">    // be free (due to reuse).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">    // Note that we only need this pass if we are actually hardening loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">    // Note that we only need this pass if we are actually hardening loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">    if (HardenLoads)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">    if (HardenLoads)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">      for (MachineInstr &MI : MBB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">      for (MachineInstr &MI : MBB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">        // We naively assume that all def'ed registers of an instruction have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">        // We naively assume that all def'ed registers of an instruction have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">        // a data dependency on all of their operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">        // a data dependency on all of their operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">        // FIXME: Do a more careful analysis of x86 to build a conservative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">        // FIXME: Do a more careful analysis of x86 to build a conservative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">        // model here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">        // model here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">        if (llvm::any_of(MI.uses(), [&](MachineOperand &Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">        if (llvm::any_of(MI.uses(), [&](MachineOperand &Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">              return Op.isReg() && LoadDepRegs.test(Op.getReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">              return Op.isReg() && LoadDepRegs.test(Op.getReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">            }))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">            }))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">          for (MachineOperand &Def : MI.defs())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">          for (MachineOperand &Def : MI.defs())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">            if (Def.isReg())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">            if (Def.isReg())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">              LoadDepRegs.set(Def.getReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">              LoadDepRegs.set(Def.getReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">        // Both Intel and AMD are guiding that they will change the semantics of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">        // Both Intel and AMD are guiding that they will change the semantics of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">        // LFENCE to be a speculation barrier, so if we see an LFENCE, there is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">        // LFENCE to be a speculation barrier, so if we see an LFENCE, there is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">        // no more need to guard things in this block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">        // no more need to guard things in this block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">        if (MI.getOpcode() == X86::LFENCE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">        if (MI.getOpcode() == X86::LFENCE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">        // If this instruction cannot load, nothing to do.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">        // If this instruction cannot load, nothing to do.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">        if (!MI.mayLoad())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">        if (!MI.mayLoad())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">        // Some instructions which "load" are trivially safe or unimportant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">        // Some instructions which "load" are trivially safe or unimportant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">        if (MI.getOpcode() == X86::MFENCE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">        if (MI.getOpcode() == X86::MFENCE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">        // Extract the memory operand information about this instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">        // Extract the memory operand information about this instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">        // FIXME: This doesn't handle loading pseudo instructions which we often</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">        // FIXME: This doesn't handle loading pseudo instructions which we often</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">        // could handle with similarly generic logic. We probably need to add an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">        // could handle with similarly generic logic. We probably need to add an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">        // MI-layer routine similar to the MC-layer one we use here which maps</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">        // MI-layer routine similar to the MC-layer one we use here which maps</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">        // pseudos much like this maps real instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">        // pseudos much like this maps real instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">        const MCInstrDesc &Desc = MI.getDesc();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">        const MCInstrDesc &Desc = MI.getDesc();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">        int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">        int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">        if (MemRefBeginIdx < 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">        if (MemRefBeginIdx < 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">                         << "WARNING: unable to harden loading instruction: ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">                         << "WARNING: unable to harden loading instruction: ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">                     MI.dump());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">                     MI.dump());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">        MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">        MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">        MachineOperand &BaseMO =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">        MachineOperand &BaseMO =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">            MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">            MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">        MachineOperand &IndexMO =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">        MachineOperand &IndexMO =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">            MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">            MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">        // If we have at least one (non-frame-index, non-RIP) register operand,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">        // If we have at least one (non-frame-index, non-RIP) register operand,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">        // and neither operand is load-dependent, we need to check the load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">        // and neither operand is load-dependent, we need to check the load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">        unsigned BaseReg = 0, IndexReg = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">        unsigned BaseReg = 0, IndexReg = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">        if (!BaseMO.isFI() && BaseMO.getReg() != X86::RIP &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">        if (!BaseMO.isFI() && BaseMO.getReg() != X86::RIP &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">            BaseMO.getReg() != X86::NoRegister)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">            BaseMO.getReg() != X86::NoRegister)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">          BaseReg = BaseMO.getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">          BaseReg = BaseMO.getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">        if (IndexMO.getReg() != X86::NoRegister)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">        if (IndexMO.getReg() != X86::NoRegister)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">          IndexReg = IndexMO.getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">          IndexReg = IndexMO.getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">        if (!BaseReg && !IndexReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">        if (!BaseReg && !IndexReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">          // No register operands!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">          // No register operands!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">        // If any register operand is dependent, this load is dependent and we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">        // If any register operand is dependent, this load is dependent and we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">        // needn't check it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">        // needn't check it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">        // FIXME: Is this true in the case where we are hardening loads after</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">        // FIXME: Is this true in the case where we are hardening loads after</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">        // they complete? Unclear, need to investigate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">        // they complete? Unclear, need to investigate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">        if ((BaseReg && LoadDepRegs.test(BaseReg)) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">        if ((BaseReg && LoadDepRegs.test(BaseReg)) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">            (IndexReg && LoadDepRegs.test(IndexReg)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">            (IndexReg && LoadDepRegs.test(IndexReg)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">        // If post-load hardening is enabled, this load is compatible with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">        // If post-load hardening is enabled, this load is compatible with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">        // post-load hardening, and we aren't already going to harden one of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">        // post-load hardening, and we aren't already going to harden one of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">        // address registers, queue it up to be hardened post-load. Notably,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">        // address registers, queue it up to be hardened post-load. Notably,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">        // even once hardened this won't introduce a useful dependency that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">        // even once hardened this won't introduce a useful dependency that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">        // could prune out subsequent loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">        // could prune out subsequent loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">        if (EnablePostLoadHardening && X86InstrInfo::isDataInvariantLoad(MI) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">        if (EnablePostLoadHardening && X86InstrInfo::isDataInvariantLoad(MI) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">            !isEFLAGSDefLive(MI) && MI.getDesc().getNumDefs() == 1 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">            !isEFLAGSDefLive(MI) && MI.getDesc().getNumDefs() == 1 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">            MI.getOperand(0).isReg() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">            MI.getOperand(0).isReg() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">            canHardenRegister(MI.getOperand(0).getReg()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">            canHardenRegister(MI.getOperand(0).getReg()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">            !HardenedAddrRegs.count(BaseReg) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">            !HardenedAddrRegs.count(BaseReg) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">            !HardenedAddrRegs.count(IndexReg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">            !HardenedAddrRegs.count(IndexReg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">          HardenPostLoad.insert(&MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">          HardenPostLoad.insert(&MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">          HardenedAddrRegs.insert(MI.getOperand(0).getReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">          HardenedAddrRegs.insert(MI.getOperand(0).getReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">        // Record this instruction for address hardening and record its register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">        // Record this instruction for address hardening and record its register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">        // operands as being address-hardened.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">        // operands as being address-hardened.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">        HardenLoadAddr.insert(&MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">        HardenLoadAddr.insert(&MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">        if (BaseReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">        if (BaseReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">          HardenedAddrRegs.insert(BaseReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">          HardenedAddrRegs.insert(BaseReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">        if (IndexReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">        if (IndexReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">          HardenedAddrRegs.insert(IndexReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">          HardenedAddrRegs.insert(IndexReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">        for (MachineOperand &Def : MI.defs())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">        for (MachineOperand &Def : MI.defs())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">          if (Def.isReg())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">          if (Def.isReg())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">            LoadDepRegs.set(Def.getReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">            LoadDepRegs.set(Def.getReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">    // Now re-walk the instructions in the basic block, and apply whichever</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">    // Now re-walk the instructions in the basic block, and apply whichever</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">    // hardening strategy we have elected. Note that we do this in a second</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">    // hardening strategy we have elected. Note that we do this in a second</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">    // pass specifically so that we have the complete set of instructions for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">    // pass specifically so that we have the complete set of instructions for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">    // which we will do post-load hardening and can defer it in certain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">    // which we will do post-load hardening and can defer it in certain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">    // circumstances.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">    // circumstances.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">    for (MachineInstr &MI : MBB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">    for (MachineInstr &MI : MBB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">      if (HardenLoads) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">      if (HardenLoads) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">        // We cannot both require hardening the def of a load and its address.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">        // We cannot both require hardening the def of a load and its address.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">        assert(!(HardenLoadAddr.count(&MI) && HardenPostLoad.count(&MI)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">        assert(!(HardenLoadAddr.count(&MI) && HardenPostLoad.count(&MI)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">               "Requested to harden both the address and def of a load!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">               "Requested to harden both the address and def of a load!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">        // Check if this is a load whose address needs to be hardened.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">        // Check if this is a load whose address needs to be hardened.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">        if (HardenLoadAddr.erase(&MI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">        if (HardenLoadAddr.erase(&MI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">          const MCInstrDesc &Desc = MI.getDesc();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">          const MCInstrDesc &Desc = MI.getDesc();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">          int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">          int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">          assert(MemRefBeginIdx >= 0 && "Cannot have an invalid index here!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">          assert(MemRefBeginIdx >= 0 && "Cannot have an invalid index here!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">          MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">          MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">          MachineOperand &BaseMO =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">          MachineOperand &BaseMO =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">              MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">              MI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">          MachineOperand &IndexMO =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">          MachineOperand &IndexMO =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">              MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">              MI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">          hardenLoadAddr(MI, BaseMO, IndexMO, AddrRegToHardenedReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">          hardenLoadAddr(MI, BaseMO, IndexMO, AddrRegToHardenedReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">        // Test if this instruction is one of our post load instructions (and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">        // Test if this instruction is one of our post load instructions (and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">        // remove it from the set if so).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">        // remove it from the set if so).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">        if (HardenPostLoad.erase(&MI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">        if (HardenPostLoad.erase(&MI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">          assert(!MI.isCall() && "Must not try to post-load harden a call!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">          assert(!MI.isCall() && "Must not try to post-load harden a call!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">          // If this is a data-invariant load and there is no EFLAGS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">          // If this is a data-invariant load and there is no EFLAGS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">          // interference, we want to try and sink any hardening as far as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">          // interference, we want to try and sink any hardening as far as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">          // possible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">          // possible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">          if (X86InstrInfo::isDataInvariantLoad(MI) && !isEFLAGSDefLive(MI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">          if (X86InstrInfo::isDataInvariantLoad(MI) && !isEFLAGSDefLive(MI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">            // Sink the instruction we'll need to harden as far as we can down</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">            // Sink the instruction we'll need to harden as far as we can down</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">            // the graph.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">            // the graph.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">            MachineInstr *SunkMI = sinkPostLoadHardenedInst(MI, HardenPostLoad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">            MachineInstr *SunkMI = sinkPostLoadHardenedInst(MI, HardenPostLoad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">            // If we managed to sink this instruction, update everything so we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">            // If we managed to sink this instruction, update everything so we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">            // harden that instruction when we reach it in the instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">            // harden that instruction when we reach it in the instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">            // sequence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">            // sequence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">            if (SunkMI != &MI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">            if (SunkMI != &MI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">              // If in sinking there was no instruction needing to be hardened,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">              // If in sinking there was no instruction needing to be hardened,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">              // we're done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">              // we're done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">              if (!SunkMI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">              if (!SunkMI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">                continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">                continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">              // Otherwise, add this to the set of defs we harden.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">              // Otherwise, add this to the set of defs we harden.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">              HardenPostLoad.insert(SunkMI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">              HardenPostLoad.insert(SunkMI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">            }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">          unsigned HardenedReg = hardenPostLoad(MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">          unsigned HardenedReg = hardenPostLoad(MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">          // Mark the resulting hardened register as such so we don't re-harden.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">          // Mark the resulting hardened register as such so we don't re-harden.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">          AddrRegToHardenedReg[HardenedReg] = HardenedReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">          AddrRegToHardenedReg[HardenedReg] = HardenedReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">        // Check for an indirect call or branch that may need its input hardened</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">        // Check for an indirect call or branch that may need its input hardened</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">        // even if we couldn't find the specific load used, or were able to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">        // even if we couldn't find the specific load used, or were able to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">        // avoid hardening it for some reason. Note that here we cannot break</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">        // avoid hardening it for some reason. Note that here we cannot break</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">        // out afterward as we may still need to handle any call aspect of this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">        // out afterward as we may still need to handle any call aspect of this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">        // instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">        // instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">        if ((MI.isCall() || MI.isBranch()) && HardenIndirectCallsAndJumps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">        if ((MI.isCall() || MI.isBranch()) && HardenIndirectCallsAndJumps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">          hardenIndirectCallOrJumpInstr(MI, AddrRegToHardenedReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">          hardenIndirectCallOrJumpInstr(MI, AddrRegToHardenedReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">      // After we finish hardening loads we handle interprocedural hardening if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">      // After we finish hardening loads we handle interprocedural hardening if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">      // enabled and relevant for this instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">      // enabled and relevant for this instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">      if (!HardenInterprocedurally)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">      if (!HardenInterprocedurally)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">      if (!MI.isCall() && !MI.isReturn())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">      if (!MI.isCall() && !MI.isReturn())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">      // If this is a direct return (IE, not a tail call) just directly harden</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">      // If this is a direct return (IE, not a tail call) just directly harden</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">      // it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">      // it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">      if (MI.isReturn() && !MI.isCall()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">      if (MI.isReturn() && !MI.isCall()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">        hardenReturnInstr(MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">        hardenReturnInstr(MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">      // Otherwise we have a call. We need to handle transferring the predicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">      // Otherwise we have a call. We need to handle transferring the predicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">      // state into a call and recovering it after the call returns (unless this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">      // state into a call and recovering it after the call returns (unless this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">      // is a tail call).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">      // is a tail call).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">      assert(MI.isCall() && "Should only reach here for calls!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">      assert(MI.isCall() && "Should only reach here for calls!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">      tracePredStateThroughCall(MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">      tracePredStateThroughCall(MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">    HardenPostLoad.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">    HardenPostLoad.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">    HardenLoadAddr.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">    HardenLoadAddr.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">    HardenedAddrRegs.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">    HardenedAddrRegs.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">    AddrRegToHardenedReg.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">    AddrRegToHardenedReg.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">    // Currently, we only track data-dependent loads within a basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">    // Currently, we only track data-dependent loads within a basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">    // FIXME: We should see if this is necessary or if we could be more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">    // FIXME: We should see if this is necessary or if we could be more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">    // aggressive here without opening up attack avenues.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">    // aggressive here without opening up attack avenues.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">    LoadDepRegs.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">    LoadDepRegs.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">/// Save EFLAGS into the returned GPR. This can in turn be restored with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">/// Save EFLAGS into the returned GPR. This can in turn be restored with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">/// `restoreEFLAGS`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">/// `restoreEFLAGS`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">/// Note that LLVM can only lower very simple patterns of saved and restored</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">/// Note that LLVM can only lower very simple patterns of saved and restored</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">/// EFLAGS registers. The restore should always be within the same basic block</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">/// EFLAGS registers. The restore should always be within the same basic block</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">/// as the save so that no PHI nodes are inserted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">/// as the save so that no PHI nodes are inserted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">unsigned X86SpeculativeLoadHardeningPass::saveEFLAGS(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">unsigned X86SpeculativeLoadHardeningPass::saveEFLAGS(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">    const DebugLoc &Loc) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">    const DebugLoc &Loc) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">  // FIXME: Hard coding this to a 32-bit register class seems weird, but matches</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">  // FIXME: Hard coding this to a 32-bit register class seems weird, but matches</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">  // what instruction selection does.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">  // what instruction selection does.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">  Register Reg = MRI->createVirtualRegister(&X86::GR32RegClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">  Register Reg = MRI->createVirtualRegister(&X86::GR32RegClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">  // We directly copy the FLAGS register and rely on later lowering to clean</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">  // We directly copy the FLAGS register and rely on later lowering to clean</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">  // this up into the appropriate setCC instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">  // this up into the appropriate setCC instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">  BuildMI(MBB, InsertPt, Loc, TII->get(X86::COPY), Reg).addReg(X86::EFLAGS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">  BuildMI(MBB, InsertPt, Loc, TII->get(X86::COPY), Reg).addReg(X86::EFLAGS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">  return Reg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">  return Reg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">/// Restore EFLAGS from the provided GPR. This should be produced by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">/// Restore EFLAGS from the provided GPR. This should be produced by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">/// `saveEFLAGS`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">/// `saveEFLAGS`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">/// This must be done within the same basic block as the save in order to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">/// This must be done within the same basic block as the save in order to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">/// reliably lower.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">/// reliably lower.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::restoreEFLAGS(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::restoreEFLAGS(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">    const DebugLoc &Loc, Register Reg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">    const DebugLoc &Loc, Register Reg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">  BuildMI(MBB, InsertPt, Loc, TII->get(X86::COPY), X86::EFLAGS).addReg(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">  BuildMI(MBB, InsertPt, Loc, TII->get(X86::COPY), X86::EFLAGS).addReg(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">/// Takes the current predicate state (in a register) and merges it into the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">/// Takes the current predicate state (in a register) and merges it into the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">/// stack pointer. The state is essentially a single bit, but we merge this in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">/// stack pointer. The state is essentially a single bit, but we merge this in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">/// a way that won't form non-canonical pointers and also will be preserved</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">/// a way that won't form non-canonical pointers and also will be preserved</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">/// across normal stack adjustments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">/// across normal stack adjustments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::mergePredStateIntoSP(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::mergePredStateIntoSP(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">    const DebugLoc &Loc, unsigned PredStateReg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">    const DebugLoc &Loc, unsigned PredStateReg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">  Register TmpReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">  Register TmpReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">  // FIXME: This hard codes a shift distance based on the number of bits needed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">  // FIXME: This hard codes a shift distance based on the number of bits needed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">  // to stay canonical on 64-bit. We should compute this somehow and support</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">  // to stay canonical on 64-bit. We should compute this somehow and support</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">  // 32-bit as part of that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">  // 32-bit as part of that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">  auto ShiftI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::SHL64ri), TmpReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">  auto ShiftI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::SHL64ri), TmpReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">                    .addReg(PredStateReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">                    .addReg(PredStateReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">                    .addImm(47);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">                    .addImm(47);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">  ShiftI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">  ShiftI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">  auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::OR64rr), X86::RSP)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">  auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::OR64rr), X86::RSP)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">                 .addReg(X86::RSP)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">                 .addReg(X86::RSP)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">                 .addReg(TmpReg, RegState::Kill);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">                 .addReg(TmpReg, RegState::Kill);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">  OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">  OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">/// Extracts the predicate state stored in the high bits of the stack pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">/// Extracts the predicate state stored in the high bits of the stack pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">unsigned X86SpeculativeLoadHardeningPass::extractPredStateFromSP(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">unsigned X86SpeculativeLoadHardeningPass::extractPredStateFromSP(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine">    MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">    const DebugLoc &Loc) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">    const DebugLoc &Loc) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">  Register PredStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">  Register PredStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">  Register TmpReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">  Register TmpReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">  // We know that the stack pointer will have any preserved predicate state in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">  // We know that the stack pointer will have any preserved predicate state in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">  // its high bit. We just want to smear this across the other bits. Turns out,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">  // its high bit. We just want to smear this across the other bits. Turns out,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">  // this is exactly what an arithmetic right shift does.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">  // this is exactly what an arithmetic right shift does.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">  BuildMI(MBB, InsertPt, Loc, TII->get(TargetOpcode::COPY), TmpReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">  BuildMI(MBB, InsertPt, Loc, TII->get(TargetOpcode::COPY), TmpReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">      .addReg(X86::RSP);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">      .addReg(X86::RSP);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">  auto ShiftI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">  auto ShiftI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::SAR64ri), PredStateReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::SAR64ri), PredStateReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">          .addReg(TmpReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">          .addReg(TmpReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">          .addImm(TRI->getRegSizeInBits(*PS->RC) - 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">          .addImm(TRI->getRegSizeInBits(*PS->RC) - 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">  ShiftI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">  ShiftI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">  return PredStateReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">  return PredStateReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::hardenLoadAddr(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::hardenLoadAddr(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">    MachineInstr &MI, MachineOperand &BaseMO, MachineOperand &IndexMO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">    MachineInstr &MI, MachineOperand &BaseMO, MachineOperand &IndexMO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">    SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">    SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">  // Check if EFLAGS are alive by seeing if there is a def of them or they</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">  // Check if EFLAGS are alive by seeing if there is a def of them or they</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">  // live-in, and then seeing if that def is in turn used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">  // live-in, and then seeing if that def is in turn used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">  bool EFLAGSLive = isEFLAGSLive(MBB, MI.getIterator(), *TRI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">  bool EFLAGSLive = isEFLAGSLive(MBB, MI.getIterator(), *TRI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">  SmallVector<MachineOperand *, 2> HardenOpRegs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">  SmallVector<MachineOperand *, 2> HardenOpRegs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">  if (BaseMO.isFI()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">  if (BaseMO.isFI()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">    // A frame index is never a dynamically controllable load, so only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">    // A frame index is never a dynamically controllable load, so only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">    // harden it if we're covering fixed address loads as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">    // harden it if we're covering fixed address loads as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">    LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">    LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">        dbgs() << "  Skipping hardening base of explicit stack frame load: ";</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">        dbgs() << "  Skipping hardening base of explicit stack frame load: ";</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">        MI.dump(); dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">        MI.dump(); dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">  } else if (BaseMO.getReg() == X86::RSP) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">  } else if (BaseMO.getReg() == X86::RSP) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">    // Some idempotent atomic operations are lowered directly to a locked</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">    // Some idempotent atomic operations are lowered directly to a locked</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">    // OR with 0 to the top of stack(or slightly offset from top) which uses an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">    // OR with 0 to the top of stack(or slightly offset from top) which uses an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">    // explicit RSP register as the base.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">    // explicit RSP register as the base.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">    assert(IndexMO.getReg() == X86::NoRegister &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">    assert(IndexMO.getReg() == X86::NoRegister &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">           "Explicit RSP access with dynamic index!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">           "Explicit RSP access with dynamic index!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">    LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">    LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">        dbgs() << "  Cannot harden base of explicit RSP offset in a load!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">        dbgs() << "  Cannot harden base of explicit RSP offset in a load!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">  } else if (BaseMO.getReg() == X86::RIP ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">  } else if (BaseMO.getReg() == X86::RIP ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">             BaseMO.getReg() == X86::NoRegister) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">             BaseMO.getReg() == X86::NoRegister) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">    // For both RIP-relative addressed loads or absolute loads, we cannot</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">    // For both RIP-relative addressed loads or absolute loads, we cannot</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">    // meaningfully harden them because the address being loaded has no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">    // meaningfully harden them because the address being loaded has no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">    // dynamic component.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">    // dynamic component.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">    // FIXME: When using a segment base (like TLS does) we end up with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">    // FIXME: When using a segment base (like TLS does) we end up with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">    // dynamic address being the base plus -1 because we can't mutate the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">    // dynamic address being the base plus -1 because we can't mutate the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">    // segment register here. This allows the signed 32-bit offset to point at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">    // segment register here. This allows the signed 32-bit offset to point at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">    // valid segment-relative addresses and load them successfully.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">    // valid segment-relative addresses and load them successfully.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">    LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">    LLVM_DEBUG(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">        dbgs() << "  Cannot harden base of "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">        dbgs() << "  Cannot harden base of "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">               << (BaseMO.getReg() == X86::RIP ? "RIP-relative" : "no-base")</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">               << (BaseMO.getReg() == X86::RIP ? "RIP-relative" : "no-base")</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">               << " address in a load!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">               << " address in a load!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">    assert(BaseMO.isReg() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">    assert(BaseMO.isReg() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">           "Only allowed to have a frame index or register base.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">           "Only allowed to have a frame index or register base.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">    HardenOpRegs.push_back(&BaseMO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">    HardenOpRegs.push_back(&BaseMO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">  if (IndexMO.getReg() != X86::NoRegister &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">  if (IndexMO.getReg() != X86::NoRegister &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">      (HardenOpRegs.empty() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">      (HardenOpRegs.empty() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">       HardenOpRegs.front()->getReg() != IndexMO.getReg()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">       HardenOpRegs.front()->getReg() != IndexMO.getReg()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">    HardenOpRegs.push_back(&IndexMO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">    HardenOpRegs.push_back(&IndexMO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">  assert((HardenOpRegs.size() == 1 || HardenOpRegs.size() == 2) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">  assert((HardenOpRegs.size() == 1 || HardenOpRegs.size() == 2) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">         "Should have exactly one or two registers to harden!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">         "Should have exactly one or two registers to harden!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">  assert((HardenOpRegs.size() == 1 ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">  assert((HardenOpRegs.size() == 1 ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">          HardenOpRegs[0]->getReg() != HardenOpRegs[1]->getReg()) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">          HardenOpRegs[0]->getReg() != HardenOpRegs[1]->getReg()) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">         "Should not have two of the same registers!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">         "Should not have two of the same registers!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">  // Remove any registers that have alreaded been checked.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">  // Remove any registers that have alreaded been checked.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">  llvm::erase_if(HardenOpRegs, [&](MachineOperand *Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">  llvm::erase_if(HardenOpRegs, [&](MachineOperand *Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">    // See if this operand's register has already been checked.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">    // See if this operand's register has already been checked.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">    auto It = AddrRegToHardenedReg.find(Op->getReg());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">    auto It = AddrRegToHardenedReg.find(Op->getReg());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">    if (It == AddrRegToHardenedReg.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">    if (It == AddrRegToHardenedReg.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">      // Not checked, so retain this one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">      // Not checked, so retain this one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">    // Otherwise, we can directly update this operand and remove it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">    // Otherwise, we can directly update this operand and remove it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">    Op->setReg(It->second);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">    Op->setReg(It->second);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">  // If there are none left, we're done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">  // If there are none left, we're done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">  if (HardenOpRegs.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">  if (HardenOpRegs.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">  // Compute the current predicate state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">  // Compute the current predicate state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">  auto InsertPt = MI.getIterator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">  auto InsertPt = MI.getIterator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">  // If EFLAGS are live and we don't have access to instructions that avoid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">  // If EFLAGS are live and we don't have access to instructions that avoid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">  // clobbering EFLAGS we need to save and restore them. This in turn makes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">  // clobbering EFLAGS we need to save and restore them. This in turn makes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">  // the EFLAGS no longer live.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">  // the EFLAGS no longer live.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">  unsigned FlagsReg = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">  unsigned FlagsReg = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">  if (EFLAGSLive && !Subtarget->hasBMI2()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">  if (EFLAGSLive && !Subtarget->hasBMI2()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">    EFLAGSLive = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">    EFLAGSLive = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">    FlagsReg = saveEFLAGS(MBB, InsertPt, Loc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">    FlagsReg = saveEFLAGS(MBB, InsertPt, Loc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">  for (MachineOperand *Op : HardenOpRegs) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">  for (MachineOperand *Op : HardenOpRegs) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">    Register OpReg = Op->getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">    Register OpReg = Op->getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">    auto *OpRC = MRI->getRegClass(OpReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">    auto *OpRC = MRI->getRegClass(OpReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">    Register TmpReg = MRI->createVirtualRegister(OpRC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">    Register TmpReg = MRI->createVirtualRegister(OpRC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">    // If this is a vector register, we'll need somewhat custom logic to handle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">    // If this is a vector register, we'll need somewhat custom logic to handle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">    // hardening it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">    // hardening it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">    if (!Subtarget->hasVLX() && (OpRC->hasSuperClassEq(&X86::VR128RegClass) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">    if (!Subtarget->hasVLX() && (OpRC->hasSuperClassEq(&X86::VR128RegClass) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">                                 OpRC->hasSuperClassEq(&X86::VR256RegClass))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">                                 OpRC->hasSuperClassEq(&X86::VR256RegClass))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">      assert(Subtarget->hasAVX2() && "AVX2-specific register classes!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">      assert(Subtarget->hasAVX2() && "AVX2-specific register classes!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">      bool Is128Bit = OpRC->hasSuperClassEq(&X86::VR128RegClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">      bool Is128Bit = OpRC->hasSuperClassEq(&X86::VR128RegClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">      // Move our state into a vector register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">      // Move our state into a vector register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">      // FIXME: We could skip this at the cost of longer encodings with AVX-512</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">      // FIXME: We could skip this at the cost of longer encodings with AVX-512</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">      // but that doesn't seem likely worth it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">      // but that doesn't seem likely worth it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">      Register VStateReg = MRI->createVirtualRegister(&X86::VR128RegClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">      Register VStateReg = MRI->createVirtualRegister(&X86::VR128RegClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">      auto MovI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">      auto MovI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">          BuildMI(MBB, InsertPt, Loc, TII->get(X86::VMOV64toPQIrr), VStateReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">          BuildMI(MBB, InsertPt, Loc, TII->get(X86::VMOV64toPQIrr), VStateReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">              .addReg(StateReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">              .addReg(StateReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">      (void)MovI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">      (void)MovI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting mov: "; MovI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting mov: "; MovI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">      // Broadcast it across the vector register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">      // Broadcast it across the vector register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">      Register VBStateReg = MRI->createVirtualRegister(OpRC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">      Register VBStateReg = MRI->createVirtualRegister(OpRC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">      auto BroadcastI = BuildMI(MBB, InsertPt, Loc,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">      auto BroadcastI = BuildMI(MBB, InsertPt, Loc,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">                                TII->get(Is128Bit ? X86::VPBROADCASTQrr</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">                                TII->get(Is128Bit ? X86::VPBROADCASTQrr</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">                                                  : X86::VPBROADCASTQYrr),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">                                                  : X86::VPBROADCASTQYrr),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">                                VBStateReg)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">                                VBStateReg)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">                            .addReg(VStateReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">                            .addReg(VStateReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">      (void)BroadcastI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">      (void)BroadcastI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting broadcast: "; BroadcastI->dump();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting broadcast: "; BroadcastI->dump();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">                 dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">                 dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">      // Merge our potential poison state into the value with a vector or.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">      // Merge our potential poison state into the value with a vector or.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">      auto OrI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">      auto OrI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine">          BuildMI(MBB, InsertPt, Loc,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine">          BuildMI(MBB, InsertPt, Loc,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">                  TII->get(Is128Bit ? X86::VPORrr : X86::VPORYrr), TmpReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">                  TII->get(Is128Bit ? X86::VPORrr : X86::VPORYrr), TmpReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">              .addReg(VBStateReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">              .addReg(VBStateReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">              .addReg(OpReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">              .addReg(OpReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">      (void)OrI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">      (void)OrI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">    } else if (OpRC->hasSuperClassEq(&X86::VR128XRegClass) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">    } else if (OpRC->hasSuperClassEq(&X86::VR128XRegClass) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">               OpRC->hasSuperClassEq(&X86::VR256XRegClass) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">               OpRC->hasSuperClassEq(&X86::VR256XRegClass) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">               OpRC->hasSuperClassEq(&X86::VR512RegClass)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">               OpRC->hasSuperClassEq(&X86::VR512RegClass)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">      assert(Subtarget->hasAVX512() && "AVX512-specific register classes!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">      assert(Subtarget->hasAVX512() && "AVX512-specific register classes!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">      bool Is128Bit = OpRC->hasSuperClassEq(&X86::VR128XRegClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">      bool Is128Bit = OpRC->hasSuperClassEq(&X86::VR128XRegClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">      bool Is256Bit = OpRC->hasSuperClassEq(&X86::VR256XRegClass);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">      bool Is256Bit = OpRC->hasSuperClassEq(&X86::VR256XRegClass);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">      if (Is128Bit || Is256Bit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">      if (Is128Bit || Is256Bit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">        assert(Subtarget->hasVLX() && "AVX512VL-specific register classes!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">        assert(Subtarget->hasVLX() && "AVX512VL-specific register classes!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">      // Broadcast our state into a vector register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">      // Broadcast our state into a vector register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">      Register VStateReg = MRI->createVirtualRegister(OpRC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">      Register VStateReg = MRI->createVirtualRegister(OpRC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">      unsigned BroadcastOp = Is128Bit ? X86::VPBROADCASTQrZ128rr</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">      unsigned BroadcastOp = Is128Bit ? X86::VPBROADCASTQrZ128rr</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">                                      : Is256Bit ? X86::VPBROADCASTQrZ256rr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">                                      : Is256Bit ? X86::VPBROADCASTQrZ256rr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">                                                 : X86::VPBROADCASTQrZrr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">                                                 : X86::VPBROADCASTQrZrr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">      auto BroadcastI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">      auto BroadcastI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">          BuildMI(MBB, InsertPt, Loc, TII->get(BroadcastOp), VStateReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">          BuildMI(MBB, InsertPt, Loc, TII->get(BroadcastOp), VStateReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">              .addReg(StateReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">              .addReg(StateReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">      (void)BroadcastI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">      (void)BroadcastI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting broadcast: "; BroadcastI->dump();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting broadcast: "; BroadcastI->dump();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">                 dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">                 dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">      // Merge our potential poison state into the value with a vector or.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">      // Merge our potential poison state into the value with a vector or.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">      unsigned OrOp = Is128Bit ? X86::VPORQZ128rr</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">      unsigned OrOp = Is128Bit ? X86::VPORQZ128rr</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">                               : Is256Bit ? X86::VPORQZ256rr : X86::VPORQZrr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">                               : Is256Bit ? X86::VPORQZ256rr : X86::VPORQZrr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">      auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(OrOp), TmpReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">      auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(OrOp), TmpReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">                     .addReg(VStateReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">                     .addReg(VStateReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">                     .addReg(OpReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">                     .addReg(OpReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">      (void)OrI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">      (void)OrI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">      ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">      // FIXME: Need to support GR32 here for 32-bit code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">      // FIXME: Need to support GR32 here for 32-bit code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">      assert(OpRC->hasSuperClassEq(&X86::GR64RegClass) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">      assert(OpRC->hasSuperClassEq(&X86::GR64RegClass) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">             "Not a supported register class for address hardening!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">             "Not a supported register class for address hardening!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">      if (!EFLAGSLive) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">      if (!EFLAGSLive) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">        // Merge our potential poison state into the value with an or.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">        // Merge our potential poison state into the value with an or.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">        auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::OR64rr), TmpReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">        auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(X86::OR64rr), TmpReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">                       .addReg(StateReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">                       .addReg(StateReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">                       .addReg(OpReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">                       .addReg(OpReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">        OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">        OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">        ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">        ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">        // We need to avoid touching EFLAGS so shift out all but the least</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">        // We need to avoid touching EFLAGS so shift out all but the least</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">        // significant bit using the instruction that doesn't update flags.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">        // significant bit using the instruction that doesn't update flags.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">        auto ShiftI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">        auto ShiftI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">            BuildMI(MBB, InsertPt, Loc, TII->get(X86::SHRX64rr), TmpReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">            BuildMI(MBB, InsertPt, Loc, TII->get(X86::SHRX64rr), TmpReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">                .addReg(OpReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">                .addReg(OpReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">                .addReg(StateReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">                .addReg(StateReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">        (void)ShiftI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">        (void)ShiftI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">        ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">        ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "  Inserting shrx: "; ShiftI->dump();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "  Inserting shrx: "; ShiftI->dump();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">                   dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">                   dbgs() << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">    // Record this register as checked and update the operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">    // Record this register as checked and update the operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">    assert(!AddrRegToHardenedReg.count(Op->getReg()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">    assert(!AddrRegToHardenedReg.count(Op->getReg()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">           "Should not have checked this register yet!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">           "Should not have checked this register yet!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">    AddrRegToHardenedReg[Op->getReg()] = TmpReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">    AddrRegToHardenedReg[Op->getReg()] = TmpReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">    Op->setReg(TmpReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">    Op->setReg(TmpReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">    ++NumAddrRegsHardened;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">    ++NumAddrRegsHardened;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">  // And restore the flags if needed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">  // And restore the flags if needed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">  if (FlagsReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">  if (FlagsReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">    restoreEFLAGS(MBB, InsertPt, Loc, FlagsReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">    restoreEFLAGS(MBB, InsertPt, Loc, FlagsReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">MachineInstr *X86SpeculativeLoadHardeningPass::sinkPostLoadHardenedInst(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">MachineInstr *X86SpeculativeLoadHardeningPass::sinkPostLoadHardenedInst(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">    MachineInstr &InitialMI, SmallPtrSetImpl<MachineInstr *> &HardenedInstrs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">    MachineInstr &InitialMI, SmallPtrSetImpl<MachineInstr *> &HardenedInstrs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">  assert(X86InstrInfo::isDataInvariantLoad(InitialMI) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">  assert(X86InstrInfo::isDataInvariantLoad(InitialMI) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">         "Cannot get here with a non-invariant load!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">         "Cannot get here with a non-invariant load!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">  assert(!isEFLAGSDefLive(InitialMI) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">  assert(!isEFLAGSDefLive(InitialMI) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">         "Cannot get here with a data invariant load "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">         "Cannot get here with a data invariant load "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">         "that interferes with EFLAGS!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">         "that interferes with EFLAGS!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">  // See if we can sink hardening the loaded value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">  // See if we can sink hardening the loaded value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">  auto SinkCheckToSingleUse =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">  auto SinkCheckToSingleUse =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">      [&](MachineInstr &MI) -> std::optional<MachineInstr *> {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">      [&](MachineInstr &MI) -> std::optional<MachineInstr *> {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">    Register DefReg = MI.getOperand(0).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">    Register DefReg = MI.getOperand(0).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">    // We need to find a single use which we can sink the check. We can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">    // We need to find a single use which we can sink the check. We can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">    // primarily do this because many uses may already end up checked on their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">    // primarily do this because many uses may already end up checked on their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">    // own.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">    // own.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">    MachineInstr *SingleUseMI = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">    MachineInstr *SingleUseMI = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">    for (MachineInstr &UseMI : MRI->use_instructions(DefReg)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">    for (MachineInstr &UseMI : MRI->use_instructions(DefReg)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">      // If we're already going to harden this use, it is data invariant, it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">      // If we're already going to harden this use, it is data invariant, it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">      // does not interfere with EFLAGS, and within our block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">      // does not interfere with EFLAGS, and within our block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">      if (HardenedInstrs.count(&UseMI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">      if (HardenedInstrs.count(&UseMI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">        if (!X86InstrInfo::isDataInvariantLoad(UseMI) || isEFLAGSDefLive(UseMI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">        if (!X86InstrInfo::isDataInvariantLoad(UseMI) || isEFLAGSDefLive(UseMI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">          // If we've already decided to harden a non-load, we must have sunk</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">          // If we've already decided to harden a non-load, we must have sunk</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">          // some other post-load hardened instruction to it and it must itself</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">          // some other post-load hardened instruction to it and it must itself</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">          // be data-invariant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">          // be data-invariant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">          assert(X86InstrInfo::isDataInvariant(UseMI) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">          assert(X86InstrInfo::isDataInvariant(UseMI) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">                 "Data variant instruction being hardened!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">                 "Data variant instruction being hardened!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">        // Otherwise, this is a load and the load component can't be data</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">        // Otherwise, this is a load and the load component can't be data</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">        // invariant so check how this register is being used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">        // invariant so check how this register is being used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">        const MCInstrDesc &Desc = UseMI.getDesc();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">        const MCInstrDesc &Desc = UseMI.getDesc();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">        int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">        int MemRefBeginIdx = X86II::getMemoryOperandNo(Desc.TSFlags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">        assert(MemRefBeginIdx >= 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">        assert(MemRefBeginIdx >= 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">               "Should always have mem references here!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">               "Should always have mem references here!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">        MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">        MemRefBeginIdx += X86II::getOperandBias(Desc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">        MachineOperand &BaseMO =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">        MachineOperand &BaseMO =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">            UseMI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">            UseMI.getOperand(MemRefBeginIdx + X86::AddrBaseReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">        MachineOperand &IndexMO =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">        MachineOperand &IndexMO =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">            UseMI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">            UseMI.getOperand(MemRefBeginIdx + X86::AddrIndexReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">        if ((BaseMO.isReg() && BaseMO.getReg() == DefReg) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">        if ((BaseMO.isReg() && BaseMO.getReg() == DefReg) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">            (IndexMO.isReg() && IndexMO.getReg() == DefReg))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">            (IndexMO.isReg() && IndexMO.getReg() == DefReg))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">          // The load uses the register as part of its address making it not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">          // The load uses the register as part of its address making it not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">          // invariant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">          // invariant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">          return {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">          return {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">      if (SingleUseMI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">      if (SingleUseMI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">        // We already have a single use, this would make two. Bail.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">        // We already have a single use, this would make two. Bail.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">        return {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">        return {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">      // If this single use isn't data invariant, isn't in this block, or has</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">      // If this single use isn't data invariant, isn't in this block, or has</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">      // interfering EFLAGS, we can't sink the hardening to it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">      // interfering EFLAGS, we can't sink the hardening to it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">      if (!X86InstrInfo::isDataInvariant(UseMI) || UseMI.getParent() != MI.getParent() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">      if (!X86InstrInfo::isDataInvariant(UseMI) || UseMI.getParent() != MI.getParent() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">          isEFLAGSDefLive(UseMI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">          isEFLAGSDefLive(UseMI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">        return {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">        return {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">      // If this instruction defines multiple registers bail as we won't harden</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">      // If this instruction defines multiple registers bail as we won't harden</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">      // all of them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">      // all of them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">      if (UseMI.getDesc().getNumDefs() > 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">      if (UseMI.getDesc().getNumDefs() > 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">        return {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">        return {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">      // If this register isn't a virtual register we can't walk uses of sanely,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">      // If this register isn't a virtual register we can't walk uses of sanely,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">      // just bail. Also check that its register class is one of the ones we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">      // just bail. Also check that its register class is one of the ones we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">      // can harden.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">      // can harden.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">      Register UseDefReg = UseMI.getOperand(0).getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">      Register UseDefReg = UseMI.getOperand(0).getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">      if (!UseDefReg.isVirtual() || !canHardenRegister(UseDefReg))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">      if (!UseDefReg.isVirtual() || !canHardenRegister(UseDefReg))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">        return {};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">        return {};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">      SingleUseMI = &UseMI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">      SingleUseMI = &UseMI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">    // If SingleUseMI is still null, there is no use that needs its own</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">    // If SingleUseMI is still null, there is no use that needs its own</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">    // checking. Otherwise, it is the single use that needs checking.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">    // checking. Otherwise, it is the single use that needs checking.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">    return {SingleUseMI};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">    return {SingleUseMI};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">  MachineInstr *MI = &InitialMI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">  MachineInstr *MI = &InitialMI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">  while (std::optional<MachineInstr *> SingleUse = SinkCheckToSingleUse(*MI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">  while (std::optional<MachineInstr *> SingleUse = SinkCheckToSingleUse(*MI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">    // Update which MI we're checking now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">    // Update which MI we're checking now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">    MI = *SingleUse;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">    MI = *SingleUse;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">    if (!MI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">    if (!MI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">  return MI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">  return MI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">bool X86SpeculativeLoadHardeningPass::canHardenRegister(Register Reg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">bool X86SpeculativeLoadHardeningPass::canHardenRegister(Register Reg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">  auto *RC = MRI->getRegClass(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">  auto *RC = MRI->getRegClass(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">  int RegBytes = TRI->getRegSizeInBits(*RC) / 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">  int RegBytes = TRI->getRegSizeInBits(*RC) / 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">  if (RegBytes > 8)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">  if (RegBytes > 8)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">    // We don't support post-load hardening of vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">    // We don't support post-load hardening of vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">  unsigned RegIdx = Log2_32(RegBytes);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">  unsigned RegIdx = Log2_32(RegBytes);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">  assert(RegIdx < 4 && "Unsupported register size");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">  assert(RegIdx < 4 && "Unsupported register size");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">  // If this register class is explicitly constrained to a class that doesn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">  // If this register class is explicitly constrained to a class that doesn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">  // require REX prefix, we may not be able to satisfy that constraint when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">  // require REX prefix, we may not be able to satisfy that constraint when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">  // emitting the hardening instructions, so bail out here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">  // emitting the hardening instructions, so bail out here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">  // FIXME: This seems like a pretty lame hack. The way this comes up is when we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">  // FIXME: This seems like a pretty lame hack. The way this comes up is when we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">  // end up both with a NOREX and REX-only register as operands to the hardening</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">  // end up both with a NOREX and REX-only register as operands to the hardening</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">  // instructions. It would be better to fix that code to handle this situation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">  // instructions. It would be better to fix that code to handle this situation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">  // rather than hack around it in this way.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">  // rather than hack around it in this way.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">  const TargetRegisterClass *NOREXRegClasses[] = {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">  const TargetRegisterClass *NOREXRegClasses[] = {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">      &X86::GR8_NOREXRegClass, &X86::GR16_NOREXRegClass,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">      &X86::GR8_NOREXRegClass, &X86::GR16_NOREXRegClass,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">      &X86::GR32_NOREXRegClass, &X86::GR64_NOREXRegClass};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">      &X86::GR32_NOREXRegClass, &X86::GR64_NOREXRegClass};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">  if (RC == NOREXRegClasses[RegIdx])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">  if (RC == NOREXRegClasses[RegIdx])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">  const TargetRegisterClass *GPRRegClasses[] = {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">  const TargetRegisterClass *GPRRegClasses[] = {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">      &X86::GR8RegClass, &X86::GR16RegClass, &X86::GR32RegClass,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">      &X86::GR8RegClass, &X86::GR16RegClass, &X86::GR32RegClass,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">      &X86::GR64RegClass};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">      &X86::GR64RegClass};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">  return RC->hasSuperClassEq(GPRRegClasses[RegIdx]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">  return RC->hasSuperClassEq(GPRRegClasses[RegIdx]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">/// Harden a value in a register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">/// Harden a value in a register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">/// This is the low-level logic to fully harden a value sitting in a register</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">/// This is the low-level logic to fully harden a value sitting in a register</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">/// against leaking during speculative execution.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">/// against leaking during speculative execution.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">/// Unlike hardening an address that is used by a load, this routine is required</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">/// Unlike hardening an address that is used by a load, this routine is required</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">/// to hide *all* incoming bits in the register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">/// to hide *all* incoming bits in the register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">/// `Reg` must be a virtual register. Currently, it is required to be a GPR no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">/// `Reg` must be a virtual register. Currently, it is required to be a GPR no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">/// larger than the predicate state register. FIXME: We should support vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">/// larger than the predicate state register. FIXME: We should support vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">/// registers here by broadcasting the predicate state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">/// registers here by broadcasting the predicate state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">/// The new, hardened virtual register is returned. It will have the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">/// The new, hardened virtual register is returned. It will have the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">/// register class as `Reg`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">/// register class as `Reg`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">unsigned X86SpeculativeLoadHardeningPass::hardenValueInRegister(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">unsigned X86SpeculativeLoadHardeningPass::hardenValueInRegister(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">    Register Reg, MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">    Register Reg, MachineBasicBlock &MBB, MachineBasicBlock::iterator InsertPt,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">    const DebugLoc &Loc) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">    const DebugLoc &Loc) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">  assert(canHardenRegister(Reg) && "Cannot harden this register!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">  assert(canHardenRegister(Reg) && "Cannot harden this register!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">  assert(Reg.isVirtual() && "Cannot harden a physical register!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">  assert(Reg.isVirtual() && "Cannot harden a physical register!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">  auto *RC = MRI->getRegClass(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">  auto *RC = MRI->getRegClass(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">  int Bytes = TRI->getRegSizeInBits(*RC) / 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">  int Bytes = TRI->getRegSizeInBits(*RC) / 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">  assert((Bytes == 1 || Bytes == 2 || Bytes == 4 || Bytes == 8) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">  assert((Bytes == 1 || Bytes == 2 || Bytes == 4 || Bytes == 8) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">         "Unknown register size");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">         "Unknown register size");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">  // FIXME: Need to teach this about 32-bit mode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">  // FIXME: Need to teach this about 32-bit mode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">  if (Bytes != 8) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">  if (Bytes != 8) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">    unsigned SubRegImms[] = {X86::sub_8bit, X86::sub_16bit, X86::sub_32bit};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">    unsigned SubRegImms[] = {X86::sub_8bit, X86::sub_16bit, X86::sub_32bit};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">    unsigned SubRegImm = SubRegImms[Log2_32(Bytes)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">    unsigned SubRegImm = SubRegImms[Log2_32(Bytes)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">    Register NarrowStateReg = MRI->createVirtualRegister(RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">    Register NarrowStateReg = MRI->createVirtualRegister(RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">    BuildMI(MBB, InsertPt, Loc, TII->get(TargetOpcode::COPY), NarrowStateReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">    BuildMI(MBB, InsertPt, Loc, TII->get(TargetOpcode::COPY), NarrowStateReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">        .addReg(StateReg, 0, SubRegImm);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">        .addReg(StateReg, 0, SubRegImm);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">    StateReg = NarrowStateReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">    StateReg = NarrowStateReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">  unsigned FlagsReg = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">  unsigned FlagsReg = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine">  if (isEFLAGSLive(MBB, InsertPt, *TRI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine">  if (isEFLAGSLive(MBB, InsertPt, *TRI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">    FlagsReg = saveEFLAGS(MBB, InsertPt, Loc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">    FlagsReg = saveEFLAGS(MBB, InsertPt, Loc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">  Register NewReg = MRI->createVirtualRegister(RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">  Register NewReg = MRI->createVirtualRegister(RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">  unsigned OrOpCodes[] = {X86::OR8rr, X86::OR16rr, X86::OR32rr, X86::OR64rr};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">  unsigned OrOpCodes[] = {X86::OR8rr, X86::OR16rr, X86::OR32rr, X86::OR64rr};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">  unsigned OrOpCode = OrOpCodes[Log2_32(Bytes)];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">  unsigned OrOpCode = OrOpCodes[Log2_32(Bytes)];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">  auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(OrOpCode), NewReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">  auto OrI = BuildMI(MBB, InsertPt, Loc, TII->get(OrOpCode), NewReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">                 .addReg(StateReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">                 .addReg(StateReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">                 .addReg(Reg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">                 .addReg(Reg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">  OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">  OrI->addRegisterDead(X86::EFLAGS, TRI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Inserting or: "; OrI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">  if (FlagsReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">  if (FlagsReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">    restoreEFLAGS(MBB, InsertPt, Loc, FlagsReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">    restoreEFLAGS(MBB, InsertPt, Loc, FlagsReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">  return NewReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">  return NewReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">/// Harden a load by hardening the loaded value in the defined register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">/// Harden a load by hardening the loaded value in the defined register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">/// We can harden a non-leaking load into a register without touching the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">/// We can harden a non-leaking load into a register without touching the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">/// address by just hiding all of the loaded bits during misspeculation. We use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">/// address by just hiding all of the loaded bits during misspeculation. We use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">/// an `or` instruction to do this because we set up our poison value as all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">/// an `or` instruction to do this because we set up our poison value as all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">/// ones. And the goal is just for the loaded bits to not be exposed to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">/// ones. And the goal is just for the loaded bits to not be exposed to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">/// execution and coercing them to one is sufficient.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">/// execution and coercing them to one is sufficient.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">/// Returns the newly hardened register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">/// Returns the newly hardened register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">unsigned X86SpeculativeLoadHardeningPass::hardenPostLoad(MachineInstr &MI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">unsigned X86SpeculativeLoadHardeningPass::hardenPostLoad(MachineInstr &MI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">  auto &DefOp = MI.getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">  auto &DefOp = MI.getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">  Register OldDefReg = DefOp.getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">  Register OldDefReg = DefOp.getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">  auto *DefRC = MRI->getRegClass(OldDefReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">  auto *DefRC = MRI->getRegClass(OldDefReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">  // Because we want to completely replace the uses of this def'ed value with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">  // Because we want to completely replace the uses of this def'ed value with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">  // the hardened value, create a dedicated new register that will only be used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">  // the hardened value, create a dedicated new register that will only be used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">  // to communicate the unhardened value to the hardening.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">  // to communicate the unhardened value to the hardening.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">  Register UnhardenedReg = MRI->createVirtualRegister(DefRC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">  Register UnhardenedReg = MRI->createVirtualRegister(DefRC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">  DefOp.setReg(UnhardenedReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">  DefOp.setReg(UnhardenedReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">  // Now harden this register's value, getting a hardened reg that is safe to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">  // Now harden this register's value, getting a hardened reg that is safe to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">  // use. Note that we insert the instructions to compute this *after* the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">  // use. Note that we insert the instructions to compute this *after* the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">  // defining instruction, not before it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">  // defining instruction, not before it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">  unsigned HardenedReg = hardenValueInRegister(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">  unsigned HardenedReg = hardenValueInRegister(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">      UnhardenedReg, MBB, std::next(MI.getIterator()), Loc);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">      UnhardenedReg, MBB, std::next(MI.getIterator()), Loc);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">  // Finally, replace the old register (which now only has the uses of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">  // Finally, replace the old register (which now only has the uses of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">  // original def) with the hardened register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">  // original def) with the hardened register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">  MRI->replaceRegWith(/*FromReg*/ OldDefReg, /*ToReg*/ HardenedReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">  MRI->replaceRegWith(/*FromReg*/ OldDefReg, /*ToReg*/ HardenedReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">  ++NumPostLoadRegsHardened;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">  ++NumPostLoadRegsHardened;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">  return HardenedReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">  return HardenedReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">/// Harden a return instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">/// Harden a return instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">/// Returns implicitly perform a load which we need to harden. Without hardening</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">/// Returns implicitly perform a load which we need to harden. Without hardening</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">/// this load, an attacker my speculatively write over the return address to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">/// this load, an attacker my speculatively write over the return address to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">/// steer speculation of the return to an attacker controlled address. This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">/// steer speculation of the return to an attacker controlled address. This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">/// called Spectre v1.1 or Bounds Check Bypass Store (BCBS) and is described in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">/// called Spectre v1.1 or Bounds Check Bypass Store (BCBS) and is described in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">/// this paper:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">/// this paper:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">/// https://people.csail.mit.edu/vlk/spectre11.pdf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">/// https://people.csail.mit.edu/vlk/spectre11.pdf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">/// We can harden this by introducing an LFENCE that will delay any load of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">/// We can harden this by introducing an LFENCE that will delay any load of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">/// return address until prior instructions have retired (and thus are not being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">/// return address until prior instructions have retired (and thus are not being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">/// speculated), or we can harden the address used by the implicit load: the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">/// speculated), or we can harden the address used by the implicit load: the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">/// stack pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">/// stack pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">/// If we are not using an LFENCE, hardening the stack pointer has an additional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">/// If we are not using an LFENCE, hardening the stack pointer has an additional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">/// benefit: it allows us to pass the predicate state accumulated in this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">/// benefit: it allows us to pass the predicate state accumulated in this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">/// function back to the caller. In the absence of a BCBS attack on the return,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">/// function back to the caller. In the absence of a BCBS attack on the return,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">/// the caller will typically be resumed and speculatively executed due to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">/// the caller will typically be resumed and speculatively executed due to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">/// Return Stack Buffer (RSB) prediction which is very accurate and has a high</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">/// Return Stack Buffer (RSB) prediction which is very accurate and has a high</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">/// priority. It is possible that some code from the caller will be executed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">/// priority. It is possible that some code from the caller will be executed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">/// speculatively even during a BCBS-attacked return until the steering takes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">/// speculatively even during a BCBS-attacked return until the steering takes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">/// effect. Whenever this happens, the caller can recover the (poisoned)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">/// effect. Whenever this happens, the caller can recover the (poisoned)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">/// predicate state from the stack pointer and continue to harden loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">/// predicate state from the stack pointer and continue to harden loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::hardenReturnInstr(MachineInstr &MI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::hardenReturnInstr(MachineInstr &MI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">  auto InsertPt = MI.getIterator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">  auto InsertPt = MI.getIterator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">  if (FenceCallAndRet)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">  if (FenceCallAndRet)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">    // No need to fence here as we'll fence at the return site itself. That</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">    // No need to fence here as we'll fence at the return site itself. That</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">    // handles more cases than we can handle here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">    // handles more cases than we can handle here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">  // Take our predicate state, shift it to the high 17 bits (so that we keep</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">  // Take our predicate state, shift it to the high 17 bits (so that we keep</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">  // pointers canonical) and merge it into RSP. This will allow the caller to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">  // pointers canonical) and merge it into RSP. This will allow the caller to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">  // extract it when we return (speculatively).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">  // extract it when we return (speculatively).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">  mergePredStateIntoSP(MBB, InsertPt, Loc, PS->SSA.GetValueAtEndOfBlock(&MBB));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">  mergePredStateIntoSP(MBB, InsertPt, Loc, PS->SSA.GetValueAtEndOfBlock(&MBB));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">/// Trace the predicate state through a call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">/// Trace the predicate state through a call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">/// There are several layers of this needed to handle the full complexity of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">/// There are several layers of this needed to handle the full complexity of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">/// calls.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">/// calls.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">/// First, we need to send the predicate state into the called function. We do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">/// First, we need to send the predicate state into the called function. We do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">/// this by merging it into the high bits of the stack pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">/// this by merging it into the high bits of the stack pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">/// For tail calls, this is all we need to do.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">/// For tail calls, this is all we need to do.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">/// For calls where we might return and resume the control flow, we need to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">/// For calls where we might return and resume the control flow, we need to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">/// extract the predicate state from the high bits of the stack pointer after</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">/// extract the predicate state from the high bits of the stack pointer after</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">/// control returns from the called function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">/// control returns from the called function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">/// We also need to verify that we intended to return to this location in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">/// We also need to verify that we intended to return to this location in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">/// code. An attacker might arrange for the processor to mispredict the return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">/// code. An attacker might arrange for the processor to mispredict the return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">/// to this valid but incorrect return address in the program rather than the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">/// to this valid but incorrect return address in the program rather than the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">/// correct one. See the paper on this attack, called "ret2spec" by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">/// correct one. See the paper on this attack, called "ret2spec" by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">/// researchers, here:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">/// researchers, here:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">/// https://christian-rossow.de/publications/ret2spec-ccs2018.pdf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">/// https://christian-rossow.de/publications/ret2spec-ccs2018.pdf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">/// The way we verify that we returned to the correct location is by preserving</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">/// The way we verify that we returned to the correct location is by preserving</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">/// the expected return address across the call. One technique involves taking</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">/// the expected return address across the call. One technique involves taking</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">/// advantage of the red-zone to load the return address from `8(%rsp)` where it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">/// advantage of the red-zone to load the return address from `8(%rsp)` where it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">/// was left by the RET instruction when it popped `%rsp`. Alternatively, we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">/// was left by the RET instruction when it popped `%rsp`. Alternatively, we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">/// directly save the address into a register that will be preserved across the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">/// directly save the address into a register that will be preserved across the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">/// call. We compare this intended return address against the address</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">/// call. We compare this intended return address against the address</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">/// immediately following the call (the observed return address). If these</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">/// immediately following the call (the observed return address). If these</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">/// mismatch, we have detected misspeculation and can poison our predicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">/// mismatch, we have detected misspeculation and can poison our predicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">/// state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">/// state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::tracePredStateThroughCall(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::tracePredStateThroughCall(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">    MachineInstr &MI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">    MachineInstr &MI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine">  MachineBasicBlock &MBB = *MI.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">  MachineFunction &MF = *MBB.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">  MachineFunction &MF = *MBB.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">  auto InsertPt = MI.getIterator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">  auto InsertPt = MI.getIterator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">  const DebugLoc &Loc = MI.getDebugLoc();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">  if (FenceCallAndRet) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">  if (FenceCallAndRet) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">    if (MI.isReturn())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">    if (MI.isReturn())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">      // Tail call, we don't return to this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">      // Tail call, we don't return to this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">      // FIXME: We should also handle noreturn calls.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">      // FIXME: We should also handle noreturn calls.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">    // We don't need to fence before the call because the function should fence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">    // We don't need to fence before the call because the function should fence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">    // in its entry. However, we do need to fence after the call returns.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">    // in its entry. However, we do need to fence after the call returns.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">    // Fencing before the return doesn't correctly handle cases where the return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">    // Fencing before the return doesn't correctly handle cases where the return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">    // itself is mispredicted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">    // itself is mispredicted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">    BuildMI(MBB, std::next(InsertPt), Loc, TII->get(X86::LFENCE));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">    BuildMI(MBB, std::next(InsertPt), Loc, TII->get(X86::LFENCE));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">    ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">    ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">    ++NumLFENCEsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">    ++NumLFENCEsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">  // First, we transfer the predicate state into the called function by merging</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">  // First, we transfer the predicate state into the called function by merging</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">  // it into the stack pointer. This will kill the current def of the state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">  // it into the stack pointer. This will kill the current def of the state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">  Register StateReg = PS->SSA.GetValueAtEndOfBlock(&MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">  mergePredStateIntoSP(MBB, InsertPt, Loc, StateReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">  mergePredStateIntoSP(MBB, InsertPt, Loc, StateReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">  // If this call is also a return, it is a tail call and we don't need anything</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">  // If this call is also a return, it is a tail call and we don't need anything</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">  // else to handle it so just return. Also, if there are no further</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">  // else to handle it so just return. Also, if there are no further</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">  // instructions and no successors, this call does not return so we can also</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">  // instructions and no successors, this call does not return so we can also</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">  // bail.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">  // bail.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">  if (MI.isReturn() || (std::next(InsertPt) == MBB.end() && MBB.succ_empty()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">  if (MI.isReturn() || (std::next(InsertPt) == MBB.end() && MBB.succ_empty()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">  // Create a symbol to track the return address and attach it to the call</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">  // Create a symbol to track the return address and attach it to the call</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">  // machine instruction. We will lower extra symbols attached to call</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">  // machine instruction. We will lower extra symbols attached to call</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">  // instructions as label immediately following the call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">  // instructions as label immediately following the call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">  MCSymbol *RetSymbol =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">  MCSymbol *RetSymbol =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">      MF.getContext().createTempSymbol("slh_ret_addr",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">      MF.getContext().createTempSymbol("slh_ret_addr",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">                                       /*AlwaysAddSuffix*/ true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">                                       /*AlwaysAddSuffix*/ true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">  MI.setPostInstrSymbol(MF, RetSymbol);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">  MI.setPostInstrSymbol(MF, RetSymbol);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">  const TargetRegisterClass *AddrRC = &X86::GR64RegClass;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">  const TargetRegisterClass *AddrRC = &X86::GR64RegClass;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">  unsigned ExpectedRetAddrReg = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">  unsigned ExpectedRetAddrReg = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">  // If we have no red zones or if the function returns twice (possibly without</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">  // If we have no red zones or if the function returns twice (possibly without</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">  // using the `ret` instruction) like setjmp, we need to save the expected</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">  // using the `ret` instruction) like setjmp, we need to save the expected</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">  // return address prior to the call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">  // return address prior to the call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">  if (!Subtarget->getFrameLowering()->has128ByteRedZone(MF) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">  if (!Subtarget->getFrameLowering()->has128ByteRedZone(MF) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">      MF.exposesReturnsTwice()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">      MF.exposesReturnsTwice()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">    // If we don't have red zones, we need to compute the expected return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">    // If we don't have red zones, we need to compute the expected return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">    // address prior to the call and store it in a register that lives across</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">    // address prior to the call and store it in a register that lives across</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">    // the call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">    // the call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">    // In some ways, this is doubly satisfying as a mitigation because it will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">    // In some ways, this is doubly satisfying as a mitigation because it will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">    // also successfully detect stack smashing bugs in some cases (typically,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">    // also successfully detect stack smashing bugs in some cases (typically,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">    // when a callee-saved register is used and the callee doesn't push it onto</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">    // when a callee-saved register is used and the callee doesn't push it onto</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">    // the stack). But that isn't our primary goal, so we only use it as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">    // the stack). But that isn't our primary goal, so we only use it as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">    // a fallback.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">    // a fallback.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">    // FIXME: It isn't clear that this is reliable in the face of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">    // FIXME: It isn't clear that this is reliable in the face of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">    // rematerialization in the register allocator. We somehow need to force</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">    // rematerialization in the register allocator. We somehow need to force</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">    // that to not occur for this particular instruction, and instead to spill</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">    // that to not occur for this particular instruction, and instead to spill</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">    // or otherwise preserve the value computed *prior* to the call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">    // or otherwise preserve the value computed *prior* to the call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">    // FIXME: It is even less clear why MachineCSE can't just fold this when we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">    // FIXME: It is even less clear why MachineCSE can't just fold this when we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">    // end up having to use identical instructions both before and after the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">    // end up having to use identical instructions both before and after the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">    // call to feed the comparison.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">    // call to feed the comparison.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">    ExpectedRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">    ExpectedRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">    if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">    if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">        !Subtarget->isPositionIndependent()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">        !Subtarget->isPositionIndependent()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::MOV64ri32), ExpectedRetAddrReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::MOV64ri32), ExpectedRetAddrReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">          .addSym(RetSymbol);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">          .addSym(RetSymbol);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::LEA64r), ExpectedRetAddrReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">      BuildMI(MBB, InsertPt, Loc, TII->get(X86::LEA64r), ExpectedRetAddrReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">          .addReg(/*Base*/ X86::RIP)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">          .addReg(/*Base*/ X86::RIP)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">          .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">          .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">          .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">          .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">          .addSym(RetSymbol)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">          .addSym(RetSymbol)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">          .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">          .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">  // Step past the call to handle when it returns.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">  // Step past the call to handle when it returns.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">  ++InsertPt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">  ++InsertPt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">  // If we didn't pre-compute the expected return address into a register, then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">  // If we didn't pre-compute the expected return address into a register, then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">  // red zones are enabled and the return address is still available on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">  // red zones are enabled and the return address is still available on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">  // stack immediately after the call. As the very first instruction, we load it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">  // stack immediately after the call. As the very first instruction, we load it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">  // into a register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">  // into a register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">  if (!ExpectedRetAddrReg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">  if (!ExpectedRetAddrReg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">    ExpectedRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">    ExpectedRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::MOV64rm), ExpectedRetAddrReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::MOV64rm), ExpectedRetAddrReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">        .addReg(/*Base*/ X86::RSP)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">        .addReg(/*Base*/ X86::RSP)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">        .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">        .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">        .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">        .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">        .addImm(/*Displacement*/ -8) // The stack pointer has been popped, so</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">        .addImm(/*Displacement*/ -8) // The stack pointer has been popped, so</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">                                     // the return address is 8-bytes past it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">                                     // the return address is 8-bytes past it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">        .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">        .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">  // Now we extract the callee's predicate state from the stack pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">  // Now we extract the callee's predicate state from the stack pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">  unsigned NewStateReg = extractPredStateFromSP(MBB, InsertPt, Loc);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">  unsigned NewStateReg = extractPredStateFromSP(MBB, InsertPt, Loc);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">  // Test the expected return address against our actual address. If we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">  // Test the expected return address against our actual address. If we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">  // form this basic block's address as an immediate, this is easy. Otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">  // form this basic block's address as an immediate, this is easy. Otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">  // we compute it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">  // we compute it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">  if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">  if (MF.getTarget().getCodeModel() == CodeModel::Small &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">      !Subtarget->isPositionIndependent()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">      !Subtarget->isPositionIndependent()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">    // FIXME: Could we fold this with the load? It would require careful EFLAGS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">    // FIXME: Could we fold this with the load? It would require careful EFLAGS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">    // management.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">    // management.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::CMP64ri32))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::CMP64ri32))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">        .addReg(ExpectedRetAddrReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">        .addReg(ExpectedRetAddrReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">        .addSym(RetSymbol);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">        .addSym(RetSymbol);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">    Register ActualRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">    Register ActualRetAddrReg = MRI->createVirtualRegister(AddrRC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::LEA64r), ActualRetAddrReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::LEA64r), ActualRetAddrReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">        .addReg(/*Base*/ X86::RIP)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">        .addReg(/*Base*/ X86::RIP)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">        .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">        .addImm(/*Scale*/ 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">        .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">        .addReg(/*Index*/ 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">        .addSym(RetSymbol)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">        .addSym(RetSymbol)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">        .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">        .addReg(/*Segment*/ 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::CMP64rr))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">    BuildMI(MBB, InsertPt, Loc, TII->get(X86::CMP64rr))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">        .addReg(ExpectedRetAddrReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">        .addReg(ExpectedRetAddrReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">        .addReg(ActualRetAddrReg, RegState::Kill);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">        .addReg(ActualRetAddrReg, RegState::Kill);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">  // Now conditionally update the predicate state we just extracted if we ended</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">  // Now conditionally update the predicate state we just extracted if we ended</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">  // up at a different return address than expected.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">  // up at a different return address than expected.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">  int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">  int PredStateSizeInBytes = TRI->getRegSizeInBits(*PS->RC) / 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">  auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">  auto CMovOp = X86::getCMovOpcode(PredStateSizeInBytes);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">  Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">  Register UpdatedStateReg = MRI->createVirtualRegister(PS->RC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">  auto CMovI = BuildMI(MBB, InsertPt, Loc, TII->get(CMovOp), UpdatedStateReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">  auto CMovI = BuildMI(MBB, InsertPt, Loc, TII->get(CMovOp), UpdatedStateReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">                   .addReg(NewStateReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">                   .addReg(NewStateReg, RegState::Kill)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">                   .addReg(PS->PoisonReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">                   .addReg(PS->PoisonReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">                   .addImm(X86::COND_NE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">                   .addImm(X86::COND_NE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">  CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">  CMovI->findRegisterUseOperand(X86::EFLAGS)->setIsKill(true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">  ++NumInstsInserted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Inserting cmov: "; CMovI->dump(); dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">  PS->SSA.AddAvailableValue(&MBB, UpdatedStateReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">  PS->SSA.AddAvailableValue(&MBB, UpdatedStateReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">/// An attacker may speculatively store over a value that is then speculatively</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">/// An attacker may speculatively store over a value that is then speculatively</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">/// loaded and used as the target of an indirect call or jump instruction. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">/// loaded and used as the target of an indirect call or jump instruction. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">/// is called Spectre v1.2 or Bounds Check Bypass Store (BCBS) and is described</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">/// is called Spectre v1.2 or Bounds Check Bypass Store (BCBS) and is described</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">/// in this paper:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">/// in this paper:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">/// https://people.csail.mit.edu/vlk/spectre11.pdf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">/// https://people.csail.mit.edu/vlk/spectre11.pdf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">/// When this happens, the speculative execution of the call or jump will end up</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">/// When this happens, the speculative execution of the call or jump will end up</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">/// being steered to this attacker controlled address. While most such loads</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">/// being steered to this attacker controlled address. While most such loads</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">/// will be adequately hardened already, we want to ensure that they are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">/// will be adequately hardened already, we want to ensure that they are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">/// definitively treated as needing post-load hardening. While address hardening</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">/// definitively treated as needing post-load hardening. While address hardening</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">/// is sufficient to prevent secret data from leaking to the attacker, it may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">/// is sufficient to prevent secret data from leaking to the attacker, it may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">/// not be sufficient to prevent an attacker from steering speculative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">/// not be sufficient to prevent an attacker from steering speculative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">/// execution. We forcibly unfolded all relevant loads above and so will always</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">/// execution. We forcibly unfolded all relevant loads above and so will always</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">/// have an opportunity to post-load harden here, we just need to scan for cases</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">/// have an opportunity to post-load harden here, we just need to scan for cases</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine">/// not already flagged and add them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine">/// not already flagged and add them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::hardenIndirectCallOrJumpInstr(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">void X86SpeculativeLoadHardeningPass::hardenIndirectCallOrJumpInstr(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">    MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">    MachineInstr &MI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">    SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">    SmallDenseMap<unsigned, unsigned, 32> &AddrRegToHardenedReg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">  switch (MI.getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">  switch (MI.getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">  case X86::FARCALL16m:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">  case X86::FARCALL16m:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">  case X86::FARCALL32m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">  case X86::FARCALL32m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">  case X86::FARCALL64m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">  case X86::FARCALL64m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">  case X86::FARJMP16m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">  case X86::FARJMP16m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine">  case X86::FARJMP32m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine">  case X86::FARJMP32m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">  case X86::FARJMP64m:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">  case X86::FARJMP64m:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">    // We don't need to harden either far calls or far jumps as they are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">    // We don't need to harden either far calls or far jumps as they are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">    // safe from Spectre.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">    // safe from Spectre.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">  // We should never see a loading instruction at this point, as those should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">  // We should never see a loading instruction at this point, as those should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">  // have been unfolded.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">  // have been unfolded.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">  assert(!MI.mayLoad() && "Found a lingering loading instruction!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">  assert(!MI.mayLoad() && "Found a lingering loading instruction!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">  // If the first operand isn't a register, this is a branch or call</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">  // If the first operand isn't a register, this is a branch or call</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">  // instruction with an immediate operand which doesn't need to be hardened.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">  // instruction with an immediate operand which doesn't need to be hardened.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">  if (!MI.getOperand(0).isReg())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">  if (!MI.getOperand(0).isReg())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">  // For all of these, the target register is the first operand of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">  // For all of these, the target register is the first operand of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">  // instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">  // instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">  auto &TargetOp = MI.getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">  auto &TargetOp = MI.getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">  Register OldTargetReg = TargetOp.getReg();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">  Register OldTargetReg = TargetOp.getReg();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">  // Try to lookup a hardened version of this register. We retain a reference</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">  // Try to lookup a hardened version of this register. We retain a reference</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">  // here as we want to update the map to track any newly computed hardened</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">  // here as we want to update the map to track any newly computed hardened</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">  // register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">  // register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">  unsigned &HardenedTargetReg = AddrRegToHardenedReg[OldTargetReg];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">  unsigned &HardenedTargetReg = AddrRegToHardenedReg[OldTargetReg];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">  // If we don't have a hardened register yet, compute one. Otherwise, just use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">  // If we don't have a hardened register yet, compute one. Otherwise, just use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">  // the already hardened register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">  // the already hardened register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">  // FIXME: It is a little suspect that we use partially hardened registers that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">  // FIXME: It is a little suspect that we use partially hardened registers that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">  // only feed addresses. The complexity of partial hardening with SHRX</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">  // only feed addresses. The complexity of partial hardening with SHRX</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">  // continues to pile up. Should definitively measure its value and consider</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">  // continues to pile up. Should definitively measure its value and consider</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">  // eliminating it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">  // eliminating it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">  if (!HardenedTargetReg)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">  if (!HardenedTargetReg)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">    HardenedTargetReg = hardenValueInRegister(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">    HardenedTargetReg = hardenValueInRegister(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">        OldTargetReg, *MI.getParent(), MI.getIterator(), MI.getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">        OldTargetReg, *MI.getParent(), MI.getIterator(), MI.getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">  // Set the target operand to the hardened register.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">  // Set the target operand to the hardened register.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">  TargetOp.setReg(HardenedTargetReg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">  TargetOp.setReg(HardenedTargetReg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">  ++NumCallsOrJumpsHardened;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">  ++NumCallsOrJumpsHardened;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(X86SpeculativeLoadHardeningPass, PASS_KEY,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(X86SpeculativeLoadHardeningPass, PASS_KEY,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">                      "X86 speculative load hardener", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">                      "X86 speculative load hardener", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(X86SpeculativeLoadHardeningPass, PASS_KEY,</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(X86SpeculativeLoadHardeningPass, PASS_KEY,</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">                    "X86 speculative load hardener", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">                    "X86 speculative load hardener", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">FunctionPass *llvm::createX86SpeculativeLoadHardeningPass() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">FunctionPass *llvm::createX86SpeculativeLoadHardeningPass() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">  return new X86SpeculativeLoadHardeningPass();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">  return new X86SpeculativeLoadHardeningPass();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>