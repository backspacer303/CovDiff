<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ISDOpcodes.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===-- llvm/CodeGen/ISDOpcodes.h - CodeGen opcodes -------------*- C++ -*-===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This file declares codegen opcodes and related utilities.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">#ifndef LLVM_CODEGEN_ISDOPCODES_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">#define LLVM_CODEGEN_ISDOPCODES_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">/// ISD namespace - This namespace contains an enum which represents all of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">/// SelectionDAG node types and value types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">namespace ISD {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">//===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">/// ISD::NodeType enum - This enum defines the target-independent operators</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">/// for a SelectionDAG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">/// Targets may also define target-dependent operator codes for SDNodes. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">/// example, on x86, these are the enum values in the X86ISD namespace.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">/// Targets should aim to use target-independent operators to model their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">/// instruction sets as much as possible, and only use target-dependent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">/// operators when they have special requirements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">/// Finally, during and after selection proper, SNodes may use special</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">/// operator codes that correspond directly with MachineInstr opcodes. These</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">/// are used to represent selected instructions. See the isMachineOpcode()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">/// and getMachineOpcode() member functions of SDNode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">enum NodeType {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">  /// DELETED_NODE - This is an illegal value that is used to catch</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">  /// errors.  This opcode is not a legal opcode for any node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">  DELETED_NODE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">  /// EntryToken - This is the marker used to indicate the start of a region.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">  EntryToken,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">  /// TokenFactor - This node takes multiple tokens as input and produces a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">  /// single token result. This is used to represent the fact that the operand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">  /// operators are independent of each other.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">  TokenFactor,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">  /// AssertSext, AssertZext - These nodes record if a register contains a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">  /// value that has already been zero or sign extended from a narrower type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">  /// These nodes take two operands.  The first is the node that has already</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">  /// been extended, and the second is a value type node indicating the width</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">  /// of the extension.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">  /// NOTE: In case of the source value (or any vector element value) is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">  /// poisoned the assertion will not be true for that value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">  AssertSext,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">  AssertZext,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">  /// AssertAlign - These nodes record if a register contains a value that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">  /// has a known alignment and the trailing bits are known to be zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">  /// NOTE: In case of the source value (or any vector element value) is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">  /// poisoned the assertion will not be true for that value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">  AssertAlign,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">  /// Various leaf nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">  BasicBlock,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">  VALUETYPE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">  CONDCODE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">  Register,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">  RegisterMask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">  Constant,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">  ConstantFP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">  GlobalAddress,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">  GlobalTLSAddress,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">  FrameIndex,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">  JumpTable,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">  ConstantPool,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">  ExternalSymbol,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">  BlockAddress,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">  /// The address of the GOT</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">  GLOBAL_OFFSET_TABLE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">  /// FRAMEADDR, RETURNADDR - These nodes represent llvm.frameaddress and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">  /// llvm.returnaddress on the DAG.  These nodes take one operand, the index</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">  /// of the frame or return address to return.  An index of zero corresponds</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">  /// to the current function's frame or return address, an index of one to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">  /// the parent's frame or return address, and so on.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">  FRAMEADDR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">  RETURNADDR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">  /// ADDROFRETURNADDR - Represents the llvm.addressofreturnaddress intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">  /// This node takes no operand, returns a target-specific pointer to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">  /// place in the stack frame where the return address of the current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">  /// function is stored.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">  ADDROFRETURNADDR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">  /// SPONENTRY - Represents the llvm.sponentry intrinsic. Takes no argument</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">  /// and returns the stack pointer value at the entry of the current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">  /// function calling this intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">  SPONENTRY,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">  /// LOCAL_RECOVER - Represents the llvm.localrecover intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">  /// Materializes the offset from the local object pointer of another</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">  /// function to a particular local object passed to llvm.localescape. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">  /// operand is the MCSymbol label used to represent this offset, since</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">  /// typically the offset is not known until after code generation of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">  /// parent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">  LOCAL_RECOVER,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">  /// READ_REGISTER, WRITE_REGISTER - This node represents llvm.register on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">  /// the DAG, which implements the named register global variables extension.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">  READ_REGISTER,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">  WRITE_REGISTER,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">  /// FRAME_TO_ARGS_OFFSET - This node represents offset from frame pointer to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">  /// first (possible) on-stack argument. This is needed for correct stack</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">  /// adjustment during unwind.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">  FRAME_TO_ARGS_OFFSET,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">  /// EH_DWARF_CFA - This node represents the pointer to the DWARF Canonical</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">  /// Frame Address (CFA), generally the value of the stack pointer at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">  /// call site in the previous frame.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">  EH_DWARF_CFA,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">  /// OUTCHAIN = EH_RETURN(INCHAIN, OFFSET, HANDLER) - This node represents</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">  /// 'eh_return' gcc dwarf builtin, which is used to return from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">  /// exception. The general meaning is: adjust stack by OFFSET and pass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">  /// execution to HANDLER. Many platform-related details also :)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">  EH_RETURN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">  /// RESULT, OUTCHAIN = EH_SJLJ_SETJMP(INCHAIN, buffer)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">  /// This corresponds to the eh.sjlj.setjmp intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">  /// It takes an input chain and a pointer to the jump buffer as inputs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">  /// and returns an outchain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">  EH_SJLJ_SETJMP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">  /// OUTCHAIN = EH_SJLJ_LONGJMP(INCHAIN, buffer)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">  /// This corresponds to the eh.sjlj.longjmp intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">  /// It takes an input chain and a pointer to the jump buffer as inputs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">  /// and returns an outchain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">  EH_SJLJ_LONGJMP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">  /// OUTCHAIN = EH_SJLJ_SETUP_DISPATCH(INCHAIN)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">  /// The target initializes the dispatch table here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">  EH_SJLJ_SETUP_DISPATCH,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">  /// TargetConstant* - Like Constant*, but the DAG does not do any folding,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">  /// simplification, or lowering of the constant. They are used for constants</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">  /// which are known to fit in the immediate fields of their users, or for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">  /// carrying magic numbers which are not values which need to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">  /// materialized in registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">  TargetConstant,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">  TargetConstantFP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">  /// TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">  /// anything else with this node, and this is valid in the target-specific</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">  /// dag, turning into a GlobalAddress operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">  TargetGlobalAddress,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">  TargetGlobalTLSAddress,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">  TargetFrameIndex,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">  TargetJumpTable,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">  TargetConstantPool,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">  TargetExternalSymbol,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">  TargetBlockAddress,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">  MCSymbol,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">  /// TargetIndex - Like a constant pool entry, but with completely</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">  /// target-dependent semantics. Holds target flags, a 32-bit index, and a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">  /// 64-bit index. Targets can use this however they like.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">  TargetIndex,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">  /// RESULT = INTRINSIC_WO_CHAIN(INTRINSICID, arg1, arg2, ...)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">  /// This node represents a target intrinsic function with no side effects.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">  /// The first operand is the ID number of the intrinsic from the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">  /// llvm::Intrinsic namespace.  The operands to the intrinsic follow.  The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">  /// node returns the result of the intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">  INTRINSIC_WO_CHAIN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">  /// RESULT,OUTCHAIN = INTRINSIC_W_CHAIN(INCHAIN, INTRINSICID, arg1, ...)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">  /// This node represents a target intrinsic function with side effects that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">  /// returns a result.  The first operand is a chain pointer.  The second is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">  /// the ID number of the intrinsic from the llvm::Intrinsic namespace.  The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">  /// operands to the intrinsic follow.  The node has two results, the result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">  /// of the intrinsic and an output chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">  INTRINSIC_W_CHAIN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">  /// OUTCHAIN = INTRINSIC_VOID(INCHAIN, INTRINSICID, arg1, arg2, ...)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">  /// This node represents a target intrinsic function with side effects that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">  /// does not return a result.  The first operand is a chain pointer.  The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">  /// second is the ID number of the intrinsic from the llvm::Intrinsic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">  /// namespace.  The operands to the intrinsic follow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">  INTRINSIC_VOID,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">  /// CopyToReg - This node has three operands: a chain, a register number to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">  /// set to this value, and a value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">  CopyToReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  /// CopyFromReg - This node indicates that the input value is a virtual or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">  /// physical register that is defined outside of the scope of this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">  /// SelectionDAG.  The register is available from the RegisterSDNode object.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">  CopyFromReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">  /// UNDEF - An undefined node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">  UNDEF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">  // FREEZE - FREEZE(VAL) returns an arbitrary value if VAL is UNDEF (or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">  // is evaluated to UNDEF), or returns VAL otherwise. Note that each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">  // read of UNDEF can yield different value, but FREEZE(UNDEF) cannot.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">  FREEZE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">  /// EXTRACT_ELEMENT - This is used to get the lower or upper (determined by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">  /// a Constant, which is required to be operand #1) half of the integer or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">  /// float value specified as operand #0.  This is only for use before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">  /// legalization, for values that will be broken into multiple registers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">  EXTRACT_ELEMENT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">  /// BUILD_PAIR - This is the opposite of EXTRACT_ELEMENT in some ways.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">  /// Given two values of the same integer value type, this produces a value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">  /// twice as big.  Like EXTRACT_ELEMENT, this can only be used before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">  /// legalization. The lower part of the composite value should be in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">  /// element 0 and the upper part should be in element 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">  BUILD_PAIR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">  /// MERGE_VALUES - This node takes multiple discrete operands and returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">  /// them all as its individual results.  This nodes has exactly the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">  /// number of inputs and outputs. This node is useful for some pieces of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">  /// code generator that want to think about a single node with multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">  /// results, not multiple nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">  MERGE_VALUES,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">  /// Simple integer binary arithmetic operators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">  ADD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">  SUB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">  MUL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">  SDIV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">  UDIV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  SREM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">  UREM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">  /// SMUL_LOHI/UMUL_LOHI - Multiply two integers of type iN, producing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">  /// a signed/unsigned value of type i[2*N], and return the full value as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">  /// two results, each of type iN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">  SMUL_LOHI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">  UMUL_LOHI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">  /// SDIVREM/UDIVREM - Divide two integers and produce both a quotient and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">  /// remainder result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">  SDIVREM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="">  UDIVREM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">  /// CARRY_FALSE - This node is used when folding other nodes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">  /// like ADDC/SUBC, which indicate the carry result is always false.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">  CARRY_FALSE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">  /// Carry-setting nodes for multiple precision addition and subtraction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">  /// These nodes take two operands of the same value type, and produce two</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  /// results.  The first result is the normal add or sub result, the second</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">  /// result is the carry flag result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">  /// FIXME: These nodes are deprecated in favor of UADDO_CARRY and USUBO_CARRY.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">  /// They are kept around for now to provide a smooth transition path</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">  /// toward the use of UADDO_CARRY/USUBO_CARRY and will eventually be removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">  ADDC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">  SUBC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">  /// Carry-using nodes for multiple precision addition and subtraction. These</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">  /// nodes take three operands: The first two are the normal lhs and rhs to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">  /// the add or sub, and the third is the input carry flag.  These nodes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">  /// produce two results; the normal result of the add or sub, and the output</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">  /// carry flag.  These nodes both read and write a carry flag to allow them</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">  /// to them to be chained together for add and sub of arbitrarily large</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">  /// values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">  ADDE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">  SUBE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">  /// Carry-using nodes for multiple precision addition and subtraction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">  /// These nodes take three operands: The first two are the normal lhs and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">  /// rhs to the add or sub, and the third is a boolean value that is 1 if and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">  /// only if there is an incoming carry/borrow. These nodes produce two</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">  /// results: the normal result of the add or sub, and a boolean value that is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  /// 1 if and only if there is an outgoing carry/borrow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">  /// Care must be taken if these opcodes are lowered to hardware instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">  /// that use the inverse logic -- 0 if and only if there is an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">  /// incoming/outgoing carry/borrow.  In such cases, you must preserve the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">  /// semantics of these opcodes by inverting the incoming carry/borrow, feeding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">  /// it to the add/sub hardware instruction, and then inverting the outgoing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">  /// carry/borrow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">  /// The use of these opcodes is preferable to adde/sube if the target supports</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="">  /// it, as the carry is a regular value rather than a glue, which allows</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">  /// further optimisation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">  /// These opcodes are different from [US]{ADD,SUB}O in that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">  /// U{ADD,SUB}O_CARRY consume and produce a carry/borrow, whereas</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">  /// [US]{ADD,SUB}O produce an overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">  UADDO_CARRY,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="">  USUBO_CARRY,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="">  /// Carry-using overflow-aware nodes for multiple precision addition and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="">  /// subtraction. These nodes take three operands: The first two are normal lhs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">  /// and rhs to the add or sub, and the third is a boolean indicating if there</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">  /// is an incoming carry. They produce two results: the normal result of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">  /// add or sub, and a boolean that indicates if an overflow occurred (*not*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">  /// flag, because it may be a store to memory, etc.). If the type of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">  /// boolean is not i1 then the high bits conform to getBooleanContents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">  SADDO_CARRY,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">  SSUBO_CARRY,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">  /// RESULT, BOOL = [SU]ADDO(LHS, RHS) - Overflow-aware nodes for addition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">  /// These nodes take two operands: the normal LHS and RHS to the add. They</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">  /// produce two results: the normal result of the add, and a boolean that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">  /// indicates if an overflow occurred (*not* a flag, because it may be store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">  /// to memory, etc.).  If the type of the boolean is not i1 then the high</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">  /// bits conform to getBooleanContents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">  /// These nodes are generated from llvm.[su]add.with.overflow intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">  SADDO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">  UADDO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">  /// Same for subtraction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">  SSUBO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">  USUBO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">  /// Same for multiplication.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">  SMULO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">  UMULO,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">  /// RESULT = [US]ADDSAT(LHS, RHS) - Perform saturation addition on 2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">  /// integers with the same bit width (W). If the true value of LHS + RHS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">  /// exceeds the largest value that can be represented by W bits, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">  /// resulting value is this maximum value. Otherwise, if this value is less</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">  /// than the smallest value that can be represented by W bits, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">  /// resulting value is this minimum value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">  SADDSAT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">  UADDSAT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">  /// RESULT = [US]SUBSAT(LHS, RHS) - Perform saturation subtraction on 2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">  /// integers with the same bit width (W). If the true value of LHS - RHS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">  /// exceeds the largest value that can be represented by W bits, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">  /// resulting value is this maximum value. Otherwise, if this value is less</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">  /// than the smallest value that can be represented by W bits, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">  /// resulting value is this minimum value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">  SSUBSAT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">  USUBSAT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">  /// RESULT = [US]SHLSAT(LHS, RHS) - Perform saturation left shift. The first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">  /// operand is the value to be shifted, and the second argument is the amount</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">  /// to shift by. Both must be integers of the same bit width (W). If the true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">  /// value of LHS << RHS exceeds the largest value that can be represented by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">  /// W bits, the resulting value is this maximum value, Otherwise, if this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">  /// value is less than the smallest value that can be represented by W bits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">  /// the resulting value is this minimum value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">  SSHLSAT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">  USHLSAT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">  /// RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">  /// on 2 integers with the same width and scale. SCALE represents the scale</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">  /// of both operands as fixed point numbers. This SCALE parameter must be a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">  /// constant integer. A scale of zero is effectively performing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">  /// multiplication on 2 integers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">  SMULFIX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">  UMULFIX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">  /// Same as the corresponding unsaturated fixed point instructions, but the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">  /// result is clamped between the min and max values representable by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">  /// bits of the first 2 operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">  SMULFIXSAT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">  UMULFIXSAT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">  /// RESULT = [US]DIVFIX(LHS, RHS, SCALE) - Perform fixed point division on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="">  /// 2 integers with the same width and scale. SCALE represents the scale</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="">  /// of both operands as fixed point numbers. This SCALE parameter must be a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">  /// constant integer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">  SDIVFIX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">  UDIVFIX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">  /// Same as the corresponding unsaturated fixed point instructions, but the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">  /// result is clamped between the min and max values representable by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="">  /// bits of the first 2 operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">  SDIVFIXSAT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">  UDIVFIXSAT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="">  /// Simple binary floating point operators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">  FADD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">  FSUB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">  FMUL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">  FDIV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">  FREM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">  /// Constrained versions of the binary floating point operators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">  /// These will be lowered to the simple operators before final selection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">  /// They are used to limit optimizations while the DAG is being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">  /// optimized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">  STRICT_FADD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">  STRICT_FSUB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">  STRICT_FMUL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">  STRICT_FDIV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">  STRICT_FREM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">  STRICT_FMA,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">  /// Constrained versions of libm-equivalent floating point intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="">  /// These will be lowered to the equivalent non-constrained pseudo-op</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">  /// (or expanded to the equivalent library call) before final selection.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">  /// They are used to limit optimizations while the DAG is being optimized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">  STRICT_FSQRT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">  STRICT_FPOW,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">  STRICT_FPOWI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">  STRICT_FLDEXP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">  STRICT_FSIN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">  STRICT_FCOS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">  STRICT_FEXP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">  STRICT_FEXP2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">  STRICT_FLOG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">  STRICT_FLOG10,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">  STRICT_FLOG2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">  STRICT_FRINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">  STRICT_FNEARBYINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">  STRICT_FMAXNUM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">  STRICT_FMINNUM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  STRICT_FCEIL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">  STRICT_FFLOOR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">  STRICT_FROUND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">  STRICT_FROUNDEVEN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">  STRICT_FTRUNC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">  STRICT_LROUND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">  STRICT_LLROUND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">  STRICT_LRINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">  STRICT_LLRINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">  STRICT_FMAXIMUM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">  STRICT_FMINIMUM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">  /// STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">  /// unsigned integer. These have the same semantics as fptosi and fptoui</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="">  /// in IR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">  /// They are used to limit optimizations while the DAG is being optimized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">  STRICT_FP_TO_SINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">  STRICT_FP_TO_UINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">  /// STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">  /// a floating point value. These have the same semantics as sitofp and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">  /// uitofp in IR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">  /// They are used to limit optimizations while the DAG is being optimized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">  STRICT_SINT_TO_FP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">  STRICT_UINT_TO_FP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">  /// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">  /// point type down to the precision of the destination VT.  TRUNC is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">  /// flag, which is always an integer that is zero or one.  If TRUNC is 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">  /// this is a normal rounding, if it is 1, this FP_ROUND is known to not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">  /// change the value of Y.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">  /// The TRUNC = 1 case is used in cases where we know that the value will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">  /// not be modified by the node, because Y is not using any of the extra</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">  /// precision of source type.  This allows certain transformations like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">  /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="">  /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="">  /// removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">  /// It is used to limit optimizations while the DAG is being optimized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">  STRICT_FP_ROUND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">  /// X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">  /// type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">  /// It is used to limit optimizations while the DAG is being optimized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">  STRICT_FP_EXTEND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">  /// STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">  /// for floating-point operands only.  STRICT_FSETCC performs a quiet</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">  /// comparison operation, while STRICT_FSETCCS performs a signaling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">  /// comparison operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">  STRICT_FSETCC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">  STRICT_FSETCCS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">  // FPTRUNC_ROUND - This corresponds to the fptrunc_round intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">  FPTRUNC_ROUND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">  /// FMA - Perform a * b + c with no intermediate rounding step.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">  FMA,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">  /// FMAD - Perform a * b + c, while getting the same result as the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">  /// separately rounded operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">  FMAD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">  /// FCOPYSIGN(X, Y) - Return the value of X with the sign of Y.  NOTE: This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">  /// DAG node does not require that X and Y have the same type, just that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">  /// they are both floating point.  X and the result must have the same type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">  /// FCOPYSIGN(f32, f64) is allowed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">  FCOPYSIGN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">  /// INT = FGETSIGN(FP) - Return the sign bit of the specified floating point</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">  /// value as an integer 0/1 value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">  FGETSIGN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">  /// Returns platform specific canonical encoding of a floating point number.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">  FCANONICALIZE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">  /// Performs a check of floating point class property, defined by IEEE-754.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">  /// The first operand is the floating point value to check. The second operand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">  /// specifies the checked property and is a TargetConstant which specifies</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">  /// test in the same way as intrinsic 'is_fpclass'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">  /// Returns boolean value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">  IS_FPCLASS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">  /// BUILD_VECTOR(ELT0, ELT1, ELT2, ELT3,...) - Return a fixed-width vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">  /// with the specified, possibly variable, elements. The types of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">  /// operands must match the vector element type, except that integer types</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">  /// are allowed to be larger than the element type, in which case the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">  /// operands are implicitly truncated. The types of the operands must all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">  /// be the same.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">  BUILD_VECTOR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">  /// INSERT_VECTOR_ELT(VECTOR, VAL, IDX) - Returns VECTOR with the element</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">  /// at IDX replaced with VAL. If the type of VAL is larger than the vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">  /// element type then VAL is truncated before replacement.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="">  /// If VECTOR is a scalable vector, then IDX may be larger than the minimum</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">  /// vector width. IDX is not first scaled by the runtime scaling factor of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">  /// VECTOR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">  INSERT_VECTOR_ELT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">  /// EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">  /// identified by the (potentially variable) element number IDX. If the return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="">  /// type is an integer type larger than the element type of the vector, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">  /// result is extended to the width of the return type. In that case, the high</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">  /// bits are undefined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">  /// If VECTOR is a scalable vector, then IDX may be larger than the minimum</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="">  /// vector width. IDX is not first scaled by the runtime scaling factor of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">  /// VECTOR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">  EXTRACT_VECTOR_ELT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">  /// CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">  /// vector type with the same length and element type, this produces a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">  /// concatenated vector result value, with length equal to the sum of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">  /// lengths of the input vectors. If VECTOR0 is a fixed-width vector, then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">  /// VECTOR1..VECTORN must all be fixed-width vectors. Similarly, if VECTOR0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">  /// is a scalable vector, then VECTOR1..VECTORN must all be scalable vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">  CONCAT_VECTORS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">  /// INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX) - Returns a vector with VECTOR2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">  /// inserted into VECTOR1. IDX represents the starting element number at which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">  /// VECTOR2 will be inserted. IDX must be a constant multiple of T's known</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">  /// minimum vector length. Let the type of VECTOR2 be T, then if T is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">  /// scalable vector, IDX is first scaled by the runtime scaling factor of T.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">  /// The elements of VECTOR1 starting at IDX are overwritten with VECTOR2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">  /// Elements IDX through (IDX + num_elements(T) - 1) must be valid VECTOR1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">  /// indices. If this condition cannot be determined statically but is false at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">  /// runtime, then the result vector is undefined. The IDX parameter must be a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">  /// vector index constant type, which for most targets will be an integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">  /// pointer type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">  /// This operation supports inserting a fixed-width vector into a scalable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">  /// vector, but not the other way around.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">  INSERT_SUBVECTOR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">  /// EXTRACT_SUBVECTOR(VECTOR, IDX) - Returns a subvector from VECTOR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">  /// Let the result type be T, then IDX represents the starting element number</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">  /// from which a subvector of type T is extracted. IDX must be a constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">  /// multiple of T's known minimum vector length. If T is a scalable vector,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">  /// IDX is first scaled by the runtime scaling factor of T. Elements IDX</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">  /// through (IDX + num_elements(T) - 1) must be valid VECTOR indices. If this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">  /// condition cannot be determined statically but is false at runtime, then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">  /// the result vector is undefined. The IDX parameter must be a vector index</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">  /// constant type, which for most targets will be an integer pointer type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">  /// This operation supports extracting a fixed-width vector from a scalable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">  /// vector, but not the other way around.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">  EXTRACT_SUBVECTOR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">  /// VECTOR_DEINTERLEAVE(VEC1, VEC2) - Returns two vectors with all input and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">  /// output vectors having the same type. The first output contains the even</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">  /// indices from CONCAT_VECTORS(VEC1, VEC2), with the second output</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">  /// containing the odd indices. The relative order of elements within an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="">  /// output match that of the concatenated input.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">  VECTOR_DEINTERLEAVE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="">  /// VECTOR_INTERLEAVE(VEC1, VEC2) - Returns two vectors with all input and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">  /// output vectors having the same type. The first output contains the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">  /// result of interleaving the low half of CONCAT_VECTORS(VEC1, VEC2), with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">  /// the second output containing the result of interleaving the high half.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">  VECTOR_INTERLEAVE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">  /// VECTOR_REVERSE(VECTOR) - Returns a vector, of the same type as VECTOR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">  /// whose elements are shuffled using the following algorithm:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="">  ///   RESULT[i] = VECTOR[VECTOR.ElementCount - 1 - i]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">  VECTOR_REVERSE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">  /// VECTOR_SHUFFLE(VEC1, VEC2) - Returns a vector, of the same type as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">  /// VEC1/VEC2.  A VECTOR_SHUFFLE node also contains an array of constant int</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">  /// values that indicate which value (or undef) each result element will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">  /// get.  These constant ints are accessible through the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">  /// ShuffleVectorSDNode class.  This is quite similar to the Altivec</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">  /// 'vperm' instruction, except that the indices must be constants and are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">  /// in terms of the element size of VEC1/VEC2, not in terms of bytes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">  VECTOR_SHUFFLE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">  /// VECTOR_SPLICE(VEC1, VEC2, IMM) - Returns a subvector of the same type as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">  /// VEC1/VEC2 from CONCAT_VECTORS(VEC1, VEC2), based on the IMM in two ways.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">  /// Let the result type be T, if IMM is positive it represents the starting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">  /// element number (an index) from which a subvector of type T is extracted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">  /// from CONCAT_VECTORS(VEC1, VEC2). If IMM is negative it represents a count</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="">  /// specifying the number of trailing elements to extract from VEC1, where the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="">  /// elements of T are selected using the following algorithm:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">  ///   RESULT[i] = CONCAT_VECTORS(VEC1,VEC2)[VEC1.ElementCount - ABS(IMM) + i]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">  /// If IMM is not in the range [-VL, VL-1] the result vector is undefined. IMM</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">  /// is a constant integer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">  VECTOR_SPLICE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">  /// SCALAR_TO_VECTOR(VAL) - This represents the operation of loading a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">  /// scalar value into element 0 of the resultant vector type.  The top</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">  /// elements 1 to N-1 of the N-element vector are undefined.  The type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">  /// of the operand must match the vector element type, except when they</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">  /// are integer types.  In this case the operand is allowed to be wider</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">  /// than the vector element type, and is implicitly truncated to it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">  SCALAR_TO_VECTOR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">  /// SPLAT_VECTOR(VAL) - Returns a vector with the scalar value VAL</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">  /// duplicated in all lanes. The type of the operand must match the vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">  /// element type, except when they are integer types.  In this case the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">  /// operand is allowed to be wider than the vector element type, and is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">  /// implicitly truncated to it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">  SPLAT_VECTOR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">  /// SPLAT_VECTOR_PARTS(SCALAR1, SCALAR2, ...) - Returns a vector with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">  /// scalar values joined together and then duplicated in all lanes. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">  /// represents a SPLAT_VECTOR that has had its scalar operand expanded. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">  /// allows representing a 64-bit splat on a target with 32-bit integers. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">  /// total width of the scalars must cover the element width. SCALAR1 contains</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">  /// the least significant bits of the value regardless of endianness and all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">  /// scalars should have the same type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">  SPLAT_VECTOR_PARTS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">  /// STEP_VECTOR(IMM) - Returns a scalable vector whose lanes are comprised</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">  /// of a linear sequence of unsigned values starting from 0 with a step of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">  /// IMM, where IMM must be a TargetConstant with type equal to the vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">  /// element type. The arithmetic is performed modulo the bitwidth of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="">  /// element.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">  /// The operation does not support returning fixed-width vectors or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">  /// non-constant operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">  STEP_VECTOR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">  /// MULHU/MULHS - Multiply high - Multiply two integers of type iN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">  /// producing an unsigned/signed value of type i[2*N], then return the top</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">  /// part.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">  MULHU,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">  MULHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">  /// AVGFLOORS/AVGFLOORU - Averaging add - Add two integers using an integer of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">  /// type i[N+1], halving the result by shifting it one bit right.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">  /// shr(add(ext(X), ext(Y)), 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">  AVGFLOORS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">  AVGFLOORU,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">  /// AVGCEILS/AVGCEILU - Rounding averaging add - Add two integers using an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">  /// integer of type i[N+2], add 1 and halve the result by shifting it one bit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">  /// right. shr(add(ext(X), ext(Y), 1), 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">  AVGCEILS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="">  AVGCEILU,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">  // ABDS/ABDU - Absolute difference - Return the absolute difference between</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">  // two numbers interpreted as signed/unsigned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">  // i.e trunc(abs(sext(Op0) - sext(Op1))) becomes abds(Op0, Op1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">  //  or trunc(abs(zext(Op0) - zext(Op1))) becomes abdu(Op0, Op1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">  ABDS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">  ABDU,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="">  /// [US]{MIN/MAX} - Binary minimum or maximum of signed or unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">  /// integers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">  SMIN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="">  SMAX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">  UMIN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">  UMAX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">  /// Bitwise operators - logical and, logical or, logical xor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">  AND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">  OR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">  XOR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">  /// ABS - Determine the unsigned absolute value of a signed integer value of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">  /// the same bitwidth.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">  /// Note: A value of INT_MIN will return INT_MIN, no saturation or overflow</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">  /// is performed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">  ABS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="">  /// Shift and rotation operations.  After legalization, the type of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">  /// shift amount is known to be TLI.getShiftAmountTy().  Before legalization</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">  /// the shift amount can be any type, but care must be taken to ensure it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">  /// large enough.  TLI.getShiftAmountTy() is i8 on some targets, but before</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">  /// legalization, types like i1024 can occur and i8 doesn't have enough bits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">  /// to represent the shift amount.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">  /// When the 1st operand is a vector, the shift amount must be in the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="">  /// type. (TLI.getShiftAmountTy() will return the same type when the input</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">  /// type is a vector.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">  /// For rotates and funnel shifts, the shift amount is treated as an unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">  /// amount modulo the element size of the first operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="">  /// Funnel 'double' shifts take 3 operands, 2 inputs and the shift amount.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">  /// fshl(X,Y,Z): (X << (Z % BW)) | (Y >> (BW - (Z % BW)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">  /// fshr(X,Y,Z): (X << (BW - (Z % BW))) | (Y >> (Z % BW))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">  SHL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">  SRA,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">  SRL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">  ROTL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">  ROTR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">  FSHL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">  FSHR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">  /// Byte Swap and Counting operators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">  BSWAP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">  CTTZ,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">  CTLZ,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">  CTPOP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">  BITREVERSE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="">  PARITY,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">  /// Bit counting operators with an undefined result for zero inputs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="">  CTTZ_ZERO_UNDEF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">  CTLZ_ZERO_UNDEF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">  /// Select(COND, TRUEVAL, FALSEVAL).  If the type of the boolean COND is not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">  /// i1 then the high bits must conform to getBooleanContents.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">  SELECT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">  /// Select with a vector condition (op #0) and two vector operands (ops #1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">  /// and #2), returning a vector result.  All vectors have the same length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">  /// Much like the scalar select and setcc, each bit in the condition selects</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="">  /// whether the corresponding result element is taken from op #1 or op #2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">  /// At first, the VSELECT condition is of vXi1 type. Later, targets may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">  /// change the condition type in order to match the VSELECT node using a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">  /// pattern. The condition follows the BooleanContent format of the target.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">  VSELECT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">  /// Select with condition operator - This selects between a true value and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="">  /// a false value (ops #2 and #3) based on the boolean result of comparing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="">  /// the lhs and rhs (ops #0 and #1) of a conditional expression with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">  /// condition code in op #4, a CondCodeSDNode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="">  SELECT_CC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">  /// SetCC operator - This evaluates to a true value iff the condition is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">  /// true.  If the result value type is not i1 then the high bits conform</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="">  /// to getBooleanContents.  The operands to this are the left and right</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">  /// operands to compare (ops #0, and #1) and the condition code to compare</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">  /// them with (op #2) as a CondCodeSDNode. If the operands are vector types</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">  /// then the result type must also be a vector type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">  SETCC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">  /// Like SetCC, ops #0 and #1 are the LHS and RHS operands to compare, but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">  /// op #2 is a boolean indicating if there is an incoming carry. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">  /// operator checks the result of "LHS - RHS - Carry", and can be used to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">  /// compare two wide integers:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">  /// (setcccarry lhshi rhshi (usubo_carry lhslo rhslo) cc).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">  /// Only valid for integers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">  SETCCCARRY,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">  /// SHL_PARTS/SRA_PARTS/SRL_PARTS - These operators are used for expanded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">  /// integer shift operations.  The operation ordering is:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">  ///       [Lo,Hi] = op [LoLHS,HiLHS], Amt</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">  SHL_PARTS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="">  SRA_PARTS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">  SRL_PARTS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">  /// Conversion operators.  These are all single input single output</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">  /// operations.  For all of these, the result type must be strictly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">  /// wider or narrower (depending on the operation) than the source</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">  /// type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">  /// SIGN_EXTEND - Used for integer types, replicating the sign bit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">  /// into new bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">  SIGN_EXTEND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="">  /// ZERO_EXTEND - Used for integer types, zeroing the new bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">  ZERO_EXTEND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">  /// ANY_EXTEND - Used for integer types.  The high bits are undefined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">  ANY_EXTEND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">  /// TRUNCATE - Completely drop the high bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">  TRUNCATE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">  /// [SU]INT_TO_FP - These operators convert integers (whose interpreted sign</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">  /// depends on the first letter) to floating point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="">  SINT_TO_FP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">  UINT_TO_FP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">  /// SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">  /// sign extend a small value in a large integer register (e.g. sign</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">  /// extending the low 8 bits of a 32-bit register to fill the top 24 bits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">  /// with the 7th bit).  The size of the smaller type is indicated by the 1th</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">  /// operand, a ValueType node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">  SIGN_EXTEND_INREG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">  /// ANY_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">  /// in-register any-extension of the low lanes of an integer vector. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">  /// result type must have fewer elements than the operand type, and those</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">  /// elements must be larger integer types such that the total size of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="">  /// operand type is less than or equal to the size of the result type. Each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="">  /// of the low operand elements is any-extended into the corresponding,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">  /// wider result elements with the high bits becoming undef.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">  /// the same to allow expansion to shuffle vector during op legalization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">  ANY_EXTEND_VECTOR_INREG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">  /// SIGN_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="">  /// in-register sign-extension of the low lanes of an integer vector. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">  /// result type must have fewer elements than the operand type, and those</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">  /// elements must be larger integer types such that the total size of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">  /// operand type is less than or equal to the size of the result type. Each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">  /// of the low operand elements is sign-extended into the corresponding,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">  /// wider result elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">  /// the same to allow expansion to shuffle vector during op legalization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">  SIGN_EXTEND_VECTOR_INREG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">  /// ZERO_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">  /// in-register zero-extension of the low lanes of an integer vector. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">  /// result type must have fewer elements than the operand type, and those</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">  /// elements must be larger integer types such that the total size of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">  /// operand type is less than or equal to the size of the result type. Each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">  /// of the low operand elements is zero-extended into the corresponding,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">  /// wider result elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">  /// the same to allow expansion to shuffle vector during op legalization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="">  ZERO_EXTEND_VECTOR_INREG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="">  /// FP_TO_[US]INT - Convert a floating point value to a signed or unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="">  /// integer. These have the same semantics as fptosi and fptoui in IR. If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">  /// the FP value cannot fit in the integer type, the results are undefined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="">  FP_TO_SINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="">  FP_TO_UINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">  /// FP_TO_[US]INT_SAT - Convert floating point value in operand 0 to a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">  /// signed or unsigned scalar integer type given in operand 1 with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">  /// following semantics:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">  ///  * If the value is NaN, zero is returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">  ///  * If the value is larger/smaller than the largest/smallest integer,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">  ///    the largest/smallest integer is returned (saturation).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">  ///  * Otherwise the result of rounding the value towards zero is returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">  /// The scalar width of the type given in operand 1 must be equal to, or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">  /// smaller than, the scalar result type width. It may end up being smaller</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">  /// than the result width as a result of integer type legalization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="">  /// After converting to the scalar integer type in operand 1, the value is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="">  /// extended to the result VT. FP_TO_SINT_SAT sign extends and FP_TO_UINT_SAT</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">  /// zero extends.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">  FP_TO_SINT_SAT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">  FP_TO_UINT_SAT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">  /// X = FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating point type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="">  /// down to the precision of the destination VT.  TRUNC is a flag, which is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">  /// always an integer that is zero or one.  If TRUNC is 0, this is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">  /// normal rounding, if it is 1, this FP_ROUND is known to not change the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="">  /// value of Y.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">  /// The TRUNC = 1 case is used in cases where we know that the value will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">  /// not be modified by the node, because Y is not using any of the extra</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">  /// precision of source type.  This allows certain transformations like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">  /// FP_EXTEND(FP_ROUND(X,1)) -> X which are not safe for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="">  /// FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren't removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="">  FP_ROUND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">  /// Returns current rounding mode:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="">  /// -1 Undefined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">  ///  0 Round to 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">  ///  1 Round to nearest, ties to even</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="">  ///  2 Round to +inf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">  ///  3 Round to -inf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="">  ///  4 Round to nearest, ties to zero</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">  /// Result is rounding mode and chain. Input is a chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">  GET_ROUNDING,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="">  /// Set rounding mode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">  /// The first operand is a chain pointer. The second specifies the required</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="">  /// rounding mode, encoded in the same way as used in '``GET_ROUNDING``'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="">  SET_ROUNDING,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">  /// X = FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">  FP_EXTEND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">  /// BITCAST - This operator converts between integer, vector and FP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">  /// values, as if the value was stored to memory with one type and loaded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">  /// from the same address with the other type (or equivalently for vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">  /// format conversions, etc).  The source and result are required to have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">  /// the same bit size (e.g.  f32 <-> i32).  This can also be used for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">  /// int-to-int or fp-to-fp conversions, but that is a noop, deleted by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">  /// getNode().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="">  /// This operator is subtly different from the bitcast instruction from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">  /// LLVM-IR since this node may change the bits in the register. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">  /// example, this occurs on big-endian NEON and big-endian MSA where the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="">  /// layout of the bits in the register depends on the vector type and this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">  /// operator acts as a shuffle operation for some vector type combinations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">  BITCAST,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">  /// ADDRSPACECAST - This operator converts between pointers of different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="">  /// address spaces.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">  ADDRSPACECAST,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="">  /// FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">  /// and truncation for half-precision (16 bit) floating numbers. These nodes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">  /// form a semi-softened interface for dealing with f16 (as an i16), which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">  /// is often a storage-only type but has native conversions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">  FP16_TO_FP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">  FP_TO_FP16,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="">  STRICT_FP16_TO_FP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">  STRICT_FP_TO_FP16,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">  /// BF16_TO_FP, FP_TO_BF16 - These operators are used to perform promotions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="">  /// and truncation for bfloat16. These nodes form a semi-softened interface</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="">  /// for dealing with bf16 (as an i16), which is often a storage-only type but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="">  /// has native conversions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="">  BF16_TO_FP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="">  FP_TO_BF16,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="">  /// Perform various unary floating-point operations inspired by libm. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">  /// FPOWI, the result is undefined if if the integer operand doesn't fit into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="">  /// sizeof(int).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="">  FNEG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="">  FABS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">  FSQRT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="">  FCBRT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="">  FSIN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">  FCOS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">  FPOW,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">  FPOWI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">  /// FLDEXP - ldexp, inspired by libm (op0 * 2**op1).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">  FLDEXP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">  /// FFREXP - frexp, extract fractional and exponent component of a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">  /// floating-point value. Returns the two components as separate return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">  /// values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">  FFREXP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="">  FLOG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">  FLOG2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">  FLOG10,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">  FEXP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">  FEXP2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">  FCEIL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="">  FTRUNC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">  FRINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">  FNEARBYINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">  FROUND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="">  FROUNDEVEN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">  FFLOOR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">  LROUND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="">  LLROUND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">  LRINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">  LLRINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">  /// FMINNUM/FMAXNUM - Perform floating-point minimum or maximum on two</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">  /// values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">  /// In the case where a single input is a NaN (either signaling or quiet),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="">  /// the non-NaN input is returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">  /// The return value of (FMINNUM 0.0, -0.0) could be either 0.0 or -0.0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">  FMINNUM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="">  FMAXNUM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">  /// FMINNUM_IEEE/FMAXNUM_IEEE - Perform floating-point minimum or maximum on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">  /// two values, following the IEEE-754 2008 definition. This differs from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="">  /// FMINNUM/FMAXNUM in the handling of signaling NaNs. If one input is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="">  /// signaling NaN, returns a quiet NaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="">  FMINNUM_IEEE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="">  FMAXNUM_IEEE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="">  /// FMINIMUM/FMAXIMUM - NaN-propagating minimum/maximum that also treat -0.0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="">  /// as less than 0.0. While FMINNUM_IEEE/FMAXNUM_IEEE follow IEEE 754-2008</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="">  /// semantics, FMINIMUM/FMAXIMUM follow IEEE 754-2018 draft semantics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="">  FMINIMUM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">  FMAXIMUM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">  /// FSINCOS - Compute both fsin and fcos as a single operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">  FSINCOS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">  /// Gets the current floating-point environment. The first operand is a token</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="">  /// chain. The results are FP environment, represented by an integer value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="">  /// and a token chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">  GET_FPENV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">  /// Sets the current floating-point environment. The first operand is a token</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="">  /// chain, the second is FP environment, represented by an integer value. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="">  /// result is a token chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="">  SET_FPENV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="">  /// Set floating-point environment to default state. The first operand and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">  /// result are token chains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="">  RESET_FPENV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">  /// Gets the current floating-point environment. The first operand is a token</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">  /// chain, the second is a pointer to memory, where FP environment is stored</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="">  /// to. The result is a token chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">  GET_FPENV_MEM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">  /// Sets the current floating point environment. The first operand is a token</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">  /// chain, the second is a pointer to memory, where FP environment is loaded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="">  /// from. The result is a token chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="">  SET_FPENV_MEM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">  /// LOAD and STORE have token chains as their first operand, then the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">  /// operands as an LLVM load/store instruction, then an offset node that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="">  /// is added / subtracted from the base pointer to form the address (for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="">  /// indexed memory ops).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="">  LOAD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="">  STORE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">  /// DYNAMIC_STACKALLOC - Allocate some number of bytes on the stack aligned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="">  /// to a specified boundary.  This node always has two return values: a new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">  /// stack pointer value and a chain. The first operand is the token chain,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">  /// the second is the number of bytes to allocate, and the third is the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="">  /// alignment boundary.  The size is guaranteed to be a multiple of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="">  /// stack alignment, and the alignment is guaranteed to be bigger than the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="">  /// stack alignment (if required) or 0 to get standard stack alignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="">  DYNAMIC_STACKALLOC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">  /// Control flow instructions.  These all have token chains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">  /// BR - Unconditional branch.  The first operand is the chain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">  /// operand, the second is the MBB to branch to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">  BR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">  /// BRIND - Indirect branch.  The first operand is the chain, the second</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="">  /// is the value to branch to, which must be of the same type as the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="">  /// target's pointer type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="">  BRIND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">  /// BR_JT - Jumptable branch. The first operand is the chain, the second</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">  /// is the jumptable index, the last one is the jumptable entry index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">  BR_JT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">  /// BRCOND - Conditional branch.  The first operand is the chain, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="">  /// second is the condition, the third is the block to branch to if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">  /// condition is true.  If the type of the condition is not i1, then the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="">  /// high bits must conform to getBooleanContents. If the condition is undef,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="">  /// it nondeterministically jumps to the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">  /// TODO: Its semantics w.r.t undef requires further discussion; we need to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">  /// make it sure that it is consistent with optimizations in MIR & the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="">  /// meaning of IMPLICIT_DEF. See https://reviews.llvm.org/D92015</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">  BRCOND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">  /// BR_CC - Conditional branch.  The behavior is like that of SELECT_CC, in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="">  /// that the condition is represented as condition code, and two nodes to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">  /// compare, rather than as a combined SetCC node.  The operands in order</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">  /// are chain, cc, lhs, rhs, block to branch to if condition is true. If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">  /// condition is undef, it nondeterministically jumps to the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="">  BR_CC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">  /// INLINEASM - Represents an inline asm block.  This node always has two</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="">  /// return values: a chain and a flag result.  The inputs are as follows:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="">  ///   Operand #0  : Input chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">  ///   Operand #1  : a ExternalSymbolSDNode with a pointer to the asm string.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">  ///   Operand #2  : a MDNodeSDNode with the !srcloc metadata.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  ///   Operand #3  : HasSideEffect, IsAlignStack bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">  ///   After this, it is followed by a list of operands with this format:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">  ///     ConstantSDNode: Flags that encode whether it is a mem or not, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="">  ///                     of operands that follow, etc.  See InlineAsm.h.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">  ///     ... however many operands ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="">  ///   Operand #last: Optional, an incoming flag.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">  /// The variable width operands are required to represent target addressing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">  /// modes as a single "operand", even though they may have multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="">  /// SDOperands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="">  INLINEASM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">  /// INLINEASM_BR - Branching version of inline asm. Used by asm-goto.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">  INLINEASM_BR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">  /// EH_LABEL - Represents a label in mid basic block used to track</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="">  /// locations needed for debug and exception handling tables.  These nodes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="">  /// take a chain as input and return a chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">  EH_LABEL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">  /// ANNOTATION_LABEL - Represents a mid basic block label used by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="">  /// annotations. This should remain within the basic block and be ordered</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="">  /// with respect to other call instructions, but loads and stores may float</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="">  /// past it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="">  ANNOTATION_LABEL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="">  /// CATCHRET - Represents a return from a catch block funclet. Used for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="">  /// MSVC compatible exception handling. Takes a chain operand and a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">  /// destination basic block operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="">  CATCHRET,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="">  /// CLEANUPRET - Represents a return from a cleanup block funclet.  Used for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="">  /// MSVC compatible exception handling. Takes only a chain operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="">  CLEANUPRET,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="">  /// STACKSAVE - STACKSAVE has one operand, an input chain.  It produces a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="">  /// value, the same type as the pointer type for the system, and an output</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">  /// chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="">  STACKSAVE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="">  /// STACKRESTORE has two operands, an input chain and a pointer to restore</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="">  /// to it returns an output chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="">  STACKRESTORE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="">  /// CALLSEQ_START/CALLSEQ_END - These operators mark the beginning and end</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">  /// of a call sequence, and carry arbitrary information that target might</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="">  /// want to know.  The first operand is a chain, the rest are specified by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="">  /// the target and not touched by the DAG optimizers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="">  /// Targets that may use stack to pass call arguments define additional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="">  /// operands:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">  /// - size of the call frame part that must be set up within the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="">  ///   CALLSEQ_START..CALLSEQ_END pair,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">  /// - part of the call frame prepared prior to CALLSEQ_START.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">  /// Both these parameters must be constants, their sum is the total call</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="">  /// frame size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="">  /// CALLSEQ_START..CALLSEQ_END pairs may not be nested.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">  CALLSEQ_START, // Beginning of a call sequence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">  CALLSEQ_END,   // End of a call sequence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="">  /// VAARG - VAARG has four operands: an input chain, a pointer, a SRCVALUE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">  /// and the alignment. It returns a pair of values: the vaarg value and a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="">  /// new chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">  VAARG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="">  /// VACOPY - VACOPY has 5 operands: an input chain, a destination pointer,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">  /// a source pointer, a SRCVALUE for the destination, and a SRCVALUE for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">  /// source.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="">  VACOPY,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="">  /// VAEND, VASTART - VAEND and VASTART have three operands: an input chain,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="">  /// pointer, and a SRCVALUE.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">  VAEND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="">  VASTART,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="">  // PREALLOCATED_SETUP - This has 2 operands: an input chain and a SRCVALUE</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">  // with the preallocated call Value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">  PREALLOCATED_SETUP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">  // PREALLOCATED_ARG - This has 3 operands: an input chain, a SRCVALUE</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">  // with the preallocated call Value, and a constant int.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">  PREALLOCATED_ARG,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="">  /// SRCVALUE - This is a node type that holds a Value* that is used to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">  /// make reference to a value in the LLVM IR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">  SRCVALUE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">  /// MDNODE_SDNODE - This is a node that holdes an MDNode*, which is used to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">  /// reference metadata in the IR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">  MDNODE_SDNODE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="">  /// PCMARKER - This corresponds to the pcmarker intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="">  PCMARKER,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="">  /// READCYCLECOUNTER - This corresponds to the readcyclecounter intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">  /// It produces a chain and one i64 value. The only operand is a chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">  /// If i64 is not legal, the result will be expanded into smaller values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">  /// Still, it returns an i64, so targets should set legality for i64.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="">  /// The result is the content of the architecture-specific cycle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="">  /// counter-like register (or other high accuracy low latency clock source).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">  READCYCLECOUNTER,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="">  /// HANDLENODE node - Used as a handle for various purposes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="">  HANDLENODE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">  /// INIT_TRAMPOLINE - This corresponds to the init_trampoline intrinsic.  It</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="">  /// takes as input a token chain, the pointer to the trampoline, the pointer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">  /// to the nested function, the pointer to pass for the 'nest' parameter, a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="">  /// SRCVALUE for the trampoline and another for the nested function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">  /// (allowing targets to access the original Function*).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="">  /// It produces a token chain as output.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="">  INIT_TRAMPOLINE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">  /// ADJUST_TRAMPOLINE - This corresponds to the adjust_trampoline intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="">  /// It takes a pointer to the trampoline and produces a (possibly) new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="">  /// pointer to the same trampoline with platform-specific adjustments</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="">  /// applied.  The pointer it returns points to an executable block of code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="">  ADJUST_TRAMPOLINE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">  /// TRAP - Trapping instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="">  TRAP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="">  /// DEBUGTRAP - Trap intended to get the attention of a debugger.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="">  DEBUGTRAP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">  /// UBSANTRAP - Trap with an immediate describing the kind of sanitizer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">  /// failure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">  UBSANTRAP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">  /// PREFETCH - This corresponds to a prefetch intrinsic. The first operand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="">  /// is the chain.  The other operands are the address to prefetch,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">  /// read / write specifier, locality specifier and instruction / data cache</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="">  /// specifier.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">  PREFETCH,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="">  /// ARITH_FENCE - This corresponds to a arithmetic fence intrinsic. Both its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="">  /// operand and output are the same floating type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="">  ARITH_FENCE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">  /// MEMBARRIER - Compiler barrier only; generate a no-op.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">  MEMBARRIER,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">  /// OUTCHAIN = ATOMIC_FENCE(INCHAIN, ordering, scope)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">  /// This corresponds to the fence instruction. It takes an input chain, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">  /// two integer constants: an AtomicOrdering and a SynchronizationScope.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">  ATOMIC_FENCE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="">  /// Val, OUTCHAIN = ATOMIC_LOAD(INCHAIN, ptr)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="">  /// This corresponds to "load atomic" instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">  ATOMIC_LOAD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="">  /// OUTCHAIN = ATOMIC_STORE(INCHAIN, ptr, val)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">  /// This corresponds to "store atomic" instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">  ATOMIC_STORE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">  /// Val, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmp, swap)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">  /// For double-word atomic operations:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmpLo, cmpHi,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">  ///                                          swapLo, swapHi)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="">  /// This corresponds to the cmpxchg instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">  ATOMIC_CMP_SWAP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">  /// Val, Success, OUTCHAIN</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="">  ///     = ATOMIC_CMP_SWAP_WITH_SUCCESS(INCHAIN, ptr, cmp, swap)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="">  /// N.b. this is still a strong cmpxchg operation, so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">  /// Success == "Val == cmp".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">  ATOMIC_CMP_SWAP_WITH_SUCCESS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">  /// Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">  /// Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">  /// For double-word atomic operations:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="">  /// These correspond to the atomicrmw instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="">  ATOMIC_SWAP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">  ATOMIC_LOAD_ADD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="">  ATOMIC_LOAD_SUB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">  ATOMIC_LOAD_AND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">  ATOMIC_LOAD_CLR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">  ATOMIC_LOAD_OR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">  ATOMIC_LOAD_XOR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="">  ATOMIC_LOAD_NAND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">  ATOMIC_LOAD_MIN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">  ATOMIC_LOAD_MAX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="">  ATOMIC_LOAD_UMIN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">  ATOMIC_LOAD_UMAX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">  ATOMIC_LOAD_FADD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">  ATOMIC_LOAD_FSUB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">  ATOMIC_LOAD_FMAX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">  ATOMIC_LOAD_FMIN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">  ATOMIC_LOAD_UINC_WRAP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">  ATOMIC_LOAD_UDEC_WRAP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">  // Masked load and store - consecutive vector load and store operations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">  // with additional mask operand that prevents memory accesses to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">  // masked-off lanes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">  // Val, OutChain = MLOAD(BasePtr, Mask, PassThru)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">  // OutChain = MSTORE(Value, BasePtr, Mask)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">  MLOAD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">  MSTORE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">  // Masked gather and scatter - load and store operations for a vector of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="">  // random addresses with additional mask operand that prevents memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="">  // accesses to the masked-off lanes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">  // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">  // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="">  // The Index operand can have more vector elements than the other operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="">  // due to type legalization. The extra elements are ignored.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="">  MGATHER,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">  MSCATTER,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="">  /// This corresponds to the llvm.lifetime.* intrinsics. The first operand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="">  /// is the chain and the second operand is the alloca pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">  LIFETIME_START,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="">  LIFETIME_END,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">  /// GC_TRANSITION_START/GC_TRANSITION_END - These operators mark the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">  /// beginning and end of GC transition  sequence, and carry arbitrary</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">  /// information that target might need for lowering.  The first operand is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">  /// a chain, the rest are specified by the target and not touched by the DAG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">  /// optimizers. GC_TRANSITION_START..GC_TRANSITION_END pairs may not be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">  /// nested.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">  GC_TRANSITION_START,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">  GC_TRANSITION_END,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">  /// GET_DYNAMIC_AREA_OFFSET - get offset from native SP to the address of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">  /// the most recent dynamic alloca. For most targets that would be 0, but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">  /// for some others (e.g. PowerPC, PowerPC64) that would be compile-time</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">  /// known nonzero constant. The only operand here is the chain.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">  GET_DYNAMIC_AREA_OFFSET,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">  /// Pseudo probe for AutoFDO, as a place holder in a basic block to improve</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">  /// the sample counts quality.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">  PSEUDO_PROBE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">  /// VSCALE(IMM) - Returns the runtime scaling factor used to calculate the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">  /// number of elements within a scalable vector. IMM is a constant integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">  /// multiplier that is applied to the runtime value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">  VSCALE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">  /// Generic reduction nodes. These nodes represent horizontal vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="">  /// reduction operations, producing a scalar result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">  /// The SEQ variants perform reductions in sequential order. The first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">  /// operand is an initial scalar accumulator value, and the second operand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="">  /// is the vector to reduce.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">  /// E.g. RES = VECREDUCE_SEQ_FADD f32 ACC, <4 x f32> SRC_VEC</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">  ///  ... is equivalent to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">  /// RES = (((ACC + SRC_VEC[0]) + SRC_VEC[1]) + SRC_VEC[2]) + SRC_VEC[3]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">  VECREDUCE_SEQ_FADD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="">  VECREDUCE_SEQ_FMUL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="">  /// These reductions have relaxed evaluation order semantics, and have a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">  /// single vector operand. The order of evaluation is unspecified. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="">  /// pow-of-2 vectors, one valid legalizer expansion is to use a tree</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="">  /// reduction, i.e.:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">  /// For RES = VECREDUCE_FADD <8 x f16> SRC_VEC</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="">  ///   PART_RDX = FADD SRC_VEC[0:3], SRC_VEC[4:7]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">  ///   PART_RDX2 = FADD PART_RDX[0:1], PART_RDX[2:3]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="">  ///   RES = FADD PART_RDX2[0], PART_RDX2[1]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="">  /// For non-pow-2 vectors, this can be computed by extracting each element</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">  /// and performing the operation as if it were scalarized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="">  VECREDUCE_FADD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">  VECREDUCE_FMUL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">  /// FMIN/FMAX nodes can have flags, for NaN/NoNaN variants.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">  VECREDUCE_FMAX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="">  VECREDUCE_FMIN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">  /// FMINIMUM/FMAXIMUM nodes propatate NaNs and signed zeroes using the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">  /// llvm.minimum and llvm.maximum semantics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="">  VECREDUCE_FMAXIMUM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="">  VECREDUCE_FMINIMUM,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="">  /// Integer reductions may have a result type larger than the vector element</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">  /// type. However, the reduction is performed using the vector element type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">  /// and the value in the top bits is unspecified.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="">  VECREDUCE_ADD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">  VECREDUCE_MUL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="">  VECREDUCE_AND,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="">  VECREDUCE_OR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="">  VECREDUCE_XOR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="">  VECREDUCE_SMAX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="">  VECREDUCE_SMIN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="">  VECREDUCE_UMAX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">  VECREDUCE_UMIN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">  // The `llvm.experimental.stackmap` intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">  // Operands: input chain, glue, <id>, <numShadowBytes>, [live0[, live1...]]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="">  // Outputs: output chain, glue</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="">  STACKMAP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="">  // The `llvm.experimental.patchpoint.*` intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="">  // Operands: input chain, [glue], reg-mask, <id>, <numShadowBytes>, callee,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="">  //   <numArgs>, cc, ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="">  // Outputs: [rv], output chain, glue</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">  PATCHPOINT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="">// Vector Predication</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="">#define BEGIN_REGISTER_VP_SDNODE(VPSDID, ...) VPSDID,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="">#include "llvm/IR/VPIntrinsics.def"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="">  /// BUILTIN_OP_END - This must be the last enum value in this list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="">  /// The target-specific pre-isel opcode values start here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="">  BUILTIN_OP_END</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">/// FIRST_TARGET_STRICTFP_OPCODE - Target-specific pre-isel operations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">/// which cannot raise FP exceptions should be less than this value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="">/// Those that do must not be less than this value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="">static const int FIRST_TARGET_STRICTFP_OPCODE = BUILTIN_OP_END + 400;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="">/// FIRST_TARGET_MEMORY_OPCODE - Target-specific pre-isel operations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="">/// which do not reference a specific memory location should be less than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="">/// this value. Those that do must not be less than this value, and can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="">/// be used with SelectionDAG::getMemIntrinsicNode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="">static const int FIRST_TARGET_MEMORY_OPCODE = BUILTIN_OP_END + 500;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="">/// Whether this is bitwise logic opcode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="coveredLine">inline bool isBitwiseLogicOp(unsigned Opcode) {</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="coveredLine">  return Opcode == ISD::AND || Opcode == ISD::OR || Opcode == ISD::XOR;</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="">/// Get underlying scalar opcode for VECREDUCE opcode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">/// For example ISD::AND for ISD::VECREDUCE_AND.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="">NodeType getVecReduceBaseOpcode(unsigned VecReduceOpcode);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="">/// Whether this is a vector-predicated Opcode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">bool isVPOpcode(unsigned Opcode);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">/// Whether this is a vector-predicated binary operation opcode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="">bool isVPBinaryOp(unsigned Opcode);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="">/// Whether this is a vector-predicated reduction opcode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">bool isVPReduction(unsigned Opcode);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="">/// The operand position of the vector mask.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">std::optional<unsigned> getVPMaskIdx(unsigned Opcode);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="">/// The operand position of the explicit vector length parameter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="">std::optional<unsigned> getVPExplicitVectorLengthIdx(unsigned Opcode);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="">/// Translate this VP Opcode to its corresponding non-VP Opcode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">std::optional<unsigned> getBaseOpcodeForVP(unsigned Opcode, bool hasFPExcept);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="">/// Translate this non-VP Opcode to its corresponding VP Opcode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="">unsigned getVPForBaseOpcode(unsigned Opcode);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="">//===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="">/// MemIndexedMode enum - This enum defines the load / store indexed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">/// addressing modes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="">/// UNINDEXED    "Normal" load / store. The effective address is already</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="">///              computed and is available in the base pointer. The offset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="">///              operand is always undefined. In addition to producing a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="">///              chain, an unindexed load produces one value (result of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="">///              load); an unindexed store does not produce a value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="">/// PRE_INC      Similar to the unindexed mode where the effective address is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="">/// PRE_DEC      the value of the base pointer add / subtract the offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="">///              It considers the computation as being folded into the load /</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">///              store operation (i.e. the load / store does the address</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">///              computation as well as performing the memory transaction).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="">///              The base operand is always undefined. In addition to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="">///              producing a chain, pre-indexed load produces two values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="">///              (result of the load and the result of the address</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="">///              computation); a pre-indexed store produces one value (result</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">///              of the address computation).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">/// POST_INC     The effective address is the value of the base pointer. The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="">/// POST_DEC     value of the offset operand is then added to / subtracted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">///              from the base after memory transaction. In addition to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">///              producing a chain, post-indexed load produces two values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">///              (the result of the load and the result of the base +/- offset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">///              computation); a post-indexed store produces one value (the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="">///              the result of the base +/- offset computation).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">enum MemIndexedMode { UNINDEXED = 0, PRE_INC, PRE_DEC, POST_INC, POST_DEC };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="">static const int LAST_INDEXED_MODE = POST_DEC + 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="">//===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="">/// MemIndexType enum - This enum defines how to interpret MGATHER/SCATTER's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="">/// index parameter when calculating addresses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">/// SIGNED_SCALED     Addr = Base + ((signed)Index * Scale)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">/// UNSIGNED_SCALED   Addr = Base + ((unsigned)Index * Scale)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="">/// NOTE: The value of Scale is typically only known to the node owning the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="">/// IndexType, with a value of 1 the equivalent of being unscaled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="">enum MemIndexType { SIGNED_SCALED = 0, UNSIGNED_SCALED };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="">static const int LAST_MEM_INDEX_TYPE = UNSIGNED_SCALED + 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="uncoveredLine">inline bool isIndexTypeSigned(MemIndexType IndexType) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="uncoveredLine">  return IndexType == SIGNED_SCALED;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="">//===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="">/// LoadExtType enum - This enum defines the three variants of LOADEXT</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="">/// (load with extension).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">/// SEXTLOAD loads the integer operand and sign extends it to a larger</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="">///          integer result type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="">/// ZEXTLOAD loads the integer operand and zero extends it to a larger</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="">///          integer result type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="">/// EXTLOAD  is used for two things: floating point extending loads and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">///          integer extending loads [the top bits are undefined].</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">enum LoadExtType { NON_EXTLOAD = 0, EXTLOAD, SEXTLOAD, ZEXTLOAD };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="">static const int LAST_LOADEXT_TYPE = ZEXTLOAD + 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="">NodeType getExtForLoadExtType(bool IsFP, LoadExtType);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="">//===--------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="">/// ISD::CondCode enum - These are ordered carefully to make the bitfields</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="">/// below work out, when considering SETFALSE (something that never exists</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="">/// dynamically) as 0.  "U" -> Unsigned (for integer operands) or Unordered</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="">/// (for floating point), "L" -> Less than, "G" -> Greater than, "E" -> Equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="">/// to.  If the "N" column is 1, the result of the comparison is undefined if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="">/// the input is a NAN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">/// All of these (except for the 'always folded ops') should be handled for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="">/// floating point.  For integer, only the SETEQ,SETNE,SETLT,SETLE,SETGT,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="">/// SETGE,SETULT,SETULE,SETUGT, and SETUGE opcodes are used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="">/// Note that these are laid out in a specific order to allow bit-twiddling</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="">/// to transform conditions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="">enum CondCode {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="">  // Opcode       N U L G E       Intuitive operation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="">  SETFALSE, //      0 0 0 0       Always false (always folded)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="">  SETOEQ,   //      0 0 0 1       True if ordered and equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="">  SETOGT,   //      0 0 1 0       True if ordered and greater than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">  SETOGE,   //      0 0 1 1       True if ordered and greater than or equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">  SETOLT,   //      0 1 0 0       True if ordered and less than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="">  SETOLE,   //      0 1 0 1       True if ordered and less than or equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="">  SETONE,   //      0 1 1 0       True if ordered and operands are unequal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="">  SETO,     //      0 1 1 1       True if ordered (no nans)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="">  SETUO,    //      1 0 0 0       True if unordered: isnan(X) | isnan(Y)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">  SETUEQ,   //      1 0 0 1       True if unordered or equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="">  SETUGT,   //      1 0 1 0       True if unordered or greater than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="">  SETUGE,   //      1 0 1 1       True if unordered, greater than, or equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="">  SETULT,   //      1 1 0 0       True if unordered or less than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="">  SETULE,   //      1 1 0 1       True if unordered, less than, or equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="">  SETUNE,   //      1 1 1 0       True if unordered or not equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="">  SETTRUE,  //      1 1 1 1       Always true (always folded)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="">  // Don't care operations: undefined if the input is a nan.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="">  SETFALSE2, //   1 X 0 0 0       Always false (always folded)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="">  SETEQ,     //   1 X 0 0 1       True if equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="">  SETGT,     //   1 X 0 1 0       True if greater than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">  SETGE,     //   1 X 0 1 1       True if greater than or equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="">  SETLT,     //   1 X 1 0 0       True if less than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="">  SETLE,     //   1 X 1 0 1       True if less than or equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="">  SETNE,     //   1 X 1 1 0       True if not equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="">  SETTRUE2,  //   1 X 1 1 1       Always true (always folded)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="">  SETCC_INVALID // Marker value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">/// Return true if this is a setcc instruction that performs a signed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="">/// comparison when used with integer operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="coveredLine">inline bool isSignedIntSetCC(CondCode Code) {</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="coveredLine">  return Code == SETGT || Code == SETGE || Code == SETLT || Code == SETLE;</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="">/// Return true if this is a setcc instruction that performs an unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">/// comparison when used with integer operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="uncoveredLine">inline bool isUnsignedIntSetCC(CondCode Code) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="uncoveredLine">  return Code == SETUGT || Code == SETUGE || Code == SETULT || Code == SETULE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">/// Return true if this is a setcc instruction that performs an equality</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">/// comparison when used with integer operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="uncoveredLine">inline bool isIntEqualitySetCC(CondCode Code) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="uncoveredLine">  return Code == SETEQ || Code == SETNE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="">/// Return true if the specified condition returns true if the two operands to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="">/// the condition are equal. Note that if one of the two operands is a NaN,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="">/// this value is meaningless.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="">inline bool isTrueWhenEqual(CondCode Cond) { return ((int)Cond & 1) != 0; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">/// This function returns 0 if the condition is always false if an operand is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="">/// a NaN, 1 if the condition is always true if the operand is a NaN, and 2 if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="">/// the condition is undefined if the operand is a NaN.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="">inline unsigned getUnorderedFlavor(CondCode Cond) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="">  return ((int)Cond >> 3) & 3;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="">/// Return the operation corresponding to !(X op Y), where 'op' is a valid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="">/// SetCC operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="">CondCode getSetCCInverse(CondCode Operation, EVT Type);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="coveredLine">inline bool isExtOpcode(unsigned Opcode) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="coveredLine">  return Opcode == ISD::ANY_EXTEND || Opcode == ISD::ZERO_EXTEND ||</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="coveredLine">         Opcode == ISD::SIGN_EXTEND;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="">inline bool isExtVecInRegOpcode(unsigned Opcode) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="">  return Opcode == ISD::ANY_EXTEND_VECTOR_INREG ||</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="">         Opcode == ISD::ZERO_EXTEND_VECTOR_INREG ||</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="">         Opcode == ISD::SIGN_EXTEND_VECTOR_INREG;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="">namespace GlobalISel {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="">/// Return the operation corresponding to !(X op Y), where 'op' is a valid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="">/// SetCC operation. The U bit of the condition code has different meanings</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="">/// between floating point and integer comparisons and LLT's don't provide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="">/// this distinction. As such we need to be told whether the comparison is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="">/// floating point or integer-like. Pointers should use integer-like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="">/// comparisons.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="">CondCode getSetCCInverse(CondCode Operation, bool isIntegerLike);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="">} // end namespace GlobalISel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="">/// Return the operation corresponding to (Y op X) when given the operation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="">/// for (X op Y).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="">CondCode getSetCCSwappedOperands(CondCode Operation);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="">/// Return the result of a logical OR between different comparisons of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="">/// identical values: ((X op1 Y) | (X op2 Y)). This function returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="">/// SETCC_INVALID if it is not possible to represent the resultant comparison.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">CondCode getSetCCOrOperation(CondCode Op1, CondCode Op2, EVT Type);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="">/// Return the result of a logical AND between different comparisons of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="">/// identical values: ((X op1 Y) & (X op2 Y)). This function returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="">/// SETCC_INVALID if it is not possible to represent the resultant comparison.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="">CondCode getSetCCAndOperation(CondCode Op1, CondCode Op2, EVT Type);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="">} // namespace ISD</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="">} // namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm3ISD17isIndexTypeSignedENS0_12MemIndexTypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm3ISD16isSignedIntSetCCENS0_8CondCodeE</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm3ISD18isUnsignedIntSetCCENS0_8CondCodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm3ISD18isIntEqualitySetCCENS0_8CondCodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm3ISD11isExtOpcodeEj</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm3ISD16isBitwiseLogicOpEj</td>
    <td class="numberOfCalls">4</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- llvm/CodeGen/ISDOpcodes.h - CodeGen opcodes -------------*- C++ -*-===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- llvm/CodeGen/ISDOpcodes.h - CodeGen opcodes -------------*- C++ -*-===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This file declares codegen opcodes and related utilities.</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This file declares codegen opcodes and related utilities.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">11</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline"></td>
    <td class="lineNumber">12</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">#ifndef LLVM_CODEGEN_ISDOPCODES_H</td>
    <td class="lineNumber">13</td>
    <td class="codeline">#ifndef LLVM_CODEGEN_ISDOPCODES_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">#define LLVM_CODEGEN_ISDOPCODES_H</td>
    <td class="lineNumber">14</td>
    <td class="codeline">#define LLVM_CODEGEN_ISDOPCODES_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline"></td>
    <td class="lineNumber">15</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/CodeGen/ValueTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline"></td>
    <td class="lineNumber">17</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">18</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline"></td>
    <td class="lineNumber">19</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">/// ISD namespace - This namespace contains an enum which represents all of the</td>
    <td class="lineNumber">20</td>
    <td class="codeline">/// ISD namespace - This namespace contains an enum which represents all of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">/// SelectionDAG node types and value types.</td>
    <td class="lineNumber">21</td>
    <td class="codeline">/// SelectionDAG node types and value types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">///</td>
    <td class="lineNumber">22</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">namespace ISD {</td>
    <td class="lineNumber">23</td>
    <td class="codeline">namespace ISD {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline"></td>
    <td class="lineNumber">24</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">25</td>
    <td class="codeline">//===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">/// ISD::NodeType enum - This enum defines the target-independent operators</td>
    <td class="lineNumber">26</td>
    <td class="codeline">/// ISD::NodeType enum - This enum defines the target-independent operators</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">/// for a SelectionDAG.</td>
    <td class="lineNumber">27</td>
    <td class="codeline">/// for a SelectionDAG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">///</td>
    <td class="lineNumber">28</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">/// Targets may also define target-dependent operator codes for SDNodes. For</td>
    <td class="lineNumber">29</td>
    <td class="codeline">/// Targets may also define target-dependent operator codes for SDNodes. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">/// example, on x86, these are the enum values in the X86ISD namespace.</td>
    <td class="lineNumber">30</td>
    <td class="codeline">/// example, on x86, these are the enum values in the X86ISD namespace.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">/// Targets should aim to use target-independent operators to model their</td>
    <td class="lineNumber">31</td>
    <td class="codeline">/// Targets should aim to use target-independent operators to model their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">/// instruction sets as much as possible, and only use target-dependent</td>
    <td class="lineNumber">32</td>
    <td class="codeline">/// instruction sets as much as possible, and only use target-dependent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">/// operators when they have special requirements.</td>
    <td class="lineNumber">33</td>
    <td class="codeline">/// operators when they have special requirements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">///</td>
    <td class="lineNumber">34</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">/// Finally, during and after selection proper, SNodes may use special</td>
    <td class="lineNumber">35</td>
    <td class="codeline">/// Finally, during and after selection proper, SNodes may use special</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">/// operator codes that correspond directly with MachineInstr opcodes. These</td>
    <td class="lineNumber">36</td>
    <td class="codeline">/// operator codes that correspond directly with MachineInstr opcodes. These</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">/// are used to represent selected instructions. See the isMachineOpcode()</td>
    <td class="lineNumber">37</td>
    <td class="codeline">/// are used to represent selected instructions. See the isMachineOpcode()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">/// and getMachineOpcode() member functions of SDNode.</td>
    <td class="lineNumber">38</td>
    <td class="codeline">/// and getMachineOpcode() member functions of SDNode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">///</td>
    <td class="lineNumber">39</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">enum NodeType {</td>
    <td class="lineNumber">40</td>
    <td class="codeline">enum NodeType {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline"></td>
    <td class="lineNumber">41</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">  /// DELETED_NODE - This is an illegal value that is used to catch</td>
    <td class="lineNumber">42</td>
    <td class="codeline">  /// DELETED_NODE - This is an illegal value that is used to catch</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">  /// errors.  This opcode is not a legal opcode for any node.</td>
    <td class="lineNumber">43</td>
    <td class="codeline">  /// errors.  This opcode is not a legal opcode for any node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">  DELETED_NODE,</td>
    <td class="lineNumber">44</td>
    <td class="codeline">  DELETED_NODE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline"></td>
    <td class="lineNumber">45</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">  /// EntryToken - This is the marker used to indicate the start of a region.</td>
    <td class="lineNumber">46</td>
    <td class="codeline">  /// EntryToken - This is the marker used to indicate the start of a region.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">  EntryToken,</td>
    <td class="lineNumber">47</td>
    <td class="codeline">  EntryToken,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline"></td>
    <td class="lineNumber">48</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">  /// TokenFactor - This node takes multiple tokens as input and produces a</td>
    <td class="lineNumber">49</td>
    <td class="codeline">  /// TokenFactor - This node takes multiple tokens as input and produces a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">  /// single token result. This is used to represent the fact that the operand</td>
    <td class="lineNumber">50</td>
    <td class="codeline">  /// single token result. This is used to represent the fact that the operand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">  /// operators are independent of each other.</td>
    <td class="lineNumber">51</td>
    <td class="codeline">  /// operators are independent of each other.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">  TokenFactor,</td>
    <td class="lineNumber">52</td>
    <td class="codeline">  TokenFactor,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline"></td>
    <td class="lineNumber">53</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">  /// AssertSext, AssertZext - These nodes record if a register contains a</td>
    <td class="lineNumber">54</td>
    <td class="codeline">  /// AssertSext, AssertZext - These nodes record if a register contains a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">  /// value that has already been zero or sign extended from a narrower type.</td>
    <td class="lineNumber">55</td>
    <td class="codeline">  /// value that has already been zero or sign extended from a narrower type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">  /// These nodes take two operands.  The first is the node that has already</td>
    <td class="lineNumber">56</td>
    <td class="codeline">  /// These nodes take two operands.  The first is the node that has already</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">  /// been extended, and the second is a value type node indicating the width</td>
    <td class="lineNumber">57</td>
    <td class="codeline">  /// been extended, and the second is a value type node indicating the width</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">  /// of the extension.</td>
    <td class="lineNumber">58</td>
    <td class="codeline">  /// of the extension.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">  /// NOTE: In case of the source value (or any vector element value) is</td>
    <td class="lineNumber">59</td>
    <td class="codeline">  /// NOTE: In case of the source value (or any vector element value) is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">  /// poisoned the assertion will not be true for that value.</td>
    <td class="lineNumber">60</td>
    <td class="codeline">  /// poisoned the assertion will not be true for that value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">  AssertSext,</td>
    <td class="lineNumber">61</td>
    <td class="codeline">  AssertSext,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">  AssertZext,</td>
    <td class="lineNumber">62</td>
    <td class="codeline">  AssertZext,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline"></td>
    <td class="lineNumber">63</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">  /// AssertAlign - These nodes record if a register contains a value that</td>
    <td class="lineNumber">64</td>
    <td class="codeline">  /// AssertAlign - These nodes record if a register contains a value that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">  /// has a known alignment and the trailing bits are known to be zero.</td>
    <td class="lineNumber">65</td>
    <td class="codeline">  /// has a known alignment and the trailing bits are known to be zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">  /// NOTE: In case of the source value (or any vector element value) is</td>
    <td class="lineNumber">66</td>
    <td class="codeline">  /// NOTE: In case of the source value (or any vector element value) is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">  /// poisoned the assertion will not be true for that value.</td>
    <td class="lineNumber">67</td>
    <td class="codeline">  /// poisoned the assertion will not be true for that value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">  AssertAlign,</td>
    <td class="lineNumber">68</td>
    <td class="codeline">  AssertAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline"></td>
    <td class="lineNumber">69</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">  /// Various leaf nodes.</td>
    <td class="lineNumber">70</td>
    <td class="codeline">  /// Various leaf nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">  BasicBlock,</td>
    <td class="lineNumber">71</td>
    <td class="codeline">  BasicBlock,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">  VALUETYPE,</td>
    <td class="lineNumber">72</td>
    <td class="codeline">  VALUETYPE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">  CONDCODE,</td>
    <td class="lineNumber">73</td>
    <td class="codeline">  CONDCODE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">  Register,</td>
    <td class="lineNumber">74</td>
    <td class="codeline">  Register,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">  RegisterMask,</td>
    <td class="lineNumber">75</td>
    <td class="codeline">  RegisterMask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">  Constant,</td>
    <td class="lineNumber">76</td>
    <td class="codeline">  Constant,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">  ConstantFP,</td>
    <td class="lineNumber">77</td>
    <td class="codeline">  ConstantFP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">  GlobalAddress,</td>
    <td class="lineNumber">78</td>
    <td class="codeline">  GlobalAddress,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">  GlobalTLSAddress,</td>
    <td class="lineNumber">79</td>
    <td class="codeline">  GlobalTLSAddress,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">  FrameIndex,</td>
    <td class="lineNumber">80</td>
    <td class="codeline">  FrameIndex,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">  JumpTable,</td>
    <td class="lineNumber">81</td>
    <td class="codeline">  JumpTable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">  ConstantPool,</td>
    <td class="lineNumber">82</td>
    <td class="codeline">  ConstantPool,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">  ExternalSymbol,</td>
    <td class="lineNumber">83</td>
    <td class="codeline">  ExternalSymbol,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">  BlockAddress,</td>
    <td class="lineNumber">84</td>
    <td class="codeline">  BlockAddress,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline"></td>
    <td class="lineNumber">85</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">  /// The address of the GOT</td>
    <td class="lineNumber">86</td>
    <td class="codeline">  /// The address of the GOT</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">  GLOBAL_OFFSET_TABLE,</td>
    <td class="lineNumber">87</td>
    <td class="codeline">  GLOBAL_OFFSET_TABLE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">  /// FRAMEADDR, RETURNADDR - These nodes represent llvm.frameaddress and</td>
    <td class="lineNumber">89</td>
    <td class="codeline">  /// FRAMEADDR, RETURNADDR - These nodes represent llvm.frameaddress and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">  /// llvm.returnaddress on the DAG.  These nodes take one operand, the index</td>
    <td class="lineNumber">90</td>
    <td class="codeline">  /// llvm.returnaddress on the DAG.  These nodes take one operand, the index</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">  /// of the frame or return address to return.  An index of zero corresponds</td>
    <td class="lineNumber">91</td>
    <td class="codeline">  /// of the frame or return address to return.  An index of zero corresponds</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">  /// to the current function's frame or return address, an index of one to</td>
    <td class="lineNumber">92</td>
    <td class="codeline">  /// to the current function's frame or return address, an index of one to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">  /// the parent's frame or return address, and so on.</td>
    <td class="lineNumber">93</td>
    <td class="codeline">  /// the parent's frame or return address, and so on.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">  FRAMEADDR,</td>
    <td class="lineNumber">94</td>
    <td class="codeline">  FRAMEADDR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">  RETURNADDR,</td>
    <td class="lineNumber">95</td>
    <td class="codeline">  RETURNADDR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline"></td>
    <td class="lineNumber">96</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">  /// ADDROFRETURNADDR - Represents the llvm.addressofreturnaddress intrinsic.</td>
    <td class="lineNumber">97</td>
    <td class="codeline">  /// ADDROFRETURNADDR - Represents the llvm.addressofreturnaddress intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">  /// This node takes no operand, returns a target-specific pointer to the</td>
    <td class="lineNumber">98</td>
    <td class="codeline">  /// This node takes no operand, returns a target-specific pointer to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">  /// place in the stack frame where the return address of the current</td>
    <td class="lineNumber">99</td>
    <td class="codeline">  /// place in the stack frame where the return address of the current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  /// function is stored.</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  /// function is stored.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">  ADDROFRETURNADDR,</td>
    <td class="lineNumber">101</td>
    <td class="codeline">  ADDROFRETURNADDR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
    <td class="lineNumber">102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">  /// SPONENTRY - Represents the llvm.sponentry intrinsic. Takes no argument</td>
    <td class="lineNumber">103</td>
    <td class="codeline">  /// SPONENTRY - Represents the llvm.sponentry intrinsic. Takes no argument</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">  /// and returns the stack pointer value at the entry of the current</td>
    <td class="lineNumber">104</td>
    <td class="codeline">  /// and returns the stack pointer value at the entry of the current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">  /// function calling this intrinsic.</td>
    <td class="lineNumber">105</td>
    <td class="codeline">  /// function calling this intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">  SPONENTRY,</td>
    <td class="lineNumber">106</td>
    <td class="codeline">  SPONENTRY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline"></td>
    <td class="lineNumber">107</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">  /// LOCAL_RECOVER - Represents the llvm.localrecover intrinsic.</td>
    <td class="lineNumber">108</td>
    <td class="codeline">  /// LOCAL_RECOVER - Represents the llvm.localrecover intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">  /// Materializes the offset from the local object pointer of another</td>
    <td class="lineNumber">109</td>
    <td class="codeline">  /// Materializes the offset from the local object pointer of another</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  /// function to a particular local object passed to llvm.localescape. The</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  /// function to a particular local object passed to llvm.localescape. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">  /// operand is the MCSymbol label used to represent this offset, since</td>
    <td class="lineNumber">111</td>
    <td class="codeline">  /// operand is the MCSymbol label used to represent this offset, since</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  /// typically the offset is not known until after code generation of the</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  /// typically the offset is not known until after code generation of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">  /// parent.</td>
    <td class="lineNumber">113</td>
    <td class="codeline">  /// parent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  LOCAL_RECOVER,</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  LOCAL_RECOVER,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline"></td>
    <td class="lineNumber">115</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">  /// READ_REGISTER, WRITE_REGISTER - This node represents llvm.register on</td>
    <td class="lineNumber">116</td>
    <td class="codeline">  /// READ_REGISTER, WRITE_REGISTER - This node represents llvm.register on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  /// the DAG, which implements the named register global variables extension.</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  /// the DAG, which implements the named register global variables extension.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  READ_REGISTER,</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  READ_REGISTER,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">  WRITE_REGISTER,</td>
    <td class="lineNumber">119</td>
    <td class="codeline">  WRITE_REGISTER,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline"></td>
    <td class="lineNumber">120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  /// FRAME_TO_ARGS_OFFSET - This node represents offset from frame pointer to</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  /// FRAME_TO_ARGS_OFFSET - This node represents offset from frame pointer to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">  /// first (possible) on-stack argument. This is needed for correct stack</td>
    <td class="lineNumber">122</td>
    <td class="codeline">  /// first (possible) on-stack argument. This is needed for correct stack</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  /// adjustment during unwind.</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  /// adjustment during unwind.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">  FRAME_TO_ARGS_OFFSET,</td>
    <td class="lineNumber">124</td>
    <td class="codeline">  FRAME_TO_ARGS_OFFSET,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  /// EH_DWARF_CFA - This node represents the pointer to the DWARF Canonical</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  /// EH_DWARF_CFA - This node represents the pointer to the DWARF Canonical</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  /// Frame Address (CFA), generally the value of the stack pointer at the</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  /// Frame Address (CFA), generally the value of the stack pointer at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  /// call site in the previous frame.</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  /// call site in the previous frame.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">  EH_DWARF_CFA,</td>
    <td class="lineNumber">129</td>
    <td class="codeline">  EH_DWARF_CFA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">  /// OUTCHAIN = EH_RETURN(INCHAIN, OFFSET, HANDLER) - This node represents</td>
    <td class="lineNumber">131</td>
    <td class="codeline">  /// OUTCHAIN = EH_RETURN(INCHAIN, OFFSET, HANDLER) - This node represents</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">  /// 'eh_return' gcc dwarf builtin, which is used to return from</td>
    <td class="lineNumber">132</td>
    <td class="codeline">  /// 'eh_return' gcc dwarf builtin, which is used to return from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">  /// exception. The general meaning is: adjust stack by OFFSET and pass</td>
    <td class="lineNumber">133</td>
    <td class="codeline">  /// exception. The general meaning is: adjust stack by OFFSET and pass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">  /// execution to HANDLER. Many platform-related details also :)</td>
    <td class="lineNumber">134</td>
    <td class="codeline">  /// execution to HANDLER. Many platform-related details also :)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">  EH_RETURN,</td>
    <td class="lineNumber">135</td>
    <td class="codeline">  EH_RETURN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline"></td>
    <td class="lineNumber">136</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">  /// RESULT, OUTCHAIN = EH_SJLJ_SETJMP(INCHAIN, buffer)</td>
    <td class="lineNumber">137</td>
    <td class="codeline">  /// RESULT, OUTCHAIN = EH_SJLJ_SETJMP(INCHAIN, buffer)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">  /// This corresponds to the eh.sjlj.setjmp intrinsic.</td>
    <td class="lineNumber">138</td>
    <td class="codeline">  /// This corresponds to the eh.sjlj.setjmp intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">  /// It takes an input chain and a pointer to the jump buffer as inputs</td>
    <td class="lineNumber">139</td>
    <td class="codeline">  /// It takes an input chain and a pointer to the jump buffer as inputs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">  /// and returns an outchain.</td>
    <td class="lineNumber">140</td>
    <td class="codeline">  /// and returns an outchain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">  EH_SJLJ_SETJMP,</td>
    <td class="lineNumber">141</td>
    <td class="codeline">  EH_SJLJ_SETJMP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline"></td>
    <td class="lineNumber">142</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">  /// OUTCHAIN = EH_SJLJ_LONGJMP(INCHAIN, buffer)</td>
    <td class="lineNumber">143</td>
    <td class="codeline">  /// OUTCHAIN = EH_SJLJ_LONGJMP(INCHAIN, buffer)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  /// This corresponds to the eh.sjlj.longjmp intrinsic.</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  /// This corresponds to the eh.sjlj.longjmp intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">  /// It takes an input chain and a pointer to the jump buffer as inputs</td>
    <td class="lineNumber">145</td>
    <td class="codeline">  /// It takes an input chain and a pointer to the jump buffer as inputs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">  /// and returns an outchain.</td>
    <td class="lineNumber">146</td>
    <td class="codeline">  /// and returns an outchain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  EH_SJLJ_LONGJMP,</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  EH_SJLJ_LONGJMP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline"></td>
    <td class="lineNumber">148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">  /// OUTCHAIN = EH_SJLJ_SETUP_DISPATCH(INCHAIN)</td>
    <td class="lineNumber">149</td>
    <td class="codeline">  /// OUTCHAIN = EH_SJLJ_SETUP_DISPATCH(INCHAIN)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">  /// The target initializes the dispatch table here.</td>
    <td class="lineNumber">150</td>
    <td class="codeline">  /// The target initializes the dispatch table here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">  EH_SJLJ_SETUP_DISPATCH,</td>
    <td class="lineNumber">151</td>
    <td class="codeline">  EH_SJLJ_SETUP_DISPATCH,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline"></td>
    <td class="lineNumber">152</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">  /// TargetConstant* - Like Constant*, but the DAG does not do any folding,</td>
    <td class="lineNumber">153</td>
    <td class="codeline">  /// TargetConstant* - Like Constant*, but the DAG does not do any folding,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">  /// simplification, or lowering of the constant. They are used for constants</td>
    <td class="lineNumber">154</td>
    <td class="codeline">  /// simplification, or lowering of the constant. They are used for constants</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">  /// which are known to fit in the immediate fields of their users, or for</td>
    <td class="lineNumber">155</td>
    <td class="codeline">  /// which are known to fit in the immediate fields of their users, or for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">  /// carrying magic numbers which are not values which need to be</td>
    <td class="lineNumber">156</td>
    <td class="codeline">  /// carrying magic numbers which are not values which need to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  /// materialized in registers.</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  /// materialized in registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">  TargetConstant,</td>
    <td class="lineNumber">158</td>
    <td class="codeline">  TargetConstant,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  TargetConstantFP,</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  TargetConstantFP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">  /// TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or</td>
    <td class="lineNumber">161</td>
    <td class="codeline">  /// TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">  /// anything else with this node, and this is valid in the target-specific</td>
    <td class="lineNumber">162</td>
    <td class="codeline">  /// anything else with this node, and this is valid in the target-specific</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">  /// dag, turning into a GlobalAddress operand.</td>
    <td class="lineNumber">163</td>
    <td class="codeline">  /// dag, turning into a GlobalAddress operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  TargetGlobalAddress,</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  TargetGlobalAddress,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">  TargetGlobalTLSAddress,</td>
    <td class="lineNumber">165</td>
    <td class="codeline">  TargetGlobalTLSAddress,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">  TargetFrameIndex,</td>
    <td class="lineNumber">166</td>
    <td class="codeline">  TargetFrameIndex,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">  TargetJumpTable,</td>
    <td class="lineNumber">167</td>
    <td class="codeline">  TargetJumpTable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  TargetConstantPool,</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  TargetConstantPool,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  TargetExternalSymbol,</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  TargetExternalSymbol,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  TargetBlockAddress,</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  TargetBlockAddress,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline"></td>
    <td class="lineNumber">171</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  MCSymbol,</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  MCSymbol,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline"></td>
    <td class="lineNumber">173</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  /// TargetIndex - Like a constant pool entry, but with completely</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  /// TargetIndex - Like a constant pool entry, but with completely</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  /// target-dependent semantics. Holds target flags, a 32-bit index, and a</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  /// target-dependent semantics. Holds target flags, a 32-bit index, and a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">  /// 64-bit index. Targets can use this however they like.</td>
    <td class="lineNumber">176</td>
    <td class="codeline">  /// 64-bit index. Targets can use this however they like.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">  TargetIndex,</td>
    <td class="lineNumber">177</td>
    <td class="codeline">  TargetIndex,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline"></td>
    <td class="lineNumber">178</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  /// RESULT = INTRINSIC_WO_CHAIN(INTRINSICID, arg1, arg2, ...)</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  /// RESULT = INTRINSIC_WO_CHAIN(INTRINSICID, arg1, arg2, ...)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">  /// This node represents a target intrinsic function with no side effects.</td>
    <td class="lineNumber">180</td>
    <td class="codeline">  /// This node represents a target intrinsic function with no side effects.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">  /// The first operand is the ID number of the intrinsic from the</td>
    <td class="lineNumber">181</td>
    <td class="codeline">  /// The first operand is the ID number of the intrinsic from the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">  /// llvm::Intrinsic namespace.  The operands to the intrinsic follow.  The</td>
    <td class="lineNumber">182</td>
    <td class="codeline">  /// llvm::Intrinsic namespace.  The operands to the intrinsic follow.  The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  /// node returns the result of the intrinsic.</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  /// node returns the result of the intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">  INTRINSIC_WO_CHAIN,</td>
    <td class="lineNumber">184</td>
    <td class="codeline">  INTRINSIC_WO_CHAIN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">  /// RESULT,OUTCHAIN = INTRINSIC_W_CHAIN(INCHAIN, INTRINSICID, arg1, ...)</td>
    <td class="lineNumber">186</td>
    <td class="codeline">  /// RESULT,OUTCHAIN = INTRINSIC_W_CHAIN(INCHAIN, INTRINSICID, arg1, ...)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  /// This node represents a target intrinsic function with side effects that</td>
    <td class="lineNumber">187</td>
    <td class="codeline">  /// This node represents a target intrinsic function with side effects that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">  /// returns a result.  The first operand is a chain pointer.  The second is</td>
    <td class="lineNumber">188</td>
    <td class="codeline">  /// returns a result.  The first operand is a chain pointer.  The second is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  /// the ID number of the intrinsic from the llvm::Intrinsic namespace.  The</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  /// the ID number of the intrinsic from the llvm::Intrinsic namespace.  The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  /// operands to the intrinsic follow.  The node has two results, the result</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  /// operands to the intrinsic follow.  The node has two results, the result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  /// of the intrinsic and an output chain.</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  /// of the intrinsic and an output chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">  INTRINSIC_W_CHAIN,</td>
    <td class="lineNumber">192</td>
    <td class="codeline">  INTRINSIC_W_CHAIN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline"></td>
    <td class="lineNumber">193</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">  /// OUTCHAIN = INTRINSIC_VOID(INCHAIN, INTRINSICID, arg1, arg2, ...)</td>
    <td class="lineNumber">194</td>
    <td class="codeline">  /// OUTCHAIN = INTRINSIC_VOID(INCHAIN, INTRINSICID, arg1, arg2, ...)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">  /// This node represents a target intrinsic function with side effects that</td>
    <td class="lineNumber">195</td>
    <td class="codeline">  /// This node represents a target intrinsic function with side effects that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">  /// does not return a result.  The first operand is a chain pointer.  The</td>
    <td class="lineNumber">196</td>
    <td class="codeline">  /// does not return a result.  The first operand is a chain pointer.  The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  /// second is the ID number of the intrinsic from the llvm::Intrinsic</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  /// second is the ID number of the intrinsic from the llvm::Intrinsic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">  /// namespace.  The operands to the intrinsic follow.</td>
    <td class="lineNumber">198</td>
    <td class="codeline">  /// namespace.  The operands to the intrinsic follow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">  INTRINSIC_VOID,</td>
    <td class="lineNumber">199</td>
    <td class="codeline">  INTRINSIC_VOID,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline"></td>
    <td class="lineNumber">200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  /// CopyToReg - This node has three operands: a chain, a register number to</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  /// CopyToReg - This node has three operands: a chain, a register number to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">  /// set to this value, and a value.</td>
    <td class="lineNumber">202</td>
    <td class="codeline">  /// set to this value, and a value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">  CopyToReg,</td>
    <td class="lineNumber">203</td>
    <td class="codeline">  CopyToReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  /// CopyFromReg - This node indicates that the input value is a virtual or</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  /// CopyFromReg - This node indicates that the input value is a virtual or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  /// physical register that is defined outside of the scope of this</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  /// physical register that is defined outside of the scope of this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  /// SelectionDAG.  The register is available from the RegisterSDNode object.</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  /// SelectionDAG.  The register is available from the RegisterSDNode object.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  CopyFromReg,</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  CopyFromReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline"></td>
    <td class="lineNumber">209</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">  /// UNDEF - An undefined node.</td>
    <td class="lineNumber">210</td>
    <td class="codeline">  /// UNDEF - An undefined node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  UNDEF,</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  UNDEF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline"></td>
    <td class="lineNumber">212</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  // FREEZE - FREEZE(VAL) returns an arbitrary value if VAL is UNDEF (or</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  // FREEZE - FREEZE(VAL) returns an arbitrary value if VAL is UNDEF (or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">  // is evaluated to UNDEF), or returns VAL otherwise. Note that each</td>
    <td class="lineNumber">214</td>
    <td class="codeline">  // is evaluated to UNDEF), or returns VAL otherwise. Note that each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">  // read of UNDEF can yield different value, but FREEZE(UNDEF) cannot.</td>
    <td class="lineNumber">215</td>
    <td class="codeline">  // read of UNDEF can yield different value, but FREEZE(UNDEF) cannot.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">  FREEZE,</td>
    <td class="lineNumber">216</td>
    <td class="codeline">  FREEZE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
    <td class="lineNumber">217</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  /// EXTRACT_ELEMENT - This is used to get the lower or upper (determined by</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  /// EXTRACT_ELEMENT - This is used to get the lower or upper (determined by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  /// a Constant, which is required to be operand #1) half of the integer or</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  /// a Constant, which is required to be operand #1) half of the integer or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">  /// float value specified as operand #0.  This is only for use before</td>
    <td class="lineNumber">220</td>
    <td class="codeline">  /// float value specified as operand #0.  This is only for use before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  /// legalization, for values that will be broken into multiple registers.</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  /// legalization, for values that will be broken into multiple registers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">  EXTRACT_ELEMENT,</td>
    <td class="lineNumber">222</td>
    <td class="codeline">  EXTRACT_ELEMENT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline"></td>
    <td class="lineNumber">223</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">  /// BUILD_PAIR - This is the opposite of EXTRACT_ELEMENT in some ways.</td>
    <td class="lineNumber">224</td>
    <td class="codeline">  /// BUILD_PAIR - This is the opposite of EXTRACT_ELEMENT in some ways.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">  /// Given two values of the same integer value type, this produces a value</td>
    <td class="lineNumber">225</td>
    <td class="codeline">  /// Given two values of the same integer value type, this produces a value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">  /// twice as big.  Like EXTRACT_ELEMENT, this can only be used before</td>
    <td class="lineNumber">226</td>
    <td class="codeline">  /// twice as big.  Like EXTRACT_ELEMENT, this can only be used before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">  /// legalization. The lower part of the composite value should be in</td>
    <td class="lineNumber">227</td>
    <td class="codeline">  /// legalization. The lower part of the composite value should be in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">  /// element 0 and the upper part should be in element 1.</td>
    <td class="lineNumber">228</td>
    <td class="codeline">  /// element 0 and the upper part should be in element 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  BUILD_PAIR,</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  BUILD_PAIR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline"></td>
    <td class="lineNumber">230</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  /// MERGE_VALUES - This node takes multiple discrete operands and returns</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  /// MERGE_VALUES - This node takes multiple discrete operands and returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  /// them all as its individual results.  This nodes has exactly the same</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  /// them all as its individual results.  This nodes has exactly the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  /// number of inputs and outputs. This node is useful for some pieces of the</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  /// number of inputs and outputs. This node is useful for some pieces of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">  /// code generator that want to think about a single node with multiple</td>
    <td class="lineNumber">234</td>
    <td class="codeline">  /// code generator that want to think about a single node with multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  /// results, not multiple nodes.</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  /// results, not multiple nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">  MERGE_VALUES,</td>
    <td class="lineNumber">236</td>
    <td class="codeline">  MERGE_VALUES,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline"></td>
    <td class="lineNumber">237</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  /// Simple integer binary arithmetic operators.</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  /// Simple integer binary arithmetic operators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  ADD,</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  ADD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  SUB,</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  SUB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  MUL,</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  MUL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  SDIV,</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  SDIV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  UDIV,</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  UDIV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  SREM,</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  SREM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">  UREM,</td>
    <td class="lineNumber">245</td>
    <td class="codeline">  UREM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  /// SMUL_LOHI/UMUL_LOHI - Multiply two integers of type iN, producing</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  /// SMUL_LOHI/UMUL_LOHI - Multiply two integers of type iN, producing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">  /// a signed/unsigned value of type i[2*N], and return the full value as</td>
    <td class="lineNumber">248</td>
    <td class="codeline">  /// a signed/unsigned value of type i[2*N], and return the full value as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  /// two results, each of type iN.</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  /// two results, each of type iN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  SMUL_LOHI,</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  SMUL_LOHI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  UMUL_LOHI,</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  UMUL_LOHI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline"></td>
    <td class="lineNumber">252</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  /// SDIVREM/UDIVREM - Divide two integers and produce both a quotient and</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  /// SDIVREM/UDIVREM - Divide two integers and produce both a quotient and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  /// remainder result.</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  /// remainder result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  SDIVREM,</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  SDIVREM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">  UDIVREM,</td>
    <td class="lineNumber">256</td>
    <td class="codeline">  UDIVREM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline"></td>
    <td class="lineNumber">257</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">  /// CARRY_FALSE - This node is used when folding other nodes,</td>
    <td class="lineNumber">258</td>
    <td class="codeline">  /// CARRY_FALSE - This node is used when folding other nodes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">  /// like ADDC/SUBC, which indicate the carry result is always false.</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  /// like ADDC/SUBC, which indicate the carry result is always false.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">  CARRY_FALSE,</td>
    <td class="lineNumber">260</td>
    <td class="codeline">  CARRY_FALSE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  /// Carry-setting nodes for multiple precision addition and subtraction.</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  /// Carry-setting nodes for multiple precision addition and subtraction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">  /// These nodes take two operands of the same value type, and produce two</td>
    <td class="lineNumber">263</td>
    <td class="codeline">  /// These nodes take two operands of the same value type, and produce two</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  /// results.  The first result is the normal add or sub result, the second</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  /// results.  The first result is the normal add or sub result, the second</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  /// result is the carry flag result.</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  /// result is the carry flag result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  /// FIXME: These nodes are deprecated in favor of UADDO_CARRY and USUBO_CARRY.</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  /// FIXME: These nodes are deprecated in favor of UADDO_CARRY and USUBO_CARRY.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  /// They are kept around for now to provide a smooth transition path</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  /// They are kept around for now to provide a smooth transition path</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">  /// toward the use of UADDO_CARRY/USUBO_CARRY and will eventually be removed.</td>
    <td class="lineNumber">268</td>
    <td class="codeline">  /// toward the use of UADDO_CARRY/USUBO_CARRY and will eventually be removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  ADDC,</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  ADDC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  SUBC,</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  SUBC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  /// Carry-using nodes for multiple precision addition and subtraction. These</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  /// Carry-using nodes for multiple precision addition and subtraction. These</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  /// nodes take three operands: The first two are the normal lhs and rhs to</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  /// nodes take three operands: The first two are the normal lhs and rhs to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  /// the add or sub, and the third is the input carry flag.  These nodes</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  /// the add or sub, and the third is the input carry flag.  These nodes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  /// produce two results; the normal result of the add or sub, and the output</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  /// produce two results; the normal result of the add or sub, and the output</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  /// carry flag.  These nodes both read and write a carry flag to allow them</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  /// carry flag.  These nodes both read and write a carry flag to allow them</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">  /// to them to be chained together for add and sub of arbitrarily large</td>
    <td class="lineNumber">277</td>
    <td class="codeline">  /// to them to be chained together for add and sub of arbitrarily large</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  /// values.</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  /// values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">  ADDE,</td>
    <td class="lineNumber">279</td>
    <td class="codeline">  ADDE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  SUBE,</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  SUBE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline"></td>
    <td class="lineNumber">281</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">  /// Carry-using nodes for multiple precision addition and subtraction.</td>
    <td class="lineNumber">282</td>
    <td class="codeline">  /// Carry-using nodes for multiple precision addition and subtraction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  /// These nodes take three operands: The first two are the normal lhs and</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  /// These nodes take three operands: The first two are the normal lhs and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  /// rhs to the add or sub, and the third is a boolean value that is 1 if and</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  /// rhs to the add or sub, and the third is a boolean value that is 1 if and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  /// only if there is an incoming carry/borrow. These nodes produce two</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  /// only if there is an incoming carry/borrow. These nodes produce two</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">  /// results: the normal result of the add or sub, and a boolean value that is</td>
    <td class="lineNumber">286</td>
    <td class="codeline">  /// results: the normal result of the add or sub, and a boolean value that is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  /// 1 if and only if there is an outgoing carry/borrow.</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  /// 1 if and only if there is an outgoing carry/borrow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  /// Care must be taken if these opcodes are lowered to hardware instructions</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  /// Care must be taken if these opcodes are lowered to hardware instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">  /// that use the inverse logic -- 0 if and only if there is an</td>
    <td class="lineNumber">290</td>
    <td class="codeline">  /// that use the inverse logic -- 0 if and only if there is an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  /// incoming/outgoing carry/borrow.  In such cases, you must preserve the</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  /// incoming/outgoing carry/borrow.  In such cases, you must preserve the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">  /// semantics of these opcodes by inverting the incoming carry/borrow, feeding</td>
    <td class="lineNumber">292</td>
    <td class="codeline">  /// semantics of these opcodes by inverting the incoming carry/borrow, feeding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  /// it to the add/sub hardware instruction, and then inverting the outgoing</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  /// it to the add/sub hardware instruction, and then inverting the outgoing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  /// carry/borrow.</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  /// carry/borrow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  /// The use of these opcodes is preferable to adde/sube if the target supports</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  /// The use of these opcodes is preferable to adde/sube if the target supports</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">  /// it, as the carry is a regular value rather than a glue, which allows</td>
    <td class="lineNumber">297</td>
    <td class="codeline">  /// it, as the carry is a regular value rather than a glue, which allows</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  /// further optimisation.</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  /// further optimisation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">  /// These opcodes are different from [US]{ADD,SUB}O in that</td>
    <td class="lineNumber">300</td>
    <td class="codeline">  /// These opcodes are different from [US]{ADD,SUB}O in that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  /// U{ADD,SUB}O_CARRY consume and produce a carry/borrow, whereas</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  /// U{ADD,SUB}O_CARRY consume and produce a carry/borrow, whereas</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  /// [US]{ADD,SUB}O produce an overflow.</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  /// [US]{ADD,SUB}O produce an overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">  UADDO_CARRY,</td>
    <td class="lineNumber">303</td>
    <td class="codeline">  UADDO_CARRY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">  USUBO_CARRY,</td>
    <td class="lineNumber">304</td>
    <td class="codeline">  USUBO_CARRY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline"></td>
    <td class="lineNumber">305</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">  /// Carry-using overflow-aware nodes for multiple precision addition and</td>
    <td class="lineNumber">306</td>
    <td class="codeline">  /// Carry-using overflow-aware nodes for multiple precision addition and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  /// subtraction. These nodes take three operands: The first two are normal lhs</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  /// subtraction. These nodes take three operands: The first two are normal lhs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">  /// and rhs to the add or sub, and the third is a boolean indicating if there</td>
    <td class="lineNumber">308</td>
    <td class="codeline">  /// and rhs to the add or sub, and the third is a boolean indicating if there</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  /// is an incoming carry. They produce two results: the normal result of the</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  /// is an incoming carry. They produce two results: the normal result of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">  /// add or sub, and a boolean that indicates if an overflow occurred (*not*</td>
    <td class="lineNumber">310</td>
    <td class="codeline">  /// add or sub, and a boolean that indicates if an overflow occurred (*not*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">  /// flag, because it may be a store to memory, etc.). If the type of the</td>
    <td class="lineNumber">311</td>
    <td class="codeline">  /// flag, because it may be a store to memory, etc.). If the type of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">  /// boolean is not i1 then the high bits conform to getBooleanContents.</td>
    <td class="lineNumber">312</td>
    <td class="codeline">  /// boolean is not i1 then the high bits conform to getBooleanContents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">  SADDO_CARRY,</td>
    <td class="lineNumber">313</td>
    <td class="codeline">  SADDO_CARRY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">  SSUBO_CARRY,</td>
    <td class="lineNumber">314</td>
    <td class="codeline">  SSUBO_CARRY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">  /// RESULT, BOOL = [SU]ADDO(LHS, RHS) - Overflow-aware nodes for addition.</td>
    <td class="lineNumber">316</td>
    <td class="codeline">  /// RESULT, BOOL = [SU]ADDO(LHS, RHS) - Overflow-aware nodes for addition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">  /// These nodes take two operands: the normal LHS and RHS to the add. They</td>
    <td class="lineNumber">317</td>
    <td class="codeline">  /// These nodes take two operands: the normal LHS and RHS to the add. They</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">  /// produce two results: the normal result of the add, and a boolean that</td>
    <td class="lineNumber">318</td>
    <td class="codeline">  /// produce two results: the normal result of the add, and a boolean that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">  /// indicates if an overflow occurred (*not* a flag, because it may be store</td>
    <td class="lineNumber">319</td>
    <td class="codeline">  /// indicates if an overflow occurred (*not* a flag, because it may be store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">  /// to memory, etc.).  If the type of the boolean is not i1 then the high</td>
    <td class="lineNumber">320</td>
    <td class="codeline">  /// to memory, etc.).  If the type of the boolean is not i1 then the high</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">  /// bits conform to getBooleanContents.</td>
    <td class="lineNumber">321</td>
    <td class="codeline">  /// bits conform to getBooleanContents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">  /// These nodes are generated from llvm.[su]add.with.overflow intrinsics.</td>
    <td class="lineNumber">322</td>
    <td class="codeline">  /// These nodes are generated from llvm.[su]add.with.overflow intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">  SADDO,</td>
    <td class="lineNumber">323</td>
    <td class="codeline">  SADDO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">  UADDO,</td>
    <td class="lineNumber">324</td>
    <td class="codeline">  UADDO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline"></td>
    <td class="lineNumber">325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">  /// Same for subtraction.</td>
    <td class="lineNumber">326</td>
    <td class="codeline">  /// Same for subtraction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">  SSUBO,</td>
    <td class="lineNumber">327</td>
    <td class="codeline">  SSUBO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">  USUBO,</td>
    <td class="lineNumber">328</td>
    <td class="codeline">  USUBO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline"></td>
    <td class="lineNumber">329</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  /// Same for multiplication.</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  /// Same for multiplication.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">  SMULO,</td>
    <td class="lineNumber">331</td>
    <td class="codeline">  SMULO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">  UMULO,</td>
    <td class="lineNumber">332</td>
    <td class="codeline">  UMULO,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline"></td>
    <td class="lineNumber">333</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">  /// RESULT = [US]ADDSAT(LHS, RHS) - Perform saturation addition on 2</td>
    <td class="lineNumber">334</td>
    <td class="codeline">  /// RESULT = [US]ADDSAT(LHS, RHS) - Perform saturation addition on 2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">  /// integers with the same bit width (W). If the true value of LHS + RHS</td>
    <td class="lineNumber">335</td>
    <td class="codeline">  /// integers with the same bit width (W). If the true value of LHS + RHS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">  /// exceeds the largest value that can be represented by W bits, the</td>
    <td class="lineNumber">336</td>
    <td class="codeline">  /// exceeds the largest value that can be represented by W bits, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  /// resulting value is this maximum value. Otherwise, if this value is less</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  /// resulting value is this maximum value. Otherwise, if this value is less</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">  /// than the smallest value that can be represented by W bits, the</td>
    <td class="lineNumber">338</td>
    <td class="codeline">  /// than the smallest value that can be represented by W bits, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">  /// resulting value is this minimum value.</td>
    <td class="lineNumber">339</td>
    <td class="codeline">  /// resulting value is this minimum value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">  SADDSAT,</td>
    <td class="lineNumber">340</td>
    <td class="codeline">  SADDSAT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">  UADDSAT,</td>
    <td class="lineNumber">341</td>
    <td class="codeline">  UADDSAT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline"></td>
    <td class="lineNumber">342</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">  /// RESULT = [US]SUBSAT(LHS, RHS) - Perform saturation subtraction on 2</td>
    <td class="lineNumber">343</td>
    <td class="codeline">  /// RESULT = [US]SUBSAT(LHS, RHS) - Perform saturation subtraction on 2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">  /// integers with the same bit width (W). If the true value of LHS - RHS</td>
    <td class="lineNumber">344</td>
    <td class="codeline">  /// integers with the same bit width (W). If the true value of LHS - RHS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  /// exceeds the largest value that can be represented by W bits, the</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  /// exceeds the largest value that can be represented by W bits, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">  /// resulting value is this maximum value. Otherwise, if this value is less</td>
    <td class="lineNumber">346</td>
    <td class="codeline">  /// resulting value is this maximum value. Otherwise, if this value is less</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">  /// than the smallest value that can be represented by W bits, the</td>
    <td class="lineNumber">347</td>
    <td class="codeline">  /// than the smallest value that can be represented by W bits, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">  /// resulting value is this minimum value.</td>
    <td class="lineNumber">348</td>
    <td class="codeline">  /// resulting value is this minimum value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">  SSUBSAT,</td>
    <td class="lineNumber">349</td>
    <td class="codeline">  SSUBSAT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">  USUBSAT,</td>
    <td class="lineNumber">350</td>
    <td class="codeline">  USUBSAT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline"></td>
    <td class="lineNumber">351</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">  /// RESULT = [US]SHLSAT(LHS, RHS) - Perform saturation left shift. The first</td>
    <td class="lineNumber">352</td>
    <td class="codeline">  /// RESULT = [US]SHLSAT(LHS, RHS) - Perform saturation left shift. The first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">  /// operand is the value to be shifted, and the second argument is the amount</td>
    <td class="lineNumber">353</td>
    <td class="codeline">  /// operand is the value to be shifted, and the second argument is the amount</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">  /// to shift by. Both must be integers of the same bit width (W). If the true</td>
    <td class="lineNumber">354</td>
    <td class="codeline">  /// to shift by. Both must be integers of the same bit width (W). If the true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">  /// value of LHS << RHS exceeds the largest value that can be represented by</td>
    <td class="lineNumber">355</td>
    <td class="codeline">  /// value of LHS << RHS exceeds the largest value that can be represented by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  /// W bits, the resulting value is this maximum value, Otherwise, if this</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  /// W bits, the resulting value is this maximum value, Otherwise, if this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">  /// value is less than the smallest value that can be represented by W bits,</td>
    <td class="lineNumber">357</td>
    <td class="codeline">  /// value is less than the smallest value that can be represented by W bits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">  /// the resulting value is this minimum value.</td>
    <td class="lineNumber">358</td>
    <td class="codeline">  /// the resulting value is this minimum value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">  SSHLSAT,</td>
    <td class="lineNumber">359</td>
    <td class="codeline">  SSHLSAT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">  USHLSAT,</td>
    <td class="lineNumber">360</td>
    <td class="codeline">  USHLSAT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline"></td>
    <td class="lineNumber">361</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">  /// RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication</td>
    <td class="lineNumber">362</td>
    <td class="codeline">  /// RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">  /// on 2 integers with the same width and scale. SCALE represents the scale</td>
    <td class="lineNumber">363</td>
    <td class="codeline">  /// on 2 integers with the same width and scale. SCALE represents the scale</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">  /// of both operands as fixed point numbers. This SCALE parameter must be a</td>
    <td class="lineNumber">364</td>
    <td class="codeline">  /// of both operands as fixed point numbers. This SCALE parameter must be a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">  /// constant integer. A scale of zero is effectively performing</td>
    <td class="lineNumber">365</td>
    <td class="codeline">  /// constant integer. A scale of zero is effectively performing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">  /// multiplication on 2 integers.</td>
    <td class="lineNumber">366</td>
    <td class="codeline">  /// multiplication on 2 integers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">  SMULFIX,</td>
    <td class="lineNumber">367</td>
    <td class="codeline">  SMULFIX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">  UMULFIX,</td>
    <td class="lineNumber">368</td>
    <td class="codeline">  UMULFIX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
    <td class="lineNumber">369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  /// Same as the corresponding unsaturated fixed point instructions, but the</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  /// Same as the corresponding unsaturated fixed point instructions, but the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  /// result is clamped between the min and max values representable by the</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  /// result is clamped between the min and max values representable by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">  /// bits of the first 2 operands.</td>
    <td class="lineNumber">372</td>
    <td class="codeline">  /// bits of the first 2 operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">  SMULFIXSAT,</td>
    <td class="lineNumber">373</td>
    <td class="codeline">  SMULFIXSAT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">  UMULFIXSAT,</td>
    <td class="lineNumber">374</td>
    <td class="codeline">  UMULFIXSAT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline"></td>
    <td class="lineNumber">375</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">  /// RESULT = [US]DIVFIX(LHS, RHS, SCALE) - Perform fixed point division on</td>
    <td class="lineNumber">376</td>
    <td class="codeline">  /// RESULT = [US]DIVFIX(LHS, RHS, SCALE) - Perform fixed point division on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">  /// 2 integers with the same width and scale. SCALE represents the scale</td>
    <td class="lineNumber">377</td>
    <td class="codeline">  /// 2 integers with the same width and scale. SCALE represents the scale</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">  /// of both operands as fixed point numbers. This SCALE parameter must be a</td>
    <td class="lineNumber">378</td>
    <td class="codeline">  /// of both operands as fixed point numbers. This SCALE parameter must be a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  /// constant integer.</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  /// constant integer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">  SDIVFIX,</td>
    <td class="lineNumber">380</td>
    <td class="codeline">  SDIVFIX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">  UDIVFIX,</td>
    <td class="lineNumber">381</td>
    <td class="codeline">  UDIVFIX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
    <td class="lineNumber">382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  /// Same as the corresponding unsaturated fixed point instructions, but the</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  /// Same as the corresponding unsaturated fixed point instructions, but the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">  /// result is clamped between the min and max values representable by the</td>
    <td class="lineNumber">384</td>
    <td class="codeline">  /// result is clamped between the min and max values representable by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  /// bits of the first 2 operands.</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  /// bits of the first 2 operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">  SDIVFIXSAT,</td>
    <td class="lineNumber">386</td>
    <td class="codeline">  SDIVFIXSAT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">  UDIVFIXSAT,</td>
    <td class="lineNumber">387</td>
    <td class="codeline">  UDIVFIXSAT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">  /// Simple binary floating point operators.</td>
    <td class="lineNumber">389</td>
    <td class="codeline">  /// Simple binary floating point operators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">  FADD,</td>
    <td class="lineNumber">390</td>
    <td class="codeline">  FADD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">  FSUB,</td>
    <td class="lineNumber">391</td>
    <td class="codeline">  FSUB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">  FMUL,</td>
    <td class="lineNumber">392</td>
    <td class="codeline">  FMUL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  FDIV,</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  FDIV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  FREM,</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  FREM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
    <td class="lineNumber">395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  /// Constrained versions of the binary floating point operators.</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  /// Constrained versions of the binary floating point operators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">  /// These will be lowered to the simple operators before final selection.</td>
    <td class="lineNumber">397</td>
    <td class="codeline">  /// These will be lowered to the simple operators before final selection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">  /// They are used to limit optimizations while the DAG is being</td>
    <td class="lineNumber">398</td>
    <td class="codeline">  /// They are used to limit optimizations while the DAG is being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">  /// optimized.</td>
    <td class="lineNumber">399</td>
    <td class="codeline">  /// optimized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  STRICT_FADD,</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  STRICT_FADD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">  STRICT_FSUB,</td>
    <td class="lineNumber">401</td>
    <td class="codeline">  STRICT_FSUB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  STRICT_FMUL,</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  STRICT_FMUL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  STRICT_FDIV,</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  STRICT_FDIV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  STRICT_FREM,</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  STRICT_FREM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  STRICT_FMA,</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  STRICT_FMA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline"></td>
    <td class="lineNumber">406</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">  /// Constrained versions of libm-equivalent floating point intrinsics.</td>
    <td class="lineNumber">407</td>
    <td class="codeline">  /// Constrained versions of libm-equivalent floating point intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">  /// These will be lowered to the equivalent non-constrained pseudo-op</td>
    <td class="lineNumber">408</td>
    <td class="codeline">  /// These will be lowered to the equivalent non-constrained pseudo-op</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">  /// (or expanded to the equivalent library call) before final selection.</td>
    <td class="lineNumber">409</td>
    <td class="codeline">  /// (or expanded to the equivalent library call) before final selection.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">  /// They are used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">410</td>
    <td class="codeline">  /// They are used to limit optimizations while the DAG is being optimized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">  STRICT_FSQRT,</td>
    <td class="lineNumber">411</td>
    <td class="codeline">  STRICT_FSQRT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  STRICT_FPOW,</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  STRICT_FPOW,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">  STRICT_FPOWI,</td>
    <td class="lineNumber">413</td>
    <td class="codeline">  STRICT_FPOWI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">  STRICT_FLDEXP,</td>
    <td class="lineNumber">414</td>
    <td class="codeline">  STRICT_FLDEXP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  STRICT_FSIN,</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  STRICT_FSIN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">  STRICT_FCOS,</td>
    <td class="lineNumber">416</td>
    <td class="codeline">  STRICT_FCOS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">  STRICT_FEXP,</td>
    <td class="lineNumber">417</td>
    <td class="codeline">  STRICT_FEXP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">  STRICT_FEXP2,</td>
    <td class="lineNumber">418</td>
    <td class="codeline">  STRICT_FEXP2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">  STRICT_FLOG,</td>
    <td class="lineNumber">419</td>
    <td class="codeline">  STRICT_FLOG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">  STRICT_FLOG10,</td>
    <td class="lineNumber">420</td>
    <td class="codeline">  STRICT_FLOG10,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">  STRICT_FLOG2,</td>
    <td class="lineNumber">421</td>
    <td class="codeline">  STRICT_FLOG2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  STRICT_FRINT,</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  STRICT_FRINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">  STRICT_FNEARBYINT,</td>
    <td class="lineNumber">423</td>
    <td class="codeline">  STRICT_FNEARBYINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  STRICT_FMAXNUM,</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  STRICT_FMAXNUM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  STRICT_FMINNUM,</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  STRICT_FMINNUM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  STRICT_FCEIL,</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  STRICT_FCEIL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  STRICT_FFLOOR,</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  STRICT_FFLOOR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  STRICT_FROUND,</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  STRICT_FROUND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">  STRICT_FROUNDEVEN,</td>
    <td class="lineNumber">429</td>
    <td class="codeline">  STRICT_FROUNDEVEN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  STRICT_FTRUNC,</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  STRICT_FTRUNC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  STRICT_LROUND,</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  STRICT_LROUND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  STRICT_LLROUND,</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  STRICT_LLROUND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">  STRICT_LRINT,</td>
    <td class="lineNumber">433</td>
    <td class="codeline">  STRICT_LRINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">  STRICT_LLRINT,</td>
    <td class="lineNumber">434</td>
    <td class="codeline">  STRICT_LLRINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  STRICT_FMAXIMUM,</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  STRICT_FMAXIMUM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">  STRICT_FMINIMUM,</td>
    <td class="lineNumber">436</td>
    <td class="codeline">  STRICT_FMINIMUM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline"></td>
    <td class="lineNumber">437</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">  /// STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or</td>
    <td class="lineNumber">438</td>
    <td class="codeline">  /// STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  /// unsigned integer. These have the same semantics as fptosi and fptoui</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  /// unsigned integer. These have the same semantics as fptosi and fptoui</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">  /// in IR.</td>
    <td class="lineNumber">440</td>
    <td class="codeline">  /// in IR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">  /// They are used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">441</td>
    <td class="codeline">  /// They are used to limit optimizations while the DAG is being optimized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">  STRICT_FP_TO_SINT,</td>
    <td class="lineNumber">442</td>
    <td class="codeline">  STRICT_FP_TO_SINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">  STRICT_FP_TO_UINT,</td>
    <td class="lineNumber">443</td>
    <td class="codeline">  STRICT_FP_TO_UINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline"></td>
    <td class="lineNumber">444</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">  /// STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to</td>
    <td class="lineNumber">445</td>
    <td class="codeline">  /// STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">  /// a floating point value. These have the same semantics as sitofp and</td>
    <td class="lineNumber">446</td>
    <td class="codeline">  /// a floating point value. These have the same semantics as sitofp and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">  /// uitofp in IR.</td>
    <td class="lineNumber">447</td>
    <td class="codeline">  /// uitofp in IR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">  /// They are used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">448</td>
    <td class="codeline">  /// They are used to limit optimizations while the DAG is being optimized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">  STRICT_SINT_TO_FP,</td>
    <td class="lineNumber">449</td>
    <td class="codeline">  STRICT_SINT_TO_FP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">  STRICT_UINT_TO_FP,</td>
    <td class="lineNumber">450</td>
    <td class="codeline">  STRICT_UINT_TO_FP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline"></td>
    <td class="lineNumber">451</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">  /// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating</td>
    <td class="lineNumber">452</td>
    <td class="codeline">  /// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  /// point type down to the precision of the destination VT.  TRUNC is a</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  /// point type down to the precision of the destination VT.  TRUNC is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">  /// flag, which is always an integer that is zero or one.  If TRUNC is 0,</td>
    <td class="lineNumber">454</td>
    <td class="codeline">  /// flag, which is always an integer that is zero or one.  If TRUNC is 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  /// this is a normal rounding, if it is 1, this FP_ROUND is known to not</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  /// this is a normal rounding, if it is 1, this FP_ROUND is known to not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">  /// change the value of Y.</td>
    <td class="lineNumber">456</td>
    <td class="codeline">  /// change the value of Y.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">457</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">  /// The TRUNC = 1 case is used in cases where we know that the value will</td>
    <td class="lineNumber">458</td>
    <td class="codeline">  /// The TRUNC = 1 case is used in cases where we know that the value will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">  /// not be modified by the node, because Y is not using any of the extra</td>
    <td class="lineNumber">459</td>
    <td class="codeline">  /// not be modified by the node, because Y is not using any of the extra</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">  /// precision of source type.  This allows certain transformations like</td>
    <td class="lineNumber">460</td>
    <td class="codeline">  /// precision of source type.  This allows certain transformations like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">  /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for</td>
    <td class="lineNumber">461</td>
    <td class="codeline">  /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">  /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't</td>
    <td class="lineNumber">462</td>
    <td class="codeline">  /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">  /// removed.</td>
    <td class="lineNumber">463</td>
    <td class="codeline">  /// removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  /// It is used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  /// It is used to limit optimizations while the DAG is being optimized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  STRICT_FP_ROUND,</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  STRICT_FP_ROUND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  /// X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  /// X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">  /// type.</td>
    <td class="lineNumber">468</td>
    <td class="codeline">  /// type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">  /// It is used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">469</td>
    <td class="codeline">  /// It is used to limit optimizations while the DAG is being optimized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">  STRICT_FP_EXTEND,</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  STRICT_FP_EXTEND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline"></td>
    <td class="lineNumber">471</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  /// STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  /// STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  /// for floating-point operands only.  STRICT_FSETCC performs a quiet</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  /// for floating-point operands only.  STRICT_FSETCC performs a quiet</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  /// comparison operation, while STRICT_FSETCCS performs a signaling</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  /// comparison operation, while STRICT_FSETCCS performs a signaling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  /// comparison operation.</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  /// comparison operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  STRICT_FSETCC,</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  STRICT_FSETCC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  STRICT_FSETCCS,</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  STRICT_FSETCCS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline"></td>
    <td class="lineNumber">478</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  // FPTRUNC_ROUND - This corresponds to the fptrunc_round intrinsic.</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  // FPTRUNC_ROUND - This corresponds to the fptrunc_round intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">  FPTRUNC_ROUND,</td>
    <td class="lineNumber">480</td>
    <td class="codeline">  FPTRUNC_ROUND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
    <td class="lineNumber">481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">  /// FMA - Perform a * b + c with no intermediate rounding step.</td>
    <td class="lineNumber">482</td>
    <td class="codeline">  /// FMA - Perform a * b + c with no intermediate rounding step.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">  FMA,</td>
    <td class="lineNumber">483</td>
    <td class="codeline">  FMA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline"></td>
    <td class="lineNumber">484</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">  /// FMAD - Perform a * b + c, while getting the same result as the</td>
    <td class="lineNumber">485</td>
    <td class="codeline">  /// FMAD - Perform a * b + c, while getting the same result as the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  /// separately rounded operations.</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  /// separately rounded operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  FMAD,</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  FMAD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">  /// FCOPYSIGN(X, Y) - Return the value of X with the sign of Y.  NOTE: This</td>
    <td class="lineNumber">489</td>
    <td class="codeline">  /// FCOPYSIGN(X, Y) - Return the value of X with the sign of Y.  NOTE: This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">  /// DAG node does not require that X and Y have the same type, just that</td>
    <td class="lineNumber">490</td>
    <td class="codeline">  /// DAG node does not require that X and Y have the same type, just that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  /// they are both floating point.  X and the result must have the same type.</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  /// they are both floating point.  X and the result must have the same type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">  /// FCOPYSIGN(f32, f64) is allowed.</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  /// FCOPYSIGN(f32, f64) is allowed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  FCOPYSIGN,</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  FCOPYSIGN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline"></td>
    <td class="lineNumber">494</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">  /// INT = FGETSIGN(FP) - Return the sign bit of the specified floating point</td>
    <td class="lineNumber">495</td>
    <td class="codeline">  /// INT = FGETSIGN(FP) - Return the sign bit of the specified floating point</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  /// value as an integer 0/1 value.</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  /// value as an integer 0/1 value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">  FGETSIGN,</td>
    <td class="lineNumber">497</td>
    <td class="codeline">  FGETSIGN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline"></td>
    <td class="lineNumber">498</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">  /// Returns platform specific canonical encoding of a floating point number.</td>
    <td class="lineNumber">499</td>
    <td class="codeline">  /// Returns platform specific canonical encoding of a floating point number.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">  FCANONICALIZE,</td>
    <td class="lineNumber">500</td>
    <td class="codeline">  FCANONICALIZE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline"></td>
    <td class="lineNumber">501</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">  /// Performs a check of floating point class property, defined by IEEE-754.</td>
    <td class="lineNumber">502</td>
    <td class="codeline">  /// Performs a check of floating point class property, defined by IEEE-754.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">  /// The first operand is the floating point value to check. The second operand</td>
    <td class="lineNumber">503</td>
    <td class="codeline">  /// The first operand is the floating point value to check. The second operand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">  /// specifies the checked property and is a TargetConstant which specifies</td>
    <td class="lineNumber">504</td>
    <td class="codeline">  /// specifies the checked property and is a TargetConstant which specifies</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">  /// test in the same way as intrinsic 'is_fpclass'.</td>
    <td class="lineNumber">505</td>
    <td class="codeline">  /// test in the same way as intrinsic 'is_fpclass'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">  /// Returns boolean value.</td>
    <td class="lineNumber">506</td>
    <td class="codeline">  /// Returns boolean value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">  IS_FPCLASS,</td>
    <td class="lineNumber">507</td>
    <td class="codeline">  IS_FPCLASS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline"></td>
    <td class="lineNumber">508</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  /// BUILD_VECTOR(ELT0, ELT1, ELT2, ELT3,...) - Return a fixed-width vector</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  /// BUILD_VECTOR(ELT0, ELT1, ELT2, ELT3,...) - Return a fixed-width vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">  /// with the specified, possibly variable, elements. The types of the</td>
    <td class="lineNumber">510</td>
    <td class="codeline">  /// with the specified, possibly variable, elements. The types of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">  /// operands must match the vector element type, except that integer types</td>
    <td class="lineNumber">511</td>
    <td class="codeline">  /// operands must match the vector element type, except that integer types</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  /// are allowed to be larger than the element type, in which case the</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  /// are allowed to be larger than the element type, in which case the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">  /// operands are implicitly truncated. The types of the operands must all</td>
    <td class="lineNumber">513</td>
    <td class="codeline">  /// operands are implicitly truncated. The types of the operands must all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">  /// be the same.</td>
    <td class="lineNumber">514</td>
    <td class="codeline">  /// be the same.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">  BUILD_VECTOR,</td>
    <td class="lineNumber">515</td>
    <td class="codeline">  BUILD_VECTOR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline"></td>
    <td class="lineNumber">516</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">  /// INSERT_VECTOR_ELT(VECTOR, VAL, IDX) - Returns VECTOR with the element</td>
    <td class="lineNumber">517</td>
    <td class="codeline">  /// INSERT_VECTOR_ELT(VECTOR, VAL, IDX) - Returns VECTOR with the element</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">  /// at IDX replaced with VAL. If the type of VAL is larger than the vector</td>
    <td class="lineNumber">518</td>
    <td class="codeline">  /// at IDX replaced with VAL. If the type of VAL is larger than the vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  /// element type then VAL is truncated before replacement.</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  /// element type then VAL is truncated before replacement.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">520</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">  /// If VECTOR is a scalable vector, then IDX may be larger than the minimum</td>
    <td class="lineNumber">521</td>
    <td class="codeline">  /// If VECTOR is a scalable vector, then IDX may be larger than the minimum</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">  /// vector width. IDX is not first scaled by the runtime scaling factor of</td>
    <td class="lineNumber">522</td>
    <td class="codeline">  /// vector width. IDX is not first scaled by the runtime scaling factor of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  /// VECTOR.</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  /// VECTOR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">  INSERT_VECTOR_ELT,</td>
    <td class="lineNumber">524</td>
    <td class="codeline">  INSERT_VECTOR_ELT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline"></td>
    <td class="lineNumber">525</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">  /// EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR</td>
    <td class="lineNumber">526</td>
    <td class="codeline">  /// EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  /// identified by the (potentially variable) element number IDX. If the return</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  /// identified by the (potentially variable) element number IDX. If the return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">  /// type is an integer type larger than the element type of the vector, the</td>
    <td class="lineNumber">528</td>
    <td class="codeline">  /// type is an integer type larger than the element type of the vector, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">  /// result is extended to the width of the return type. In that case, the high</td>
    <td class="lineNumber">529</td>
    <td class="codeline">  /// result is extended to the width of the return type. In that case, the high</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  /// bits are undefined.</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  /// bits are undefined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">531</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">  /// If VECTOR is a scalable vector, then IDX may be larger than the minimum</td>
    <td class="lineNumber">532</td>
    <td class="codeline">  /// If VECTOR is a scalable vector, then IDX may be larger than the minimum</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">  /// vector width. IDX is not first scaled by the runtime scaling factor of</td>
    <td class="lineNumber">533</td>
    <td class="codeline">  /// vector width. IDX is not first scaled by the runtime scaling factor of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">  /// VECTOR.</td>
    <td class="lineNumber">534</td>
    <td class="codeline">  /// VECTOR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">  EXTRACT_VECTOR_ELT,</td>
    <td class="lineNumber">535</td>
    <td class="codeline">  EXTRACT_VECTOR_ELT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline"></td>
    <td class="lineNumber">536</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  /// CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  /// CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">  /// vector type with the same length and element type, this produces a</td>
    <td class="lineNumber">538</td>
    <td class="codeline">  /// vector type with the same length and element type, this produces a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  /// concatenated vector result value, with length equal to the sum of the</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  /// concatenated vector result value, with length equal to the sum of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">  /// lengths of the input vectors. If VECTOR0 is a fixed-width vector, then</td>
    <td class="lineNumber">540</td>
    <td class="codeline">  /// lengths of the input vectors. If VECTOR0 is a fixed-width vector, then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  /// VECTOR1..VECTORN must all be fixed-width vectors. Similarly, if VECTOR0</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  /// VECTOR1..VECTORN must all be fixed-width vectors. Similarly, if VECTOR0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">  /// is a scalable vector, then VECTOR1..VECTORN must all be scalable vectors.</td>
    <td class="lineNumber">542</td>
    <td class="codeline">  /// is a scalable vector, then VECTOR1..VECTORN must all be scalable vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">  CONCAT_VECTORS,</td>
    <td class="lineNumber">543</td>
    <td class="codeline">  CONCAT_VECTORS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline"></td>
    <td class="lineNumber">544</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">  /// INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX) - Returns a vector with VECTOR2</td>
    <td class="lineNumber">545</td>
    <td class="codeline">  /// INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX) - Returns a vector with VECTOR2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">  /// inserted into VECTOR1. IDX represents the starting element number at which</td>
    <td class="lineNumber">546</td>
    <td class="codeline">  /// inserted into VECTOR1. IDX represents the starting element number at which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  /// VECTOR2 will be inserted. IDX must be a constant multiple of T's known</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  /// VECTOR2 will be inserted. IDX must be a constant multiple of T's known</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  /// minimum vector length. Let the type of VECTOR2 be T, then if T is a</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  /// minimum vector length. Let the type of VECTOR2 be T, then if T is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">  /// scalable vector, IDX is first scaled by the runtime scaling factor of T.</td>
    <td class="lineNumber">549</td>
    <td class="codeline">  /// scalable vector, IDX is first scaled by the runtime scaling factor of T.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">  /// The elements of VECTOR1 starting at IDX are overwritten with VECTOR2.</td>
    <td class="lineNumber">550</td>
    <td class="codeline">  /// The elements of VECTOR1 starting at IDX are overwritten with VECTOR2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">  /// Elements IDX through (IDX + num_elements(T) - 1) must be valid VECTOR1</td>
    <td class="lineNumber">551</td>
    <td class="codeline">  /// Elements IDX through (IDX + num_elements(T) - 1) must be valid VECTOR1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">  /// indices. If this condition cannot be determined statically but is false at</td>
    <td class="lineNumber">552</td>
    <td class="codeline">  /// indices. If this condition cannot be determined statically but is false at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">  /// runtime, then the result vector is undefined. The IDX parameter must be a</td>
    <td class="lineNumber">553</td>
    <td class="codeline">  /// runtime, then the result vector is undefined. The IDX parameter must be a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">  /// vector index constant type, which for most targets will be an integer</td>
    <td class="lineNumber">554</td>
    <td class="codeline">  /// vector index constant type, which for most targets will be an integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">  /// pointer type.</td>
    <td class="lineNumber">555</td>
    <td class="codeline">  /// pointer type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">556</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">  /// This operation supports inserting a fixed-width vector into a scalable</td>
    <td class="lineNumber">557</td>
    <td class="codeline">  /// This operation supports inserting a fixed-width vector into a scalable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">  /// vector, but not the other way around.</td>
    <td class="lineNumber">558</td>
    <td class="codeline">  /// vector, but not the other way around.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">  INSERT_SUBVECTOR,</td>
    <td class="lineNumber">559</td>
    <td class="codeline">  INSERT_SUBVECTOR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline"></td>
    <td class="lineNumber">560</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">  /// EXTRACT_SUBVECTOR(VECTOR, IDX) - Returns a subvector from VECTOR.</td>
    <td class="lineNumber">561</td>
    <td class="codeline">  /// EXTRACT_SUBVECTOR(VECTOR, IDX) - Returns a subvector from VECTOR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">  /// Let the result type be T, then IDX represents the starting element number</td>
    <td class="lineNumber">562</td>
    <td class="codeline">  /// Let the result type be T, then IDX represents the starting element number</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  /// from which a subvector of type T is extracted. IDX must be a constant</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  /// from which a subvector of type T is extracted. IDX must be a constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">  /// multiple of T's known minimum vector length. If T is a scalable vector,</td>
    <td class="lineNumber">564</td>
    <td class="codeline">  /// multiple of T's known minimum vector length. If T is a scalable vector,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">  /// IDX is first scaled by the runtime scaling factor of T. Elements IDX</td>
    <td class="lineNumber">565</td>
    <td class="codeline">  /// IDX is first scaled by the runtime scaling factor of T. Elements IDX</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">  /// through (IDX + num_elements(T) - 1) must be valid VECTOR indices. If this</td>
    <td class="lineNumber">566</td>
    <td class="codeline">  /// through (IDX + num_elements(T) - 1) must be valid VECTOR indices. If this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">  /// condition cannot be determined statically but is false at runtime, then</td>
    <td class="lineNumber">567</td>
    <td class="codeline">  /// condition cannot be determined statically but is false at runtime, then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">  /// the result vector is undefined. The IDX parameter must be a vector index</td>
    <td class="lineNumber">568</td>
    <td class="codeline">  /// the result vector is undefined. The IDX parameter must be a vector index</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">  /// constant type, which for most targets will be an integer pointer type.</td>
    <td class="lineNumber">569</td>
    <td class="codeline">  /// constant type, which for most targets will be an integer pointer type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">570</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">  /// This operation supports extracting a fixed-width vector from a scalable</td>
    <td class="lineNumber">571</td>
    <td class="codeline">  /// This operation supports extracting a fixed-width vector from a scalable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">  /// vector, but not the other way around.</td>
    <td class="lineNumber">572</td>
    <td class="codeline">  /// vector, but not the other way around.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">  EXTRACT_SUBVECTOR,</td>
    <td class="lineNumber">573</td>
    <td class="codeline">  EXTRACT_SUBVECTOR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline"></td>
    <td class="lineNumber">574</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">  /// VECTOR_DEINTERLEAVE(VEC1, VEC2) - Returns two vectors with all input and</td>
    <td class="lineNumber">575</td>
    <td class="codeline">  /// VECTOR_DEINTERLEAVE(VEC1, VEC2) - Returns two vectors with all input and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  /// output vectors having the same type. The first output contains the even</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  /// output vectors having the same type. The first output contains the even</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  /// indices from CONCAT_VECTORS(VEC1, VEC2), with the second output</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  /// indices from CONCAT_VECTORS(VEC1, VEC2), with the second output</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">  /// containing the odd indices. The relative order of elements within an</td>
    <td class="lineNumber">578</td>
    <td class="codeline">  /// containing the odd indices. The relative order of elements within an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">  /// output match that of the concatenated input.</td>
    <td class="lineNumber">579</td>
    <td class="codeline">  /// output match that of the concatenated input.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">  VECTOR_DEINTERLEAVE,</td>
    <td class="lineNumber">580</td>
    <td class="codeline">  VECTOR_DEINTERLEAVE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline"></td>
    <td class="lineNumber">581</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">  /// VECTOR_INTERLEAVE(VEC1, VEC2) - Returns two vectors with all input and</td>
    <td class="lineNumber">582</td>
    <td class="codeline">  /// VECTOR_INTERLEAVE(VEC1, VEC2) - Returns two vectors with all input and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">  /// output vectors having the same type. The first output contains the</td>
    <td class="lineNumber">583</td>
    <td class="codeline">  /// output vectors having the same type. The first output contains the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">  /// result of interleaving the low half of CONCAT_VECTORS(VEC1, VEC2), with</td>
    <td class="lineNumber">584</td>
    <td class="codeline">  /// result of interleaving the low half of CONCAT_VECTORS(VEC1, VEC2), with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  /// the second output containing the result of interleaving the high half.</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  /// the second output containing the result of interleaving the high half.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">  VECTOR_INTERLEAVE,</td>
    <td class="lineNumber">586</td>
    <td class="codeline">  VECTOR_INTERLEAVE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
    <td class="lineNumber">587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">  /// VECTOR_REVERSE(VECTOR) - Returns a vector, of the same type as VECTOR,</td>
    <td class="lineNumber">588</td>
    <td class="codeline">  /// VECTOR_REVERSE(VECTOR) - Returns a vector, of the same type as VECTOR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">  /// whose elements are shuffled using the following algorithm:</td>
    <td class="lineNumber">589</td>
    <td class="codeline">  /// whose elements are shuffled using the following algorithm:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">  ///   RESULT[i] = VECTOR[VECTOR.ElementCount - 1 - i]</td>
    <td class="lineNumber">590</td>
    <td class="codeline">  ///   RESULT[i] = VECTOR[VECTOR.ElementCount - 1 - i]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">  VECTOR_REVERSE,</td>
    <td class="lineNumber">591</td>
    <td class="codeline">  VECTOR_REVERSE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline"></td>
    <td class="lineNumber">592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">  /// VECTOR_SHUFFLE(VEC1, VEC2) - Returns a vector, of the same type as</td>
    <td class="lineNumber">593</td>
    <td class="codeline">  /// VECTOR_SHUFFLE(VEC1, VEC2) - Returns a vector, of the same type as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">  /// VEC1/VEC2.  A VECTOR_SHUFFLE node also contains an array of constant int</td>
    <td class="lineNumber">594</td>
    <td class="codeline">  /// VEC1/VEC2.  A VECTOR_SHUFFLE node also contains an array of constant int</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">  /// values that indicate which value (or undef) each result element will</td>
    <td class="lineNumber">595</td>
    <td class="codeline">  /// values that indicate which value (or undef) each result element will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  /// get.  These constant ints are accessible through the</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  /// get.  These constant ints are accessible through the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">  /// ShuffleVectorSDNode class.  This is quite similar to the Altivec</td>
    <td class="lineNumber">597</td>
    <td class="codeline">  /// ShuffleVectorSDNode class.  This is quite similar to the Altivec</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">  /// 'vperm' instruction, except that the indices must be constants and are</td>
    <td class="lineNumber">598</td>
    <td class="codeline">  /// 'vperm' instruction, except that the indices must be constants and are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  /// in terms of the element size of VEC1/VEC2, not in terms of bytes.</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  /// in terms of the element size of VEC1/VEC2, not in terms of bytes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">  VECTOR_SHUFFLE,</td>
    <td class="lineNumber">600</td>
    <td class="codeline">  VECTOR_SHUFFLE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline"></td>
    <td class="lineNumber">601</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">  /// VECTOR_SPLICE(VEC1, VEC2, IMM) - Returns a subvector of the same type as</td>
    <td class="lineNumber">602</td>
    <td class="codeline">  /// VECTOR_SPLICE(VEC1, VEC2, IMM) - Returns a subvector of the same type as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">  /// VEC1/VEC2 from CONCAT_VECTORS(VEC1, VEC2), based on the IMM in two ways.</td>
    <td class="lineNumber">603</td>
    <td class="codeline">  /// VEC1/VEC2 from CONCAT_VECTORS(VEC1, VEC2), based on the IMM in two ways.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  /// Let the result type be T, if IMM is positive it represents the starting</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  /// Let the result type be T, if IMM is positive it represents the starting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">  /// element number (an index) from which a subvector of type T is extracted</td>
    <td class="lineNumber">605</td>
    <td class="codeline">  /// element number (an index) from which a subvector of type T is extracted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">  /// from CONCAT_VECTORS(VEC1, VEC2). If IMM is negative it represents a count</td>
    <td class="lineNumber">606</td>
    <td class="codeline">  /// from CONCAT_VECTORS(VEC1, VEC2). If IMM is negative it represents a count</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">  /// specifying the number of trailing elements to extract from VEC1, where the</td>
    <td class="lineNumber">607</td>
    <td class="codeline">  /// specifying the number of trailing elements to extract from VEC1, where the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">  /// elements of T are selected using the following algorithm:</td>
    <td class="lineNumber">608</td>
    <td class="codeline">  /// elements of T are selected using the following algorithm:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">  ///   RESULT[i] = CONCAT_VECTORS(VEC1,VEC2)[VEC1.ElementCount - ABS(IMM) + i]</td>
    <td class="lineNumber">609</td>
    <td class="codeline">  ///   RESULT[i] = CONCAT_VECTORS(VEC1,VEC2)[VEC1.ElementCount - ABS(IMM) + i]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">  /// If IMM is not in the range [-VL, VL-1] the result vector is undefined. IMM</td>
    <td class="lineNumber">610</td>
    <td class="codeline">  /// If IMM is not in the range [-VL, VL-1] the result vector is undefined. IMM</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">  /// is a constant integer.</td>
    <td class="lineNumber">611</td>
    <td class="codeline">  /// is a constant integer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">  VECTOR_SPLICE,</td>
    <td class="lineNumber">612</td>
    <td class="codeline">  VECTOR_SPLICE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">  /// SCALAR_TO_VECTOR(VAL) - This represents the operation of loading a</td>
    <td class="lineNumber">614</td>
    <td class="codeline">  /// SCALAR_TO_VECTOR(VAL) - This represents the operation of loading a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  /// scalar value into element 0 of the resultant vector type.  The top</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  /// scalar value into element 0 of the resultant vector type.  The top</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  /// elements 1 to N-1 of the N-element vector are undefined.  The type</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  /// elements 1 to N-1 of the N-element vector are undefined.  The type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">  /// of the operand must match the vector element type, except when they</td>
    <td class="lineNumber">617</td>
    <td class="codeline">  /// of the operand must match the vector element type, except when they</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">  /// are integer types.  In this case the operand is allowed to be wider</td>
    <td class="lineNumber">618</td>
    <td class="codeline">  /// are integer types.  In this case the operand is allowed to be wider</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  /// than the vector element type, and is implicitly truncated to it.</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  /// than the vector element type, and is implicitly truncated to it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">  SCALAR_TO_VECTOR,</td>
    <td class="lineNumber">620</td>
    <td class="codeline">  SCALAR_TO_VECTOR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
    <td class="lineNumber">621</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">  /// SPLAT_VECTOR(VAL) - Returns a vector with the scalar value VAL</td>
    <td class="lineNumber">622</td>
    <td class="codeline">  /// SPLAT_VECTOR(VAL) - Returns a vector with the scalar value VAL</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  /// duplicated in all lanes. The type of the operand must match the vector</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  /// duplicated in all lanes. The type of the operand must match the vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  /// element type, except when they are integer types.  In this case the</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  /// element type, except when they are integer types.  In this case the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  /// operand is allowed to be wider than the vector element type, and is</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  /// operand is allowed to be wider than the vector element type, and is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  /// implicitly truncated to it.</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  /// implicitly truncated to it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">  SPLAT_VECTOR,</td>
    <td class="lineNumber">627</td>
    <td class="codeline">  SPLAT_VECTOR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  /// SPLAT_VECTOR_PARTS(SCALAR1, SCALAR2, ...) - Returns a vector with the</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  /// SPLAT_VECTOR_PARTS(SCALAR1, SCALAR2, ...) - Returns a vector with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">  /// scalar values joined together and then duplicated in all lanes. This</td>
    <td class="lineNumber">630</td>
    <td class="codeline">  /// scalar values joined together and then duplicated in all lanes. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">  /// represents a SPLAT_VECTOR that has had its scalar operand expanded. This</td>
    <td class="lineNumber">631</td>
    <td class="codeline">  /// represents a SPLAT_VECTOR that has had its scalar operand expanded. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  /// allows representing a 64-bit splat on a target with 32-bit integers. The</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  /// allows representing a 64-bit splat on a target with 32-bit integers. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  /// total width of the scalars must cover the element width. SCALAR1 contains</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  /// total width of the scalars must cover the element width. SCALAR1 contains</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  /// the least significant bits of the value regardless of endianness and all</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  /// the least significant bits of the value regardless of endianness and all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">  /// scalars should have the same type.</td>
    <td class="lineNumber">635</td>
    <td class="codeline">  /// scalars should have the same type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">  SPLAT_VECTOR_PARTS,</td>
    <td class="lineNumber">636</td>
    <td class="codeline">  SPLAT_VECTOR_PARTS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline"></td>
    <td class="lineNumber">637</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">  /// STEP_VECTOR(IMM) - Returns a scalable vector whose lanes are comprised</td>
    <td class="lineNumber">638</td>
    <td class="codeline">  /// STEP_VECTOR(IMM) - Returns a scalable vector whose lanes are comprised</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">  /// of a linear sequence of unsigned values starting from 0 with a step of</td>
    <td class="lineNumber">639</td>
    <td class="codeline">  /// of a linear sequence of unsigned values starting from 0 with a step of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">  /// IMM, where IMM must be a TargetConstant with type equal to the vector</td>
    <td class="lineNumber">640</td>
    <td class="codeline">  /// IMM, where IMM must be a TargetConstant with type equal to the vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">  /// element type. The arithmetic is performed modulo the bitwidth of the</td>
    <td class="lineNumber">641</td>
    <td class="codeline">  /// element type. The arithmetic is performed modulo the bitwidth of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">  /// element.</td>
    <td class="lineNumber">642</td>
    <td class="codeline">  /// element.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">  /// The operation does not support returning fixed-width vectors or</td>
    <td class="lineNumber">644</td>
    <td class="codeline">  /// The operation does not support returning fixed-width vectors or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  /// non-constant operands.</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  /// non-constant operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">  STEP_VECTOR,</td>
    <td class="lineNumber">646</td>
    <td class="codeline">  STEP_VECTOR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline"></td>
    <td class="lineNumber">647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">  /// MULHU/MULHS - Multiply high - Multiply two integers of type iN,</td>
    <td class="lineNumber">648</td>
    <td class="codeline">  /// MULHU/MULHS - Multiply high - Multiply two integers of type iN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  /// producing an unsigned/signed value of type i[2*N], then return the top</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  /// producing an unsigned/signed value of type i[2*N], then return the top</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">  /// part.</td>
    <td class="lineNumber">650</td>
    <td class="codeline">  /// part.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  MULHU,</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  MULHU,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">  MULHS,</td>
    <td class="lineNumber">652</td>
    <td class="codeline">  MULHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline"></td>
    <td class="lineNumber">653</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  /// AVGFLOORS/AVGFLOORU - Averaging add - Add two integers using an integer of</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  /// AVGFLOORS/AVGFLOORU - Averaging add - Add two integers using an integer of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">  /// type i[N+1], halving the result by shifting it one bit right.</td>
    <td class="lineNumber">655</td>
    <td class="codeline">  /// type i[N+1], halving the result by shifting it one bit right.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  /// shr(add(ext(X), ext(Y)), 1)</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  /// shr(add(ext(X), ext(Y)), 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">  AVGFLOORS,</td>
    <td class="lineNumber">657</td>
    <td class="codeline">  AVGFLOORS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  AVGFLOORU,</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  AVGFLOORU,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">  /// AVGCEILS/AVGCEILU - Rounding averaging add - Add two integers using an</td>
    <td class="lineNumber">659</td>
    <td class="codeline">  /// AVGCEILS/AVGCEILU - Rounding averaging add - Add two integers using an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  /// integer of type i[N+2], add 1 and halve the result by shifting it one bit</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  /// integer of type i[N+2], add 1 and halve the result by shifting it one bit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">  /// right. shr(add(ext(X), ext(Y), 1), 1)</td>
    <td class="lineNumber">661</td>
    <td class="codeline">  /// right. shr(add(ext(X), ext(Y), 1), 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  AVGCEILS,</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  AVGCEILS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">  AVGCEILU,</td>
    <td class="lineNumber">663</td>
    <td class="codeline">  AVGCEILU,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline"></td>
    <td class="lineNumber">664</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">  // ABDS/ABDU - Absolute difference - Return the absolute difference between</td>
    <td class="lineNumber">665</td>
    <td class="codeline">  // ABDS/ABDU - Absolute difference - Return the absolute difference between</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  // two numbers interpreted as signed/unsigned.</td>
    <td class="lineNumber">666</td>
    <td class="codeline">  // two numbers interpreted as signed/unsigned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  // i.e trunc(abs(sext(Op0) - sext(Op1))) becomes abds(Op0, Op1)</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  // i.e trunc(abs(sext(Op0) - sext(Op1))) becomes abds(Op0, Op1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  //  or trunc(abs(zext(Op0) - zext(Op1))) becomes abdu(Op0, Op1)</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  //  or trunc(abs(zext(Op0) - zext(Op1))) becomes abdu(Op0, Op1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">  ABDS,</td>
    <td class="lineNumber">669</td>
    <td class="codeline">  ABDS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">  ABDU,</td>
    <td class="lineNumber">670</td>
    <td class="codeline">  ABDU,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline"></td>
    <td class="lineNumber">671</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">  /// [US]{MIN/MAX} - Binary minimum or maximum of signed or unsigned</td>
    <td class="lineNumber">672</td>
    <td class="codeline">  /// [US]{MIN/MAX} - Binary minimum or maximum of signed or unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  /// integers.</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  /// integers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  SMIN,</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  SMIN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">  SMAX,</td>
    <td class="lineNumber">675</td>
    <td class="codeline">  SMAX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">  UMIN,</td>
    <td class="lineNumber">676</td>
    <td class="codeline">  UMIN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">  UMAX,</td>
    <td class="lineNumber">677</td>
    <td class="codeline">  UMAX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline"></td>
    <td class="lineNumber">678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  /// Bitwise operators - logical and, logical or, logical xor.</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  /// Bitwise operators - logical and, logical or, logical xor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">  AND,</td>
    <td class="lineNumber">680</td>
    <td class="codeline">  AND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">  OR,</td>
    <td class="lineNumber">681</td>
    <td class="codeline">  OR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">  XOR,</td>
    <td class="lineNumber">682</td>
    <td class="codeline">  XOR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  /// ABS - Determine the unsigned absolute value of a signed integer value of</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  /// ABS - Determine the unsigned absolute value of a signed integer value of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">  /// the same bitwidth.</td>
    <td class="lineNumber">685</td>
    <td class="codeline">  /// the same bitwidth.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  /// Note: A value of INT_MIN will return INT_MIN, no saturation or overflow</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  /// Note: A value of INT_MIN will return INT_MIN, no saturation or overflow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">  /// is performed.</td>
    <td class="lineNumber">687</td>
    <td class="codeline">  /// is performed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  ABS,</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  ABS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline"></td>
    <td class="lineNumber">689</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  /// Shift and rotation operations.  After legalization, the type of the</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  /// Shift and rotation operations.  After legalization, the type of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">  /// shift amount is known to be TLI.getShiftAmountTy().  Before legalization</td>
    <td class="lineNumber">691</td>
    <td class="codeline">  /// shift amount is known to be TLI.getShiftAmountTy().  Before legalization</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  /// the shift amount can be any type, but care must be taken to ensure it is</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  /// the shift amount can be any type, but care must be taken to ensure it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  /// large enough.  TLI.getShiftAmountTy() is i8 on some targets, but before</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  /// large enough.  TLI.getShiftAmountTy() is i8 on some targets, but before</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  /// legalization, types like i1024 can occur and i8 doesn't have enough bits</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  /// legalization, types like i1024 can occur and i8 doesn't have enough bits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">  /// to represent the shift amount.</td>
    <td class="lineNumber">695</td>
    <td class="codeline">  /// to represent the shift amount.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  /// When the 1st operand is a vector, the shift amount must be in the same</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  /// When the 1st operand is a vector, the shift amount must be in the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">  /// type. (TLI.getShiftAmountTy() will return the same type when the input</td>
    <td class="lineNumber">697</td>
    <td class="codeline">  /// type. (TLI.getShiftAmountTy() will return the same type when the input</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  /// type is a vector.)</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  /// type is a vector.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  /// For rotates and funnel shifts, the shift amount is treated as an unsigned</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  /// For rotates and funnel shifts, the shift amount is treated as an unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  /// amount modulo the element size of the first operand.</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  /// amount modulo the element size of the first operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">701</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">  /// Funnel 'double' shifts take 3 operands, 2 inputs and the shift amount.</td>
    <td class="lineNumber">702</td>
    <td class="codeline">  /// Funnel 'double' shifts take 3 operands, 2 inputs and the shift amount.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">  /// fshl(X,Y,Z): (X << (Z % BW)) | (Y >> (BW - (Z % BW)))</td>
    <td class="lineNumber">703</td>
    <td class="codeline">  /// fshl(X,Y,Z): (X << (Z % BW)) | (Y >> (BW - (Z % BW)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">  /// fshr(X,Y,Z): (X << (BW - (Z % BW))) | (Y >> (Z % BW))</td>
    <td class="lineNumber">704</td>
    <td class="codeline">  /// fshr(X,Y,Z): (X << (BW - (Z % BW))) | (Y >> (Z % BW))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">  SHL,</td>
    <td class="lineNumber">705</td>
    <td class="codeline">  SHL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">  SRA,</td>
    <td class="lineNumber">706</td>
    <td class="codeline">  SRA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">  SRL,</td>
    <td class="lineNumber">707</td>
    <td class="codeline">  SRL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">  ROTL,</td>
    <td class="lineNumber">708</td>
    <td class="codeline">  ROTL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">  ROTR,</td>
    <td class="lineNumber">709</td>
    <td class="codeline">  ROTR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">  FSHL,</td>
    <td class="lineNumber">710</td>
    <td class="codeline">  FSHL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">  FSHR,</td>
    <td class="lineNumber">711</td>
    <td class="codeline">  FSHR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">  /// Byte Swap and Counting operators.</td>
    <td class="lineNumber">713</td>
    <td class="codeline">  /// Byte Swap and Counting operators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  BSWAP,</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  BSWAP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">  CTTZ,</td>
    <td class="lineNumber">715</td>
    <td class="codeline">  CTTZ,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  CTLZ,</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  CTLZ,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">  CTPOP,</td>
    <td class="lineNumber">717</td>
    <td class="codeline">  CTPOP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">  BITREVERSE,</td>
    <td class="lineNumber">718</td>
    <td class="codeline">  BITREVERSE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">  PARITY,</td>
    <td class="lineNumber">719</td>
    <td class="codeline">  PARITY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline"></td>
    <td class="lineNumber">720</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">  /// Bit counting operators with an undefined result for zero inputs.</td>
    <td class="lineNumber">721</td>
    <td class="codeline">  /// Bit counting operators with an undefined result for zero inputs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">  CTTZ_ZERO_UNDEF,</td>
    <td class="lineNumber">722</td>
    <td class="codeline">  CTTZ_ZERO_UNDEF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  CTLZ_ZERO_UNDEF,</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  CTLZ_ZERO_UNDEF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline"></td>
    <td class="lineNumber">724</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">  /// Select(COND, TRUEVAL, FALSEVAL).  If the type of the boolean COND is not</td>
    <td class="lineNumber">725</td>
    <td class="codeline">  /// Select(COND, TRUEVAL, FALSEVAL).  If the type of the boolean COND is not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">  /// i1 then the high bits must conform to getBooleanContents.</td>
    <td class="lineNumber">726</td>
    <td class="codeline">  /// i1 then the high bits must conform to getBooleanContents.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">  SELECT,</td>
    <td class="lineNumber">727</td>
    <td class="codeline">  SELECT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline"></td>
    <td class="lineNumber">728</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">  /// Select with a vector condition (op #0) and two vector operands (ops #1</td>
    <td class="lineNumber">729</td>
    <td class="codeline">  /// Select with a vector condition (op #0) and two vector operands (ops #1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">  /// and #2), returning a vector result.  All vectors have the same length.</td>
    <td class="lineNumber">730</td>
    <td class="codeline">  /// and #2), returning a vector result.  All vectors have the same length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">  /// Much like the scalar select and setcc, each bit in the condition selects</td>
    <td class="lineNumber">731</td>
    <td class="codeline">  /// Much like the scalar select and setcc, each bit in the condition selects</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">  /// whether the corresponding result element is taken from op #1 or op #2.</td>
    <td class="lineNumber">732</td>
    <td class="codeline">  /// whether the corresponding result element is taken from op #1 or op #2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">  /// At first, the VSELECT condition is of vXi1 type. Later, targets may</td>
    <td class="lineNumber">733</td>
    <td class="codeline">  /// At first, the VSELECT condition is of vXi1 type. Later, targets may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">  /// change the condition type in order to match the VSELECT node using a</td>
    <td class="lineNumber">734</td>
    <td class="codeline">  /// change the condition type in order to match the VSELECT node using a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">  /// pattern. The condition follows the BooleanContent format of the target.</td>
    <td class="lineNumber">735</td>
    <td class="codeline">  /// pattern. The condition follows the BooleanContent format of the target.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">  VSELECT,</td>
    <td class="lineNumber">736</td>
    <td class="codeline">  VSELECT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  /// Select with condition operator - This selects between a true value and</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  /// Select with condition operator - This selects between a true value and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">  /// a false value (ops #2 and #3) based on the boolean result of comparing</td>
    <td class="lineNumber">739</td>
    <td class="codeline">  /// a false value (ops #2 and #3) based on the boolean result of comparing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">  /// the lhs and rhs (ops #0 and #1) of a conditional expression with the</td>
    <td class="lineNumber">740</td>
    <td class="codeline">  /// the lhs and rhs (ops #0 and #1) of a conditional expression with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">  /// condition code in op #4, a CondCodeSDNode.</td>
    <td class="lineNumber">741</td>
    <td class="codeline">  /// condition code in op #4, a CondCodeSDNode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">  SELECT_CC,</td>
    <td class="lineNumber">742</td>
    <td class="codeline">  SELECT_CC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline"></td>
    <td class="lineNumber">743</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">  /// SetCC operator - This evaluates to a true value iff the condition is</td>
    <td class="lineNumber">744</td>
    <td class="codeline">  /// SetCC operator - This evaluates to a true value iff the condition is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">  /// true.  If the result value type is not i1 then the high bits conform</td>
    <td class="lineNumber">745</td>
    <td class="codeline">  /// true.  If the result value type is not i1 then the high bits conform</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  /// to getBooleanContents.  The operands to this are the left and right</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  /// to getBooleanContents.  The operands to this are the left and right</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">  /// operands to compare (ops #0, and #1) and the condition code to compare</td>
    <td class="lineNumber">747</td>
    <td class="codeline">  /// operands to compare (ops #0, and #1) and the condition code to compare</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">  /// them with (op #2) as a CondCodeSDNode. If the operands are vector types</td>
    <td class="lineNumber">748</td>
    <td class="codeline">  /// them with (op #2) as a CondCodeSDNode. If the operands are vector types</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">  /// then the result type must also be a vector type.</td>
    <td class="lineNumber">749</td>
    <td class="codeline">  /// then the result type must also be a vector type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">  SETCC,</td>
    <td class="lineNumber">750</td>
    <td class="codeline">  SETCC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline"></td>
    <td class="lineNumber">751</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">  /// Like SetCC, ops #0 and #1 are the LHS and RHS operands to compare, but</td>
    <td class="lineNumber">752</td>
    <td class="codeline">  /// Like SetCC, ops #0 and #1 are the LHS and RHS operands to compare, but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">  /// op #2 is a boolean indicating if there is an incoming carry. This</td>
    <td class="lineNumber">753</td>
    <td class="codeline">  /// op #2 is a boolean indicating if there is an incoming carry. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">  /// operator checks the result of "LHS - RHS - Carry", and can be used to</td>
    <td class="lineNumber">754</td>
    <td class="codeline">  /// operator checks the result of "LHS - RHS - Carry", and can be used to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">  /// compare two wide integers:</td>
    <td class="lineNumber">755</td>
    <td class="codeline">  /// compare two wide integers:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">  /// (setcccarry lhshi rhshi (usubo_carry lhslo rhslo) cc).</td>
    <td class="lineNumber">756</td>
    <td class="codeline">  /// (setcccarry lhshi rhshi (usubo_carry lhslo rhslo) cc).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">  /// Only valid for integers.</td>
    <td class="lineNumber">757</td>
    <td class="codeline">  /// Only valid for integers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">  SETCCCARRY,</td>
    <td class="lineNumber">758</td>
    <td class="codeline">  SETCCCARRY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline"></td>
    <td class="lineNumber">759</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">  /// SHL_PARTS/SRA_PARTS/SRL_PARTS - These operators are used for expanded</td>
    <td class="lineNumber">760</td>
    <td class="codeline">  /// SHL_PARTS/SRA_PARTS/SRL_PARTS - These operators are used for expanded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">  /// integer shift operations.  The operation ordering is:</td>
    <td class="lineNumber">761</td>
    <td class="codeline">  /// integer shift operations.  The operation ordering is:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">  ///       [Lo,Hi] = op [LoLHS,HiLHS], Amt</td>
    <td class="lineNumber">762</td>
    <td class="codeline">  ///       [Lo,Hi] = op [LoLHS,HiLHS], Amt</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">  SHL_PARTS,</td>
    <td class="lineNumber">763</td>
    <td class="codeline">  SHL_PARTS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">  SRA_PARTS,</td>
    <td class="lineNumber">764</td>
    <td class="codeline">  SRA_PARTS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">  SRL_PARTS,</td>
    <td class="lineNumber">765</td>
    <td class="codeline">  SRL_PARTS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">  /// Conversion operators.  These are all single input single output</td>
    <td class="lineNumber">767</td>
    <td class="codeline">  /// Conversion operators.  These are all single input single output</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">  /// operations.  For all of these, the result type must be strictly</td>
    <td class="lineNumber">768</td>
    <td class="codeline">  /// operations.  For all of these, the result type must be strictly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">  /// wider or narrower (depending on the operation) than the source</td>
    <td class="lineNumber">769</td>
    <td class="codeline">  /// wider or narrower (depending on the operation) than the source</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">  /// type.</td>
    <td class="lineNumber">770</td>
    <td class="codeline">  /// type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">  /// SIGN_EXTEND - Used for integer types, replicating the sign bit</td>
    <td class="lineNumber">772</td>
    <td class="codeline">  /// SIGN_EXTEND - Used for integer types, replicating the sign bit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">  /// into new bits.</td>
    <td class="lineNumber">773</td>
    <td class="codeline">  /// into new bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">  SIGN_EXTEND,</td>
    <td class="lineNumber">774</td>
    <td class="codeline">  SIGN_EXTEND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline"></td>
    <td class="lineNumber">775</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">  /// ZERO_EXTEND - Used for integer types, zeroing the new bits.</td>
    <td class="lineNumber">776</td>
    <td class="codeline">  /// ZERO_EXTEND - Used for integer types, zeroing the new bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">  ZERO_EXTEND,</td>
    <td class="lineNumber">777</td>
    <td class="codeline">  ZERO_EXTEND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">  /// ANY_EXTEND - Used for integer types.  The high bits are undefined.</td>
    <td class="lineNumber">779</td>
    <td class="codeline">  /// ANY_EXTEND - Used for integer types.  The high bits are undefined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">  ANY_EXTEND,</td>
    <td class="lineNumber">780</td>
    <td class="codeline">  ANY_EXTEND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline"></td>
    <td class="lineNumber">781</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">  /// TRUNCATE - Completely drop the high bits.</td>
    <td class="lineNumber">782</td>
    <td class="codeline">  /// TRUNCATE - Completely drop the high bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">  TRUNCATE,</td>
    <td class="lineNumber">783</td>
    <td class="codeline">  TRUNCATE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline"></td>
    <td class="lineNumber">784</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">  /// [SU]INT_TO_FP - These operators convert integers (whose interpreted sign</td>
    <td class="lineNumber">785</td>
    <td class="codeline">  /// [SU]INT_TO_FP - These operators convert integers (whose interpreted sign</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">  /// depends on the first letter) to floating point.</td>
    <td class="lineNumber">786</td>
    <td class="codeline">  /// depends on the first letter) to floating point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">  SINT_TO_FP,</td>
    <td class="lineNumber">787</td>
    <td class="codeline">  SINT_TO_FP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">  UINT_TO_FP,</td>
    <td class="lineNumber">788</td>
    <td class="codeline">  UINT_TO_FP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline"></td>
    <td class="lineNumber">789</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">  /// SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to</td>
    <td class="lineNumber">790</td>
    <td class="codeline">  /// SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">  /// sign extend a small value in a large integer register (e.g. sign</td>
    <td class="lineNumber">791</td>
    <td class="codeline">  /// sign extend a small value in a large integer register (e.g. sign</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">  /// extending the low 8 bits of a 32-bit register to fill the top 24 bits</td>
    <td class="lineNumber">792</td>
    <td class="codeline">  /// extending the low 8 bits of a 32-bit register to fill the top 24 bits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">  /// with the 7th bit).  The size of the smaller type is indicated by the 1th</td>
    <td class="lineNumber">793</td>
    <td class="codeline">  /// with the 7th bit).  The size of the smaller type is indicated by the 1th</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">  /// operand, a ValueType node.</td>
    <td class="lineNumber">794</td>
    <td class="codeline">  /// operand, a ValueType node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">  SIGN_EXTEND_INREG,</td>
    <td class="lineNumber">795</td>
    <td class="codeline">  SIGN_EXTEND_INREG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">  /// ANY_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
    <td class="lineNumber">797</td>
    <td class="codeline">  /// ANY_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">  /// in-register any-extension of the low lanes of an integer vector. The</td>
    <td class="lineNumber">798</td>
    <td class="codeline">  /// in-register any-extension of the low lanes of an integer vector. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">  /// result type must have fewer elements than the operand type, and those</td>
    <td class="lineNumber">799</td>
    <td class="codeline">  /// result type must have fewer elements than the operand type, and those</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">  /// elements must be larger integer types such that the total size of the</td>
    <td class="lineNumber">800</td>
    <td class="codeline">  /// elements must be larger integer types such that the total size of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">  /// operand type is less than or equal to the size of the result type. Each</td>
    <td class="lineNumber">801</td>
    <td class="codeline">  /// operand type is less than or equal to the size of the result type. Each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">  /// of the low operand elements is any-extended into the corresponding,</td>
    <td class="lineNumber">802</td>
    <td class="codeline">  /// of the low operand elements is any-extended into the corresponding,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">  /// wider result elements with the high bits becoming undef.</td>
    <td class="lineNumber">803</td>
    <td class="codeline">  /// wider result elements with the high bits becoming undef.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
    <td class="lineNumber">804</td>
    <td class="codeline">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">  /// the same to allow expansion to shuffle vector during op legalization.</td>
    <td class="lineNumber">805</td>
    <td class="codeline">  /// the same to allow expansion to shuffle vector during op legalization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">  ANY_EXTEND_VECTOR_INREG,</td>
    <td class="lineNumber">806</td>
    <td class="codeline">  ANY_EXTEND_VECTOR_INREG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  /// SIGN_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  /// SIGN_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">  /// in-register sign-extension of the low lanes of an integer vector. The</td>
    <td class="lineNumber">809</td>
    <td class="codeline">  /// in-register sign-extension of the low lanes of an integer vector. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">  /// result type must have fewer elements than the operand type, and those</td>
    <td class="lineNumber">810</td>
    <td class="codeline">  /// result type must have fewer elements than the operand type, and those</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  /// elements must be larger integer types such that the total size of the</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  /// elements must be larger integer types such that the total size of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">  /// operand type is less than or equal to the size of the result type. Each</td>
    <td class="lineNumber">812</td>
    <td class="codeline">  /// operand type is less than or equal to the size of the result type. Each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  /// of the low operand elements is sign-extended into the corresponding,</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  /// of the low operand elements is sign-extended into the corresponding,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">  /// wider result elements.</td>
    <td class="lineNumber">814</td>
    <td class="codeline">  /// wider result elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
    <td class="lineNumber">815</td>
    <td class="codeline">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">  /// the same to allow expansion to shuffle vector during op legalization.</td>
    <td class="lineNumber">816</td>
    <td class="codeline">  /// the same to allow expansion to shuffle vector during op legalization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  SIGN_EXTEND_VECTOR_INREG,</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  SIGN_EXTEND_VECTOR_INREG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline"></td>
    <td class="lineNumber">818</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">  /// ZERO_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
    <td class="lineNumber">819</td>
    <td class="codeline">  /// ZERO_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  /// in-register zero-extension of the low lanes of an integer vector. The</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  /// in-register zero-extension of the low lanes of an integer vector. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  /// result type must have fewer elements than the operand type, and those</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  /// result type must have fewer elements than the operand type, and those</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">  /// elements must be larger integer types such that the total size of the</td>
    <td class="lineNumber">822</td>
    <td class="codeline">  /// elements must be larger integer types such that the total size of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">  /// operand type is less than or equal to the size of the result type. Each</td>
    <td class="lineNumber">823</td>
    <td class="codeline">  /// operand type is less than or equal to the size of the result type. Each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">  /// of the low operand elements is zero-extended into the corresponding,</td>
    <td class="lineNumber">824</td>
    <td class="codeline">  /// of the low operand elements is zero-extended into the corresponding,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">  /// wider result elements.</td>
    <td class="lineNumber">825</td>
    <td class="codeline">  /// wider result elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
    <td class="lineNumber">826</td>
    <td class="codeline">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">  /// the same to allow expansion to shuffle vector during op legalization.</td>
    <td class="lineNumber">827</td>
    <td class="codeline">  /// the same to allow expansion to shuffle vector during op legalization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">  ZERO_EXTEND_VECTOR_INREG,</td>
    <td class="lineNumber">828</td>
    <td class="codeline">  ZERO_EXTEND_VECTOR_INREG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline"></td>
    <td class="lineNumber">829</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">  /// FP_TO_[US]INT - Convert a floating point value to a signed or unsigned</td>
    <td class="lineNumber">830</td>
    <td class="codeline">  /// FP_TO_[US]INT - Convert a floating point value to a signed or unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  /// integer. These have the same semantics as fptosi and fptoui in IR. If</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  /// integer. These have the same semantics as fptosi and fptoui in IR. If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">  /// the FP value cannot fit in the integer type, the results are undefined.</td>
    <td class="lineNumber">832</td>
    <td class="codeline">  /// the FP value cannot fit in the integer type, the results are undefined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">  FP_TO_SINT,</td>
    <td class="lineNumber">833</td>
    <td class="codeline">  FP_TO_SINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  FP_TO_UINT,</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  FP_TO_UINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">  /// FP_TO_[US]INT_SAT - Convert floating point value in operand 0 to a</td>
    <td class="lineNumber">836</td>
    <td class="codeline">  /// FP_TO_[US]INT_SAT - Convert floating point value in operand 0 to a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">  /// signed or unsigned scalar integer type given in operand 1 with the</td>
    <td class="lineNumber">837</td>
    <td class="codeline">  /// signed or unsigned scalar integer type given in operand 1 with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">  /// following semantics:</td>
    <td class="lineNumber">838</td>
    <td class="codeline">  /// following semantics:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">839</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">  ///  * If the value is NaN, zero is returned.</td>
    <td class="lineNumber">840</td>
    <td class="codeline">  ///  * If the value is NaN, zero is returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">  ///  * If the value is larger/smaller than the largest/smallest integer,</td>
    <td class="lineNumber">841</td>
    <td class="codeline">  ///  * If the value is larger/smaller than the largest/smallest integer,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">  ///    the largest/smallest integer is returned (saturation).</td>
    <td class="lineNumber">842</td>
    <td class="codeline">  ///    the largest/smallest integer is returned (saturation).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">  ///  * Otherwise the result of rounding the value towards zero is returned.</td>
    <td class="lineNumber">843</td>
    <td class="codeline">  ///  * Otherwise the result of rounding the value towards zero is returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">844</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">  /// The scalar width of the type given in operand 1 must be equal to, or</td>
    <td class="lineNumber">845</td>
    <td class="codeline">  /// The scalar width of the type given in operand 1 must be equal to, or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">  /// smaller than, the scalar result type width. It may end up being smaller</td>
    <td class="lineNumber">846</td>
    <td class="codeline">  /// smaller than, the scalar result type width. It may end up being smaller</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  /// than the result width as a result of integer type legalization.</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  /// than the result width as a result of integer type legalization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">  /// After converting to the scalar integer type in operand 1, the value is</td>
    <td class="lineNumber">849</td>
    <td class="codeline">  /// After converting to the scalar integer type in operand 1, the value is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">  /// extended to the result VT. FP_TO_SINT_SAT sign extends and FP_TO_UINT_SAT</td>
    <td class="lineNumber">850</td>
    <td class="codeline">  /// extended to the result VT. FP_TO_SINT_SAT sign extends and FP_TO_UINT_SAT</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">  /// zero extends.</td>
    <td class="lineNumber">851</td>
    <td class="codeline">  /// zero extends.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">  FP_TO_SINT_SAT,</td>
    <td class="lineNumber">852</td>
    <td class="codeline">  FP_TO_SINT_SAT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  FP_TO_UINT_SAT,</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  FP_TO_UINT_SAT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline"></td>
    <td class="lineNumber">854</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">  /// X = FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating point type</td>
    <td class="lineNumber">855</td>
    <td class="codeline">  /// X = FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating point type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">  /// down to the precision of the destination VT.  TRUNC is a flag, which is</td>
    <td class="lineNumber">856</td>
    <td class="codeline">  /// down to the precision of the destination VT.  TRUNC is a flag, which is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">  /// always an integer that is zero or one.  If TRUNC is 0, this is a</td>
    <td class="lineNumber">857</td>
    <td class="codeline">  /// always an integer that is zero or one.  If TRUNC is 0, this is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">  /// normal rounding, if it is 1, this FP_ROUND is known to not change the</td>
    <td class="lineNumber">858</td>
    <td class="codeline">  /// normal rounding, if it is 1, this FP_ROUND is known to not change the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">  /// value of Y.</td>
    <td class="lineNumber">859</td>
    <td class="codeline">  /// value of Y.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">860</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">  /// The TRUNC = 1 case is used in cases where we know that the value will</td>
    <td class="lineNumber">861</td>
    <td class="codeline">  /// The TRUNC = 1 case is used in cases where we know that the value will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">  /// not be modified by the node, because Y is not using any of the extra</td>
    <td class="lineNumber">862</td>
    <td class="codeline">  /// not be modified by the node, because Y is not using any of the extra</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">  /// precision of source type.  This allows certain transformations like</td>
    <td class="lineNumber">863</td>
    <td class="codeline">  /// precision of source type.  This allows certain transformations like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">  /// FP_EXTEND(FP_ROUND(X,1)) -> X which are not safe for</td>
    <td class="lineNumber">864</td>
    <td class="codeline">  /// FP_EXTEND(FP_ROUND(X,1)) -> X which are not safe for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">  /// FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren't removed.</td>
    <td class="lineNumber">865</td>
    <td class="codeline">  /// FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren't removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">  FP_ROUND,</td>
    <td class="lineNumber">866</td>
    <td class="codeline">  FP_ROUND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline"></td>
    <td class="lineNumber">867</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">  /// Returns current rounding mode:</td>
    <td class="lineNumber">868</td>
    <td class="codeline">  /// Returns current rounding mode:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">  /// -1 Undefined</td>
    <td class="lineNumber">869</td>
    <td class="codeline">  /// -1 Undefined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  ///  0 Round to 0</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  ///  0 Round to 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">  ///  1 Round to nearest, ties to even</td>
    <td class="lineNumber">871</td>
    <td class="codeline">  ///  1 Round to nearest, ties to even</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">  ///  2 Round to +inf</td>
    <td class="lineNumber">872</td>
    <td class="codeline">  ///  2 Round to +inf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">  ///  3 Round to -inf</td>
    <td class="lineNumber">873</td>
    <td class="codeline">  ///  3 Round to -inf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">  ///  4 Round to nearest, ties to zero</td>
    <td class="lineNumber">874</td>
    <td class="codeline">  ///  4 Round to nearest, ties to zero</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  /// Result is rounding mode and chain. Input is a chain.</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  /// Result is rounding mode and chain. Input is a chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  GET_ROUNDING,</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  GET_ROUNDING,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline"></td>
    <td class="lineNumber">877</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">  /// Set rounding mode.</td>
    <td class="lineNumber">878</td>
    <td class="codeline">  /// Set rounding mode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">  /// The first operand is a chain pointer. The second specifies the required</td>
    <td class="lineNumber">879</td>
    <td class="codeline">  /// The first operand is a chain pointer. The second specifies the required</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">  /// rounding mode, encoded in the same way as used in '``GET_ROUNDING``'.</td>
    <td class="lineNumber">880</td>
    <td class="codeline">  /// rounding mode, encoded in the same way as used in '``GET_ROUNDING``'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">  SET_ROUNDING,</td>
    <td class="lineNumber">881</td>
    <td class="codeline">  SET_ROUNDING,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline"></td>
    <td class="lineNumber">882</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">  /// X = FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type.</td>
    <td class="lineNumber">883</td>
    <td class="codeline">  /// X = FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">  FP_EXTEND,</td>
    <td class="lineNumber">884</td>
    <td class="codeline">  FP_EXTEND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline"></td>
    <td class="lineNumber">885</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">  /// BITCAST - This operator converts between integer, vector and FP</td>
    <td class="lineNumber">886</td>
    <td class="codeline">  /// BITCAST - This operator converts between integer, vector and FP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">  /// values, as if the value was stored to memory with one type and loaded</td>
    <td class="lineNumber">887</td>
    <td class="codeline">  /// values, as if the value was stored to memory with one type and loaded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">  /// from the same address with the other type (or equivalently for vector</td>
    <td class="lineNumber">888</td>
    <td class="codeline">  /// from the same address with the other type (or equivalently for vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">  /// format conversions, etc).  The source and result are required to have</td>
    <td class="lineNumber">889</td>
    <td class="codeline">  /// format conversions, etc).  The source and result are required to have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">  /// the same bit size (e.g.  f32 <-> i32).  This can also be used for</td>
    <td class="lineNumber">890</td>
    <td class="codeline">  /// the same bit size (e.g.  f32 <-> i32).  This can also be used for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">  /// int-to-int or fp-to-fp conversions, but that is a noop, deleted by</td>
    <td class="lineNumber">891</td>
    <td class="codeline">  /// int-to-int or fp-to-fp conversions, but that is a noop, deleted by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">  /// getNode().</td>
    <td class="lineNumber">892</td>
    <td class="codeline">  /// getNode().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">893</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">  /// This operator is subtly different from the bitcast instruction from</td>
    <td class="lineNumber">894</td>
    <td class="codeline">  /// This operator is subtly different from the bitcast instruction from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">  /// LLVM-IR since this node may change the bits in the register. For</td>
    <td class="lineNumber">895</td>
    <td class="codeline">  /// LLVM-IR since this node may change the bits in the register. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">  /// example, this occurs on big-endian NEON and big-endian MSA where the</td>
    <td class="lineNumber">896</td>
    <td class="codeline">  /// example, this occurs on big-endian NEON and big-endian MSA where the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">  /// layout of the bits in the register depends on the vector type and this</td>
    <td class="lineNumber">897</td>
    <td class="codeline">  /// layout of the bits in the register depends on the vector type and this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">  /// operator acts as a shuffle operation for some vector type combinations.</td>
    <td class="lineNumber">898</td>
    <td class="codeline">  /// operator acts as a shuffle operation for some vector type combinations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">  BITCAST,</td>
    <td class="lineNumber">899</td>
    <td class="codeline">  BITCAST,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline"></td>
    <td class="lineNumber">900</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">  /// ADDRSPACECAST - This operator converts between pointers of different</td>
    <td class="lineNumber">901</td>
    <td class="codeline">  /// ADDRSPACECAST - This operator converts between pointers of different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">  /// address spaces.</td>
    <td class="lineNumber">902</td>
    <td class="codeline">  /// address spaces.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">  ADDRSPACECAST,</td>
    <td class="lineNumber">903</td>
    <td class="codeline">  ADDRSPACECAST,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
    <td class="lineNumber">904</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">  /// FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions</td>
    <td class="lineNumber">905</td>
    <td class="codeline">  /// FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">  /// and truncation for half-precision (16 bit) floating numbers. These nodes</td>
    <td class="lineNumber">906</td>
    <td class="codeline">  /// and truncation for half-precision (16 bit) floating numbers. These nodes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">  /// form a semi-softened interface for dealing with f16 (as an i16), which</td>
    <td class="lineNumber">907</td>
    <td class="codeline">  /// form a semi-softened interface for dealing with f16 (as an i16), which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">  /// is often a storage-only type but has native conversions.</td>
    <td class="lineNumber">908</td>
    <td class="codeline">  /// is often a storage-only type but has native conversions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">  FP16_TO_FP,</td>
    <td class="lineNumber">909</td>
    <td class="codeline">  FP16_TO_FP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">  FP_TO_FP16,</td>
    <td class="lineNumber">910</td>
    <td class="codeline">  FP_TO_FP16,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">  STRICT_FP16_TO_FP,</td>
    <td class="lineNumber">911</td>
    <td class="codeline">  STRICT_FP16_TO_FP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">  STRICT_FP_TO_FP16,</td>
    <td class="lineNumber">912</td>
    <td class="codeline">  STRICT_FP_TO_FP16,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline"></td>
    <td class="lineNumber">913</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">  /// BF16_TO_FP, FP_TO_BF16 - These operators are used to perform promotions</td>
    <td class="lineNumber">914</td>
    <td class="codeline">  /// BF16_TO_FP, FP_TO_BF16 - These operators are used to perform promotions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">  /// and truncation for bfloat16. These nodes form a semi-softened interface</td>
    <td class="lineNumber">915</td>
    <td class="codeline">  /// and truncation for bfloat16. These nodes form a semi-softened interface</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">  /// for dealing with bf16 (as an i16), which is often a storage-only type but</td>
    <td class="lineNumber">916</td>
    <td class="codeline">  /// for dealing with bf16 (as an i16), which is often a storage-only type but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">  /// has native conversions.</td>
    <td class="lineNumber">917</td>
    <td class="codeline">  /// has native conversions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">  BF16_TO_FP,</td>
    <td class="lineNumber">918</td>
    <td class="codeline">  BF16_TO_FP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">  FP_TO_BF16,</td>
    <td class="lineNumber">919</td>
    <td class="codeline">  FP_TO_BF16,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline"></td>
    <td class="lineNumber">920</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">  /// Perform various unary floating-point operations inspired by libm. For</td>
    <td class="lineNumber">921</td>
    <td class="codeline">  /// Perform various unary floating-point operations inspired by libm. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">  /// FPOWI, the result is undefined if if the integer operand doesn't fit into</td>
    <td class="lineNumber">922</td>
    <td class="codeline">  /// FPOWI, the result is undefined if if the integer operand doesn't fit into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">  /// sizeof(int).</td>
    <td class="lineNumber">923</td>
    <td class="codeline">  /// sizeof(int).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">  FNEG,</td>
    <td class="lineNumber">924</td>
    <td class="codeline">  FNEG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">  FABS,</td>
    <td class="lineNumber">925</td>
    <td class="codeline">  FABS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">  FSQRT,</td>
    <td class="lineNumber">926</td>
    <td class="codeline">  FSQRT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">  FCBRT,</td>
    <td class="lineNumber">927</td>
    <td class="codeline">  FCBRT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">  FSIN,</td>
    <td class="lineNumber">928</td>
    <td class="codeline">  FSIN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">  FCOS,</td>
    <td class="lineNumber">929</td>
    <td class="codeline">  FCOS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">  FPOW,</td>
    <td class="lineNumber">930</td>
    <td class="codeline">  FPOW,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">  FPOWI,</td>
    <td class="lineNumber">931</td>
    <td class="codeline">  FPOWI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">  /// FLDEXP - ldexp, inspired by libm (op0 * 2**op1).</td>
    <td class="lineNumber">932</td>
    <td class="codeline">  /// FLDEXP - ldexp, inspired by libm (op0 * 2**op1).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">  FLDEXP,</td>
    <td class="lineNumber">933</td>
    <td class="codeline">  FLDEXP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline"></td>
    <td class="lineNumber">934</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">  /// FFREXP - frexp, extract fractional and exponent component of a</td>
    <td class="lineNumber">935</td>
    <td class="codeline">  /// FFREXP - frexp, extract fractional and exponent component of a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">  /// floating-point value. Returns the two components as separate return</td>
    <td class="lineNumber">936</td>
    <td class="codeline">  /// floating-point value. Returns the two components as separate return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">  /// values.</td>
    <td class="lineNumber">937</td>
    <td class="codeline">  /// values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">  FFREXP,</td>
    <td class="lineNumber">938</td>
    <td class="codeline">  FFREXP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline"></td>
    <td class="lineNumber">939</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">  FLOG,</td>
    <td class="lineNumber">940</td>
    <td class="codeline">  FLOG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">  FLOG2,</td>
    <td class="lineNumber">941</td>
    <td class="codeline">  FLOG2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">  FLOG10,</td>
    <td class="lineNumber">942</td>
    <td class="codeline">  FLOG10,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">  FEXP,</td>
    <td class="lineNumber">943</td>
    <td class="codeline">  FEXP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">  FEXP2,</td>
    <td class="lineNumber">944</td>
    <td class="codeline">  FEXP2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">  FCEIL,</td>
    <td class="lineNumber">945</td>
    <td class="codeline">  FCEIL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">  FTRUNC,</td>
    <td class="lineNumber">946</td>
    <td class="codeline">  FTRUNC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">  FRINT,</td>
    <td class="lineNumber">947</td>
    <td class="codeline">  FRINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">  FNEARBYINT,</td>
    <td class="lineNumber">948</td>
    <td class="codeline">  FNEARBYINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">  FROUND,</td>
    <td class="lineNumber">949</td>
    <td class="codeline">  FROUND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">  FROUNDEVEN,</td>
    <td class="lineNumber">950</td>
    <td class="codeline">  FROUNDEVEN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">  FFLOOR,</td>
    <td class="lineNumber">951</td>
    <td class="codeline">  FFLOOR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">  LROUND,</td>
    <td class="lineNumber">952</td>
    <td class="codeline">  LROUND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">  LLROUND,</td>
    <td class="lineNumber">953</td>
    <td class="codeline">  LLROUND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">  LRINT,</td>
    <td class="lineNumber">954</td>
    <td class="codeline">  LRINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">  LLRINT,</td>
    <td class="lineNumber">955</td>
    <td class="codeline">  LLRINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline"></td>
    <td class="lineNumber">956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">  /// FMINNUM/FMAXNUM - Perform floating-point minimum or maximum on two</td>
    <td class="lineNumber">957</td>
    <td class="codeline">  /// FMINNUM/FMAXNUM - Perform floating-point minimum or maximum on two</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">  /// values.</td>
    <td class="lineNumber">958</td>
    <td class="codeline">  /// values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">959</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">  /// In the case where a single input is a NaN (either signaling or quiet),</td>
    <td class="lineNumber">960</td>
    <td class="codeline">  /// In the case where a single input is a NaN (either signaling or quiet),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">  /// the non-NaN input is returned.</td>
    <td class="lineNumber">961</td>
    <td class="codeline">  /// the non-NaN input is returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">962</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">  /// The return value of (FMINNUM 0.0, -0.0) could be either 0.0 or -0.0.</td>
    <td class="lineNumber">963</td>
    <td class="codeline">  /// The return value of (FMINNUM 0.0, -0.0) could be either 0.0 or -0.0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">  FMINNUM,</td>
    <td class="lineNumber">964</td>
    <td class="codeline">  FMINNUM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">  FMAXNUM,</td>
    <td class="lineNumber">965</td>
    <td class="codeline">  FMAXNUM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline"></td>
    <td class="lineNumber">966</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  /// FMINNUM_IEEE/FMAXNUM_IEEE - Perform floating-point minimum or maximum on</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  /// FMINNUM_IEEE/FMAXNUM_IEEE - Perform floating-point minimum or maximum on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  /// two values, following the IEEE-754 2008 definition. This differs from</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  /// two values, following the IEEE-754 2008 definition. This differs from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">  /// FMINNUM/FMAXNUM in the handling of signaling NaNs. If one input is a</td>
    <td class="lineNumber">969</td>
    <td class="codeline">  /// FMINNUM/FMAXNUM in the handling of signaling NaNs. If one input is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">  /// signaling NaN, returns a quiet NaN.</td>
    <td class="lineNumber">970</td>
    <td class="codeline">  /// signaling NaN, returns a quiet NaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">  FMINNUM_IEEE,</td>
    <td class="lineNumber">971</td>
    <td class="codeline">  FMINNUM_IEEE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">  FMAXNUM_IEEE,</td>
    <td class="lineNumber">972</td>
    <td class="codeline">  FMAXNUM_IEEE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">  /// FMINIMUM/FMAXIMUM - NaN-propagating minimum/maximum that also treat -0.0</td>
    <td class="lineNumber">974</td>
    <td class="codeline">  /// FMINIMUM/FMAXIMUM - NaN-propagating minimum/maximum that also treat -0.0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">  /// as less than 0.0. While FMINNUM_IEEE/FMAXNUM_IEEE follow IEEE 754-2008</td>
    <td class="lineNumber">975</td>
    <td class="codeline">  /// as less than 0.0. While FMINNUM_IEEE/FMAXNUM_IEEE follow IEEE 754-2008</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">  /// semantics, FMINIMUM/FMAXIMUM follow IEEE 754-2018 draft semantics.</td>
    <td class="lineNumber">976</td>
    <td class="codeline">  /// semantics, FMINIMUM/FMAXIMUM follow IEEE 754-2018 draft semantics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">  FMINIMUM,</td>
    <td class="lineNumber">977</td>
    <td class="codeline">  FMINIMUM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">  FMAXIMUM,</td>
    <td class="lineNumber">978</td>
    <td class="codeline">  FMAXIMUM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline"></td>
    <td class="lineNumber">979</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">  /// FSINCOS - Compute both fsin and fcos as a single operation.</td>
    <td class="lineNumber">980</td>
    <td class="codeline">  /// FSINCOS - Compute both fsin and fcos as a single operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">  FSINCOS,</td>
    <td class="lineNumber">981</td>
    <td class="codeline">  FSINCOS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline"></td>
    <td class="lineNumber">982</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">  /// Gets the current floating-point environment. The first operand is a token</td>
    <td class="lineNumber">983</td>
    <td class="codeline">  /// Gets the current floating-point environment. The first operand is a token</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">  /// chain. The results are FP environment, represented by an integer value,</td>
    <td class="lineNumber">984</td>
    <td class="codeline">  /// chain. The results are FP environment, represented by an integer value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">  /// and a token chain.</td>
    <td class="lineNumber">985</td>
    <td class="codeline">  /// and a token chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">  GET_FPENV,</td>
    <td class="lineNumber">986</td>
    <td class="codeline">  GET_FPENV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline"></td>
    <td class="lineNumber">987</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">  /// Sets the current floating-point environment. The first operand is a token</td>
    <td class="lineNumber">988</td>
    <td class="codeline">  /// Sets the current floating-point environment. The first operand is a token</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  /// chain, the second is FP environment, represented by an integer value. The</td>
    <td class="lineNumber">989</td>
    <td class="codeline">  /// chain, the second is FP environment, represented by an integer value. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">  /// result is a token chain.</td>
    <td class="lineNumber">990</td>
    <td class="codeline">  /// result is a token chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">  SET_FPENV,</td>
    <td class="lineNumber">991</td>
    <td class="codeline">  SET_FPENV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">  /// Set floating-point environment to default state. The first operand and the</td>
    <td class="lineNumber">993</td>
    <td class="codeline">  /// Set floating-point environment to default state. The first operand and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">  /// result are token chains.</td>
    <td class="lineNumber">994</td>
    <td class="codeline">  /// result are token chains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">  RESET_FPENV,</td>
    <td class="lineNumber">995</td>
    <td class="codeline">  RESET_FPENV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline"></td>
    <td class="lineNumber">996</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">  /// Gets the current floating-point environment. The first operand is a token</td>
    <td class="lineNumber">997</td>
    <td class="codeline">  /// Gets the current floating-point environment. The first operand is a token</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  /// chain, the second is a pointer to memory, where FP environment is stored</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  /// chain, the second is a pointer to memory, where FP environment is stored</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">  /// to. The result is a token chain.</td>
    <td class="lineNumber">999</td>
    <td class="codeline">  /// to. The result is a token chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">  GET_FPENV_MEM,</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">  GET_FPENV_MEM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline"></td>
    <td class="lineNumber">1001</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">  /// Sets the current floating point environment. The first operand is a token</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">  /// Sets the current floating point environment. The first operand is a token</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">  /// chain, the second is a pointer to memory, where FP environment is loaded</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">  /// chain, the second is a pointer to memory, where FP environment is loaded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">  /// from. The result is a token chain.</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">  /// from. The result is a token chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">  SET_FPENV_MEM,</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">  SET_FPENV_MEM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline"></td>
    <td class="lineNumber">1006</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">  /// LOAD and STORE have token chains as their first operand, then the same</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">  /// LOAD and STORE have token chains as their first operand, then the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">  /// operands as an LLVM load/store instruction, then an offset node that</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">  /// operands as an LLVM load/store instruction, then an offset node that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">  /// is added / subtracted from the base pointer to form the address (for</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">  /// is added / subtracted from the base pointer to form the address (for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">  /// indexed memory ops).</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">  /// indexed memory ops).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">  LOAD,</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">  LOAD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">  STORE,</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">  STORE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline"></td>
    <td class="lineNumber">1013</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">  /// DYNAMIC_STACKALLOC - Allocate some number of bytes on the stack aligned</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">  /// DYNAMIC_STACKALLOC - Allocate some number of bytes on the stack aligned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">  /// to a specified boundary.  This node always has two return values: a new</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">  /// to a specified boundary.  This node always has two return values: a new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">  /// stack pointer value and a chain. The first operand is the token chain,</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">  /// stack pointer value and a chain. The first operand is the token chain,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">  /// the second is the number of bytes to allocate, and the third is the</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">  /// the second is the number of bytes to allocate, and the third is the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">  /// alignment boundary.  The size is guaranteed to be a multiple of the</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">  /// alignment boundary.  The size is guaranteed to be a multiple of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">  /// stack alignment, and the alignment is guaranteed to be bigger than the</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">  /// stack alignment, and the alignment is guaranteed to be bigger than the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">  /// stack alignment (if required) or 0 to get standard stack alignment.</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">  /// stack alignment (if required) or 0 to get standard stack alignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">  DYNAMIC_STACKALLOC,</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">  DYNAMIC_STACKALLOC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline"></td>
    <td class="lineNumber">1022</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">  /// Control flow instructions.  These all have token chains.</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">  /// Control flow instructions.  These all have token chains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline"></td>
    <td class="lineNumber">1024</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">  /// BR - Unconditional branch.  The first operand is the chain</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">  /// BR - Unconditional branch.  The first operand is the chain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">  /// operand, the second is the MBB to branch to.</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">  /// operand, the second is the MBB to branch to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">  BR,</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">  BR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline"></td>
    <td class="lineNumber">1028</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">  /// BRIND - Indirect branch.  The first operand is the chain, the second</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">  /// BRIND - Indirect branch.  The first operand is the chain, the second</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">  /// is the value to branch to, which must be of the same type as the</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">  /// is the value to branch to, which must be of the same type as the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">  /// target's pointer type.</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">  /// target's pointer type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">  BRIND,</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">  BRIND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline"></td>
    <td class="lineNumber">1033</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">  /// BR_JT - Jumptable branch. The first operand is the chain, the second</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">  /// BR_JT - Jumptable branch. The first operand is the chain, the second</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">  /// is the jumptable index, the last one is the jumptable entry index.</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">  /// is the jumptable index, the last one is the jumptable entry index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">  BR_JT,</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">  BR_JT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline"></td>
    <td class="lineNumber">1037</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">  /// BRCOND - Conditional branch.  The first operand is the chain, the</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">  /// BRCOND - Conditional branch.  The first operand is the chain, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  /// second is the condition, the third is the block to branch to if the</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  /// second is the condition, the third is the block to branch to if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">  /// condition is true.  If the type of the condition is not i1, then the</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">  /// condition is true.  If the type of the condition is not i1, then the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">  /// high bits must conform to getBooleanContents. If the condition is undef,</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">  /// high bits must conform to getBooleanContents. If the condition is undef,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">  /// it nondeterministically jumps to the block.</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">  /// it nondeterministically jumps to the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">  /// TODO: Its semantics w.r.t undef requires further discussion; we need to</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">  /// TODO: Its semantics w.r.t undef requires further discussion; we need to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">  /// make it sure that it is consistent with optimizations in MIR & the</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">  /// make it sure that it is consistent with optimizations in MIR & the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">  /// meaning of IMPLICIT_DEF. See https://reviews.llvm.org/D92015</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">  /// meaning of IMPLICIT_DEF. See https://reviews.llvm.org/D92015</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">  BRCOND,</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">  BRCOND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline"></td>
    <td class="lineNumber">1047</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">  /// BR_CC - Conditional branch.  The behavior is like that of SELECT_CC, in</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">  /// BR_CC - Conditional branch.  The behavior is like that of SELECT_CC, in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  /// that the condition is represented as condition code, and two nodes to</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  /// that the condition is represented as condition code, and two nodes to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">  /// compare, rather than as a combined SetCC node.  The operands in order</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">  /// compare, rather than as a combined SetCC node.  The operands in order</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">  /// are chain, cc, lhs, rhs, block to branch to if condition is true. If</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">  /// are chain, cc, lhs, rhs, block to branch to if condition is true. If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">  /// condition is undef, it nondeterministically jumps to the block.</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">  /// condition is undef, it nondeterministically jumps to the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">  BR_CC,</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">  BR_CC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline"></td>
    <td class="lineNumber">1054</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  /// INLINEASM - Represents an inline asm block.  This node always has two</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  /// INLINEASM - Represents an inline asm block.  This node always has two</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">  /// return values: a chain and a flag result.  The inputs are as follows:</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">  /// return values: a chain and a flag result.  The inputs are as follows:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">  ///   Operand #0  : Input chain.</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">  ///   Operand #0  : Input chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">  ///   Operand #1  : a ExternalSymbolSDNode with a pointer to the asm string.</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">  ///   Operand #1  : a ExternalSymbolSDNode with a pointer to the asm string.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  ///   Operand #2  : a MDNodeSDNode with the !srcloc metadata.</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  ///   Operand #2  : a MDNodeSDNode with the !srcloc metadata.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  ///   Operand #3  : HasSideEffect, IsAlignStack bits.</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  ///   Operand #3  : HasSideEffect, IsAlignStack bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">  ///   After this, it is followed by a list of operands with this format:</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">  ///   After this, it is followed by a list of operands with this format:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  ///     ConstantSDNode: Flags that encode whether it is a mem or not, the</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  ///     ConstantSDNode: Flags that encode whether it is a mem or not, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">  ///                     of operands that follow, etc.  See InlineAsm.h.</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">  ///                     of operands that follow, etc.  See InlineAsm.h.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">  ///     ... however many operands ...</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">  ///     ... however many operands ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">  ///   Operand #last: Optional, an incoming flag.</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">  ///   Operand #last: Optional, an incoming flag.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">  /// The variable width operands are required to represent target addressing</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">  /// The variable width operands are required to represent target addressing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">  /// modes as a single "operand", even though they may have multiple</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">  /// modes as a single "operand", even though they may have multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">  /// SDOperands.</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">  /// SDOperands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">  INLINEASM,</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">  INLINEASM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">  /// INLINEASM_BR - Branching version of inline asm. Used by asm-goto.</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">  /// INLINEASM_BR - Branching version of inline asm. Used by asm-goto.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">  INLINEASM_BR,</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">  INLINEASM_BR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline"></td>
    <td class="lineNumber">1074</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">  /// EH_LABEL - Represents a label in mid basic block used to track</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">  /// EH_LABEL - Represents a label in mid basic block used to track</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">  /// locations needed for debug and exception handling tables.  These nodes</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">  /// locations needed for debug and exception handling tables.  These nodes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">  /// take a chain as input and return a chain.</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">  /// take a chain as input and return a chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">  EH_LABEL,</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">  EH_LABEL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline"></td>
    <td class="lineNumber">1079</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">  /// ANNOTATION_LABEL - Represents a mid basic block label used by</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">  /// ANNOTATION_LABEL - Represents a mid basic block label used by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">  /// annotations. This should remain within the basic block and be ordered</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">  /// annotations. This should remain within the basic block and be ordered</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">  /// with respect to other call instructions, but loads and stores may float</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">  /// with respect to other call instructions, but loads and stores may float</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">  /// past it.</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">  /// past it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">  ANNOTATION_LABEL,</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">  ANNOTATION_LABEL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline"></td>
    <td class="lineNumber">1085</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">  /// CATCHRET - Represents a return from a catch block funclet. Used for</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">  /// CATCHRET - Represents a return from a catch block funclet. Used for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">  /// MSVC compatible exception handling. Takes a chain operand and a</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">  /// MSVC compatible exception handling. Takes a chain operand and a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">  /// destination basic block operand.</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">  /// destination basic block operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">  CATCHRET,</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">  CATCHRET,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline"></td>
    <td class="lineNumber">1090</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">  /// CLEANUPRET - Represents a return from a cleanup block funclet.  Used for</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">  /// CLEANUPRET - Represents a return from a cleanup block funclet.  Used for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">  /// MSVC compatible exception handling. Takes only a chain operand.</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">  /// MSVC compatible exception handling. Takes only a chain operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">  CLEANUPRET,</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">  CLEANUPRET,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline"></td>
    <td class="lineNumber">1094</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">  /// STACKSAVE - STACKSAVE has one operand, an input chain.  It produces a</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">  /// STACKSAVE - STACKSAVE has one operand, an input chain.  It produces a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">  /// value, the same type as the pointer type for the system, and an output</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">  /// value, the same type as the pointer type for the system, and an output</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">  /// chain.</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">  /// chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">  STACKSAVE,</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">  STACKSAVE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline"></td>
    <td class="lineNumber">1099</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">  /// STACKRESTORE has two operands, an input chain and a pointer to restore</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">  /// STACKRESTORE has two operands, an input chain and a pointer to restore</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">  /// to it returns an output chain.</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">  /// to it returns an output chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">  STACKRESTORE,</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">  STACKRESTORE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline"></td>
    <td class="lineNumber">1103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">  /// CALLSEQ_START/CALLSEQ_END - These operators mark the beginning and end</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">  /// CALLSEQ_START/CALLSEQ_END - These operators mark the beginning and end</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">  /// of a call sequence, and carry arbitrary information that target might</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">  /// of a call sequence, and carry arbitrary information that target might</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">  /// want to know.  The first operand is a chain, the rest are specified by</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">  /// want to know.  The first operand is a chain, the rest are specified by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">  /// the target and not touched by the DAG optimizers.</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">  /// the target and not touched by the DAG optimizers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">  /// Targets that may use stack to pass call arguments define additional</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">  /// Targets that may use stack to pass call arguments define additional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">  /// operands:</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">  /// operands:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">  /// - size of the call frame part that must be set up within the</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">  /// - size of the call frame part that must be set up within the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">  ///   CALLSEQ_START..CALLSEQ_END pair,</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">  ///   CALLSEQ_START..CALLSEQ_END pair,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">  /// - part of the call frame prepared prior to CALLSEQ_START.</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">  /// - part of the call frame prepared prior to CALLSEQ_START.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">  /// Both these parameters must be constants, their sum is the total call</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">  /// Both these parameters must be constants, their sum is the total call</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">  /// frame size.</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">  /// frame size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">  /// CALLSEQ_START..CALLSEQ_END pairs may not be nested.</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">  /// CALLSEQ_START..CALLSEQ_END pairs may not be nested.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">  CALLSEQ_START, // Beginning of a call sequence</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">  CALLSEQ_START, // Beginning of a call sequence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">  CALLSEQ_END,   // End of a call sequence</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">  CALLSEQ_END,   // End of a call sequence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline"></td>
    <td class="lineNumber">1118</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">  /// VAARG - VAARG has four operands: an input chain, a pointer, a SRCVALUE,</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">  /// VAARG - VAARG has four operands: an input chain, a pointer, a SRCVALUE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">  /// and the alignment. It returns a pair of values: the vaarg value and a</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">  /// and the alignment. It returns a pair of values: the vaarg value and a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">  /// new chain.</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">  /// new chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">  VAARG,</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">  VAARG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
    <td class="lineNumber">1123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">  /// VACOPY - VACOPY has 5 operands: an input chain, a destination pointer,</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">  /// VACOPY - VACOPY has 5 operands: an input chain, a destination pointer,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">  /// a source pointer, a SRCVALUE for the destination, and a SRCVALUE for the</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">  /// a source pointer, a SRCVALUE for the destination, and a SRCVALUE for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">  /// source.</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">  /// source.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">  VACOPY,</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">  VACOPY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline"></td>
    <td class="lineNumber">1128</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">  /// VAEND, VASTART - VAEND and VASTART have three operands: an input chain,</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">  /// VAEND, VASTART - VAEND and VASTART have three operands: an input chain,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">  /// pointer, and a SRCVALUE.</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">  /// pointer, and a SRCVALUE.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">  VAEND,</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">  VAEND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">  VASTART,</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">  VASTART,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline"></td>
    <td class="lineNumber">1133</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">  // PREALLOCATED_SETUP - This has 2 operands: an input chain and a SRCVALUE</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">  // PREALLOCATED_SETUP - This has 2 operands: an input chain and a SRCVALUE</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">  // with the preallocated call Value.</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">  // with the preallocated call Value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">  PREALLOCATED_SETUP,</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">  PREALLOCATED_SETUP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">  // PREALLOCATED_ARG - This has 3 operands: an input chain, a SRCVALUE</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">  // PREALLOCATED_ARG - This has 3 operands: an input chain, a SRCVALUE</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">  // with the preallocated call Value, and a constant int.</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">  // with the preallocated call Value, and a constant int.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">  PREALLOCATED_ARG,</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">  PREALLOCATED_ARG,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline"></td>
    <td class="lineNumber">1140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">  /// SRCVALUE - This is a node type that holds a Value* that is used to</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">  /// SRCVALUE - This is a node type that holds a Value* that is used to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">  /// make reference to a value in the LLVM IR.</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">  /// make reference to a value in the LLVM IR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">  SRCVALUE,</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">  SRCVALUE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline"></td>
    <td class="lineNumber">1144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">  /// MDNODE_SDNODE - This is a node that holdes an MDNode*, which is used to</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">  /// MDNODE_SDNODE - This is a node that holdes an MDNode*, which is used to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">  /// reference metadata in the IR.</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">  /// reference metadata in the IR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">  MDNODE_SDNODE,</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">  MDNODE_SDNODE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline"></td>
    <td class="lineNumber">1148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">  /// PCMARKER - This corresponds to the pcmarker intrinsic.</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">  /// PCMARKER - This corresponds to the pcmarker intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">  PCMARKER,</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">  PCMARKER,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline"></td>
    <td class="lineNumber">1151</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">  /// READCYCLECOUNTER - This corresponds to the readcyclecounter intrinsic.</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">  /// READCYCLECOUNTER - This corresponds to the readcyclecounter intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">  /// It produces a chain and one i64 value. The only operand is a chain.</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">  /// It produces a chain and one i64 value. The only operand is a chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">  /// If i64 is not legal, the result will be expanded into smaller values.</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">  /// If i64 is not legal, the result will be expanded into smaller values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">  /// Still, it returns an i64, so targets should set legality for i64.</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">  /// Still, it returns an i64, so targets should set legality for i64.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">  /// The result is the content of the architecture-specific cycle</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">  /// The result is the content of the architecture-specific cycle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">  /// counter-like register (or other high accuracy low latency clock source).</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">  /// counter-like register (or other high accuracy low latency clock source).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">  READCYCLECOUNTER,</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">  READCYCLECOUNTER,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">  /// HANDLENODE node - Used as a handle for various purposes.</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">  /// HANDLENODE node - Used as a handle for various purposes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">  HANDLENODE,</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">  HANDLENODE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline"></td>
    <td class="lineNumber">1162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">  /// INIT_TRAMPOLINE - This corresponds to the init_trampoline intrinsic.  It</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">  /// INIT_TRAMPOLINE - This corresponds to the init_trampoline intrinsic.  It</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">  /// takes as input a token chain, the pointer to the trampoline, the pointer</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">  /// takes as input a token chain, the pointer to the trampoline, the pointer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">  /// to the nested function, the pointer to pass for the 'nest' parameter, a</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">  /// to the nested function, the pointer to pass for the 'nest' parameter, a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">  /// SRCVALUE for the trampoline and another for the nested function</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">  /// SRCVALUE for the trampoline and another for the nested function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">  /// (allowing targets to access the original Function*).</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">  /// (allowing targets to access the original Function*).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">  /// It produces a token chain as output.</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">  /// It produces a token chain as output.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">  INIT_TRAMPOLINE,</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">  INIT_TRAMPOLINE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline"></td>
    <td class="lineNumber">1170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">  /// ADJUST_TRAMPOLINE - This corresponds to the adjust_trampoline intrinsic.</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">  /// ADJUST_TRAMPOLINE - This corresponds to the adjust_trampoline intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">  /// It takes a pointer to the trampoline and produces a (possibly) new</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">  /// It takes a pointer to the trampoline and produces a (possibly) new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">  /// pointer to the same trampoline with platform-specific adjustments</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">  /// pointer to the same trampoline with platform-specific adjustments</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">  /// applied.  The pointer it returns points to an executable block of code.</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">  /// applied.  The pointer it returns points to an executable block of code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">  ADJUST_TRAMPOLINE,</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">  ADJUST_TRAMPOLINE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline"></td>
    <td class="lineNumber">1176</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">  /// TRAP - Trapping instruction</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">  /// TRAP - Trapping instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">  TRAP,</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">  TRAP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline"></td>
    <td class="lineNumber">1179</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">  /// DEBUGTRAP - Trap intended to get the attention of a debugger.</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">  /// DEBUGTRAP - Trap intended to get the attention of a debugger.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">  DEBUGTRAP,</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">  DEBUGTRAP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline"></td>
    <td class="lineNumber">1182</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">  /// UBSANTRAP - Trap with an immediate describing the kind of sanitizer</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">  /// UBSANTRAP - Trap with an immediate describing the kind of sanitizer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">  /// failure.</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">  /// failure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">  UBSANTRAP,</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">  UBSANTRAP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline"></td>
    <td class="lineNumber">1186</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">  /// PREFETCH - This corresponds to a prefetch intrinsic. The first operand</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">  /// PREFETCH - This corresponds to a prefetch intrinsic. The first operand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">  /// is the chain.  The other operands are the address to prefetch,</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">  /// is the chain.  The other operands are the address to prefetch,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">  /// read / write specifier, locality specifier and instruction / data cache</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">  /// read / write specifier, locality specifier and instruction / data cache</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">  /// specifier.</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">  /// specifier.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">  PREFETCH,</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">  PREFETCH,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline"></td>
    <td class="lineNumber">1192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">  /// ARITH_FENCE - This corresponds to a arithmetic fence intrinsic. Both its</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">  /// ARITH_FENCE - This corresponds to a arithmetic fence intrinsic. Both its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">  /// operand and output are the same floating type.</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">  /// operand and output are the same floating type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">  ARITH_FENCE,</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">  ARITH_FENCE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline"></td>
    <td class="lineNumber">1196</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">  /// MEMBARRIER - Compiler barrier only; generate a no-op.</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">  /// MEMBARRIER - Compiler barrier only; generate a no-op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">  MEMBARRIER,</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">  MEMBARRIER,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline"></td>
    <td class="lineNumber">1199</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">  /// OUTCHAIN = ATOMIC_FENCE(INCHAIN, ordering, scope)</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">  /// OUTCHAIN = ATOMIC_FENCE(INCHAIN, ordering, scope)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">  /// This corresponds to the fence instruction. It takes an input chain, and</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">  /// This corresponds to the fence instruction. It takes an input chain, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">  /// two integer constants: an AtomicOrdering and a SynchronizationScope.</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">  /// two integer constants: an AtomicOrdering and a SynchronizationScope.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">  ATOMIC_FENCE,</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">  ATOMIC_FENCE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline"></td>
    <td class="lineNumber">1204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  /// Val, OUTCHAIN = ATOMIC_LOAD(INCHAIN, ptr)</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  /// Val, OUTCHAIN = ATOMIC_LOAD(INCHAIN, ptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">  /// This corresponds to "load atomic" instruction.</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">  /// This corresponds to "load atomic" instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">  ATOMIC_LOAD,</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">  ATOMIC_LOAD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline"></td>
    <td class="lineNumber">1208</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">  /// OUTCHAIN = ATOMIC_STORE(INCHAIN, ptr, val)</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">  /// OUTCHAIN = ATOMIC_STORE(INCHAIN, ptr, val)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">  /// This corresponds to "store atomic" instruction.</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">  /// This corresponds to "store atomic" instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">  ATOMIC_STORE,</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">  ATOMIC_STORE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline"></td>
    <td class="lineNumber">1212</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">  /// Val, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmp, swap)</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">  /// Val, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmp, swap)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  /// For double-word atomic operations:</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  /// For double-word atomic operations:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmpLo, cmpHi,</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmpLo, cmpHi,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">  ///                                          swapLo, swapHi)</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">  ///                                          swapLo, swapHi)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">  /// This corresponds to the cmpxchg instruction.</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">  /// This corresponds to the cmpxchg instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  ATOMIC_CMP_SWAP,</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  ATOMIC_CMP_SWAP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">  /// Val, Success, OUTCHAIN</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">  /// Val, Success, OUTCHAIN</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">  ///     = ATOMIC_CMP_SWAP_WITH_SUCCESS(INCHAIN, ptr, cmp, swap)</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">  ///     = ATOMIC_CMP_SWAP_WITH_SUCCESS(INCHAIN, ptr, cmp, swap)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  /// N.b. this is still a strong cmpxchg operation, so</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  /// N.b. this is still a strong cmpxchg operation, so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">  /// Success == "Val == cmp".</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">  /// Success == "Val == cmp".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">  ATOMIC_CMP_SWAP_WITH_SUCCESS,</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">  ATOMIC_CMP_SWAP_WITH_SUCCESS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">  /// Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt)</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">  /// Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  /// Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt)</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  /// Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">  /// For double-word atomic operations:</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">  /// For double-word atomic operations:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi)</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi)</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">  /// These correspond to the atomicrmw instruction.</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">  /// These correspond to the atomicrmw instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  ATOMIC_SWAP,</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  ATOMIC_SWAP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">  ATOMIC_LOAD_ADD,</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">  ATOMIC_LOAD_ADD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">  ATOMIC_LOAD_SUB,</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">  ATOMIC_LOAD_SUB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  ATOMIC_LOAD_AND,</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  ATOMIC_LOAD_AND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">  ATOMIC_LOAD_CLR,</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">  ATOMIC_LOAD_CLR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  ATOMIC_LOAD_OR,</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  ATOMIC_LOAD_OR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">  ATOMIC_LOAD_XOR,</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">  ATOMIC_LOAD_XOR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">  ATOMIC_LOAD_NAND,</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">  ATOMIC_LOAD_NAND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">  ATOMIC_LOAD_MIN,</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">  ATOMIC_LOAD_MIN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">  ATOMIC_LOAD_MAX,</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">  ATOMIC_LOAD_MAX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">  ATOMIC_LOAD_UMIN,</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">  ATOMIC_LOAD_UMIN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">  ATOMIC_LOAD_UMAX,</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">  ATOMIC_LOAD_UMAX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">  ATOMIC_LOAD_FADD,</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">  ATOMIC_LOAD_FADD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">  ATOMIC_LOAD_FSUB,</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">  ATOMIC_LOAD_FSUB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">  ATOMIC_LOAD_FMAX,</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">  ATOMIC_LOAD_FMAX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">  ATOMIC_LOAD_FMIN,</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">  ATOMIC_LOAD_FMIN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">  ATOMIC_LOAD_UINC_WRAP,</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">  ATOMIC_LOAD_UINC_WRAP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">  ATOMIC_LOAD_UDEC_WRAP,</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">  ATOMIC_LOAD_UDEC_WRAP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline"></td>
    <td class="lineNumber">1250</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">  // Masked load and store - consecutive vector load and store operations</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">  // Masked load and store - consecutive vector load and store operations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">  // with additional mask operand that prevents memory accesses to the</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">  // with additional mask operand that prevents memory accesses to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">  // masked-off lanes.</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">  // masked-off lanes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">  // Val, OutChain = MLOAD(BasePtr, Mask, PassThru)</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">  // Val, OutChain = MLOAD(BasePtr, Mask, PassThru)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">  // OutChain = MSTORE(Value, BasePtr, Mask)</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">  // OutChain = MSTORE(Value, BasePtr, Mask)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">  MLOAD,</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">  MLOAD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  MSTORE,</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  MSTORE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline"></td>
    <td class="lineNumber">1259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">  // Masked gather and scatter - load and store operations for a vector of</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">  // Masked gather and scatter - load and store operations for a vector of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">  // random addresses with additional mask operand that prevents memory</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">  // random addresses with additional mask operand that prevents memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">  // accesses to the masked-off lanes.</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">  // accesses to the masked-off lanes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">  // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale)</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">  // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">  // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale)</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">  // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">  // The Index operand can have more vector elements than the other operands</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">  // The Index operand can have more vector elements than the other operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">  // due to type legalization. The extra elements are ignored.</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">  // due to type legalization. The extra elements are ignored.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">  MGATHER,</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">  MGATHER,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">  MSCATTER,</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">  MSCATTER,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline"></td>
    <td class="lineNumber">1271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">  /// This corresponds to the llvm.lifetime.* intrinsics. The first operand</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">  /// This corresponds to the llvm.lifetime.* intrinsics. The first operand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">  /// is the chain and the second operand is the alloca pointer.</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">  /// is the chain and the second operand is the alloca pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  LIFETIME_START,</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  LIFETIME_START,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">  LIFETIME_END,</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">  LIFETIME_END,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">  /// GC_TRANSITION_START/GC_TRANSITION_END - These operators mark the</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">  /// GC_TRANSITION_START/GC_TRANSITION_END - These operators mark the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">  /// beginning and end of GC transition  sequence, and carry arbitrary</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">  /// beginning and end of GC transition  sequence, and carry arbitrary</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">  /// information that target might need for lowering.  The first operand is</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">  /// information that target might need for lowering.  The first operand is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">  /// a chain, the rest are specified by the target and not touched by the DAG</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">  /// a chain, the rest are specified by the target and not touched by the DAG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">  /// optimizers. GC_TRANSITION_START..GC_TRANSITION_END pairs may not be</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">  /// optimizers. GC_TRANSITION_START..GC_TRANSITION_END pairs may not be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">  /// nested.</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">  /// nested.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">  GC_TRANSITION_START,</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">  GC_TRANSITION_START,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">  GC_TRANSITION_END,</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">  GC_TRANSITION_END,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">  /// GET_DYNAMIC_AREA_OFFSET - get offset from native SP to the address of</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">  /// GET_DYNAMIC_AREA_OFFSET - get offset from native SP to the address of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">  /// the most recent dynamic alloca. For most targets that would be 0, but</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">  /// the most recent dynamic alloca. For most targets that would be 0, but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">  /// for some others (e.g. PowerPC, PowerPC64) that would be compile-time</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">  /// for some others (e.g. PowerPC, PowerPC64) that would be compile-time</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">  /// known nonzero constant. The only operand here is the chain.</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">  /// known nonzero constant. The only operand here is the chain.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">  GET_DYNAMIC_AREA_OFFSET,</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">  GET_DYNAMIC_AREA_OFFSET,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline"></td>
    <td class="lineNumber">1291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">  /// Pseudo probe for AutoFDO, as a place holder in a basic block to improve</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">  /// Pseudo probe for AutoFDO, as a place holder in a basic block to improve</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">  /// the sample counts quality.</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">  /// the sample counts quality.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">  PSEUDO_PROBE,</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">  PSEUDO_PROBE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline"></td>
    <td class="lineNumber">1295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">  /// VSCALE(IMM) - Returns the runtime scaling factor used to calculate the</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">  /// VSCALE(IMM) - Returns the runtime scaling factor used to calculate the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">  /// number of elements within a scalable vector. IMM is a constant integer</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">  /// number of elements within a scalable vector. IMM is a constant integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">  /// multiplier that is applied to the runtime value.</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">  /// multiplier that is applied to the runtime value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">  VSCALE,</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">  VSCALE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline"></td>
    <td class="lineNumber">1300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">  /// Generic reduction nodes. These nodes represent horizontal vector</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">  /// Generic reduction nodes. These nodes represent horizontal vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">  /// reduction operations, producing a scalar result.</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">  /// reduction operations, producing a scalar result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">  /// The SEQ variants perform reductions in sequential order. The first</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">  /// The SEQ variants perform reductions in sequential order. The first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">  /// operand is an initial scalar accumulator value, and the second operand</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">  /// operand is an initial scalar accumulator value, and the second operand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">  /// is the vector to reduce.</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">  /// is the vector to reduce.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">  /// E.g. RES = VECREDUCE_SEQ_FADD f32 ACC, <4 x f32> SRC_VEC</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">  /// E.g. RES = VECREDUCE_SEQ_FADD f32 ACC, <4 x f32> SRC_VEC</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">  ///  ... is equivalent to</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">  ///  ... is equivalent to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">  /// RES = (((ACC + SRC_VEC[0]) + SRC_VEC[1]) + SRC_VEC[2]) + SRC_VEC[3]</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">  /// RES = (((ACC + SRC_VEC[0]) + SRC_VEC[1]) + SRC_VEC[2]) + SRC_VEC[3]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">  VECREDUCE_SEQ_FADD,</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">  VECREDUCE_SEQ_FADD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">  VECREDUCE_SEQ_FMUL,</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">  VECREDUCE_SEQ_FMUL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">  /// These reductions have relaxed evaluation order semantics, and have a</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">  /// These reductions have relaxed evaluation order semantics, and have a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  /// single vector operand. The order of evaluation is unspecified. For</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  /// single vector operand. The order of evaluation is unspecified. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">  /// pow-of-2 vectors, one valid legalizer expansion is to use a tree</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">  /// pow-of-2 vectors, one valid legalizer expansion is to use a tree</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">  /// reduction, i.e.:</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">  /// reduction, i.e.:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">  /// For RES = VECREDUCE_FADD <8 x f16> SRC_VEC</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">  /// For RES = VECREDUCE_FADD <8 x f16> SRC_VEC</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">  ///   PART_RDX = FADD SRC_VEC[0:3], SRC_VEC[4:7]</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">  ///   PART_RDX = FADD SRC_VEC[0:3], SRC_VEC[4:7]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">  ///   PART_RDX2 = FADD PART_RDX[0:1], PART_RDX[2:3]</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">  ///   PART_RDX2 = FADD PART_RDX[0:1], PART_RDX[2:3]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">  ///   RES = FADD PART_RDX2[0], PART_RDX2[1]</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">  ///   RES = FADD PART_RDX2[0], PART_RDX2[1]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">  /// For non-pow-2 vectors, this can be computed by extracting each element</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">  /// For non-pow-2 vectors, this can be computed by extracting each element</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">  /// and performing the operation as if it were scalarized.</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">  /// and performing the operation as if it were scalarized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">  VECREDUCE_FADD,</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">  VECREDUCE_FADD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">  VECREDUCE_FMUL,</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">  VECREDUCE_FMUL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">  /// FMIN/FMAX nodes can have flags, for NaN/NoNaN variants.</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">  /// FMIN/FMAX nodes can have flags, for NaN/NoNaN variants.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">  VECREDUCE_FMAX,</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">  VECREDUCE_FMAX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">  VECREDUCE_FMIN,</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">  VECREDUCE_FMIN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">  /// FMINIMUM/FMAXIMUM nodes propatate NaNs and signed zeroes using the</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">  /// FMINIMUM/FMAXIMUM nodes propatate NaNs and signed zeroes using the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">  /// llvm.minimum and llvm.maximum semantics.</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">  /// llvm.minimum and llvm.maximum semantics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">  VECREDUCE_FMAXIMUM,</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">  VECREDUCE_FMAXIMUM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">  VECREDUCE_FMINIMUM,</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">  VECREDUCE_FMINIMUM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">  /// Integer reductions may have a result type larger than the vector element</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">  /// Integer reductions may have a result type larger than the vector element</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">  /// type. However, the reduction is performed using the vector element type</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">  /// type. However, the reduction is performed using the vector element type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">  /// and the value in the top bits is unspecified.</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">  /// and the value in the top bits is unspecified.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">  VECREDUCE_ADD,</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">  VECREDUCE_ADD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">  VECREDUCE_MUL,</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">  VECREDUCE_MUL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">  VECREDUCE_AND,</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">  VECREDUCE_AND,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">  VECREDUCE_OR,</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">  VECREDUCE_OR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">  VECREDUCE_XOR,</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">  VECREDUCE_XOR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">  VECREDUCE_SMAX,</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">  VECREDUCE_SMAX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">  VECREDUCE_SMIN,</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">  VECREDUCE_SMIN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">  VECREDUCE_UMAX,</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">  VECREDUCE_UMAX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">  VECREDUCE_UMIN,</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">  VECREDUCE_UMIN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">  // The `llvm.experimental.stackmap` intrinsic.</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">  // The `llvm.experimental.stackmap` intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">  // Operands: input chain, glue, <id>, <numShadowBytes>, [live0[, live1...]]</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">  // Operands: input chain, glue, <id>, <numShadowBytes>, [live0[, live1...]]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">  // Outputs: output chain, glue</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">  // Outputs: output chain, glue</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">  STACKMAP,</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">  STACKMAP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline"></td>
    <td class="lineNumber">1348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">  // The `llvm.experimental.patchpoint.*` intrinsic.</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">  // The `llvm.experimental.patchpoint.*` intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">  // Operands: input chain, [glue], reg-mask, <id>, <numShadowBytes>, callee,</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">  // Operands: input chain, [glue], reg-mask, <id>, <numShadowBytes>, callee,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">  //   <numArgs>, cc, ...</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">  //   <numArgs>, cc, ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">  // Outputs: [rv], output chain, glue</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">  // Outputs: [rv], output chain, glue</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">  PATCHPOINT,</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">  PATCHPOINT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline"></td>
    <td class="lineNumber">1354</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">// Vector Predication</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">// Vector Predication</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">#define BEGIN_REGISTER_VP_SDNODE(VPSDID, ...) VPSDID,</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">#define BEGIN_REGISTER_VP_SDNODE(VPSDID, ...) VPSDID,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">#include "llvm/IR/VPIntrinsics.def"</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">#include "llvm/IR/VPIntrinsics.def"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline"></td>
    <td class="lineNumber">1358</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">  /// BUILTIN_OP_END - This must be the last enum value in this list.</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">  /// BUILTIN_OP_END - This must be the last enum value in this list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">  /// The target-specific pre-isel opcode values start here.</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">  /// The target-specific pre-isel opcode values start here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">  BUILTIN_OP_END</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">  BUILTIN_OP_END</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline"></td>
    <td class="lineNumber">1363</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">/// FIRST_TARGET_STRICTFP_OPCODE - Target-specific pre-isel operations</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">/// FIRST_TARGET_STRICTFP_OPCODE - Target-specific pre-isel operations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">/// which cannot raise FP exceptions should be less than this value.</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">/// which cannot raise FP exceptions should be less than this value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">/// Those that do must not be less than this value.</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">/// Those that do must not be less than this value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">static const int FIRST_TARGET_STRICTFP_OPCODE = BUILTIN_OP_END + 400;</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">static const int FIRST_TARGET_STRICTFP_OPCODE = BUILTIN_OP_END + 400;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline"></td>
    <td class="lineNumber">1368</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">/// FIRST_TARGET_MEMORY_OPCODE - Target-specific pre-isel operations</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">/// FIRST_TARGET_MEMORY_OPCODE - Target-specific pre-isel operations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">/// which do not reference a specific memory location should be less than</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">/// which do not reference a specific memory location should be less than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">/// this value. Those that do must not be less than this value, and can</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">/// this value. Those that do must not be less than this value, and can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">/// be used with SelectionDAG::getMemIntrinsicNode.</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">/// be used with SelectionDAG::getMemIntrinsicNode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">static const int FIRST_TARGET_MEMORY_OPCODE = BUILTIN_OP_END + 500;</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">static const int FIRST_TARGET_MEMORY_OPCODE = BUILTIN_OP_END + 500;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline"></td>
    <td class="lineNumber">1374</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">/// Whether this is bitwise logic opcode.</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">/// Whether this is bitwise logic opcode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">inline bool isBitwiseLogicOp(unsigned Opcode) {</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">inline bool isBitwiseLogicOp(unsigned Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">  return Opcode == ISD::AND || Opcode == ISD::OR || Opcode == ISD::XOR;</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">  return Opcode == ISD::AND || Opcode == ISD::OR || Opcode == ISD::XOR;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline"></td>
    <td class="lineNumber">1379</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">/// Get underlying scalar opcode for VECREDUCE opcode.</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">/// Get underlying scalar opcode for VECREDUCE opcode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">/// For example ISD::AND for ISD::VECREDUCE_AND.</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">/// For example ISD::AND for ISD::VECREDUCE_AND.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">NodeType getVecReduceBaseOpcode(unsigned VecReduceOpcode);</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">NodeType getVecReduceBaseOpcode(unsigned VecReduceOpcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline"></td>
    <td class="lineNumber">1383</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">/// Whether this is a vector-predicated Opcode.</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">/// Whether this is a vector-predicated Opcode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">bool isVPOpcode(unsigned Opcode);</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">bool isVPOpcode(unsigned Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline"></td>
    <td class="lineNumber">1386</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">/// Whether this is a vector-predicated binary operation opcode.</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">/// Whether this is a vector-predicated binary operation opcode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">bool isVPBinaryOp(unsigned Opcode);</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">bool isVPBinaryOp(unsigned Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline"></td>
    <td class="lineNumber">1389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">/// Whether this is a vector-predicated reduction opcode.</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">/// Whether this is a vector-predicated reduction opcode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">bool isVPReduction(unsigned Opcode);</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">bool isVPReduction(unsigned Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline"></td>
    <td class="lineNumber">1392</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">/// The operand position of the vector mask.</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">/// The operand position of the vector mask.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">std::optional<unsigned> getVPMaskIdx(unsigned Opcode);</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">std::optional<unsigned> getVPMaskIdx(unsigned Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline"></td>
    <td class="lineNumber">1395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">/// The operand position of the explicit vector length parameter.</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">/// The operand position of the explicit vector length parameter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">std::optional<unsigned> getVPExplicitVectorLengthIdx(unsigned Opcode);</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">std::optional<unsigned> getVPExplicitVectorLengthIdx(unsigned Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline"></td>
    <td class="lineNumber">1398</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">/// Translate this VP Opcode to its corresponding non-VP Opcode.</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">/// Translate this VP Opcode to its corresponding non-VP Opcode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">std::optional<unsigned> getBaseOpcodeForVP(unsigned Opcode, bool hasFPExcept);</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">std::optional<unsigned> getBaseOpcodeForVP(unsigned Opcode, bool hasFPExcept);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline"></td>
    <td class="lineNumber">1401</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">/// Translate this non-VP Opcode to its corresponding VP Opcode.</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">/// Translate this non-VP Opcode to its corresponding VP Opcode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">unsigned getVPForBaseOpcode(unsigned Opcode);</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">unsigned getVPForBaseOpcode(unsigned Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline"></td>
    <td class="lineNumber">1404</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">//===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">/// MemIndexedMode enum - This enum defines the load / store indexed</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">/// MemIndexedMode enum - This enum defines the load / store indexed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">/// addressing modes.</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">/// addressing modes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">/// UNINDEXED    "Normal" load / store. The effective address is already</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">/// UNINDEXED    "Normal" load / store. The effective address is already</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">///              computed and is available in the base pointer. The offset</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">///              computed and is available in the base pointer. The offset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">///              operand is always undefined. In addition to producing a</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">///              operand is always undefined. In addition to producing a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">///              chain, an unindexed load produces one value (result of the</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">///              chain, an unindexed load produces one value (result of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">///              load); an unindexed store does not produce a value.</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">///              load); an unindexed store does not produce a value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">/// PRE_INC      Similar to the unindexed mode where the effective address is</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">/// PRE_INC      Similar to the unindexed mode where the effective address is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">/// PRE_DEC      the value of the base pointer add / subtract the offset.</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">/// PRE_DEC      the value of the base pointer add / subtract the offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">///              It considers the computation as being folded into the load /</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">///              It considers the computation as being folded into the load /</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">///              store operation (i.e. the load / store does the address</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">///              store operation (i.e. the load / store does the address</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">///              computation as well as performing the memory transaction).</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">///              computation as well as performing the memory transaction).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">///              The base operand is always undefined. In addition to</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">///              The base operand is always undefined. In addition to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">///              producing a chain, pre-indexed load produces two values</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">///              producing a chain, pre-indexed load produces two values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">///              (result of the load and the result of the address</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">///              (result of the load and the result of the address</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">///              computation); a pre-indexed store produces one value (result</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">///              computation); a pre-indexed store produces one value (result</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">///              of the address computation).</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">///              of the address computation).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">/// POST_INC     The effective address is the value of the base pointer. The</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">/// POST_INC     The effective address is the value of the base pointer. The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">/// POST_DEC     value of the offset operand is then added to / subtracted</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">/// POST_DEC     value of the offset operand is then added to / subtracted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">///              from the base after memory transaction. In addition to</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">///              from the base after memory transaction. In addition to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">///              producing a chain, post-indexed load produces two values</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">///              producing a chain, post-indexed load produces two values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">///              (the result of the load and the result of the base +/- offset</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">///              (the result of the load and the result of the base +/- offset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">///              computation); a post-indexed store produces one value (the</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">///              computation); a post-indexed store produces one value (the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">///              the result of the base +/- offset computation).</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">///              the result of the base +/- offset computation).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">enum MemIndexedMode { UNINDEXED = 0, PRE_INC, PRE_DEC, POST_INC, POST_DEC };</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">enum MemIndexedMode { UNINDEXED = 0, PRE_INC, PRE_DEC, POST_INC, POST_DEC };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline"></td>
    <td class="lineNumber">1434</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">static const int LAST_INDEXED_MODE = POST_DEC + 1;</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">static const int LAST_INDEXED_MODE = POST_DEC + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline"></td>
    <td class="lineNumber">1436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">//===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">/// MemIndexType enum - This enum defines how to interpret MGATHER/SCATTER's</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">/// MemIndexType enum - This enum defines how to interpret MGATHER/SCATTER's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">/// index parameter when calculating addresses.</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">/// index parameter when calculating addresses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">/// SIGNED_SCALED     Addr = Base + ((signed)Index * Scale)</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">/// SIGNED_SCALED     Addr = Base + ((signed)Index * Scale)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">/// UNSIGNED_SCALED   Addr = Base + ((unsigned)Index * Scale)</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">/// UNSIGNED_SCALED   Addr = Base + ((unsigned)Index * Scale)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">/// NOTE: The value of Scale is typically only known to the node owning the</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">/// NOTE: The value of Scale is typically only known to the node owning the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">/// IndexType, with a value of 1 the equivalent of being unscaled.</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">/// IndexType, with a value of 1 the equivalent of being unscaled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">enum MemIndexType { SIGNED_SCALED = 0, UNSIGNED_SCALED };</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">enum MemIndexType { SIGNED_SCALED = 0, UNSIGNED_SCALED };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline"></td>
    <td class="lineNumber">1447</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">static const int LAST_MEM_INDEX_TYPE = UNSIGNED_SCALED + 1;</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">static const int LAST_MEM_INDEX_TYPE = UNSIGNED_SCALED + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline"></td>
    <td class="lineNumber">1449</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">inline bool isIndexTypeSigned(MemIndexType IndexType) {</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">inline bool isIndexTypeSigned(MemIndexType IndexType) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">  return IndexType == SIGNED_SCALED;</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">  return IndexType == SIGNED_SCALED;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline"></td>
    <td class="lineNumber">1453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">//===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">/// LoadExtType enum - This enum defines the three variants of LOADEXT</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">/// LoadExtType enum - This enum defines the three variants of LOADEXT</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">/// (load with extension).</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">/// (load with extension).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">/// SEXTLOAD loads the integer operand and sign extends it to a larger</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">/// SEXTLOAD loads the integer operand and sign extends it to a larger</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">///          integer result type.</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">///          integer result type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">/// ZEXTLOAD loads the integer operand and zero extends it to a larger</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">/// ZEXTLOAD loads the integer operand and zero extends it to a larger</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">///          integer result type.</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">///          integer result type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">/// EXTLOAD  is used for two things: floating point extending loads and</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">/// EXTLOAD  is used for two things: floating point extending loads and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">///          integer extending loads [the top bits are undefined].</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">///          integer extending loads [the top bits are undefined].</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">enum LoadExtType { NON_EXTLOAD = 0, EXTLOAD, SEXTLOAD, ZEXTLOAD };</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">enum LoadExtType { NON_EXTLOAD = 0, EXTLOAD, SEXTLOAD, ZEXTLOAD };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline"></td>
    <td class="lineNumber">1465</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">static const int LAST_LOADEXT_TYPE = ZEXTLOAD + 1;</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">static const int LAST_LOADEXT_TYPE = ZEXTLOAD + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline"></td>
    <td class="lineNumber">1467</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">NodeType getExtForLoadExtType(bool IsFP, LoadExtType);</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">NodeType getExtForLoadExtType(bool IsFP, LoadExtType);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline"></td>
    <td class="lineNumber">1469</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">//===--------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">/// ISD::CondCode enum - These are ordered carefully to make the bitfields</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">/// ISD::CondCode enum - These are ordered carefully to make the bitfields</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">/// below work out, when considering SETFALSE (something that never exists</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">/// below work out, when considering SETFALSE (something that never exists</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">/// dynamically) as 0.  "U" -> Unsigned (for integer operands) or Unordered</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">/// dynamically) as 0.  "U" -> Unsigned (for integer operands) or Unordered</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">/// (for floating point), "L" -> Less than, "G" -> Greater than, "E" -> Equal</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">/// (for floating point), "L" -> Less than, "G" -> Greater than, "E" -> Equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">/// to.  If the "N" column is 1, the result of the comparison is undefined if</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">/// to.  If the "N" column is 1, the result of the comparison is undefined if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">/// the input is a NAN.</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">/// the input is a NAN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">/// All of these (except for the 'always folded ops') should be handled for</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">/// All of these (except for the 'always folded ops') should be handled for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">/// floating point.  For integer, only the SETEQ,SETNE,SETLT,SETLE,SETGT,</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">/// floating point.  For integer, only the SETEQ,SETNE,SETLT,SETLE,SETGT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">/// SETGE,SETULT,SETULE,SETUGT, and SETUGE opcodes are used.</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">/// SETGE,SETULT,SETULE,SETUGT, and SETUGE opcodes are used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">/// Note that these are laid out in a specific order to allow bit-twiddling</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">/// Note that these are laid out in a specific order to allow bit-twiddling</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">/// to transform conditions.</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">/// to transform conditions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">enum CondCode {</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">enum CondCode {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">  // Opcode       N U L G E       Intuitive operation</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">  // Opcode       N U L G E       Intuitive operation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">  SETFALSE, //      0 0 0 0       Always false (always folded)</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">  SETFALSE, //      0 0 0 0       Always false (always folded)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">  SETOEQ,   //      0 0 0 1       True if ordered and equal</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">  SETOEQ,   //      0 0 0 1       True if ordered and equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">  SETOGT,   //      0 0 1 0       True if ordered and greater than</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">  SETOGT,   //      0 0 1 0       True if ordered and greater than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">  SETOGE,   //      0 0 1 1       True if ordered and greater than or equal</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">  SETOGE,   //      0 0 1 1       True if ordered and greater than or equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">  SETOLT,   //      0 1 0 0       True if ordered and less than</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">  SETOLT,   //      0 1 0 0       True if ordered and less than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">  SETOLE,   //      0 1 0 1       True if ordered and less than or equal</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">  SETOLE,   //      0 1 0 1       True if ordered and less than or equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">  SETONE,   //      0 1 1 0       True if ordered and operands are unequal</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">  SETONE,   //      0 1 1 0       True if ordered and operands are unequal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">  SETO,     //      0 1 1 1       True if ordered (no nans)</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">  SETO,     //      0 1 1 1       True if ordered (no nans)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">  SETUO,    //      1 0 0 0       True if unordered: isnan(X) | isnan(Y)</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">  SETUO,    //      1 0 0 0       True if unordered: isnan(X) | isnan(Y)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">  SETUEQ,   //      1 0 0 1       True if unordered or equal</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">  SETUEQ,   //      1 0 0 1       True if unordered or equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">  SETUGT,   //      1 0 1 0       True if unordered or greater than</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">  SETUGT,   //      1 0 1 0       True if unordered or greater than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  SETUGE,   //      1 0 1 1       True if unordered, greater than, or equal</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  SETUGE,   //      1 0 1 1       True if unordered, greater than, or equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">  SETULT,   //      1 1 0 0       True if unordered or less than</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">  SETULT,   //      1 1 0 0       True if unordered or less than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">  SETULE,   //      1 1 0 1       True if unordered, less than, or equal</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">  SETULE,   //      1 1 0 1       True if unordered, less than, or equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">  SETUNE,   //      1 1 1 0       True if unordered or not equal</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">  SETUNE,   //      1 1 1 0       True if unordered or not equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">  SETTRUE,  //      1 1 1 1       Always true (always folded)</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">  SETTRUE,  //      1 1 1 1       Always true (always folded)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">  // Don't care operations: undefined if the input is a nan.</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">  // Don't care operations: undefined if the input is a nan.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">  SETFALSE2, //   1 X 0 0 0       Always false (always folded)</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">  SETFALSE2, //   1 X 0 0 0       Always false (always folded)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">  SETEQ,     //   1 X 0 0 1       True if equal</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">  SETEQ,     //   1 X 0 0 1       True if equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">  SETGT,     //   1 X 0 1 0       True if greater than</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">  SETGT,     //   1 X 0 1 0       True if greater than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">  SETGE,     //   1 X 0 1 1       True if greater than or equal</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">  SETGE,     //   1 X 0 1 1       True if greater than or equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">  SETLT,     //   1 X 1 0 0       True if less than</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">  SETLT,     //   1 X 1 0 0       True if less than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">  SETLE,     //   1 X 1 0 1       True if less than or equal</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">  SETLE,     //   1 X 1 0 1       True if less than or equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">  SETNE,     //   1 X 1 1 0       True if not equal</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">  SETNE,     //   1 X 1 1 0       True if not equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">  SETTRUE2,  //   1 X 1 1 1       Always true (always folded)</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">  SETTRUE2,  //   1 X 1 1 1       Always true (always folded)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline"></td>
    <td class="lineNumber">1511</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">  SETCC_INVALID // Marker value.</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">  SETCC_INVALID // Marker value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline"></td>
    <td class="lineNumber">1514</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">/// Return true if this is a setcc instruction that performs a signed</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">/// Return true if this is a setcc instruction that performs a signed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">/// comparison when used with integer operands.</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">/// comparison when used with integer operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">inline bool isSignedIntSetCC(CondCode Code) {</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">inline bool isSignedIntSetCC(CondCode Code) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">  return Code == SETGT || Code == SETGE || Code == SETLT || Code == SETLE;</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">  return Code == SETGT || Code == SETGE || Code == SETLT || Code == SETLE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline"></td>
    <td class="lineNumber">1520</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">/// Return true if this is a setcc instruction that performs an unsigned</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">/// Return true if this is a setcc instruction that performs an unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">/// comparison when used with integer operands.</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">/// comparison when used with integer operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">inline bool isUnsignedIntSetCC(CondCode Code) {</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">inline bool isUnsignedIntSetCC(CondCode Code) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">  return Code == SETUGT || Code == SETUGE || Code == SETULT || Code == SETULE;</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">  return Code == SETUGT || Code == SETUGE || Code == SETULT || Code == SETULE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline"></td>
    <td class="lineNumber">1526</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">/// Return true if this is a setcc instruction that performs an equality</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">/// Return true if this is a setcc instruction that performs an equality</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">/// comparison when used with integer operands.</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">/// comparison when used with integer operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">inline bool isIntEqualitySetCC(CondCode Code) {</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">inline bool isIntEqualitySetCC(CondCode Code) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">  return Code == SETEQ || Code == SETNE;</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">  return Code == SETEQ || Code == SETNE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline"></td>
    <td class="lineNumber">1532</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">/// Return true if the specified condition returns true if the two operands to</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">/// Return true if the specified condition returns true if the two operands to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">/// the condition are equal. Note that if one of the two operands is a NaN,</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">/// the condition are equal. Note that if one of the two operands is a NaN,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">/// this value is meaningless.</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">/// this value is meaningless.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">inline bool isTrueWhenEqual(CondCode Cond) { return ((int)Cond & 1) != 0; }</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">inline bool isTrueWhenEqual(CondCode Cond) { return ((int)Cond & 1) != 0; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline"></td>
    <td class="lineNumber">1537</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">/// This function returns 0 if the condition is always false if an operand is</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">/// This function returns 0 if the condition is always false if an operand is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">/// a NaN, 1 if the condition is always true if the operand is a NaN, and 2 if</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">/// a NaN, 1 if the condition is always true if the operand is a NaN, and 2 if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">/// the condition is undefined if the operand is a NaN.</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">/// the condition is undefined if the operand is a NaN.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">inline unsigned getUnorderedFlavor(CondCode Cond) {</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">inline unsigned getUnorderedFlavor(CondCode Cond) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">  return ((int)Cond >> 3) & 3;</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">  return ((int)Cond >> 3) & 3;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline"></td>
    <td class="lineNumber">1544</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">/// Return the operation corresponding to !(X op Y), where 'op' is a valid</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">/// Return the operation corresponding to !(X op Y), where 'op' is a valid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">/// SetCC operation.</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">/// SetCC operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">CondCode getSetCCInverse(CondCode Operation, EVT Type);</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">CondCode getSetCCInverse(CondCode Operation, EVT Type);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">inline bool isExtOpcode(unsigned Opcode) {</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">inline bool isExtOpcode(unsigned Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">  return Opcode == ISD::ANY_EXTEND || Opcode == ISD::ZERO_EXTEND ||</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">  return Opcode == ISD::ANY_EXTEND || Opcode == ISD::ZERO_EXTEND ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">         Opcode == ISD::SIGN_EXTEND;</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">         Opcode == ISD::SIGN_EXTEND;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1552</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline"></td>
    <td class="lineNumber">1553</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">inline bool isExtVecInRegOpcode(unsigned Opcode) {</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">inline bool isExtVecInRegOpcode(unsigned Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">  return Opcode == ISD::ANY_EXTEND_VECTOR_INREG ||</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">  return Opcode == ISD::ANY_EXTEND_VECTOR_INREG ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">         Opcode == ISD::ZERO_EXTEND_VECTOR_INREG ||</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">         Opcode == ISD::ZERO_EXTEND_VECTOR_INREG ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">         Opcode == ISD::SIGN_EXTEND_VECTOR_INREG;</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">         Opcode == ISD::SIGN_EXTEND_VECTOR_INREG;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline"></td>
    <td class="lineNumber">1559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">namespace GlobalISel {</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">namespace GlobalISel {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">/// Return the operation corresponding to !(X op Y), where 'op' is a valid</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">/// Return the operation corresponding to !(X op Y), where 'op' is a valid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">/// SetCC operation. The U bit of the condition code has different meanings</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">/// SetCC operation. The U bit of the condition code has different meanings</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">/// between floating point and integer comparisons and LLT's don't provide</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">/// between floating point and integer comparisons and LLT's don't provide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">/// this distinction. As such we need to be told whether the comparison is</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">/// this distinction. As such we need to be told whether the comparison is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">/// floating point or integer-like. Pointers should use integer-like</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">/// floating point or integer-like. Pointers should use integer-like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">/// comparisons.</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">/// comparisons.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">CondCode getSetCCInverse(CondCode Operation, bool isIntegerLike);</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">CondCode getSetCCInverse(CondCode Operation, bool isIntegerLike);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">} // end namespace GlobalISel</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">} // end namespace GlobalISel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline"></td>
    <td class="lineNumber">1569</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">/// Return the operation corresponding to (Y op X) when given the operation</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">/// Return the operation corresponding to (Y op X) when given the operation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">/// for (X op Y).</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">/// for (X op Y).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">CondCode getSetCCSwappedOperands(CondCode Operation);</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">CondCode getSetCCSwappedOperands(CondCode Operation);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline"></td>
    <td class="lineNumber">1573</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">/// Return the result of a logical OR between different comparisons of</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">/// Return the result of a logical OR between different comparisons of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">/// identical values: ((X op1 Y) | (X op2 Y)). This function returns</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">/// identical values: ((X op1 Y) | (X op2 Y)). This function returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">/// SETCC_INVALID if it is not possible to represent the resultant comparison.</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">/// SETCC_INVALID if it is not possible to represent the resultant comparison.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">CondCode getSetCCOrOperation(CondCode Op1, CondCode Op2, EVT Type);</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">CondCode getSetCCOrOperation(CondCode Op1, CondCode Op2, EVT Type);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline"></td>
    <td class="lineNumber">1578</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">/// Return the result of a logical AND between different comparisons of</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">/// Return the result of a logical AND between different comparisons of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">/// identical values: ((X op1 Y) & (X op2 Y)). This function returns</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">/// identical values: ((X op1 Y) & (X op2 Y)). This function returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">/// SETCC_INVALID if it is not possible to represent the resultant comparison.</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">/// SETCC_INVALID if it is not possible to represent the resultant comparison.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">CondCode getSetCCAndOperation(CondCode Op1, CondCode Op2, EVT Type);</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">CondCode getSetCCAndOperation(CondCode Op1, CondCode Op2, EVT Type);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline"></td>
    <td class="lineNumber">1583</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">} // namespace ISD</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">} // namespace ISD</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline"></td>
    <td class="lineNumber">1585</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">} // namespace llvm</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">} // namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline"></td>
    <td class="lineNumber">1587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline"></td>
    <td class="lineNumber">1589</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- llvm/CodeGen/ISDOpcodes.h - CodeGen opcodes -------------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- llvm/CodeGen/ISDOpcodes.h - CodeGen opcodes -------------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file declares codegen opcodes and related utilities.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file declares codegen opcodes and related utilities.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">#ifndef LLVM_CODEGEN_ISDOPCODES_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">#ifndef LLVM_CODEGEN_ISDOPCODES_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">#define LLVM_CODEGEN_ISDOPCODES_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">#define LLVM_CODEGEN_ISDOPCODES_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">/// ISD namespace - This namespace contains an enum which represents all of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">/// ISD namespace - This namespace contains an enum which represents all of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">/// SelectionDAG node types and value types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">/// SelectionDAG node types and value types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">namespace ISD {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">namespace ISD {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">/// ISD::NodeType enum - This enum defines the target-independent operators</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">/// ISD::NodeType enum - This enum defines the target-independent operators</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">/// for a SelectionDAG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">/// for a SelectionDAG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">/// Targets may also define target-dependent operator codes for SDNodes. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">/// Targets may also define target-dependent operator codes for SDNodes. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">/// example, on x86, these are the enum values in the X86ISD namespace.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">/// example, on x86, these are the enum values in the X86ISD namespace.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">/// Targets should aim to use target-independent operators to model their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">/// Targets should aim to use target-independent operators to model their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">/// instruction sets as much as possible, and only use target-dependent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">/// instruction sets as much as possible, and only use target-dependent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">/// operators when they have special requirements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">/// operators when they have special requirements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">/// Finally, during and after selection proper, SNodes may use special</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">/// Finally, during and after selection proper, SNodes may use special</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">/// operator codes that correspond directly with MachineInstr opcodes. These</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">/// operator codes that correspond directly with MachineInstr opcodes. These</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">/// are used to represent selected instructions. See the isMachineOpcode()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">/// are used to represent selected instructions. See the isMachineOpcode()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">/// and getMachineOpcode() member functions of SDNode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">/// and getMachineOpcode() member functions of SDNode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">enum NodeType {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">enum NodeType {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">  /// DELETED_NODE - This is an illegal value that is used to catch</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">  /// DELETED_NODE - This is an illegal value that is used to catch</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">  /// errors.  This opcode is not a legal opcode for any node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">  /// errors.  This opcode is not a legal opcode for any node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">  DELETED_NODE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">  DELETED_NODE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">  /// EntryToken - This is the marker used to indicate the start of a region.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">  /// EntryToken - This is the marker used to indicate the start of a region.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">  EntryToken,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">  EntryToken,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">  /// TokenFactor - This node takes multiple tokens as input and produces a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">  /// TokenFactor - This node takes multiple tokens as input and produces a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">  /// single token result. This is used to represent the fact that the operand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">  /// single token result. This is used to represent the fact that the operand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">  /// operators are independent of each other.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">  /// operators are independent of each other.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">  TokenFactor,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">  TokenFactor,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">  /// AssertSext, AssertZext - These nodes record if a register contains a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">  /// AssertSext, AssertZext - These nodes record if a register contains a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">  /// value that has already been zero or sign extended from a narrower type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">  /// value that has already been zero or sign extended from a narrower type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">  /// These nodes take two operands.  The first is the node that has already</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">  /// These nodes take two operands.  The first is the node that has already</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">  /// been extended, and the second is a value type node indicating the width</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">  /// been extended, and the second is a value type node indicating the width</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">  /// of the extension.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">  /// of the extension.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">  /// NOTE: In case of the source value (or any vector element value) is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">  /// NOTE: In case of the source value (or any vector element value) is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">  /// poisoned the assertion will not be true for that value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">  /// poisoned the assertion will not be true for that value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">  AssertSext,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">  AssertSext,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">  AssertZext,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">  AssertZext,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">  /// AssertAlign - These nodes record if a register contains a value that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">  /// AssertAlign - These nodes record if a register contains a value that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">  /// has a known alignment and the trailing bits are known to be zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">  /// has a known alignment and the trailing bits are known to be zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">  /// NOTE: In case of the source value (or any vector element value) is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">  /// NOTE: In case of the source value (or any vector element value) is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">  /// poisoned the assertion will not be true for that value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">  /// poisoned the assertion will not be true for that value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">  AssertAlign,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">  AssertAlign,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">  /// Various leaf nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">  /// Various leaf nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">  BasicBlock,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">  BasicBlock,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">  VALUETYPE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">  VALUETYPE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">  CONDCODE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">  CONDCODE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">  Register,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">  Register,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">  RegisterMask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">  RegisterMask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">  Constant,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">  Constant,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">  ConstantFP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">  ConstantFP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">  GlobalAddress,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">  GlobalAddress,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">  GlobalTLSAddress,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">  GlobalTLSAddress,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">  FrameIndex,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">  FrameIndex,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">  JumpTable,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">  JumpTable,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">  ConstantPool,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">  ConstantPool,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">  ExternalSymbol,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">  ExternalSymbol,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">  BlockAddress,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">  BlockAddress,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">  /// The address of the GOT</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">  /// The address of the GOT</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">  GLOBAL_OFFSET_TABLE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">  GLOBAL_OFFSET_TABLE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">  /// FRAMEADDR, RETURNADDR - These nodes represent llvm.frameaddress and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">  /// FRAMEADDR, RETURNADDR - These nodes represent llvm.frameaddress and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">  /// llvm.returnaddress on the DAG.  These nodes take one operand, the index</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">  /// llvm.returnaddress on the DAG.  These nodes take one operand, the index</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">  /// of the frame or return address to return.  An index of zero corresponds</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">  /// of the frame or return address to return.  An index of zero corresponds</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">  /// to the current function's frame or return address, an index of one to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">  /// to the current function's frame or return address, an index of one to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">  /// the parent's frame or return address, and so on.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">  /// the parent's frame or return address, and so on.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">  FRAMEADDR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">  FRAMEADDR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">  RETURNADDR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">  RETURNADDR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">  /// ADDROFRETURNADDR - Represents the llvm.addressofreturnaddress intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">  /// ADDROFRETURNADDR - Represents the llvm.addressofreturnaddress intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">  /// This node takes no operand, returns a target-specific pointer to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">  /// This node takes no operand, returns a target-specific pointer to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">  /// place in the stack frame where the return address of the current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">  /// place in the stack frame where the return address of the current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  /// function is stored.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  /// function is stored.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">  ADDROFRETURNADDR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">  ADDROFRETURNADDR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">  /// SPONENTRY - Represents the llvm.sponentry intrinsic. Takes no argument</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">  /// SPONENTRY - Represents the llvm.sponentry intrinsic. Takes no argument</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">  /// and returns the stack pointer value at the entry of the current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">  /// and returns the stack pointer value at the entry of the current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">  /// function calling this intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">  /// function calling this intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">  SPONENTRY,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">  SPONENTRY,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">  /// LOCAL_RECOVER - Represents the llvm.localrecover intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">  /// LOCAL_RECOVER - Represents the llvm.localrecover intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">  /// Materializes the offset from the local object pointer of another</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">  /// Materializes the offset from the local object pointer of another</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  /// function to a particular local object passed to llvm.localescape. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  /// function to a particular local object passed to llvm.localescape. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">  /// operand is the MCSymbol label used to represent this offset, since</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">  /// operand is the MCSymbol label used to represent this offset, since</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">  /// typically the offset is not known until after code generation of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">  /// typically the offset is not known until after code generation of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">  /// parent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">  /// parent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">  LOCAL_RECOVER,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">  LOCAL_RECOVER,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">  /// READ_REGISTER, WRITE_REGISTER - This node represents llvm.register on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">  /// READ_REGISTER, WRITE_REGISTER - This node represents llvm.register on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  /// the DAG, which implements the named register global variables extension.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  /// the DAG, which implements the named register global variables extension.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">  READ_REGISTER,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">  READ_REGISTER,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">  WRITE_REGISTER,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">  WRITE_REGISTER,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  /// FRAME_TO_ARGS_OFFSET - This node represents offset from frame pointer to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  /// FRAME_TO_ARGS_OFFSET - This node represents offset from frame pointer to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">  /// first (possible) on-stack argument. This is needed for correct stack</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">  /// first (possible) on-stack argument. This is needed for correct stack</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  /// adjustment during unwind.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  /// adjustment during unwind.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">  FRAME_TO_ARGS_OFFSET,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">  FRAME_TO_ARGS_OFFSET,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">  /// EH_DWARF_CFA - This node represents the pointer to the DWARF Canonical</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">  /// EH_DWARF_CFA - This node represents the pointer to the DWARF Canonical</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  /// Frame Address (CFA), generally the value of the stack pointer at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  /// Frame Address (CFA), generally the value of the stack pointer at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  /// call site in the previous frame.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  /// call site in the previous frame.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">  EH_DWARF_CFA,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">  EH_DWARF_CFA,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">  /// OUTCHAIN = EH_RETURN(INCHAIN, OFFSET, HANDLER) - This node represents</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">  /// OUTCHAIN = EH_RETURN(INCHAIN, OFFSET, HANDLER) - This node represents</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">  /// 'eh_return' gcc dwarf builtin, which is used to return from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">  /// 'eh_return' gcc dwarf builtin, which is used to return from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">  /// exception. The general meaning is: adjust stack by OFFSET and pass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">  /// exception. The general meaning is: adjust stack by OFFSET and pass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">  /// execution to HANDLER. Many platform-related details also :)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">  /// execution to HANDLER. Many platform-related details also :)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">  EH_RETURN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">  EH_RETURN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">  /// RESULT, OUTCHAIN = EH_SJLJ_SETJMP(INCHAIN, buffer)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">  /// RESULT, OUTCHAIN = EH_SJLJ_SETJMP(INCHAIN, buffer)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">  /// This corresponds to the eh.sjlj.setjmp intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">  /// This corresponds to the eh.sjlj.setjmp intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">  /// It takes an input chain and a pointer to the jump buffer as inputs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">  /// It takes an input chain and a pointer to the jump buffer as inputs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">  /// and returns an outchain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">  /// and returns an outchain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">  EH_SJLJ_SETJMP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">  EH_SJLJ_SETJMP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">  /// OUTCHAIN = EH_SJLJ_LONGJMP(INCHAIN, buffer)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">  /// OUTCHAIN = EH_SJLJ_LONGJMP(INCHAIN, buffer)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  /// This corresponds to the eh.sjlj.longjmp intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  /// This corresponds to the eh.sjlj.longjmp intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">  /// It takes an input chain and a pointer to the jump buffer as inputs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">  /// It takes an input chain and a pointer to the jump buffer as inputs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">  /// and returns an outchain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">  /// and returns an outchain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  EH_SJLJ_LONGJMP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  EH_SJLJ_LONGJMP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">  /// OUTCHAIN = EH_SJLJ_SETUP_DISPATCH(INCHAIN)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">  /// OUTCHAIN = EH_SJLJ_SETUP_DISPATCH(INCHAIN)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">  /// The target initializes the dispatch table here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">  /// The target initializes the dispatch table here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">  EH_SJLJ_SETUP_DISPATCH,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">  EH_SJLJ_SETUP_DISPATCH,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">  /// TargetConstant* - Like Constant*, but the DAG does not do any folding,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">  /// TargetConstant* - Like Constant*, but the DAG does not do any folding,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">  /// simplification, or lowering of the constant. They are used for constants</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">  /// simplification, or lowering of the constant. They are used for constants</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">  /// which are known to fit in the immediate fields of their users, or for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">  /// which are known to fit in the immediate fields of their users, or for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">  /// carrying magic numbers which are not values which need to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">  /// carrying magic numbers which are not values which need to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  /// materialized in registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  /// materialized in registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">  TargetConstant,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">  TargetConstant,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">  TargetConstantFP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">  TargetConstantFP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">  /// TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">  /// TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">  /// anything else with this node, and this is valid in the target-specific</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">  /// anything else with this node, and this is valid in the target-specific</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">  /// dag, turning into a GlobalAddress operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">  /// dag, turning into a GlobalAddress operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  TargetGlobalAddress,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  TargetGlobalAddress,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">  TargetGlobalTLSAddress,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">  TargetGlobalTLSAddress,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">  TargetFrameIndex,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">  TargetFrameIndex,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">  TargetJumpTable,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">  TargetJumpTable,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">  TargetConstantPool,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">  TargetConstantPool,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  TargetExternalSymbol,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  TargetExternalSymbol,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">  TargetBlockAddress,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">  TargetBlockAddress,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  MCSymbol,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  MCSymbol,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  /// TargetIndex - Like a constant pool entry, but with completely</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  /// TargetIndex - Like a constant pool entry, but with completely</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">  /// target-dependent semantics. Holds target flags, a 32-bit index, and a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">  /// target-dependent semantics. Holds target flags, a 32-bit index, and a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">  /// 64-bit index. Targets can use this however they like.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">  /// 64-bit index. Targets can use this however they like.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">  TargetIndex,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">  TargetIndex,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  /// RESULT = INTRINSIC_WO_CHAIN(INTRINSICID, arg1, arg2, ...)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  /// RESULT = INTRINSIC_WO_CHAIN(INTRINSICID, arg1, arg2, ...)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">  /// This node represents a target intrinsic function with no side effects.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">  /// This node represents a target intrinsic function with no side effects.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">  /// The first operand is the ID number of the intrinsic from the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">  /// The first operand is the ID number of the intrinsic from the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">  /// llvm::Intrinsic namespace.  The operands to the intrinsic follow.  The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">  /// llvm::Intrinsic namespace.  The operands to the intrinsic follow.  The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  /// node returns the result of the intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  /// node returns the result of the intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">  INTRINSIC_WO_CHAIN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">  INTRINSIC_WO_CHAIN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">  /// RESULT,OUTCHAIN = INTRINSIC_W_CHAIN(INCHAIN, INTRINSICID, arg1, ...)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">  /// RESULT,OUTCHAIN = INTRINSIC_W_CHAIN(INCHAIN, INTRINSICID, arg1, ...)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">  /// This node represents a target intrinsic function with side effects that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">  /// This node represents a target intrinsic function with side effects that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">  /// returns a result.  The first operand is a chain pointer.  The second is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">  /// returns a result.  The first operand is a chain pointer.  The second is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  /// the ID number of the intrinsic from the llvm::Intrinsic namespace.  The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  /// the ID number of the intrinsic from the llvm::Intrinsic namespace.  The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  /// operands to the intrinsic follow.  The node has two results, the result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  /// operands to the intrinsic follow.  The node has two results, the result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  /// of the intrinsic and an output chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  /// of the intrinsic and an output chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">  INTRINSIC_W_CHAIN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">  INTRINSIC_W_CHAIN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">  /// OUTCHAIN = INTRINSIC_VOID(INCHAIN, INTRINSICID, arg1, arg2, ...)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">  /// OUTCHAIN = INTRINSIC_VOID(INCHAIN, INTRINSICID, arg1, arg2, ...)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">  /// This node represents a target intrinsic function with side effects that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">  /// This node represents a target intrinsic function with side effects that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">  /// does not return a result.  The first operand is a chain pointer.  The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">  /// does not return a result.  The first operand is a chain pointer.  The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  /// second is the ID number of the intrinsic from the llvm::Intrinsic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  /// second is the ID number of the intrinsic from the llvm::Intrinsic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">  /// namespace.  The operands to the intrinsic follow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">  /// namespace.  The operands to the intrinsic follow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">  INTRINSIC_VOID,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">  INTRINSIC_VOID,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">  /// CopyToReg - This node has three operands: a chain, a register number to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">  /// CopyToReg - This node has three operands: a chain, a register number to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">  /// set to this value, and a value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">  /// set to this value, and a value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">  CopyToReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">  CopyToReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  /// CopyFromReg - This node indicates that the input value is a virtual or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  /// CopyFromReg - This node indicates that the input value is a virtual or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  /// physical register that is defined outside of the scope of this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  /// physical register that is defined outside of the scope of this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">  /// SelectionDAG.  The register is available from the RegisterSDNode object.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">  /// SelectionDAG.  The register is available from the RegisterSDNode object.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  CopyFromReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  CopyFromReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">  /// UNDEF - An undefined node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">  /// UNDEF - An undefined node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  UNDEF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  UNDEF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  // FREEZE - FREEZE(VAL) returns an arbitrary value if VAL is UNDEF (or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  // FREEZE - FREEZE(VAL) returns an arbitrary value if VAL is UNDEF (or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">  // is evaluated to UNDEF), or returns VAL otherwise. Note that each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">  // is evaluated to UNDEF), or returns VAL otherwise. Note that each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">  // read of UNDEF can yield different value, but FREEZE(UNDEF) cannot.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">  // read of UNDEF can yield different value, but FREEZE(UNDEF) cannot.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">  FREEZE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">  FREEZE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">  /// EXTRACT_ELEMENT - This is used to get the lower or upper (determined by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">  /// EXTRACT_ELEMENT - This is used to get the lower or upper (determined by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  /// a Constant, which is required to be operand #1) half of the integer or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  /// a Constant, which is required to be operand #1) half of the integer or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">  /// float value specified as operand #0.  This is only for use before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">  /// float value specified as operand #0.  This is only for use before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">  /// legalization, for values that will be broken into multiple registers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">  /// legalization, for values that will be broken into multiple registers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">  EXTRACT_ELEMENT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">  EXTRACT_ELEMENT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">  /// BUILD_PAIR - This is the opposite of EXTRACT_ELEMENT in some ways.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">  /// BUILD_PAIR - This is the opposite of EXTRACT_ELEMENT in some ways.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">  /// Given two values of the same integer value type, this produces a value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">  /// Given two values of the same integer value type, this produces a value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">  /// twice as big.  Like EXTRACT_ELEMENT, this can only be used before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">  /// twice as big.  Like EXTRACT_ELEMENT, this can only be used before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">  /// legalization. The lower part of the composite value should be in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">  /// legalization. The lower part of the composite value should be in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">  /// element 0 and the upper part should be in element 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">  /// element 0 and the upper part should be in element 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">  BUILD_PAIR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">  BUILD_PAIR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  /// MERGE_VALUES - This node takes multiple discrete operands and returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  /// MERGE_VALUES - This node takes multiple discrete operands and returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">  /// them all as its individual results.  This nodes has exactly the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">  /// them all as its individual results.  This nodes has exactly the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  /// number of inputs and outputs. This node is useful for some pieces of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  /// number of inputs and outputs. This node is useful for some pieces of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">  /// code generator that want to think about a single node with multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">  /// code generator that want to think about a single node with multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  /// results, not multiple nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  /// results, not multiple nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">  MERGE_VALUES,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">  MERGE_VALUES,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  /// Simple integer binary arithmetic operators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  /// Simple integer binary arithmetic operators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  ADD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  ADD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  SUB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  SUB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  MUL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  MUL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  SDIV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  SDIV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  UDIV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  UDIV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  SREM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  SREM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">  UREM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">  UREM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">  /// SMUL_LOHI/UMUL_LOHI - Multiply two integers of type iN, producing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">  /// SMUL_LOHI/UMUL_LOHI - Multiply two integers of type iN, producing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">  /// a signed/unsigned value of type i[2*N], and return the full value as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">  /// a signed/unsigned value of type i[2*N], and return the full value as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  /// two results, each of type iN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  /// two results, each of type iN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  SMUL_LOHI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  SMUL_LOHI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">  UMUL_LOHI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">  UMUL_LOHI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  /// SDIVREM/UDIVREM - Divide two integers and produce both a quotient and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  /// SDIVREM/UDIVREM - Divide two integers and produce both a quotient and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  /// remainder result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  /// remainder result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  SDIVREM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  SDIVREM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">  UDIVREM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">  UDIVREM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">  /// CARRY_FALSE - This node is used when folding other nodes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">  /// CARRY_FALSE - This node is used when folding other nodes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">  /// like ADDC/SUBC, which indicate the carry result is always false.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">  /// like ADDC/SUBC, which indicate the carry result is always false.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">  CARRY_FALSE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">  CARRY_FALSE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  /// Carry-setting nodes for multiple precision addition and subtraction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  /// Carry-setting nodes for multiple precision addition and subtraction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">  /// These nodes take two operands of the same value type, and produce two</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">  /// These nodes take two operands of the same value type, and produce two</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  /// results.  The first result is the normal add or sub result, the second</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  /// results.  The first result is the normal add or sub result, the second</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  /// result is the carry flag result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  /// result is the carry flag result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  /// FIXME: These nodes are deprecated in favor of UADDO_CARRY and USUBO_CARRY.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  /// FIXME: These nodes are deprecated in favor of UADDO_CARRY and USUBO_CARRY.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  /// They are kept around for now to provide a smooth transition path</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  /// They are kept around for now to provide a smooth transition path</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">  /// toward the use of UADDO_CARRY/USUBO_CARRY and will eventually be removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">  /// toward the use of UADDO_CARRY/USUBO_CARRY and will eventually be removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  ADDC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  ADDC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">  SUBC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">  SUBC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  /// Carry-using nodes for multiple precision addition and subtraction. These</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  /// Carry-using nodes for multiple precision addition and subtraction. These</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">  /// nodes take three operands: The first two are the normal lhs and rhs to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">  /// nodes take three operands: The first two are the normal lhs and rhs to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  /// the add or sub, and the third is the input carry flag.  These nodes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  /// the add or sub, and the third is the input carry flag.  These nodes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">  /// produce two results; the normal result of the add or sub, and the output</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  /// produce two results; the normal result of the add or sub, and the output</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  /// carry flag.  These nodes both read and write a carry flag to allow them</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  /// carry flag.  These nodes both read and write a carry flag to allow them</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">  /// to them to be chained together for add and sub of arbitrarily large</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">  /// to them to be chained together for add and sub of arbitrarily large</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">  /// values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">  /// values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">  ADDE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">  ADDE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  SUBE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  SUBE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">  /// Carry-using nodes for multiple precision addition and subtraction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">  /// Carry-using nodes for multiple precision addition and subtraction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">  /// These nodes take three operands: The first two are the normal lhs and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">  /// These nodes take three operands: The first two are the normal lhs and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  /// rhs to the add or sub, and the third is a boolean value that is 1 if and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  /// rhs to the add or sub, and the third is a boolean value that is 1 if and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  /// only if there is an incoming carry/borrow. These nodes produce two</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  /// only if there is an incoming carry/borrow. These nodes produce two</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">  /// results: the normal result of the add or sub, and a boolean value that is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">  /// results: the normal result of the add or sub, and a boolean value that is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  /// 1 if and only if there is an outgoing carry/borrow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  /// 1 if and only if there is an outgoing carry/borrow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">  /// Care must be taken if these opcodes are lowered to hardware instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">  /// Care must be taken if these opcodes are lowered to hardware instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">  /// that use the inverse logic -- 0 if and only if there is an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">  /// that use the inverse logic -- 0 if and only if there is an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  /// incoming/outgoing carry/borrow.  In such cases, you must preserve the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  /// incoming/outgoing carry/borrow.  In such cases, you must preserve the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">  /// semantics of these opcodes by inverting the incoming carry/borrow, feeding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">  /// semantics of these opcodes by inverting the incoming carry/borrow, feeding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  /// it to the add/sub hardware instruction, and then inverting the outgoing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  /// it to the add/sub hardware instruction, and then inverting the outgoing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  /// carry/borrow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  /// carry/borrow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">  /// The use of these opcodes is preferable to adde/sube if the target supports</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">  /// The use of these opcodes is preferable to adde/sube if the target supports</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">  /// it, as the carry is a regular value rather than a glue, which allows</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">  /// it, as the carry is a regular value rather than a glue, which allows</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  /// further optimisation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  /// further optimisation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">  /// These opcodes are different from [US]{ADD,SUB}O in that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">  /// These opcodes are different from [US]{ADD,SUB}O in that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  /// U{ADD,SUB}O_CARRY consume and produce a carry/borrow, whereas</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  /// U{ADD,SUB}O_CARRY consume and produce a carry/borrow, whereas</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  /// [US]{ADD,SUB}O produce an overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  /// [US]{ADD,SUB}O produce an overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">  UADDO_CARRY,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">  UADDO_CARRY,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">  USUBO_CARRY,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">  USUBO_CARRY,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">  /// Carry-using overflow-aware nodes for multiple precision addition and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">  /// Carry-using overflow-aware nodes for multiple precision addition and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  /// subtraction. These nodes take three operands: The first two are normal lhs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  /// subtraction. These nodes take three operands: The first two are normal lhs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">  /// and rhs to the add or sub, and the third is a boolean indicating if there</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">  /// and rhs to the add or sub, and the third is a boolean indicating if there</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  /// is an incoming carry. They produce two results: the normal result of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  /// is an incoming carry. They produce two results: the normal result of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">  /// add or sub, and a boolean that indicates if an overflow occurred (*not*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">  /// add or sub, and a boolean that indicates if an overflow occurred (*not*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">  /// flag, because it may be a store to memory, etc.). If the type of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">  /// flag, because it may be a store to memory, etc.). If the type of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">  /// boolean is not i1 then the high bits conform to getBooleanContents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">  /// boolean is not i1 then the high bits conform to getBooleanContents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">  SADDO_CARRY,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">  SADDO_CARRY,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">  SSUBO_CARRY,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">  SSUBO_CARRY,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">  /// RESULT, BOOL = [SU]ADDO(LHS, RHS) - Overflow-aware nodes for addition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">  /// RESULT, BOOL = [SU]ADDO(LHS, RHS) - Overflow-aware nodes for addition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">  /// These nodes take two operands: the normal LHS and RHS to the add. They</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">  /// These nodes take two operands: the normal LHS and RHS to the add. They</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">  /// produce two results: the normal result of the add, and a boolean that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">  /// produce two results: the normal result of the add, and a boolean that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">  /// indicates if an overflow occurred (*not* a flag, because it may be store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">  /// indicates if an overflow occurred (*not* a flag, because it may be store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">  /// to memory, etc.).  If the type of the boolean is not i1 then the high</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">  /// to memory, etc.).  If the type of the boolean is not i1 then the high</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">  /// bits conform to getBooleanContents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">  /// bits conform to getBooleanContents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">  /// These nodes are generated from llvm.[su]add.with.overflow intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">  /// These nodes are generated from llvm.[su]add.with.overflow intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">  SADDO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">  SADDO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">  UADDO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">  UADDO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">  /// Same for subtraction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">  /// Same for subtraction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">  SSUBO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">  SSUBO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">  USUBO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">  USUBO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  /// Same for multiplication.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  /// Same for multiplication.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">  SMULO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">  SMULO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">  UMULO,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">  UMULO,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">  /// RESULT = [US]ADDSAT(LHS, RHS) - Perform saturation addition on 2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">  /// RESULT = [US]ADDSAT(LHS, RHS) - Perform saturation addition on 2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">  /// integers with the same bit width (W). If the true value of LHS + RHS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">  /// integers with the same bit width (W). If the true value of LHS + RHS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">  /// exceeds the largest value that can be represented by W bits, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">  /// exceeds the largest value that can be represented by W bits, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">  /// resulting value is this maximum value. Otherwise, if this value is less</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">  /// resulting value is this maximum value. Otherwise, if this value is less</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">  /// than the smallest value that can be represented by W bits, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">  /// than the smallest value that can be represented by W bits, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">  /// resulting value is this minimum value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">  /// resulting value is this minimum value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">  SADDSAT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">  SADDSAT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">  UADDSAT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">  UADDSAT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">  /// RESULT = [US]SUBSAT(LHS, RHS) - Perform saturation subtraction on 2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">  /// RESULT = [US]SUBSAT(LHS, RHS) - Perform saturation subtraction on 2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">  /// integers with the same bit width (W). If the true value of LHS - RHS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">  /// integers with the same bit width (W). If the true value of LHS - RHS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  /// exceeds the largest value that can be represented by W bits, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  /// exceeds the largest value that can be represented by W bits, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">  /// resulting value is this maximum value. Otherwise, if this value is less</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">  /// resulting value is this maximum value. Otherwise, if this value is less</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">  /// than the smallest value that can be represented by W bits, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">  /// than the smallest value that can be represented by W bits, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">  /// resulting value is this minimum value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">  /// resulting value is this minimum value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">  SSUBSAT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">  SSUBSAT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">  USUBSAT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">  USUBSAT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">  /// RESULT = [US]SHLSAT(LHS, RHS) - Perform saturation left shift. The first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">  /// RESULT = [US]SHLSAT(LHS, RHS) - Perform saturation left shift. The first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">  /// operand is the value to be shifted, and the second argument is the amount</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">  /// operand is the value to be shifted, and the second argument is the amount</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">  /// to shift by. Both must be integers of the same bit width (W). If the true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">  /// to shift by. Both must be integers of the same bit width (W). If the true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">  /// value of LHS << RHS exceeds the largest value that can be represented by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">  /// value of LHS << RHS exceeds the largest value that can be represented by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  /// W bits, the resulting value is this maximum value, Otherwise, if this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  /// W bits, the resulting value is this maximum value, Otherwise, if this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">  /// value is less than the smallest value that can be represented by W bits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">  /// value is less than the smallest value that can be represented by W bits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">  /// the resulting value is this minimum value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">  /// the resulting value is this minimum value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">  SSHLSAT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">  SSHLSAT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">  USHLSAT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">  USHLSAT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">  /// RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">  /// RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">  /// on 2 integers with the same width and scale. SCALE represents the scale</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">  /// on 2 integers with the same width and scale. SCALE represents the scale</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">  /// of both operands as fixed point numbers. This SCALE parameter must be a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">  /// of both operands as fixed point numbers. This SCALE parameter must be a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">  /// constant integer. A scale of zero is effectively performing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">  /// constant integer. A scale of zero is effectively performing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">  /// multiplication on 2 integers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">  /// multiplication on 2 integers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">  SMULFIX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">  SMULFIX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">  UMULFIX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">  UMULFIX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">  /// Same as the corresponding unsaturated fixed point instructions, but the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">  /// Same as the corresponding unsaturated fixed point instructions, but the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  /// result is clamped between the min and max values representable by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  /// result is clamped between the min and max values representable by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">  /// bits of the first 2 operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">  /// bits of the first 2 operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">  SMULFIXSAT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">  SMULFIXSAT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">  UMULFIXSAT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">  UMULFIXSAT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">  /// RESULT = [US]DIVFIX(LHS, RHS, SCALE) - Perform fixed point division on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">  /// RESULT = [US]DIVFIX(LHS, RHS, SCALE) - Perform fixed point division on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">  /// 2 integers with the same width and scale. SCALE represents the scale</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">  /// 2 integers with the same width and scale. SCALE represents the scale</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">  /// of both operands as fixed point numbers. This SCALE parameter must be a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">  /// of both operands as fixed point numbers. This SCALE parameter must be a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  /// constant integer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  /// constant integer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">  SDIVFIX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">  SDIVFIX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">  UDIVFIX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">  UDIVFIX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  /// Same as the corresponding unsaturated fixed point instructions, but the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  /// Same as the corresponding unsaturated fixed point instructions, but the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">  /// result is clamped between the min and max values representable by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">  /// result is clamped between the min and max values representable by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  /// bits of the first 2 operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  /// bits of the first 2 operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">  SDIVFIXSAT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">  SDIVFIXSAT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">  UDIVFIXSAT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">  UDIVFIXSAT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">  /// Simple binary floating point operators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">  /// Simple binary floating point operators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">  FADD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">  FADD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">  FSUB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">  FSUB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">  FMUL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">  FMUL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  FDIV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  FDIV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  FREM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  FREM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  /// Constrained versions of the binary floating point operators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  /// Constrained versions of the binary floating point operators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">  /// These will be lowered to the simple operators before final selection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">  /// These will be lowered to the simple operators before final selection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">  /// They are used to limit optimizations while the DAG is being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">  /// They are used to limit optimizations while the DAG is being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">  /// optimized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">  /// optimized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">  STRICT_FADD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">  STRICT_FADD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">  STRICT_FSUB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">  STRICT_FSUB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  STRICT_FMUL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  STRICT_FMUL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">  STRICT_FDIV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">  STRICT_FDIV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  STRICT_FREM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  STRICT_FREM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">  STRICT_FMA,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">  STRICT_FMA,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">  /// Constrained versions of libm-equivalent floating point intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">  /// Constrained versions of libm-equivalent floating point intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">  /// These will be lowered to the equivalent non-constrained pseudo-op</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">  /// These will be lowered to the equivalent non-constrained pseudo-op</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">  /// (or expanded to the equivalent library call) before final selection.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">  /// (or expanded to the equivalent library call) before final selection.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">  /// They are used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">  /// They are used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">  STRICT_FSQRT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">  STRICT_FSQRT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  STRICT_FPOW,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  STRICT_FPOW,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">  STRICT_FPOWI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">  STRICT_FPOWI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">  STRICT_FLDEXP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">  STRICT_FLDEXP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">  STRICT_FSIN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">  STRICT_FSIN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">  STRICT_FCOS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">  STRICT_FCOS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">  STRICT_FEXP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">  STRICT_FEXP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">  STRICT_FEXP2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">  STRICT_FEXP2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">  STRICT_FLOG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">  STRICT_FLOG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">  STRICT_FLOG10,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">  STRICT_FLOG10,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">  STRICT_FLOG2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">  STRICT_FLOG2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  STRICT_FRINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  STRICT_FRINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">  STRICT_FNEARBYINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">  STRICT_FNEARBYINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  STRICT_FMAXNUM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  STRICT_FMAXNUM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  STRICT_FMINNUM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  STRICT_FMINNUM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  STRICT_FCEIL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  STRICT_FCEIL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  STRICT_FFLOOR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  STRICT_FFLOOR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  STRICT_FROUND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  STRICT_FROUND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">  STRICT_FROUNDEVEN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">  STRICT_FROUNDEVEN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  STRICT_FTRUNC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  STRICT_FTRUNC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">  STRICT_LROUND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">  STRICT_LROUND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  STRICT_LLROUND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  STRICT_LLROUND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">  STRICT_LRINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">  STRICT_LRINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">  STRICT_LLRINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">  STRICT_LLRINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  STRICT_FMAXIMUM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  STRICT_FMAXIMUM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">  STRICT_FMINIMUM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">  STRICT_FMINIMUM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">  /// STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">  /// STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">  /// unsigned integer. These have the same semantics as fptosi and fptoui</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">  /// unsigned integer. These have the same semantics as fptosi and fptoui</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">  /// in IR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">  /// in IR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">  /// They are used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">  /// They are used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">  STRICT_FP_TO_SINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">  STRICT_FP_TO_SINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">  STRICT_FP_TO_UINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">  STRICT_FP_TO_UINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">  /// STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">  /// STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">  /// a floating point value. These have the same semantics as sitofp and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">  /// a floating point value. These have the same semantics as sitofp and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">  /// uitofp in IR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">  /// uitofp in IR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">  /// They are used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">  /// They are used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">  STRICT_SINT_TO_FP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">  STRICT_SINT_TO_FP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">  STRICT_UINT_TO_FP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">  STRICT_UINT_TO_FP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">  /// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">  /// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  /// point type down to the precision of the destination VT.  TRUNC is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  /// point type down to the precision of the destination VT.  TRUNC is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">  /// flag, which is always an integer that is zero or one.  If TRUNC is 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">  /// flag, which is always an integer that is zero or one.  If TRUNC is 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  /// this is a normal rounding, if it is 1, this FP_ROUND is known to not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  /// this is a normal rounding, if it is 1, this FP_ROUND is known to not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">  /// change the value of Y.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">  /// change the value of Y.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">  /// The TRUNC = 1 case is used in cases where we know that the value will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">  /// The TRUNC = 1 case is used in cases where we know that the value will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">  /// not be modified by the node, because Y is not using any of the extra</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">  /// not be modified by the node, because Y is not using any of the extra</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">  /// precision of source type.  This allows certain transformations like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">  /// precision of source type.  This allows certain transformations like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">  /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">  /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">  /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">  /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">  /// removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">  /// removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  /// It is used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  /// It is used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  STRICT_FP_ROUND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  STRICT_FP_ROUND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  /// X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  /// X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">  /// type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">  /// type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">  /// It is used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">  /// It is used to limit optimizations while the DAG is being optimized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">  STRICT_FP_EXTEND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">  STRICT_FP_EXTEND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  /// STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  /// STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  /// for floating-point operands only.  STRICT_FSETCC performs a quiet</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  /// for floating-point operands only.  STRICT_FSETCC performs a quiet</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  /// comparison operation, while STRICT_FSETCCS performs a signaling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  /// comparison operation, while STRICT_FSETCCS performs a signaling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  /// comparison operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  /// comparison operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  STRICT_FSETCC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  STRICT_FSETCC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  STRICT_FSETCCS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  STRICT_FSETCCS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  // FPTRUNC_ROUND - This corresponds to the fptrunc_round intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  // FPTRUNC_ROUND - This corresponds to the fptrunc_round intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">  FPTRUNC_ROUND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">  FPTRUNC_ROUND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">  /// FMA - Perform a * b + c with no intermediate rounding step.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">  /// FMA - Perform a * b + c with no intermediate rounding step.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">  FMA,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">  FMA,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">  /// FMAD - Perform a * b + c, while getting the same result as the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">  /// FMAD - Perform a * b + c, while getting the same result as the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  /// separately rounded operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  /// separately rounded operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  FMAD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  FMAD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">  /// FCOPYSIGN(X, Y) - Return the value of X with the sign of Y.  NOTE: This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">  /// FCOPYSIGN(X, Y) - Return the value of X with the sign of Y.  NOTE: This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">  /// DAG node does not require that X and Y have the same type, just that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">  /// DAG node does not require that X and Y have the same type, just that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  /// they are both floating point.  X and the result must have the same type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  /// they are both floating point.  X and the result must have the same type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">  /// FCOPYSIGN(f32, f64) is allowed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">  /// FCOPYSIGN(f32, f64) is allowed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  FCOPYSIGN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  FCOPYSIGN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">  /// INT = FGETSIGN(FP) - Return the sign bit of the specified floating point</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">  /// INT = FGETSIGN(FP) - Return the sign bit of the specified floating point</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  /// value as an integer 0/1 value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  /// value as an integer 0/1 value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">  FGETSIGN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">  FGETSIGN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">  /// Returns platform specific canonical encoding of a floating point number.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">  /// Returns platform specific canonical encoding of a floating point number.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">  FCANONICALIZE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">  FCANONICALIZE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">  /// Performs a check of floating point class property, defined by IEEE-754.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">  /// Performs a check of floating point class property, defined by IEEE-754.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">  /// The first operand is the floating point value to check. The second operand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">  /// The first operand is the floating point value to check. The second operand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">  /// specifies the checked property and is a TargetConstant which specifies</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">  /// specifies the checked property and is a TargetConstant which specifies</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">  /// test in the same way as intrinsic 'is_fpclass'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">  /// test in the same way as intrinsic 'is_fpclass'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">  /// Returns boolean value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">  /// Returns boolean value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">  IS_FPCLASS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">  IS_FPCLASS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  /// BUILD_VECTOR(ELT0, ELT1, ELT2, ELT3,...) - Return a fixed-width vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  /// BUILD_VECTOR(ELT0, ELT1, ELT2, ELT3,...) - Return a fixed-width vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">  /// with the specified, possibly variable, elements. The types of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">  /// with the specified, possibly variable, elements. The types of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">  /// operands must match the vector element type, except that integer types</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">  /// operands must match the vector element type, except that integer types</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  /// are allowed to be larger than the element type, in which case the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  /// are allowed to be larger than the element type, in which case the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">  /// operands are implicitly truncated. The types of the operands must all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">  /// operands are implicitly truncated. The types of the operands must all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">  /// be the same.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">  /// be the same.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">  BUILD_VECTOR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">  BUILD_VECTOR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">  /// INSERT_VECTOR_ELT(VECTOR, VAL, IDX) - Returns VECTOR with the element</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">  /// INSERT_VECTOR_ELT(VECTOR, VAL, IDX) - Returns VECTOR with the element</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">  /// at IDX replaced with VAL. If the type of VAL is larger than the vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">  /// at IDX replaced with VAL. If the type of VAL is larger than the vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  /// element type then VAL is truncated before replacement.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  /// element type then VAL is truncated before replacement.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">  /// If VECTOR is a scalable vector, then IDX may be larger than the minimum</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">  /// If VECTOR is a scalable vector, then IDX may be larger than the minimum</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">  /// vector width. IDX is not first scaled by the runtime scaling factor of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">  /// vector width. IDX is not first scaled by the runtime scaling factor of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  /// VECTOR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  /// VECTOR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">  INSERT_VECTOR_ELT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">  INSERT_VECTOR_ELT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">  /// EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">  /// EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  /// identified by the (potentially variable) element number IDX. If the return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  /// identified by the (potentially variable) element number IDX. If the return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">  /// type is an integer type larger than the element type of the vector, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">  /// type is an integer type larger than the element type of the vector, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">  /// result is extended to the width of the return type. In that case, the high</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">  /// result is extended to the width of the return type. In that case, the high</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  /// bits are undefined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  /// bits are undefined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">  /// If VECTOR is a scalable vector, then IDX may be larger than the minimum</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">  /// If VECTOR is a scalable vector, then IDX may be larger than the minimum</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">  /// vector width. IDX is not first scaled by the runtime scaling factor of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">  /// vector width. IDX is not first scaled by the runtime scaling factor of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">  /// VECTOR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">  /// VECTOR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">  EXTRACT_VECTOR_ELT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">  EXTRACT_VECTOR_ELT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  /// CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  /// CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">  /// vector type with the same length and element type, this produces a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">  /// vector type with the same length and element type, this produces a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  /// concatenated vector result value, with length equal to the sum of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  /// concatenated vector result value, with length equal to the sum of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">  /// lengths of the input vectors. If VECTOR0 is a fixed-width vector, then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">  /// lengths of the input vectors. If VECTOR0 is a fixed-width vector, then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  /// VECTOR1..VECTORN must all be fixed-width vectors. Similarly, if VECTOR0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  /// VECTOR1..VECTORN must all be fixed-width vectors. Similarly, if VECTOR0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">  /// is a scalable vector, then VECTOR1..VECTORN must all be scalable vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">  /// is a scalable vector, then VECTOR1..VECTORN must all be scalable vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">  CONCAT_VECTORS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">  CONCAT_VECTORS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">  /// INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX) - Returns a vector with VECTOR2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">  /// INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX) - Returns a vector with VECTOR2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">  /// inserted into VECTOR1. IDX represents the starting element number at which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">  /// inserted into VECTOR1. IDX represents the starting element number at which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  /// VECTOR2 will be inserted. IDX must be a constant multiple of T's known</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  /// VECTOR2 will be inserted. IDX must be a constant multiple of T's known</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  /// minimum vector length. Let the type of VECTOR2 be T, then if T is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  /// minimum vector length. Let the type of VECTOR2 be T, then if T is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">  /// scalable vector, IDX is first scaled by the runtime scaling factor of T.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">  /// scalable vector, IDX is first scaled by the runtime scaling factor of T.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">  /// The elements of VECTOR1 starting at IDX are overwritten with VECTOR2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">  /// The elements of VECTOR1 starting at IDX are overwritten with VECTOR2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">  /// Elements IDX through (IDX + num_elements(T) - 1) must be valid VECTOR1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">  /// Elements IDX through (IDX + num_elements(T) - 1) must be valid VECTOR1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">  /// indices. If this condition cannot be determined statically but is false at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">  /// indices. If this condition cannot be determined statically but is false at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">  /// runtime, then the result vector is undefined. The IDX parameter must be a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">  /// runtime, then the result vector is undefined. The IDX parameter must be a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">  /// vector index constant type, which for most targets will be an integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">  /// vector index constant type, which for most targets will be an integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">  /// pointer type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">  /// pointer type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">  /// This operation supports inserting a fixed-width vector into a scalable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">  /// This operation supports inserting a fixed-width vector into a scalable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">  /// vector, but not the other way around.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">  /// vector, but not the other way around.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">  INSERT_SUBVECTOR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">  INSERT_SUBVECTOR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">  /// EXTRACT_SUBVECTOR(VECTOR, IDX) - Returns a subvector from VECTOR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">  /// EXTRACT_SUBVECTOR(VECTOR, IDX) - Returns a subvector from VECTOR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">  /// Let the result type be T, then IDX represents the starting element number</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">  /// Let the result type be T, then IDX represents the starting element number</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">  /// from which a subvector of type T is extracted. IDX must be a constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">  /// from which a subvector of type T is extracted. IDX must be a constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">  /// multiple of T's known minimum vector length. If T is a scalable vector,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">  /// multiple of T's known minimum vector length. If T is a scalable vector,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">  /// IDX is first scaled by the runtime scaling factor of T. Elements IDX</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">  /// IDX is first scaled by the runtime scaling factor of T. Elements IDX</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">  /// through (IDX + num_elements(T) - 1) must be valid VECTOR indices. If this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">  /// through (IDX + num_elements(T) - 1) must be valid VECTOR indices. If this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">  /// condition cannot be determined statically but is false at runtime, then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">  /// condition cannot be determined statically but is false at runtime, then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">  /// the result vector is undefined. The IDX parameter must be a vector index</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">  /// the result vector is undefined. The IDX parameter must be a vector index</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">  /// constant type, which for most targets will be an integer pointer type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">  /// constant type, which for most targets will be an integer pointer type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">  /// This operation supports extracting a fixed-width vector from a scalable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">  /// This operation supports extracting a fixed-width vector from a scalable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">  /// vector, but not the other way around.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">  /// vector, but not the other way around.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">  EXTRACT_SUBVECTOR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">  EXTRACT_SUBVECTOR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">  /// VECTOR_DEINTERLEAVE(VEC1, VEC2) - Returns two vectors with all input and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">  /// VECTOR_DEINTERLEAVE(VEC1, VEC2) - Returns two vectors with all input and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  /// output vectors having the same type. The first output contains the even</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  /// output vectors having the same type. The first output contains the even</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  /// indices from CONCAT_VECTORS(VEC1, VEC2), with the second output</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  /// indices from CONCAT_VECTORS(VEC1, VEC2), with the second output</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">  /// containing the odd indices. The relative order of elements within an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">  /// containing the odd indices. The relative order of elements within an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">  /// output match that of the concatenated input.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">  /// output match that of the concatenated input.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">  VECTOR_DEINTERLEAVE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">  VECTOR_DEINTERLEAVE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">  /// VECTOR_INTERLEAVE(VEC1, VEC2) - Returns two vectors with all input and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">  /// VECTOR_INTERLEAVE(VEC1, VEC2) - Returns two vectors with all input and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">  /// output vectors having the same type. The first output contains the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">  /// output vectors having the same type. The first output contains the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">  /// result of interleaving the low half of CONCAT_VECTORS(VEC1, VEC2), with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">  /// result of interleaving the low half of CONCAT_VECTORS(VEC1, VEC2), with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  /// the second output containing the result of interleaving the high half.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  /// the second output containing the result of interleaving the high half.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">  VECTOR_INTERLEAVE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">  VECTOR_INTERLEAVE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">  /// VECTOR_REVERSE(VECTOR) - Returns a vector, of the same type as VECTOR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">  /// VECTOR_REVERSE(VECTOR) - Returns a vector, of the same type as VECTOR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">  /// whose elements are shuffled using the following algorithm:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">  /// whose elements are shuffled using the following algorithm:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">  ///   RESULT[i] = VECTOR[VECTOR.ElementCount - 1 - i]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">  ///   RESULT[i] = VECTOR[VECTOR.ElementCount - 1 - i]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">  VECTOR_REVERSE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">  VECTOR_REVERSE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">  /// VECTOR_SHUFFLE(VEC1, VEC2) - Returns a vector, of the same type as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">  /// VECTOR_SHUFFLE(VEC1, VEC2) - Returns a vector, of the same type as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">  /// VEC1/VEC2.  A VECTOR_SHUFFLE node also contains an array of constant int</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">  /// VEC1/VEC2.  A VECTOR_SHUFFLE node also contains an array of constant int</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">  /// values that indicate which value (or undef) each result element will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">  /// values that indicate which value (or undef) each result element will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  /// get.  These constant ints are accessible through the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  /// get.  These constant ints are accessible through the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">  /// ShuffleVectorSDNode class.  This is quite similar to the Altivec</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">  /// ShuffleVectorSDNode class.  This is quite similar to the Altivec</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">  /// 'vperm' instruction, except that the indices must be constants and are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">  /// 'vperm' instruction, except that the indices must be constants and are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  /// in terms of the element size of VEC1/VEC2, not in terms of bytes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  /// in terms of the element size of VEC1/VEC2, not in terms of bytes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">  VECTOR_SHUFFLE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">  VECTOR_SHUFFLE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">  /// VECTOR_SPLICE(VEC1, VEC2, IMM) - Returns a subvector of the same type as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">  /// VECTOR_SPLICE(VEC1, VEC2, IMM) - Returns a subvector of the same type as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">  /// VEC1/VEC2 from CONCAT_VECTORS(VEC1, VEC2), based on the IMM in two ways.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">  /// VEC1/VEC2 from CONCAT_VECTORS(VEC1, VEC2), based on the IMM in two ways.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  /// Let the result type be T, if IMM is positive it represents the starting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  /// Let the result type be T, if IMM is positive it represents the starting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">  /// element number (an index) from which a subvector of type T is extracted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">  /// element number (an index) from which a subvector of type T is extracted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">  /// from CONCAT_VECTORS(VEC1, VEC2). If IMM is negative it represents a count</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">  /// from CONCAT_VECTORS(VEC1, VEC2). If IMM is negative it represents a count</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">  /// specifying the number of trailing elements to extract from VEC1, where the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">  /// specifying the number of trailing elements to extract from VEC1, where the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">  /// elements of T are selected using the following algorithm:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">  /// elements of T are selected using the following algorithm:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">  ///   RESULT[i] = CONCAT_VECTORS(VEC1,VEC2)[VEC1.ElementCount - ABS(IMM) + i]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">  ///   RESULT[i] = CONCAT_VECTORS(VEC1,VEC2)[VEC1.ElementCount - ABS(IMM) + i]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">  /// If IMM is not in the range [-VL, VL-1] the result vector is undefined. IMM</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">  /// If IMM is not in the range [-VL, VL-1] the result vector is undefined. IMM</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">  /// is a constant integer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">  /// is a constant integer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">  VECTOR_SPLICE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">  VECTOR_SPLICE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">  /// SCALAR_TO_VECTOR(VAL) - This represents the operation of loading a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">  /// SCALAR_TO_VECTOR(VAL) - This represents the operation of loading a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  /// scalar value into element 0 of the resultant vector type.  The top</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  /// scalar value into element 0 of the resultant vector type.  The top</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  /// elements 1 to N-1 of the N-element vector are undefined.  The type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  /// elements 1 to N-1 of the N-element vector are undefined.  The type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">  /// of the operand must match the vector element type, except when they</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">  /// of the operand must match the vector element type, except when they</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">  /// are integer types.  In this case the operand is allowed to be wider</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">  /// are integer types.  In this case the operand is allowed to be wider</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  /// than the vector element type, and is implicitly truncated to it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  /// than the vector element type, and is implicitly truncated to it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">  SCALAR_TO_VECTOR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">  SCALAR_TO_VECTOR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">  /// SPLAT_VECTOR(VAL) - Returns a vector with the scalar value VAL</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">  /// SPLAT_VECTOR(VAL) - Returns a vector with the scalar value VAL</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  /// duplicated in all lanes. The type of the operand must match the vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  /// duplicated in all lanes. The type of the operand must match the vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  /// element type, except when they are integer types.  In this case the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  /// element type, except when they are integer types.  In this case the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  /// operand is allowed to be wider than the vector element type, and is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  /// operand is allowed to be wider than the vector element type, and is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  /// implicitly truncated to it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  /// implicitly truncated to it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">  SPLAT_VECTOR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">  SPLAT_VECTOR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">  /// SPLAT_VECTOR_PARTS(SCALAR1, SCALAR2, ...) - Returns a vector with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">  /// SPLAT_VECTOR_PARTS(SCALAR1, SCALAR2, ...) - Returns a vector with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">  /// scalar values joined together and then duplicated in all lanes. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">  /// scalar values joined together and then duplicated in all lanes. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">  /// represents a SPLAT_VECTOR that has had its scalar operand expanded. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">  /// represents a SPLAT_VECTOR that has had its scalar operand expanded. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  /// allows representing a 64-bit splat on a target with 32-bit integers. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  /// allows representing a 64-bit splat on a target with 32-bit integers. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  /// total width of the scalars must cover the element width. SCALAR1 contains</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  /// total width of the scalars must cover the element width. SCALAR1 contains</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  /// the least significant bits of the value regardless of endianness and all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  /// the least significant bits of the value regardless of endianness and all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">  /// scalars should have the same type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">  /// scalars should have the same type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">  SPLAT_VECTOR_PARTS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">  SPLAT_VECTOR_PARTS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">  /// STEP_VECTOR(IMM) - Returns a scalable vector whose lanes are comprised</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">  /// STEP_VECTOR(IMM) - Returns a scalable vector whose lanes are comprised</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">  /// of a linear sequence of unsigned values starting from 0 with a step of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">  /// of a linear sequence of unsigned values starting from 0 with a step of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">  /// IMM, where IMM must be a TargetConstant with type equal to the vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">  /// IMM, where IMM must be a TargetConstant with type equal to the vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">  /// element type. The arithmetic is performed modulo the bitwidth of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">  /// element type. The arithmetic is performed modulo the bitwidth of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">  /// element.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">  /// element.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">  /// The operation does not support returning fixed-width vectors or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">  /// The operation does not support returning fixed-width vectors or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  /// non-constant operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  /// non-constant operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">  STEP_VECTOR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">  STEP_VECTOR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">  /// MULHU/MULHS - Multiply high - Multiply two integers of type iN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">  /// MULHU/MULHS - Multiply high - Multiply two integers of type iN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  /// producing an unsigned/signed value of type i[2*N], then return the top</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  /// producing an unsigned/signed value of type i[2*N], then return the top</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">  /// part.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">  /// part.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  MULHU,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  MULHU,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">  MULHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">  MULHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  /// AVGFLOORS/AVGFLOORU - Averaging add - Add two integers using an integer of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  /// AVGFLOORS/AVGFLOORU - Averaging add - Add two integers using an integer of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">  /// type i[N+1], halving the result by shifting it one bit right.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">  /// type i[N+1], halving the result by shifting it one bit right.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  /// shr(add(ext(X), ext(Y)), 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  /// shr(add(ext(X), ext(Y)), 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">  AVGFLOORS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">  AVGFLOORS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  AVGFLOORU,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  AVGFLOORU,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">  /// AVGCEILS/AVGCEILU - Rounding averaging add - Add two integers using an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">  /// AVGCEILS/AVGCEILU - Rounding averaging add - Add two integers using an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  /// integer of type i[N+2], add 1 and halve the result by shifting it one bit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  /// integer of type i[N+2], add 1 and halve the result by shifting it one bit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">  /// right. shr(add(ext(X), ext(Y), 1), 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">  /// right. shr(add(ext(X), ext(Y), 1), 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  AVGCEILS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  AVGCEILS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">  AVGCEILU,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">  AVGCEILU,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">  // ABDS/ABDU - Absolute difference - Return the absolute difference between</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">  // ABDS/ABDU - Absolute difference - Return the absolute difference between</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  // two numbers interpreted as signed/unsigned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  // two numbers interpreted as signed/unsigned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  // i.e trunc(abs(sext(Op0) - sext(Op1))) becomes abds(Op0, Op1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  // i.e trunc(abs(sext(Op0) - sext(Op1))) becomes abds(Op0, Op1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">  //  or trunc(abs(zext(Op0) - zext(Op1))) becomes abdu(Op0, Op1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">  //  or trunc(abs(zext(Op0) - zext(Op1))) becomes abdu(Op0, Op1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">  ABDS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">  ABDS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">  ABDU,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">  ABDU,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">  /// [US]{MIN/MAX} - Binary minimum or maximum of signed or unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">  /// [US]{MIN/MAX} - Binary minimum or maximum of signed or unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  /// integers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  /// integers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  SMIN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  SMIN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">  SMAX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">  SMAX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">  UMIN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">  UMIN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">  UMAX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">  UMAX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  /// Bitwise operators - logical and, logical or, logical xor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  /// Bitwise operators - logical and, logical or, logical xor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">  AND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">  AND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">  OR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">  OR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">  XOR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">  XOR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  /// ABS - Determine the unsigned absolute value of a signed integer value of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  /// ABS - Determine the unsigned absolute value of a signed integer value of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">  /// the same bitwidth.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">  /// the same bitwidth.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  /// Note: A value of INT_MIN will return INT_MIN, no saturation or overflow</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  /// Note: A value of INT_MIN will return INT_MIN, no saturation or overflow</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">  /// is performed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">  /// is performed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  ABS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  ABS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  /// Shift and rotation operations.  After legalization, the type of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  /// Shift and rotation operations.  After legalization, the type of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">  /// shift amount is known to be TLI.getShiftAmountTy().  Before legalization</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">  /// shift amount is known to be TLI.getShiftAmountTy().  Before legalization</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  /// the shift amount can be any type, but care must be taken to ensure it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  /// the shift amount can be any type, but care must be taken to ensure it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  /// large enough.  TLI.getShiftAmountTy() is i8 on some targets, but before</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  /// large enough.  TLI.getShiftAmountTy() is i8 on some targets, but before</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  /// legalization, types like i1024 can occur and i8 doesn't have enough bits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  /// legalization, types like i1024 can occur and i8 doesn't have enough bits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">  /// to represent the shift amount.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">  /// to represent the shift amount.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">  /// When the 1st operand is a vector, the shift amount must be in the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">  /// When the 1st operand is a vector, the shift amount must be in the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">  /// type. (TLI.getShiftAmountTy() will return the same type when the input</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">  /// type. (TLI.getShiftAmountTy() will return the same type when the input</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  /// type is a vector.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  /// type is a vector.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  /// For rotates and funnel shifts, the shift amount is treated as an unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  /// For rotates and funnel shifts, the shift amount is treated as an unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  /// amount modulo the element size of the first operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  /// amount modulo the element size of the first operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">  /// Funnel 'double' shifts take 3 operands, 2 inputs and the shift amount.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">  /// Funnel 'double' shifts take 3 operands, 2 inputs and the shift amount.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">  /// fshl(X,Y,Z): (X << (Z % BW)) | (Y >> (BW - (Z % BW)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">  /// fshl(X,Y,Z): (X << (Z % BW)) | (Y >> (BW - (Z % BW)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">  /// fshr(X,Y,Z): (X << (BW - (Z % BW))) | (Y >> (Z % BW))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">  /// fshr(X,Y,Z): (X << (BW - (Z % BW))) | (Y >> (Z % BW))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">  SHL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">  SHL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">  SRA,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">  SRA,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">  SRL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">  SRL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">  ROTL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">  ROTL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">  ROTR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">  ROTR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">  FSHL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">  FSHL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">  FSHR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">  FSHR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">  /// Byte Swap and Counting operators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">  /// Byte Swap and Counting operators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  BSWAP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  BSWAP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">  CTTZ,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">  CTTZ,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  CTLZ,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  CTLZ,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">  CTPOP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">  CTPOP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">  BITREVERSE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">  BITREVERSE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">  PARITY,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">  PARITY,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">  /// Bit counting operators with an undefined result for zero inputs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">  /// Bit counting operators with an undefined result for zero inputs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">  CTTZ_ZERO_UNDEF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">  CTTZ_ZERO_UNDEF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">  CTLZ_ZERO_UNDEF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">  CTLZ_ZERO_UNDEF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">  /// Select(COND, TRUEVAL, FALSEVAL).  If the type of the boolean COND is not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">  /// Select(COND, TRUEVAL, FALSEVAL).  If the type of the boolean COND is not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">  /// i1 then the high bits must conform to getBooleanContents.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">  /// i1 then the high bits must conform to getBooleanContents.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">  SELECT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">  SELECT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">  /// Select with a vector condition (op #0) and two vector operands (ops #1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">  /// Select with a vector condition (op #0) and two vector operands (ops #1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">  /// and #2), returning a vector result.  All vectors have the same length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">  /// and #2), returning a vector result.  All vectors have the same length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">  /// Much like the scalar select and setcc, each bit in the condition selects</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">  /// Much like the scalar select and setcc, each bit in the condition selects</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">  /// whether the corresponding result element is taken from op #1 or op #2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">  /// whether the corresponding result element is taken from op #1 or op #2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">  /// At first, the VSELECT condition is of vXi1 type. Later, targets may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">  /// At first, the VSELECT condition is of vXi1 type. Later, targets may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">  /// change the condition type in order to match the VSELECT node using a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">  /// change the condition type in order to match the VSELECT node using a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">  /// pattern. The condition follows the BooleanContent format of the target.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">  /// pattern. The condition follows the BooleanContent format of the target.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">  VSELECT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">  VSELECT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  /// Select with condition operator - This selects between a true value and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  /// Select with condition operator - This selects between a true value and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">  /// a false value (ops #2 and #3) based on the boolean result of comparing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">  /// a false value (ops #2 and #3) based on the boolean result of comparing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">  /// the lhs and rhs (ops #0 and #1) of a conditional expression with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">  /// the lhs and rhs (ops #0 and #1) of a conditional expression with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">  /// condition code in op #4, a CondCodeSDNode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">  /// condition code in op #4, a CondCodeSDNode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">  SELECT_CC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">  SELECT_CC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">  /// SetCC operator - This evaluates to a true value iff the condition is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">  /// SetCC operator - This evaluates to a true value iff the condition is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">  /// true.  If the result value type is not i1 then the high bits conform</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">  /// true.  If the result value type is not i1 then the high bits conform</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  /// to getBooleanContents.  The operands to this are the left and right</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  /// to getBooleanContents.  The operands to this are the left and right</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">  /// operands to compare (ops #0, and #1) and the condition code to compare</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">  /// operands to compare (ops #0, and #1) and the condition code to compare</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">  /// them with (op #2) as a CondCodeSDNode. If the operands are vector types</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">  /// them with (op #2) as a CondCodeSDNode. If the operands are vector types</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">  /// then the result type must also be a vector type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">  /// then the result type must also be a vector type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">  SETCC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">  SETCC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">  /// Like SetCC, ops #0 and #1 are the LHS and RHS operands to compare, but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">  /// Like SetCC, ops #0 and #1 are the LHS and RHS operands to compare, but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">  /// op #2 is a boolean indicating if there is an incoming carry. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">  /// op #2 is a boolean indicating if there is an incoming carry. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">  /// operator checks the result of "LHS - RHS - Carry", and can be used to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">  /// operator checks the result of "LHS - RHS - Carry", and can be used to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">  /// compare two wide integers:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">  /// compare two wide integers:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">  /// (setcccarry lhshi rhshi (usubo_carry lhslo rhslo) cc).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">  /// (setcccarry lhshi rhshi (usubo_carry lhslo rhslo) cc).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">  /// Only valid for integers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">  /// Only valid for integers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">  SETCCCARRY,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">  SETCCCARRY,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">  /// SHL_PARTS/SRA_PARTS/SRL_PARTS - These operators are used for expanded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">  /// SHL_PARTS/SRA_PARTS/SRL_PARTS - These operators are used for expanded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">  /// integer shift operations.  The operation ordering is:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">  /// integer shift operations.  The operation ordering is:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">  ///       [Lo,Hi] = op [LoLHS,HiLHS], Amt</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">  ///       [Lo,Hi] = op [LoLHS,HiLHS], Amt</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">  SHL_PARTS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">  SHL_PARTS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">  SRA_PARTS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">  SRA_PARTS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">  SRL_PARTS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">  SRL_PARTS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">  /// Conversion operators.  These are all single input single output</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">  /// Conversion operators.  These are all single input single output</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">  /// operations.  For all of these, the result type must be strictly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">  /// operations.  For all of these, the result type must be strictly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">  /// wider or narrower (depending on the operation) than the source</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">  /// wider or narrower (depending on the operation) than the source</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">  /// type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">  /// type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">  /// SIGN_EXTEND - Used for integer types, replicating the sign bit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">  /// SIGN_EXTEND - Used for integer types, replicating the sign bit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">  /// into new bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">  /// into new bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">  SIGN_EXTEND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">  SIGN_EXTEND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">  /// ZERO_EXTEND - Used for integer types, zeroing the new bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">  /// ZERO_EXTEND - Used for integer types, zeroing the new bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">  ZERO_EXTEND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">  ZERO_EXTEND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">  /// ANY_EXTEND - Used for integer types.  The high bits are undefined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">  /// ANY_EXTEND - Used for integer types.  The high bits are undefined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">  ANY_EXTEND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">  ANY_EXTEND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">  /// TRUNCATE - Completely drop the high bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">  /// TRUNCATE - Completely drop the high bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">  TRUNCATE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">  TRUNCATE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">  /// [SU]INT_TO_FP - These operators convert integers (whose interpreted sign</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">  /// [SU]INT_TO_FP - These operators convert integers (whose interpreted sign</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">  /// depends on the first letter) to floating point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">  /// depends on the first letter) to floating point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">  SINT_TO_FP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">  SINT_TO_FP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">  UINT_TO_FP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">  UINT_TO_FP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">  /// SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">  /// SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">  /// sign extend a small value in a large integer register (e.g. sign</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">  /// sign extend a small value in a large integer register (e.g. sign</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">  /// extending the low 8 bits of a 32-bit register to fill the top 24 bits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">  /// extending the low 8 bits of a 32-bit register to fill the top 24 bits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">  /// with the 7th bit).  The size of the smaller type is indicated by the 1th</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">  /// with the 7th bit).  The size of the smaller type is indicated by the 1th</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">  /// operand, a ValueType node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">  /// operand, a ValueType node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">  SIGN_EXTEND_INREG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">  SIGN_EXTEND_INREG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">  /// ANY_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">  /// ANY_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">  /// in-register any-extension of the low lanes of an integer vector. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">  /// in-register any-extension of the low lanes of an integer vector. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">  /// result type must have fewer elements than the operand type, and those</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">  /// result type must have fewer elements than the operand type, and those</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">  /// elements must be larger integer types such that the total size of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">  /// elements must be larger integer types such that the total size of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">  /// operand type is less than or equal to the size of the result type. Each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">  /// operand type is less than or equal to the size of the result type. Each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">  /// of the low operand elements is any-extended into the corresponding,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">  /// of the low operand elements is any-extended into the corresponding,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">  /// wider result elements with the high bits becoming undef.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">  /// wider result elements with the high bits becoming undef.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">  /// the same to allow expansion to shuffle vector during op legalization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">  /// the same to allow expansion to shuffle vector during op legalization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">  ANY_EXTEND_VECTOR_INREG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">  ANY_EXTEND_VECTOR_INREG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  /// SIGN_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  /// SIGN_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">  /// in-register sign-extension of the low lanes of an integer vector. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">  /// in-register sign-extension of the low lanes of an integer vector. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">  /// result type must have fewer elements than the operand type, and those</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">  /// result type must have fewer elements than the operand type, and those</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  /// elements must be larger integer types such that the total size of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  /// elements must be larger integer types such that the total size of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">  /// operand type is less than or equal to the size of the result type. Each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">  /// operand type is less than or equal to the size of the result type. Each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">  /// of the low operand elements is sign-extended into the corresponding,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">  /// of the low operand elements is sign-extended into the corresponding,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">  /// wider result elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">  /// wider result elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">  /// the same to allow expansion to shuffle vector during op legalization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">  /// the same to allow expansion to shuffle vector during op legalization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  SIGN_EXTEND_VECTOR_INREG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  SIGN_EXTEND_VECTOR_INREG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">  /// ZERO_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">  /// ZERO_EXTEND_VECTOR_INREG(Vector) - This operator represents an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  /// in-register zero-extension of the low lanes of an integer vector. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  /// in-register zero-extension of the low lanes of an integer vector. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  /// result type must have fewer elements than the operand type, and those</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  /// result type must have fewer elements than the operand type, and those</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">  /// elements must be larger integer types such that the total size of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">  /// elements must be larger integer types such that the total size of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">  /// operand type is less than or equal to the size of the result type. Each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">  /// operand type is less than or equal to the size of the result type. Each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">  /// of the low operand elements is zero-extended into the corresponding,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">  /// of the low operand elements is zero-extended into the corresponding,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">  /// wider result elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">  /// wider result elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">  /// NOTE: The type legalizer prefers to make the operand and result size</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">  /// the same to allow expansion to shuffle vector during op legalization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">  /// the same to allow expansion to shuffle vector during op legalization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">  ZERO_EXTEND_VECTOR_INREG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">  ZERO_EXTEND_VECTOR_INREG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">  /// FP_TO_[US]INT - Convert a floating point value to a signed or unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">  /// FP_TO_[US]INT - Convert a floating point value to a signed or unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  /// integer. These have the same semantics as fptosi and fptoui in IR. If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  /// integer. These have the same semantics as fptosi and fptoui in IR. If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">  /// the FP value cannot fit in the integer type, the results are undefined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">  /// the FP value cannot fit in the integer type, the results are undefined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">  FP_TO_SINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">  FP_TO_SINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">  FP_TO_UINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">  FP_TO_UINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">  /// FP_TO_[US]INT_SAT - Convert floating point value in operand 0 to a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">  /// FP_TO_[US]INT_SAT - Convert floating point value in operand 0 to a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">  /// signed or unsigned scalar integer type given in operand 1 with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">  /// signed or unsigned scalar integer type given in operand 1 with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">  /// following semantics:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">  /// following semantics:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">  ///  * If the value is NaN, zero is returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">  ///  * If the value is NaN, zero is returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">  ///  * If the value is larger/smaller than the largest/smallest integer,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">  ///  * If the value is larger/smaller than the largest/smallest integer,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">  ///    the largest/smallest integer is returned (saturation).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">  ///    the largest/smallest integer is returned (saturation).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">  ///  * Otherwise the result of rounding the value towards zero is returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">  ///  * Otherwise the result of rounding the value towards zero is returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">  /// The scalar width of the type given in operand 1 must be equal to, or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">  /// The scalar width of the type given in operand 1 must be equal to, or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">  /// smaller than, the scalar result type width. It may end up being smaller</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">  /// smaller than, the scalar result type width. It may end up being smaller</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  /// than the result width as a result of integer type legalization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  /// than the result width as a result of integer type legalization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">  /// After converting to the scalar integer type in operand 1, the value is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">  /// After converting to the scalar integer type in operand 1, the value is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">  /// extended to the result VT. FP_TO_SINT_SAT sign extends and FP_TO_UINT_SAT</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">  /// extended to the result VT. FP_TO_SINT_SAT sign extends and FP_TO_UINT_SAT</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">  /// zero extends.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">  /// zero extends.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">  FP_TO_SINT_SAT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">  FP_TO_SINT_SAT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">  FP_TO_UINT_SAT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">  FP_TO_UINT_SAT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">  /// X = FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating point type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">  /// X = FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating point type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">  /// down to the precision of the destination VT.  TRUNC is a flag, which is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">  /// down to the precision of the destination VT.  TRUNC is a flag, which is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">  /// always an integer that is zero or one.  If TRUNC is 0, this is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">  /// always an integer that is zero or one.  If TRUNC is 0, this is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">  /// normal rounding, if it is 1, this FP_ROUND is known to not change the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">  /// normal rounding, if it is 1, this FP_ROUND is known to not change the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">  /// value of Y.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">  /// value of Y.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">  /// The TRUNC = 1 case is used in cases where we know that the value will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">  /// The TRUNC = 1 case is used in cases where we know that the value will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">  /// not be modified by the node, because Y is not using any of the extra</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">  /// not be modified by the node, because Y is not using any of the extra</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">  /// precision of source type.  This allows certain transformations like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">  /// precision of source type.  This allows certain transformations like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">  /// FP_EXTEND(FP_ROUND(X,1)) -> X which are not safe for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">  /// FP_EXTEND(FP_ROUND(X,1)) -> X which are not safe for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">  /// FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren't removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">  /// FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren't removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">  FP_ROUND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">  FP_ROUND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">  /// Returns current rounding mode:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">  /// Returns current rounding mode:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">  /// -1 Undefined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">  /// -1 Undefined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  ///  0 Round to 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  ///  0 Round to 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">  ///  1 Round to nearest, ties to even</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">  ///  1 Round to nearest, ties to even</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">  ///  2 Round to +inf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">  ///  2 Round to +inf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">  ///  3 Round to -inf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">  ///  3 Round to -inf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">  ///  4 Round to nearest, ties to zero</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">  ///  4 Round to nearest, ties to zero</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  /// Result is rounding mode and chain. Input is a chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  /// Result is rounding mode and chain. Input is a chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  GET_ROUNDING,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  GET_ROUNDING,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">  /// Set rounding mode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">  /// Set rounding mode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">  /// The first operand is a chain pointer. The second specifies the required</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">  /// The first operand is a chain pointer. The second specifies the required</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">  /// rounding mode, encoded in the same way as used in '``GET_ROUNDING``'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">  /// rounding mode, encoded in the same way as used in '``GET_ROUNDING``'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">  SET_ROUNDING,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">  SET_ROUNDING,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">  /// X = FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">  /// X = FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">  FP_EXTEND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">  FP_EXTEND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">  /// BITCAST - This operator converts between integer, vector and FP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">  /// BITCAST - This operator converts between integer, vector and FP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">  /// values, as if the value was stored to memory with one type and loaded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">  /// values, as if the value was stored to memory with one type and loaded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">  /// from the same address with the other type (or equivalently for vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">  /// from the same address with the other type (or equivalently for vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">  /// format conversions, etc).  The source and result are required to have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">  /// format conversions, etc).  The source and result are required to have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">  /// the same bit size (e.g.  f32 <-> i32).  This can also be used for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">  /// the same bit size (e.g.  f32 <-> i32).  This can also be used for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">  /// int-to-int or fp-to-fp conversions, but that is a noop, deleted by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">  /// int-to-int or fp-to-fp conversions, but that is a noop, deleted by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">  /// getNode().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">  /// getNode().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">  /// This operator is subtly different from the bitcast instruction from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">  /// This operator is subtly different from the bitcast instruction from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">  /// LLVM-IR since this node may change the bits in the register. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">  /// LLVM-IR since this node may change the bits in the register. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">  /// example, this occurs on big-endian NEON and big-endian MSA where the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">  /// example, this occurs on big-endian NEON and big-endian MSA where the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">  /// layout of the bits in the register depends on the vector type and this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">  /// layout of the bits in the register depends on the vector type and this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">  /// operator acts as a shuffle operation for some vector type combinations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">  /// operator acts as a shuffle operation for some vector type combinations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">  BITCAST,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">  BITCAST,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">  /// ADDRSPACECAST - This operator converts between pointers of different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">  /// ADDRSPACECAST - This operator converts between pointers of different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">  /// address spaces.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">  /// address spaces.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">  ADDRSPACECAST,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">  ADDRSPACECAST,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">  /// FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">  /// FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">  /// and truncation for half-precision (16 bit) floating numbers. These nodes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">  /// and truncation for half-precision (16 bit) floating numbers. These nodes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">  /// form a semi-softened interface for dealing with f16 (as an i16), which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">  /// form a semi-softened interface for dealing with f16 (as an i16), which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">  /// is often a storage-only type but has native conversions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">  /// is often a storage-only type but has native conversions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">  FP16_TO_FP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">  FP16_TO_FP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">  FP_TO_FP16,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">  FP_TO_FP16,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">  STRICT_FP16_TO_FP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">  STRICT_FP16_TO_FP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">  STRICT_FP_TO_FP16,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">  STRICT_FP_TO_FP16,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">  /// BF16_TO_FP, FP_TO_BF16 - These operators are used to perform promotions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">  /// BF16_TO_FP, FP_TO_BF16 - These operators are used to perform promotions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">  /// and truncation for bfloat16. These nodes form a semi-softened interface</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">  /// and truncation for bfloat16. These nodes form a semi-softened interface</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">  /// for dealing with bf16 (as an i16), which is often a storage-only type but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">  /// for dealing with bf16 (as an i16), which is often a storage-only type but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">  /// has native conversions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">  /// has native conversions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">  BF16_TO_FP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">  BF16_TO_FP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">  FP_TO_BF16,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">  FP_TO_BF16,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">  /// Perform various unary floating-point operations inspired by libm. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">  /// Perform various unary floating-point operations inspired by libm. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">  /// FPOWI, the result is undefined if if the integer operand doesn't fit into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">  /// FPOWI, the result is undefined if if the integer operand doesn't fit into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">  /// sizeof(int).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">  /// sizeof(int).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">  FNEG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">  FNEG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">  FABS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">  FABS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">  FSQRT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">  FSQRT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">  FCBRT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">  FCBRT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">  FSIN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">  FSIN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">  FCOS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">  FCOS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">  FPOW,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">  FPOW,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">  FPOWI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">  FPOWI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">  /// FLDEXP - ldexp, inspired by libm (op0 * 2**op1).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">  /// FLDEXP - ldexp, inspired by libm (op0 * 2**op1).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">  FLDEXP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">  FLDEXP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">  /// FFREXP - frexp, extract fractional and exponent component of a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">  /// FFREXP - frexp, extract fractional and exponent component of a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">  /// floating-point value. Returns the two components as separate return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">  /// floating-point value. Returns the two components as separate return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">  /// values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">  /// values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">  FFREXP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">  FFREXP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">  FLOG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">  FLOG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">  FLOG2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">  FLOG2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">  FLOG10,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">  FLOG10,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">  FEXP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">  FEXP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">  FEXP2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">  FEXP2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">  FCEIL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">  FCEIL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">  FTRUNC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">  FTRUNC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">  FRINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">  FRINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">  FNEARBYINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">  FNEARBYINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">  FROUND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">  FROUND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">  FROUNDEVEN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">  FROUNDEVEN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">  FFLOOR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">  FFLOOR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">  LROUND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">  LROUND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">  LLROUND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">  LLROUND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">  LRINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">  LRINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">  LLRINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">  LLRINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">  /// FMINNUM/FMAXNUM - Perform floating-point minimum or maximum on two</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">  /// FMINNUM/FMAXNUM - Perform floating-point minimum or maximum on two</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">  /// values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">  /// values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">  /// In the case where a single input is a NaN (either signaling or quiet),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">  /// In the case where a single input is a NaN (either signaling or quiet),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">  /// the non-NaN input is returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">  /// the non-NaN input is returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">  /// The return value of (FMINNUM 0.0, -0.0) could be either 0.0 or -0.0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">  /// The return value of (FMINNUM 0.0, -0.0) could be either 0.0 or -0.0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">  FMINNUM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">  FMINNUM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">  FMAXNUM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">  FMAXNUM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">  /// FMINNUM_IEEE/FMAXNUM_IEEE - Perform floating-point minimum or maximum on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">  /// FMINNUM_IEEE/FMAXNUM_IEEE - Perform floating-point minimum or maximum on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">  /// two values, following the IEEE-754 2008 definition. This differs from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">  /// two values, following the IEEE-754 2008 definition. This differs from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">  /// FMINNUM/FMAXNUM in the handling of signaling NaNs. If one input is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">  /// FMINNUM/FMAXNUM in the handling of signaling NaNs. If one input is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">  /// signaling NaN, returns a quiet NaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">  /// signaling NaN, returns a quiet NaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">  FMINNUM_IEEE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">  FMINNUM_IEEE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">  FMAXNUM_IEEE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">  FMAXNUM_IEEE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">  /// FMINIMUM/FMAXIMUM - NaN-propagating minimum/maximum that also treat -0.0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">  /// FMINIMUM/FMAXIMUM - NaN-propagating minimum/maximum that also treat -0.0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">  /// as less than 0.0. While FMINNUM_IEEE/FMAXNUM_IEEE follow IEEE 754-2008</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">  /// as less than 0.0. While FMINNUM_IEEE/FMAXNUM_IEEE follow IEEE 754-2008</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">  /// semantics, FMINIMUM/FMAXIMUM follow IEEE 754-2018 draft semantics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">  /// semantics, FMINIMUM/FMAXIMUM follow IEEE 754-2018 draft semantics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">  FMINIMUM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">  FMINIMUM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">  FMAXIMUM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">  FMAXIMUM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">  /// FSINCOS - Compute both fsin and fcos as a single operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">  /// FSINCOS - Compute both fsin and fcos as a single operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">  FSINCOS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">  FSINCOS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">  /// Gets the current floating-point environment. The first operand is a token</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">  /// Gets the current floating-point environment. The first operand is a token</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">  /// chain. The results are FP environment, represented by an integer value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">  /// chain. The results are FP environment, represented by an integer value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">  /// and a token chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">  /// and a token chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">  GET_FPENV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">  GET_FPENV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">  /// Sets the current floating-point environment. The first operand is a token</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">  /// Sets the current floating-point environment. The first operand is a token</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  /// chain, the second is FP environment, represented by an integer value. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  /// chain, the second is FP environment, represented by an integer value. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">  /// result is a token chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">  /// result is a token chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">  SET_FPENV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">  SET_FPENV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">  /// Set floating-point environment to default state. The first operand and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">  /// Set floating-point environment to default state. The first operand and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">  /// result are token chains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">  /// result are token chains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">  RESET_FPENV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">  RESET_FPENV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">  /// Gets the current floating-point environment. The first operand is a token</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">  /// Gets the current floating-point environment. The first operand is a token</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  /// chain, the second is a pointer to memory, where FP environment is stored</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  /// chain, the second is a pointer to memory, where FP environment is stored</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">  /// to. The result is a token chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">  /// to. The result is a token chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">  GET_FPENV_MEM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">  GET_FPENV_MEM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">  /// Sets the current floating point environment. The first operand is a token</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">  /// Sets the current floating point environment. The first operand is a token</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">  /// chain, the second is a pointer to memory, where FP environment is loaded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">  /// chain, the second is a pointer to memory, where FP environment is loaded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">  /// from. The result is a token chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">  /// from. The result is a token chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">  SET_FPENV_MEM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">  SET_FPENV_MEM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">  /// LOAD and STORE have token chains as their first operand, then the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">  /// LOAD and STORE have token chains as their first operand, then the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">  /// operands as an LLVM load/store instruction, then an offset node that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">  /// operands as an LLVM load/store instruction, then an offset node that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">  /// is added / subtracted from the base pointer to form the address (for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">  /// is added / subtracted from the base pointer to form the address (for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">  /// indexed memory ops).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">  /// indexed memory ops).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">  LOAD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">  LOAD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">  STORE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">  STORE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">  /// DYNAMIC_STACKALLOC - Allocate some number of bytes on the stack aligned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">  /// DYNAMIC_STACKALLOC - Allocate some number of bytes on the stack aligned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">  /// to a specified boundary.  This node always has two return values: a new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">  /// to a specified boundary.  This node always has two return values: a new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">  /// stack pointer value and a chain. The first operand is the token chain,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">  /// stack pointer value and a chain. The first operand is the token chain,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">  /// the second is the number of bytes to allocate, and the third is the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">  /// the second is the number of bytes to allocate, and the third is the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">  /// alignment boundary.  The size is guaranteed to be a multiple of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">  /// alignment boundary.  The size is guaranteed to be a multiple of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">  /// stack alignment, and the alignment is guaranteed to be bigger than the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">  /// stack alignment, and the alignment is guaranteed to be bigger than the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">  /// stack alignment (if required) or 0 to get standard stack alignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">  /// stack alignment (if required) or 0 to get standard stack alignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">  DYNAMIC_STACKALLOC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">  DYNAMIC_STACKALLOC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">  /// Control flow instructions.  These all have token chains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">  /// Control flow instructions.  These all have token chains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">  /// BR - Unconditional branch.  The first operand is the chain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">  /// BR - Unconditional branch.  The first operand is the chain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">  /// operand, the second is the MBB to branch to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">  /// operand, the second is the MBB to branch to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">  BR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">  BR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">  /// BRIND - Indirect branch.  The first operand is the chain, the second</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">  /// BRIND - Indirect branch.  The first operand is the chain, the second</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">  /// is the value to branch to, which must be of the same type as the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">  /// is the value to branch to, which must be of the same type as the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">  /// target's pointer type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">  /// target's pointer type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">  BRIND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">  BRIND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">  /// BR_JT - Jumptable branch. The first operand is the chain, the second</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">  /// BR_JT - Jumptable branch. The first operand is the chain, the second</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">  /// is the jumptable index, the last one is the jumptable entry index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">  /// is the jumptable index, the last one is the jumptable entry index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">  BR_JT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">  BR_JT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">  /// BRCOND - Conditional branch.  The first operand is the chain, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">  /// BRCOND - Conditional branch.  The first operand is the chain, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  /// second is the condition, the third is the block to branch to if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  /// second is the condition, the third is the block to branch to if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">  /// condition is true.  If the type of the condition is not i1, then the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">  /// condition is true.  If the type of the condition is not i1, then the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">  /// high bits must conform to getBooleanContents. If the condition is undef,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">  /// high bits must conform to getBooleanContents. If the condition is undef,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">  /// it nondeterministically jumps to the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">  /// it nondeterministically jumps to the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">  /// TODO: Its semantics w.r.t undef requires further discussion; we need to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">  /// TODO: Its semantics w.r.t undef requires further discussion; we need to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">  /// make it sure that it is consistent with optimizations in MIR & the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">  /// make it sure that it is consistent with optimizations in MIR & the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">  /// meaning of IMPLICIT_DEF. See https://reviews.llvm.org/D92015</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">  /// meaning of IMPLICIT_DEF. See https://reviews.llvm.org/D92015</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">  BRCOND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">  BRCOND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">  /// BR_CC - Conditional branch.  The behavior is like that of SELECT_CC, in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">  /// BR_CC - Conditional branch.  The behavior is like that of SELECT_CC, in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">  /// that the condition is represented as condition code, and two nodes to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">  /// that the condition is represented as condition code, and two nodes to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">  /// compare, rather than as a combined SetCC node.  The operands in order</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">  /// compare, rather than as a combined SetCC node.  The operands in order</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">  /// are chain, cc, lhs, rhs, block to branch to if condition is true. If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">  /// are chain, cc, lhs, rhs, block to branch to if condition is true. If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">  /// condition is undef, it nondeterministically jumps to the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">  /// condition is undef, it nondeterministically jumps to the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">  BR_CC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">  BR_CC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  /// INLINEASM - Represents an inline asm block.  This node always has two</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  /// INLINEASM - Represents an inline asm block.  This node always has two</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">  /// return values: a chain and a flag result.  The inputs are as follows:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">  /// return values: a chain and a flag result.  The inputs are as follows:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">  ///   Operand #0  : Input chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">  ///   Operand #0  : Input chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">  ///   Operand #1  : a ExternalSymbolSDNode with a pointer to the asm string.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">  ///   Operand #1  : a ExternalSymbolSDNode with a pointer to the asm string.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  ///   Operand #2  : a MDNodeSDNode with the !srcloc metadata.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  ///   Operand #2  : a MDNodeSDNode with the !srcloc metadata.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  ///   Operand #3  : HasSideEffect, IsAlignStack bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  ///   Operand #3  : HasSideEffect, IsAlignStack bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">  ///   After this, it is followed by a list of operands with this format:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">  ///   After this, it is followed by a list of operands with this format:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">  ///     ConstantSDNode: Flags that encode whether it is a mem or not, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">  ///     ConstantSDNode: Flags that encode whether it is a mem or not, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">  ///                     of operands that follow, etc.  See InlineAsm.h.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">  ///                     of operands that follow, etc.  See InlineAsm.h.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">  ///     ... however many operands ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">  ///     ... however many operands ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">  ///   Operand #last: Optional, an incoming flag.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">  ///   Operand #last: Optional, an incoming flag.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">  /// The variable width operands are required to represent target addressing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">  /// The variable width operands are required to represent target addressing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">  /// modes as a single "operand", even though they may have multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">  /// modes as a single "operand", even though they may have multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">  /// SDOperands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">  /// SDOperands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">  INLINEASM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">  INLINEASM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">  /// INLINEASM_BR - Branching version of inline asm. Used by asm-goto.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">  /// INLINEASM_BR - Branching version of inline asm. Used by asm-goto.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">  INLINEASM_BR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">  INLINEASM_BR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">  /// EH_LABEL - Represents a label in mid basic block used to track</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">  /// EH_LABEL - Represents a label in mid basic block used to track</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">  /// locations needed for debug and exception handling tables.  These nodes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">  /// locations needed for debug and exception handling tables.  These nodes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">  /// take a chain as input and return a chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">  /// take a chain as input and return a chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">  EH_LABEL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">  EH_LABEL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">  /// ANNOTATION_LABEL - Represents a mid basic block label used by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">  /// ANNOTATION_LABEL - Represents a mid basic block label used by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">  /// annotations. This should remain within the basic block and be ordered</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">  /// annotations. This should remain within the basic block and be ordered</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">  /// with respect to other call instructions, but loads and stores may float</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">  /// with respect to other call instructions, but loads and stores may float</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">  /// past it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">  /// past it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">  ANNOTATION_LABEL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">  ANNOTATION_LABEL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">  /// CATCHRET - Represents a return from a catch block funclet. Used for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">  /// CATCHRET - Represents a return from a catch block funclet. Used for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">  /// MSVC compatible exception handling. Takes a chain operand and a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">  /// MSVC compatible exception handling. Takes a chain operand and a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">  /// destination basic block operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">  /// destination basic block operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">  CATCHRET,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">  CATCHRET,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">  /// CLEANUPRET - Represents a return from a cleanup block funclet.  Used for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">  /// CLEANUPRET - Represents a return from a cleanup block funclet.  Used for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">  /// MSVC compatible exception handling. Takes only a chain operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">  /// MSVC compatible exception handling. Takes only a chain operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">  CLEANUPRET,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">  CLEANUPRET,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">  /// STACKSAVE - STACKSAVE has one operand, an input chain.  It produces a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">  /// STACKSAVE - STACKSAVE has one operand, an input chain.  It produces a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">  /// value, the same type as the pointer type for the system, and an output</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">  /// value, the same type as the pointer type for the system, and an output</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">  /// chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">  /// chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">  STACKSAVE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">  STACKSAVE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">  /// STACKRESTORE has two operands, an input chain and a pointer to restore</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">  /// STACKRESTORE has two operands, an input chain and a pointer to restore</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">  /// to it returns an output chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">  /// to it returns an output chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">  STACKRESTORE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">  STACKRESTORE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">  /// CALLSEQ_START/CALLSEQ_END - These operators mark the beginning and end</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">  /// CALLSEQ_START/CALLSEQ_END - These operators mark the beginning and end</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">  /// of a call sequence, and carry arbitrary information that target might</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">  /// of a call sequence, and carry arbitrary information that target might</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">  /// want to know.  The first operand is a chain, the rest are specified by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">  /// want to know.  The first operand is a chain, the rest are specified by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">  /// the target and not touched by the DAG optimizers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">  /// the target and not touched by the DAG optimizers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">  /// Targets that may use stack to pass call arguments define additional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">  /// Targets that may use stack to pass call arguments define additional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">  /// operands:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">  /// operands:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">  /// - size of the call frame part that must be set up within the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">  /// - size of the call frame part that must be set up within the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">  ///   CALLSEQ_START..CALLSEQ_END pair,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">  ///   CALLSEQ_START..CALLSEQ_END pair,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">  /// - part of the call frame prepared prior to CALLSEQ_START.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">  /// - part of the call frame prepared prior to CALLSEQ_START.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">  /// Both these parameters must be constants, their sum is the total call</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">  /// Both these parameters must be constants, their sum is the total call</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">  /// frame size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">  /// frame size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">  /// CALLSEQ_START..CALLSEQ_END pairs may not be nested.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">  /// CALLSEQ_START..CALLSEQ_END pairs may not be nested.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">  CALLSEQ_START, // Beginning of a call sequence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">  CALLSEQ_START, // Beginning of a call sequence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">  CALLSEQ_END,   // End of a call sequence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">  CALLSEQ_END,   // End of a call sequence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">  /// VAARG - VAARG has four operands: an input chain, a pointer, a SRCVALUE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">  /// VAARG - VAARG has four operands: an input chain, a pointer, a SRCVALUE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">  /// and the alignment. It returns a pair of values: the vaarg value and a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">  /// and the alignment. It returns a pair of values: the vaarg value and a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">  /// new chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">  /// new chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">  VAARG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">  VAARG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">  /// VACOPY - VACOPY has 5 operands: an input chain, a destination pointer,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">  /// VACOPY - VACOPY has 5 operands: an input chain, a destination pointer,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">  /// a source pointer, a SRCVALUE for the destination, and a SRCVALUE for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">  /// a source pointer, a SRCVALUE for the destination, and a SRCVALUE for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">  /// source.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">  /// source.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">  VACOPY,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">  VACOPY,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">  /// VAEND, VASTART - VAEND and VASTART have three operands: an input chain,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">  /// VAEND, VASTART - VAEND and VASTART have three operands: an input chain,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">  /// pointer, and a SRCVALUE.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">  /// pointer, and a SRCVALUE.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">  VAEND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">  VAEND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">  VASTART,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">  VASTART,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">  // PREALLOCATED_SETUP - This has 2 operands: an input chain and a SRCVALUE</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">  // PREALLOCATED_SETUP - This has 2 operands: an input chain and a SRCVALUE</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">  // with the preallocated call Value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">  // with the preallocated call Value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">  PREALLOCATED_SETUP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">  PREALLOCATED_SETUP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">  // PREALLOCATED_ARG - This has 3 operands: an input chain, a SRCVALUE</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">  // PREALLOCATED_ARG - This has 3 operands: an input chain, a SRCVALUE</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">  // with the preallocated call Value, and a constant int.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">  // with the preallocated call Value, and a constant int.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">  PREALLOCATED_ARG,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">  PREALLOCATED_ARG,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">  /// SRCVALUE - This is a node type that holds a Value* that is used to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">  /// SRCVALUE - This is a node type that holds a Value* that is used to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">  /// make reference to a value in the LLVM IR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">  /// make reference to a value in the LLVM IR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">  SRCVALUE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">  SRCVALUE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">  /// MDNODE_SDNODE - This is a node that holdes an MDNode*, which is used to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">  /// MDNODE_SDNODE - This is a node that holdes an MDNode*, which is used to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">  /// reference metadata in the IR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">  /// reference metadata in the IR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">  MDNODE_SDNODE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">  MDNODE_SDNODE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">  /// PCMARKER - This corresponds to the pcmarker intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">  /// PCMARKER - This corresponds to the pcmarker intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">  PCMARKER,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">  PCMARKER,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">  /// READCYCLECOUNTER - This corresponds to the readcyclecounter intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">  /// READCYCLECOUNTER - This corresponds to the readcyclecounter intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">  /// It produces a chain and one i64 value. The only operand is a chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">  /// It produces a chain and one i64 value. The only operand is a chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">  /// If i64 is not legal, the result will be expanded into smaller values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">  /// If i64 is not legal, the result will be expanded into smaller values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">  /// Still, it returns an i64, so targets should set legality for i64.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">  /// Still, it returns an i64, so targets should set legality for i64.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">  /// The result is the content of the architecture-specific cycle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">  /// The result is the content of the architecture-specific cycle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">  /// counter-like register (or other high accuracy low latency clock source).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">  /// counter-like register (or other high accuracy low latency clock source).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">  READCYCLECOUNTER,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">  READCYCLECOUNTER,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">  /// HANDLENODE node - Used as a handle for various purposes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">  /// HANDLENODE node - Used as a handle for various purposes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">  HANDLENODE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">  HANDLENODE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">  /// INIT_TRAMPOLINE - This corresponds to the init_trampoline intrinsic.  It</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">  /// INIT_TRAMPOLINE - This corresponds to the init_trampoline intrinsic.  It</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">  /// takes as input a token chain, the pointer to the trampoline, the pointer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">  /// takes as input a token chain, the pointer to the trampoline, the pointer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">  /// to the nested function, the pointer to pass for the 'nest' parameter, a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">  /// to the nested function, the pointer to pass for the 'nest' parameter, a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">  /// SRCVALUE for the trampoline and another for the nested function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">  /// SRCVALUE for the trampoline and another for the nested function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">  /// (allowing targets to access the original Function*).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">  /// (allowing targets to access the original Function*).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">  /// It produces a token chain as output.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">  /// It produces a token chain as output.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">  INIT_TRAMPOLINE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">  INIT_TRAMPOLINE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">  /// ADJUST_TRAMPOLINE - This corresponds to the adjust_trampoline intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">  /// ADJUST_TRAMPOLINE - This corresponds to the adjust_trampoline intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">  /// It takes a pointer to the trampoline and produces a (possibly) new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">  /// It takes a pointer to the trampoline and produces a (possibly) new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">  /// pointer to the same trampoline with platform-specific adjustments</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">  /// pointer to the same trampoline with platform-specific adjustments</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">  /// applied.  The pointer it returns points to an executable block of code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">  /// applied.  The pointer it returns points to an executable block of code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">  ADJUST_TRAMPOLINE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">  ADJUST_TRAMPOLINE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">  /// TRAP - Trapping instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">  /// TRAP - Trapping instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">  TRAP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">  TRAP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">  /// DEBUGTRAP - Trap intended to get the attention of a debugger.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">  /// DEBUGTRAP - Trap intended to get the attention of a debugger.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">  DEBUGTRAP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">  DEBUGTRAP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">  /// UBSANTRAP - Trap with an immediate describing the kind of sanitizer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">  /// UBSANTRAP - Trap with an immediate describing the kind of sanitizer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">  /// failure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">  /// failure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">  UBSANTRAP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">  UBSANTRAP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">  /// PREFETCH - This corresponds to a prefetch intrinsic. The first operand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">  /// PREFETCH - This corresponds to a prefetch intrinsic. The first operand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">  /// is the chain.  The other operands are the address to prefetch,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">  /// is the chain.  The other operands are the address to prefetch,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">  /// read / write specifier, locality specifier and instruction / data cache</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">  /// read / write specifier, locality specifier and instruction / data cache</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">  /// specifier.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">  /// specifier.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">  PREFETCH,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">  PREFETCH,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">  /// ARITH_FENCE - This corresponds to a arithmetic fence intrinsic. Both its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">  /// ARITH_FENCE - This corresponds to a arithmetic fence intrinsic. Both its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">  /// operand and output are the same floating type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">  /// operand and output are the same floating type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">  ARITH_FENCE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">  ARITH_FENCE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">  /// MEMBARRIER - Compiler barrier only; generate a no-op.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">  /// MEMBARRIER - Compiler barrier only; generate a no-op.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">  MEMBARRIER,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">  MEMBARRIER,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">  /// OUTCHAIN = ATOMIC_FENCE(INCHAIN, ordering, scope)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">  /// OUTCHAIN = ATOMIC_FENCE(INCHAIN, ordering, scope)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">  /// This corresponds to the fence instruction. It takes an input chain, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">  /// This corresponds to the fence instruction. It takes an input chain, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">  /// two integer constants: an AtomicOrdering and a SynchronizationScope.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">  /// two integer constants: an AtomicOrdering and a SynchronizationScope.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">  ATOMIC_FENCE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">  ATOMIC_FENCE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  /// Val, OUTCHAIN = ATOMIC_LOAD(INCHAIN, ptr)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  /// Val, OUTCHAIN = ATOMIC_LOAD(INCHAIN, ptr)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">  /// This corresponds to "load atomic" instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">  /// This corresponds to "load atomic" instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">  ATOMIC_LOAD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">  ATOMIC_LOAD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">  /// OUTCHAIN = ATOMIC_STORE(INCHAIN, ptr, val)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">  /// OUTCHAIN = ATOMIC_STORE(INCHAIN, ptr, val)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">  /// This corresponds to "store atomic" instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">  /// This corresponds to "store atomic" instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">  ATOMIC_STORE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">  ATOMIC_STORE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">  /// Val, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmp, swap)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">  /// Val, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmp, swap)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  /// For double-word atomic operations:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  /// For double-word atomic operations:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmpLo, cmpHi,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmpLo, cmpHi,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">  ///                                          swapLo, swapHi)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">  ///                                          swapLo, swapHi)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">  /// This corresponds to the cmpxchg instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">  /// This corresponds to the cmpxchg instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  ATOMIC_CMP_SWAP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  ATOMIC_CMP_SWAP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">  /// Val, Success, OUTCHAIN</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">  /// Val, Success, OUTCHAIN</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">  ///     = ATOMIC_CMP_SWAP_WITH_SUCCESS(INCHAIN, ptr, cmp, swap)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">  ///     = ATOMIC_CMP_SWAP_WITH_SUCCESS(INCHAIN, ptr, cmp, swap)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">  /// N.b. this is still a strong cmpxchg operation, so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">  /// N.b. this is still a strong cmpxchg operation, so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">  /// Success == "Val == cmp".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">  /// Success == "Val == cmp".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">  ATOMIC_CMP_SWAP_WITH_SUCCESS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">  ATOMIC_CMP_SWAP_WITH_SUCCESS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">  /// Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">  /// Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  /// Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  /// Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">  /// For double-word atomic operations:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">  /// For double-word atomic operations:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  /// ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">  /// These correspond to the atomicrmw instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">  /// These correspond to the atomicrmw instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  ATOMIC_SWAP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  ATOMIC_SWAP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">  ATOMIC_LOAD_ADD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">  ATOMIC_LOAD_ADD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">  ATOMIC_LOAD_SUB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">  ATOMIC_LOAD_SUB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  ATOMIC_LOAD_AND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  ATOMIC_LOAD_AND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">  ATOMIC_LOAD_CLR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">  ATOMIC_LOAD_CLR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  ATOMIC_LOAD_OR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  ATOMIC_LOAD_OR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">  ATOMIC_LOAD_XOR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">  ATOMIC_LOAD_XOR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">  ATOMIC_LOAD_NAND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">  ATOMIC_LOAD_NAND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">  ATOMIC_LOAD_MIN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">  ATOMIC_LOAD_MIN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">  ATOMIC_LOAD_MAX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">  ATOMIC_LOAD_MAX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">  ATOMIC_LOAD_UMIN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">  ATOMIC_LOAD_UMIN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">  ATOMIC_LOAD_UMAX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">  ATOMIC_LOAD_UMAX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">  ATOMIC_LOAD_FADD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">  ATOMIC_LOAD_FADD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">  ATOMIC_LOAD_FSUB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">  ATOMIC_LOAD_FSUB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">  ATOMIC_LOAD_FMAX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">  ATOMIC_LOAD_FMAX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">  ATOMIC_LOAD_FMIN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">  ATOMIC_LOAD_FMIN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">  ATOMIC_LOAD_UINC_WRAP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">  ATOMIC_LOAD_UINC_WRAP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">  ATOMIC_LOAD_UDEC_WRAP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">  ATOMIC_LOAD_UDEC_WRAP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">  // Masked load and store - consecutive vector load and store operations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">  // Masked load and store - consecutive vector load and store operations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">  // with additional mask operand that prevents memory accesses to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">  // with additional mask operand that prevents memory accesses to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">  // masked-off lanes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">  // masked-off lanes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">  // Val, OutChain = MLOAD(BasePtr, Mask, PassThru)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">  // Val, OutChain = MLOAD(BasePtr, Mask, PassThru)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">  // OutChain = MSTORE(Value, BasePtr, Mask)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">  // OutChain = MSTORE(Value, BasePtr, Mask)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">  MLOAD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">  MLOAD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  MSTORE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  MSTORE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">  // Masked gather and scatter - load and store operations for a vector of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">  // Masked gather and scatter - load and store operations for a vector of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">  // random addresses with additional mask operand that prevents memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">  // random addresses with additional mask operand that prevents memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">  // accesses to the masked-off lanes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">  // accesses to the masked-off lanes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">  // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">  // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">  // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">  // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">  // The Index operand can have more vector elements than the other operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">  // The Index operand can have more vector elements than the other operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">  // due to type legalization. The extra elements are ignored.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">  // due to type legalization. The extra elements are ignored.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">  MGATHER,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">  MGATHER,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">  MSCATTER,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">  MSCATTER,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">  /// This corresponds to the llvm.lifetime.* intrinsics. The first operand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">  /// This corresponds to the llvm.lifetime.* intrinsics. The first operand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">  /// is the chain and the second operand is the alloca pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">  /// is the chain and the second operand is the alloca pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  LIFETIME_START,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  LIFETIME_START,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">  LIFETIME_END,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">  LIFETIME_END,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">  /// GC_TRANSITION_START/GC_TRANSITION_END - These operators mark the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">  /// GC_TRANSITION_START/GC_TRANSITION_END - These operators mark the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">  /// beginning and end of GC transition  sequence, and carry arbitrary</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">  /// beginning and end of GC transition  sequence, and carry arbitrary</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">  /// information that target might need for lowering.  The first operand is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">  /// information that target might need for lowering.  The first operand is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">  /// a chain, the rest are specified by the target and not touched by the DAG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">  /// a chain, the rest are specified by the target and not touched by the DAG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">  /// optimizers. GC_TRANSITION_START..GC_TRANSITION_END pairs may not be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">  /// optimizers. GC_TRANSITION_START..GC_TRANSITION_END pairs may not be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">  /// nested.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">  /// nested.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">  GC_TRANSITION_START,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">  GC_TRANSITION_START,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">  GC_TRANSITION_END,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">  GC_TRANSITION_END,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">  /// GET_DYNAMIC_AREA_OFFSET - get offset from native SP to the address of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">  /// GET_DYNAMIC_AREA_OFFSET - get offset from native SP to the address of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">  /// the most recent dynamic alloca. For most targets that would be 0, but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">  /// the most recent dynamic alloca. For most targets that would be 0, but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">  /// for some others (e.g. PowerPC, PowerPC64) that would be compile-time</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">  /// for some others (e.g. PowerPC, PowerPC64) that would be compile-time</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">  /// known nonzero constant. The only operand here is the chain.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">  /// known nonzero constant. The only operand here is the chain.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">  GET_DYNAMIC_AREA_OFFSET,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">  GET_DYNAMIC_AREA_OFFSET,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">  /// Pseudo probe for AutoFDO, as a place holder in a basic block to improve</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">  /// Pseudo probe for AutoFDO, as a place holder in a basic block to improve</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">  /// the sample counts quality.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">  /// the sample counts quality.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">  PSEUDO_PROBE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">  PSEUDO_PROBE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">  /// VSCALE(IMM) - Returns the runtime scaling factor used to calculate the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">  /// VSCALE(IMM) - Returns the runtime scaling factor used to calculate the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">  /// number of elements within a scalable vector. IMM is a constant integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">  /// number of elements within a scalable vector. IMM is a constant integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">  /// multiplier that is applied to the runtime value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">  /// multiplier that is applied to the runtime value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">  VSCALE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">  VSCALE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">  /// Generic reduction nodes. These nodes represent horizontal vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">  /// Generic reduction nodes. These nodes represent horizontal vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">  /// reduction operations, producing a scalar result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">  /// reduction operations, producing a scalar result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">  /// The SEQ variants perform reductions in sequential order. The first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">  /// The SEQ variants perform reductions in sequential order. The first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">  /// operand is an initial scalar accumulator value, and the second operand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">  /// operand is an initial scalar accumulator value, and the second operand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">  /// is the vector to reduce.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">  /// is the vector to reduce.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">  /// E.g. RES = VECREDUCE_SEQ_FADD f32 ACC, <4 x f32> SRC_VEC</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">  /// E.g. RES = VECREDUCE_SEQ_FADD f32 ACC, <4 x f32> SRC_VEC</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">  ///  ... is equivalent to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">  ///  ... is equivalent to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">  /// RES = (((ACC + SRC_VEC[0]) + SRC_VEC[1]) + SRC_VEC[2]) + SRC_VEC[3]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">  /// RES = (((ACC + SRC_VEC[0]) + SRC_VEC[1]) + SRC_VEC[2]) + SRC_VEC[3]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">  VECREDUCE_SEQ_FADD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">  VECREDUCE_SEQ_FADD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">  VECREDUCE_SEQ_FMUL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">  VECREDUCE_SEQ_FMUL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">  /// These reductions have relaxed evaluation order semantics, and have a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">  /// These reductions have relaxed evaluation order semantics, and have a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  /// single vector operand. The order of evaluation is unspecified. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  /// single vector operand. The order of evaluation is unspecified. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">  /// pow-of-2 vectors, one valid legalizer expansion is to use a tree</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">  /// pow-of-2 vectors, one valid legalizer expansion is to use a tree</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">  /// reduction, i.e.:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">  /// reduction, i.e.:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">  /// For RES = VECREDUCE_FADD <8 x f16> SRC_VEC</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">  /// For RES = VECREDUCE_FADD <8 x f16> SRC_VEC</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">  ///   PART_RDX = FADD SRC_VEC[0:3], SRC_VEC[4:7]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">  ///   PART_RDX = FADD SRC_VEC[0:3], SRC_VEC[4:7]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">  ///   PART_RDX2 = FADD PART_RDX[0:1], PART_RDX[2:3]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">  ///   PART_RDX2 = FADD PART_RDX[0:1], PART_RDX[2:3]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">  ///   RES = FADD PART_RDX2[0], PART_RDX2[1]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">  ///   RES = FADD PART_RDX2[0], PART_RDX2[1]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">  /// For non-pow-2 vectors, this can be computed by extracting each element</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">  /// For non-pow-2 vectors, this can be computed by extracting each element</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">  /// and performing the operation as if it were scalarized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">  /// and performing the operation as if it were scalarized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">  VECREDUCE_FADD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">  VECREDUCE_FADD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">  VECREDUCE_FMUL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">  VECREDUCE_FMUL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">  /// FMIN/FMAX nodes can have flags, for NaN/NoNaN variants.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">  /// FMIN/FMAX nodes can have flags, for NaN/NoNaN variants.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">  VECREDUCE_FMAX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">  VECREDUCE_FMAX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">  VECREDUCE_FMIN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">  VECREDUCE_FMIN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">  /// FMINIMUM/FMAXIMUM nodes propatate NaNs and signed zeroes using the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">  /// FMINIMUM/FMAXIMUM nodes propatate NaNs and signed zeroes using the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">  /// llvm.minimum and llvm.maximum semantics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">  /// llvm.minimum and llvm.maximum semantics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">  VECREDUCE_FMAXIMUM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">  VECREDUCE_FMAXIMUM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">  VECREDUCE_FMINIMUM,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">  VECREDUCE_FMINIMUM,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">  /// Integer reductions may have a result type larger than the vector element</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">  /// Integer reductions may have a result type larger than the vector element</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">  /// type. However, the reduction is performed using the vector element type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">  /// type. However, the reduction is performed using the vector element type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">  /// and the value in the top bits is unspecified.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">  /// and the value in the top bits is unspecified.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">  VECREDUCE_ADD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">  VECREDUCE_ADD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">  VECREDUCE_MUL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">  VECREDUCE_MUL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">  VECREDUCE_AND,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">  VECREDUCE_AND,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">  VECREDUCE_OR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">  VECREDUCE_OR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">  VECREDUCE_XOR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">  VECREDUCE_XOR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">  VECREDUCE_SMAX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">  VECREDUCE_SMAX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">  VECREDUCE_SMIN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">  VECREDUCE_SMIN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">  VECREDUCE_UMAX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">  VECREDUCE_UMAX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">  VECREDUCE_UMIN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">  VECREDUCE_UMIN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">  // The `llvm.experimental.stackmap` intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">  // The `llvm.experimental.stackmap` intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">  // Operands: input chain, glue, <id>, <numShadowBytes>, [live0[, live1...]]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">  // Operands: input chain, glue, <id>, <numShadowBytes>, [live0[, live1...]]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">  // Outputs: output chain, glue</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">  // Outputs: output chain, glue</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">  STACKMAP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">  STACKMAP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">  // The `llvm.experimental.patchpoint.*` intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">  // The `llvm.experimental.patchpoint.*` intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">  // Operands: input chain, [glue], reg-mask, <id>, <numShadowBytes>, callee,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">  // Operands: input chain, [glue], reg-mask, <id>, <numShadowBytes>, callee,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">  //   <numArgs>, cc, ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">  //   <numArgs>, cc, ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">  // Outputs: [rv], output chain, glue</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">  // Outputs: [rv], output chain, glue</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">  PATCHPOINT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">  PATCHPOINT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">// Vector Predication</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">// Vector Predication</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">#define BEGIN_REGISTER_VP_SDNODE(VPSDID, ...) VPSDID,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">#define BEGIN_REGISTER_VP_SDNODE(VPSDID, ...) VPSDID,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">#include "llvm/IR/VPIntrinsics.def"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">#include "llvm/IR/VPIntrinsics.def"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">  /// BUILTIN_OP_END - This must be the last enum value in this list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">  /// BUILTIN_OP_END - This must be the last enum value in this list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">  /// The target-specific pre-isel opcode values start here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">  /// The target-specific pre-isel opcode values start here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">  BUILTIN_OP_END</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">  BUILTIN_OP_END</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">/// FIRST_TARGET_STRICTFP_OPCODE - Target-specific pre-isel operations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">/// FIRST_TARGET_STRICTFP_OPCODE - Target-specific pre-isel operations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">/// which cannot raise FP exceptions should be less than this value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">/// which cannot raise FP exceptions should be less than this value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">/// Those that do must not be less than this value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">/// Those that do must not be less than this value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">static const int FIRST_TARGET_STRICTFP_OPCODE = BUILTIN_OP_END + 400;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">static const int FIRST_TARGET_STRICTFP_OPCODE = BUILTIN_OP_END + 400;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">/// FIRST_TARGET_MEMORY_OPCODE - Target-specific pre-isel operations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">/// FIRST_TARGET_MEMORY_OPCODE - Target-specific pre-isel operations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">/// which do not reference a specific memory location should be less than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">/// which do not reference a specific memory location should be less than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">/// this value. Those that do must not be less than this value, and can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">/// this value. Those that do must not be less than this value, and can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">/// be used with SelectionDAG::getMemIntrinsicNode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">/// be used with SelectionDAG::getMemIntrinsicNode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">static const int FIRST_TARGET_MEMORY_OPCODE = BUILTIN_OP_END + 500;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">static const int FIRST_TARGET_MEMORY_OPCODE = BUILTIN_OP_END + 500;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">/// Whether this is bitwise logic opcode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">/// Whether this is bitwise logic opcode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine coveredLine">inline bool isBitwiseLogicOp(unsigned Opcode) {</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine coveredLine">inline bool isBitwiseLogicOp(unsigned Opcode) {</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine coveredLine">  return Opcode == ISD::AND || Opcode == ISD::OR || Opcode == ISD::XOR;</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine coveredLine">  return Opcode == ISD::AND || Opcode == ISD::OR || Opcode == ISD::XOR;</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">/// Get underlying scalar opcode for VECREDUCE opcode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">/// Get underlying scalar opcode for VECREDUCE opcode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">/// For example ISD::AND for ISD::VECREDUCE_AND.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">/// For example ISD::AND for ISD::VECREDUCE_AND.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">NodeType getVecReduceBaseOpcode(unsigned VecReduceOpcode);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">NodeType getVecReduceBaseOpcode(unsigned VecReduceOpcode);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">/// Whether this is a vector-predicated Opcode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">/// Whether this is a vector-predicated Opcode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">bool isVPOpcode(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">bool isVPOpcode(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">/// Whether this is a vector-predicated binary operation opcode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">/// Whether this is a vector-predicated binary operation opcode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">bool isVPBinaryOp(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">bool isVPBinaryOp(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">/// Whether this is a vector-predicated reduction opcode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">/// Whether this is a vector-predicated reduction opcode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">bool isVPReduction(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">bool isVPReduction(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">/// The operand position of the vector mask.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">/// The operand position of the vector mask.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">std::optional<unsigned> getVPMaskIdx(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">std::optional<unsigned> getVPMaskIdx(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">/// The operand position of the explicit vector length parameter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">/// The operand position of the explicit vector length parameter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">std::optional<unsigned> getVPExplicitVectorLengthIdx(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">std::optional<unsigned> getVPExplicitVectorLengthIdx(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">/// Translate this VP Opcode to its corresponding non-VP Opcode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">/// Translate this VP Opcode to its corresponding non-VP Opcode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">std::optional<unsigned> getBaseOpcodeForVP(unsigned Opcode, bool hasFPExcept);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">std::optional<unsigned> getBaseOpcodeForVP(unsigned Opcode, bool hasFPExcept);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">/// Translate this non-VP Opcode to its corresponding VP Opcode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">/// Translate this non-VP Opcode to its corresponding VP Opcode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">unsigned getVPForBaseOpcode(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">unsigned getVPForBaseOpcode(unsigned Opcode);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">/// MemIndexedMode enum - This enum defines the load / store indexed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">/// MemIndexedMode enum - This enum defines the load / store indexed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">/// addressing modes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">/// addressing modes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">/// UNINDEXED    "Normal" load / store. The effective address is already</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">/// UNINDEXED    "Normal" load / store. The effective address is already</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">///              computed and is available in the base pointer. The offset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">///              computed and is available in the base pointer. The offset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">///              operand is always undefined. In addition to producing a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">///              operand is always undefined. In addition to producing a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">///              chain, an unindexed load produces one value (result of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">///              chain, an unindexed load produces one value (result of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">///              load); an unindexed store does not produce a value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">///              load); an unindexed store does not produce a value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">/// PRE_INC      Similar to the unindexed mode where the effective address is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">/// PRE_INC      Similar to the unindexed mode where the effective address is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">/// PRE_DEC      the value of the base pointer add / subtract the offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">/// PRE_DEC      the value of the base pointer add / subtract the offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">///              It considers the computation as being folded into the load /</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">///              It considers the computation as being folded into the load /</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">///              store operation (i.e. the load / store does the address</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">///              store operation (i.e. the load / store does the address</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">///              computation as well as performing the memory transaction).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">///              computation as well as performing the memory transaction).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">///              The base operand is always undefined. In addition to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">///              The base operand is always undefined. In addition to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">///              producing a chain, pre-indexed load produces two values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">///              producing a chain, pre-indexed load produces two values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">///              (result of the load and the result of the address</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">///              (result of the load and the result of the address</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">///              computation); a pre-indexed store produces one value (result</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">///              computation); a pre-indexed store produces one value (result</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">///              of the address computation).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">///              of the address computation).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">/// POST_INC     The effective address is the value of the base pointer. The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">/// POST_INC     The effective address is the value of the base pointer. The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">/// POST_DEC     value of the offset operand is then added to / subtracted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">/// POST_DEC     value of the offset operand is then added to / subtracted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">///              from the base after memory transaction. In addition to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">///              from the base after memory transaction. In addition to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">///              producing a chain, post-indexed load produces two values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">///              producing a chain, post-indexed load produces two values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">///              (the result of the load and the result of the base +/- offset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">///              (the result of the load and the result of the base +/- offset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">///              computation); a post-indexed store produces one value (the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">///              computation); a post-indexed store produces one value (the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">///              the result of the base +/- offset computation).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">///              the result of the base +/- offset computation).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">enum MemIndexedMode { UNINDEXED = 0, PRE_INC, PRE_DEC, POST_INC, POST_DEC };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">enum MemIndexedMode { UNINDEXED = 0, PRE_INC, PRE_DEC, POST_INC, POST_DEC };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">static const int LAST_INDEXED_MODE = POST_DEC + 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">static const int LAST_INDEXED_MODE = POST_DEC + 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">/// MemIndexType enum - This enum defines how to interpret MGATHER/SCATTER's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">/// MemIndexType enum - This enum defines how to interpret MGATHER/SCATTER's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">/// index parameter when calculating addresses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">/// index parameter when calculating addresses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">/// SIGNED_SCALED     Addr = Base + ((signed)Index * Scale)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">/// SIGNED_SCALED     Addr = Base + ((signed)Index * Scale)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">/// UNSIGNED_SCALED   Addr = Base + ((unsigned)Index * Scale)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">/// UNSIGNED_SCALED   Addr = Base + ((unsigned)Index * Scale)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">/// NOTE: The value of Scale is typically only known to the node owning the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">/// NOTE: The value of Scale is typically only known to the node owning the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">/// IndexType, with a value of 1 the equivalent of being unscaled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">/// IndexType, with a value of 1 the equivalent of being unscaled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">enum MemIndexType { SIGNED_SCALED = 0, UNSIGNED_SCALED };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">enum MemIndexType { SIGNED_SCALED = 0, UNSIGNED_SCALED };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">static const int LAST_MEM_INDEX_TYPE = UNSIGNED_SCALED + 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">static const int LAST_MEM_INDEX_TYPE = UNSIGNED_SCALED + 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">inline bool isIndexTypeSigned(MemIndexType IndexType) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">inline bool isIndexTypeSigned(MemIndexType IndexType) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">  return IndexType == SIGNED_SCALED;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">  return IndexType == SIGNED_SCALED;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">/// LoadExtType enum - This enum defines the three variants of LOADEXT</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">/// LoadExtType enum - This enum defines the three variants of LOADEXT</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">/// (load with extension).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">/// (load with extension).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">/// SEXTLOAD loads the integer operand and sign extends it to a larger</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">/// SEXTLOAD loads the integer operand and sign extends it to a larger</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">///          integer result type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">///          integer result type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">/// ZEXTLOAD loads the integer operand and zero extends it to a larger</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">/// ZEXTLOAD loads the integer operand and zero extends it to a larger</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">///          integer result type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">///          integer result type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">/// EXTLOAD  is used for two things: floating point extending loads and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">/// EXTLOAD  is used for two things: floating point extending loads and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">///          integer extending loads [the top bits are undefined].</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">///          integer extending loads [the top bits are undefined].</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">enum LoadExtType { NON_EXTLOAD = 0, EXTLOAD, SEXTLOAD, ZEXTLOAD };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">enum LoadExtType { NON_EXTLOAD = 0, EXTLOAD, SEXTLOAD, ZEXTLOAD };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">static const int LAST_LOADEXT_TYPE = ZEXTLOAD + 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">static const int LAST_LOADEXT_TYPE = ZEXTLOAD + 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">NodeType getExtForLoadExtType(bool IsFP, LoadExtType);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">NodeType getExtForLoadExtType(bool IsFP, LoadExtType);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">//===--------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">/// ISD::CondCode enum - These are ordered carefully to make the bitfields</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">/// ISD::CondCode enum - These are ordered carefully to make the bitfields</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">/// below work out, when considering SETFALSE (something that never exists</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">/// below work out, when considering SETFALSE (something that never exists</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">/// dynamically) as 0.  "U" -> Unsigned (for integer operands) or Unordered</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">/// dynamically) as 0.  "U" -> Unsigned (for integer operands) or Unordered</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">/// (for floating point), "L" -> Less than, "G" -> Greater than, "E" -> Equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">/// (for floating point), "L" -> Less than, "G" -> Greater than, "E" -> Equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">/// to.  If the "N" column is 1, the result of the comparison is undefined if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">/// to.  If the "N" column is 1, the result of the comparison is undefined if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">/// the input is a NAN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">/// the input is a NAN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">/// All of these (except for the 'always folded ops') should be handled for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">/// All of these (except for the 'always folded ops') should be handled for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">/// floating point.  For integer, only the SETEQ,SETNE,SETLT,SETLE,SETGT,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">/// floating point.  For integer, only the SETEQ,SETNE,SETLT,SETLE,SETGT,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">/// SETGE,SETULT,SETULE,SETUGT, and SETUGE opcodes are used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">/// SETGE,SETULT,SETULE,SETUGT, and SETUGE opcodes are used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">/// Note that these are laid out in a specific order to allow bit-twiddling</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">/// Note that these are laid out in a specific order to allow bit-twiddling</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">/// to transform conditions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">/// to transform conditions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">enum CondCode {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">enum CondCode {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">  // Opcode       N U L G E       Intuitive operation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">  // Opcode       N U L G E       Intuitive operation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">  SETFALSE, //      0 0 0 0       Always false (always folded)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">  SETFALSE, //      0 0 0 0       Always false (always folded)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">  SETOEQ,   //      0 0 0 1       True if ordered and equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">  SETOEQ,   //      0 0 0 1       True if ordered and equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">  SETOGT,   //      0 0 1 0       True if ordered and greater than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">  SETOGT,   //      0 0 1 0       True if ordered and greater than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">  SETOGE,   //      0 0 1 1       True if ordered and greater than or equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">  SETOGE,   //      0 0 1 1       True if ordered and greater than or equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">  SETOLT,   //      0 1 0 0       True if ordered and less than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">  SETOLT,   //      0 1 0 0       True if ordered and less than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">  SETOLE,   //      0 1 0 1       True if ordered and less than or equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">  SETOLE,   //      0 1 0 1       True if ordered and less than or equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">  SETONE,   //      0 1 1 0       True if ordered and operands are unequal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">  SETONE,   //      0 1 1 0       True if ordered and operands are unequal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">  SETO,     //      0 1 1 1       True if ordered (no nans)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">  SETO,     //      0 1 1 1       True if ordered (no nans)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">  SETUO,    //      1 0 0 0       True if unordered: isnan(X) | isnan(Y)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">  SETUO,    //      1 0 0 0       True if unordered: isnan(X) | isnan(Y)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">  SETUEQ,   //      1 0 0 1       True if unordered or equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">  SETUEQ,   //      1 0 0 1       True if unordered or equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">  SETUGT,   //      1 0 1 0       True if unordered or greater than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">  SETUGT,   //      1 0 1 0       True if unordered or greater than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  SETUGE,   //      1 0 1 1       True if unordered, greater than, or equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  SETUGE,   //      1 0 1 1       True if unordered, greater than, or equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">  SETULT,   //      1 1 0 0       True if unordered or less than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">  SETULT,   //      1 1 0 0       True if unordered or less than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">  SETULE,   //      1 1 0 1       True if unordered, less than, or equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">  SETULE,   //      1 1 0 1       True if unordered, less than, or equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">  SETUNE,   //      1 1 1 0       True if unordered or not equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">  SETUNE,   //      1 1 1 0       True if unordered or not equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">  SETTRUE,  //      1 1 1 1       Always true (always folded)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">  SETTRUE,  //      1 1 1 1       Always true (always folded)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">  // Don't care operations: undefined if the input is a nan.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">  // Don't care operations: undefined if the input is a nan.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">  SETFALSE2, //   1 X 0 0 0       Always false (always folded)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">  SETFALSE2, //   1 X 0 0 0       Always false (always folded)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">  SETEQ,     //   1 X 0 0 1       True if equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">  SETEQ,     //   1 X 0 0 1       True if equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">  SETGT,     //   1 X 0 1 0       True if greater than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">  SETGT,     //   1 X 0 1 0       True if greater than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">  SETGE,     //   1 X 0 1 1       True if greater than or equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">  SETGE,     //   1 X 0 1 1       True if greater than or equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">  SETLT,     //   1 X 1 0 0       True if less than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">  SETLT,     //   1 X 1 0 0       True if less than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">  SETLE,     //   1 X 1 0 1       True if less than or equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">  SETLE,     //   1 X 1 0 1       True if less than or equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">  SETNE,     //   1 X 1 1 0       True if not equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">  SETNE,     //   1 X 1 1 0       True if not equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">  SETTRUE2,  //   1 X 1 1 1       Always true (always folded)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">  SETTRUE2,  //   1 X 1 1 1       Always true (always folded)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">  SETCC_INVALID // Marker value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">  SETCC_INVALID // Marker value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">/// Return true if this is a setcc instruction that performs a signed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">/// Return true if this is a setcc instruction that performs a signed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">/// comparison when used with integer operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">/// comparison when used with integer operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine coveredLine">inline bool isSignedIntSetCC(CondCode Code) {</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine coveredLine">inline bool isSignedIntSetCC(CondCode Code) {</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine coveredLine">  return Code == SETGT || Code == SETGE || Code == SETLT || Code == SETLE;</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine coveredLine">  return Code == SETGT || Code == SETGE || Code == SETLT || Code == SETLE;</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">/// Return true if this is a setcc instruction that performs an unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">/// Return true if this is a setcc instruction that performs an unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">/// comparison when used with integer operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">/// comparison when used with integer operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">inline bool isUnsignedIntSetCC(CondCode Code) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">inline bool isUnsignedIntSetCC(CondCode Code) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">  return Code == SETUGT || Code == SETUGE || Code == SETULT || Code == SETULE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">  return Code == SETUGT || Code == SETUGE || Code == SETULT || Code == SETULE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">/// Return true if this is a setcc instruction that performs an equality</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">/// Return true if this is a setcc instruction that performs an equality</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">/// comparison when used with integer operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">/// comparison when used with integer operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">inline bool isIntEqualitySetCC(CondCode Code) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">inline bool isIntEqualitySetCC(CondCode Code) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">  return Code == SETEQ || Code == SETNE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">  return Code == SETEQ || Code == SETNE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">/// Return true if the specified condition returns true if the two operands to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">/// Return true if the specified condition returns true if the two operands to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">/// the condition are equal. Note that if one of the two operands is a NaN,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">/// the condition are equal. Note that if one of the two operands is a NaN,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">/// this value is meaningless.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">/// this value is meaningless.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">inline bool isTrueWhenEqual(CondCode Cond) { return ((int)Cond & 1) != 0; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">inline bool isTrueWhenEqual(CondCode Cond) { return ((int)Cond & 1) != 0; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">/// This function returns 0 if the condition is always false if an operand is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">/// This function returns 0 if the condition is always false if an operand is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">/// a NaN, 1 if the condition is always true if the operand is a NaN, and 2 if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">/// a NaN, 1 if the condition is always true if the operand is a NaN, and 2 if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">/// the condition is undefined if the operand is a NaN.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">/// the condition is undefined if the operand is a NaN.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">inline unsigned getUnorderedFlavor(CondCode Cond) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">inline unsigned getUnorderedFlavor(CondCode Cond) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">  return ((int)Cond >> 3) & 3;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">  return ((int)Cond >> 3) & 3;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">/// Return the operation corresponding to !(X op Y), where 'op' is a valid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">/// Return the operation corresponding to !(X op Y), where 'op' is a valid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">/// SetCC operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">/// SetCC operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">CondCode getSetCCInverse(CondCode Operation, EVT Type);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">CondCode getSetCCInverse(CondCode Operation, EVT Type);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine coveredLine">inline bool isExtOpcode(unsigned Opcode) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine coveredLine">inline bool isExtOpcode(unsigned Opcode) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine coveredLine">  return Opcode == ISD::ANY_EXTEND || Opcode == ISD::ZERO_EXTEND ||</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine coveredLine">  return Opcode == ISD::ANY_EXTEND || Opcode == ISD::ZERO_EXTEND ||</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine coveredLine">         Opcode == ISD::SIGN_EXTEND;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine coveredLine">         Opcode == ISD::SIGN_EXTEND;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">inline bool isExtVecInRegOpcode(unsigned Opcode) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">inline bool isExtVecInRegOpcode(unsigned Opcode) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">  return Opcode == ISD::ANY_EXTEND_VECTOR_INREG ||</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">  return Opcode == ISD::ANY_EXTEND_VECTOR_INREG ||</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">         Opcode == ISD::ZERO_EXTEND_VECTOR_INREG ||</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">         Opcode == ISD::ZERO_EXTEND_VECTOR_INREG ||</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">         Opcode == ISD::SIGN_EXTEND_VECTOR_INREG;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">         Opcode == ISD::SIGN_EXTEND_VECTOR_INREG;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">namespace GlobalISel {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">namespace GlobalISel {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">/// Return the operation corresponding to !(X op Y), where 'op' is a valid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">/// Return the operation corresponding to !(X op Y), where 'op' is a valid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">/// SetCC operation. The U bit of the condition code has different meanings</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">/// SetCC operation. The U bit of the condition code has different meanings</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">/// between floating point and integer comparisons and LLT's don't provide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">/// between floating point and integer comparisons and LLT's don't provide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">/// this distinction. As such we need to be told whether the comparison is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">/// this distinction. As such we need to be told whether the comparison is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">/// floating point or integer-like. Pointers should use integer-like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">/// floating point or integer-like. Pointers should use integer-like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">/// comparisons.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">/// comparisons.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">CondCode getSetCCInverse(CondCode Operation, bool isIntegerLike);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">CondCode getSetCCInverse(CondCode Operation, bool isIntegerLike);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">} // end namespace GlobalISel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">} // end namespace GlobalISel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">/// Return the operation corresponding to (Y op X) when given the operation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">/// Return the operation corresponding to (Y op X) when given the operation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">/// for (X op Y).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">/// for (X op Y).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">CondCode getSetCCSwappedOperands(CondCode Operation);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">CondCode getSetCCSwappedOperands(CondCode Operation);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">/// Return the result of a logical OR between different comparisons of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">/// Return the result of a logical OR between different comparisons of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">/// identical values: ((X op1 Y) | (X op2 Y)). This function returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">/// identical values: ((X op1 Y) | (X op2 Y)). This function returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">/// SETCC_INVALID if it is not possible to represent the resultant comparison.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">/// SETCC_INVALID if it is not possible to represent the resultant comparison.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">CondCode getSetCCOrOperation(CondCode Op1, CondCode Op2, EVT Type);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">CondCode getSetCCOrOperation(CondCode Op1, CondCode Op2, EVT Type);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">/// Return the result of a logical AND between different comparisons of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">/// Return the result of a logical AND between different comparisons of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">/// identical values: ((X op1 Y) & (X op2 Y)). This function returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">/// identical values: ((X op1 Y) & (X op2 Y)). This function returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">/// SETCC_INVALID if it is not possible to represent the resultant comparison.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">/// SETCC_INVALID if it is not possible to represent the resultant comparison.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">CondCode getSetCCAndOperation(CondCode Op1, CondCode Op2, EVT Type);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">CondCode getSetCCAndOperation(CondCode Op1, CondCode Op2, EVT Type);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">} // namespace ISD</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">} // namespace ISD</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>