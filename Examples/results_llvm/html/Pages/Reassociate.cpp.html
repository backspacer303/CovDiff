<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Reassociate.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- Reassociate.cpp - Reassociate binary expressions -------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This pass reassociates commutative expressions in an order that is designed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// to promote better constant propagation, GCSE, LICM, PRE, etc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">// For example: 4 + (x + 5) -> x + (4 + 5)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">// In the implementation of this algorithm, constants are assigned rank = 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">// function arguments are rank = 1, and other values are assigned ranks</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">// corresponding to the reverse post order traversal of current function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">// (starting at 2), which effectively gives values in deep loops higher rank</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">// than values not in loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/Transforms/Scalar/Reassociate.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/ADT/APFloat.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/ADT/APInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/ADT/PostOrderIterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/ADT/SmallSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/ADT/Statistic.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/Analysis/BasicAliasAnalysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/Analysis/ConstantFolding.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/Analysis/GlobalsModRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/Analysis/ValueTracking.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/IR/Argument.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/IR/BasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/IR/CFG.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/IR/Constant.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include "llvm/IR/Constants.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include "llvm/IR/IRBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include "llvm/IR/InstrTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include "llvm/IR/Instruction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">#include "llvm/IR/Operator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#include "llvm/IR/PassManager.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">#include "llvm/IR/PatternMatch.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">#include "llvm/IR/Type.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">#include "llvm/IR/User.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">#include "llvm/IR/Value.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">#include "llvm/IR/ValueHandle.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">#include "llvm/Support/Casting.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">#include "llvm/Transforms/Scalar.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">#include "llvm/Transforms/Utils/Local.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">using namespace reassociate;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">using namespace PatternMatch;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">#define DEBUG_TYPE "reassociate"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">STATISTIC(NumChanged, "Number of insts reassociated");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">STATISTIC(NumAnnihil, "Number of expr tree annihilated");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">STATISTIC(NumFactor , "Number of multiplies factored");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">static cl::opt<bool></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">    UseCSELocalOpt(DEBUG_TYPE "-use-cse-local",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">                   cl::desc("Only reorder expressions within a basic block "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">                            "when exposing CSE opportunities"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">                   cl::init(true), cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">/// Print out the expression identified in the Ops list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="uncoveredLine">static void PrintOps(Instruction *I, const SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="uncoveredLine">  Module *M = I->getModule();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="uncoveredLine">  dbgs() << Instruction::getOpcodeName(I->getOpcode()) << " "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="uncoveredLine">       << *Ops[0].Op->getType() << '\t';</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="uncoveredLine">    dbgs() << "[ ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="uncoveredLine">    Ops[i].Op->printAsOperand(dbgs(), false, M);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="uncoveredLine">    dbgs() << ", #" << Ops[i].Rank << "] ";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">/// Utility class representing a non-constant Xor-operand. We classify</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">/// non-constant Xor-Operands into two categories:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">///  C1) The operand is in the form "X & C", where C is a constant and C != ~0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">///  C2)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">///    C2.1) The operand is in the form of "X | C", where C is a non-zero</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">///          constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">///    C2.2) Any operand E which doesn't fall into C1 and C2.1, we view this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">///          operand as "E | 0"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">class llvm::reassociate::XorOpnd {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">  XorOpnd(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="uncoveredLine">  bool isInvalid() const { return SymbolicPart == nullptr; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="uncoveredLine">  bool isOrExpr() const { return isOr; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="uncoveredLine">  Value *getValue() const { return OrigVal; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="uncoveredLine">  Value *getSymbolicPart() const { return SymbolicPart; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="uncoveredLine">  unsigned getSymbolicRank() const { return SymbolicRank; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="uncoveredLine">  const APInt &getConstPart() const { return ConstPart; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="uncoveredLine">  void Invalidate() { SymbolicPart = OrigVal = nullptr; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="uncoveredLine">  void setSymbolicRank(unsigned R) { SymbolicRank = R; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">  Value *OrigVal;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">  Value *SymbolicPart;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">  APInt ConstPart;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">  unsigned SymbolicRank;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">  bool isOr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="uncoveredLine">XorOpnd::XorOpnd(Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="uncoveredLine">  assert(!isa<ConstantInt>(V) && "No ConstantInt");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="uncoveredLine">  OrigVal = V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="uncoveredLine">  Instruction *I = dyn_cast<Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="uncoveredLine">  SymbolicRank = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="uncoveredLine">  if (I && (I->getOpcode() == Instruction::Or ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="uncoveredLine">            I->getOpcode() == Instruction::And)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="uncoveredLine">    Value *V0 = I->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="uncoveredLine">    Value *V1 = I->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">    const APInt *C;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="uncoveredLine">    if (match(V0, m_APInt(C)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="uncoveredLine">      std::swap(V0, V1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="uncoveredLine">    if (match(V1, m_APInt(C))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="uncoveredLine">      ConstPart = *C;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="uncoveredLine">      SymbolicPart = V0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="uncoveredLine">      isOr = (I->getOpcode() == Instruction::Or);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">  // view the operand as "V | 0"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="uncoveredLine">  SymbolicPart = V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="uncoveredLine">  ConstPart = APInt::getZero(V->getType()->getScalarSizeInBits());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="uncoveredLine">  isOr = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">/// Return true if I is an instruction with the FastMathFlags that are needed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">/// for general reassociation set.  This is not the same as testing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">/// Instruction::isAssociative() because it includes operations like fsub.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">/// (This routine is only intended to be called for floating-point operations.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="uncoveredLine">static bool hasFPAssociativeFlags(Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="uncoveredLine">  assert(I && isa<FPMathOperator>(I) && "Should only check FP ops");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="uncoveredLine">  return I->hasAllowReassoc() && I->hasNoSignedZeros();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">/// Return true if V is an instruction of the specified opcode and if it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">/// only has one use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="uncoveredLine">static BinaryOperator *isReassociableOp(Value *V, unsigned Opcode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="uncoveredLine">  auto *BO = dyn_cast<BinaryOperator>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="uncoveredLine">  if (BO && BO->hasOneUse() && BO->getOpcode() == Opcode)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="uncoveredLine">    if (!isa<FPMathOperator>(BO) || hasFPAssociativeFlags(BO))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="uncoveredLine">      return BO;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="uncoveredLine">static BinaryOperator *isReassociableOp(Value *V, unsigned Opcode1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">                                        unsigned Opcode2) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="uncoveredLine">  auto *BO = dyn_cast<BinaryOperator>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="uncoveredLine">  if (BO && BO->hasOneUse() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="uncoveredLine">      (BO->getOpcode() == Opcode1 || BO->getOpcode() == Opcode2))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="uncoveredLine">    if (!isa<FPMathOperator>(BO) || hasFPAssociativeFlags(BO))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="uncoveredLine">      return BO;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="uncoveredLine">void ReassociatePass::BuildRankMap(Function &F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">                                   ReversePostOrderTraversal<Function*> &RPOT) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="uncoveredLine">  unsigned Rank = 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">  // Assign distinct ranks to function arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="uncoveredLine">  for (auto &Arg : F.args()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="uncoveredLine">    ValueRankMap[&Arg] = ++Rank;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Calculated Rank[" << Arg.getName() << "] = " << Rank</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">                      << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">  // Traverse basic blocks in ReversePostOrder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="uncoveredLine">  for (BasicBlock *BB : RPOT) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="uncoveredLine">    unsigned BBRank = RankMap[BB] = ++Rank << 16;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">    // Walk the basic block, adding precomputed ranks for any instructions that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">    // we cannot move.  This ensures that the ranks for these instructions are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">    // all different in the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">    for (Instruction &I : *BB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="uncoveredLine">      if (mayHaveNonDefUseDependency(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="uncoveredLine">        ValueRankMap[&I] = ++BBRank;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="uncoveredLine">unsigned ReassociatePass::getRank(Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="uncoveredLine">  Instruction *I = dyn_cast<Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="uncoveredLine">  if (!I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="uncoveredLine">    if (isa<Argument>(V)) return ValueRankMap[V];   // Function argument.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="uncoveredLine">    return 0;  // Otherwise it's a global or constant, rank 0.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="uncoveredLine">  if (unsigned Rank = ValueRankMap[I])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="uncoveredLine">    return Rank;    // Rank already known?</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">  // If this is an expression, return the 1+MAX(rank(LHS), rank(RHS)) so that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">  // we can reassociate expressions for code motion!  Since we do not recurse</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">  // for PHI nodes, we cannot have infinite recursion here, because there</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">  // cannot be loops in the value graph that do not go through PHI nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="uncoveredLine">  unsigned Rank = 0, MaxRank = RankMap[I->getParent()];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = I->getNumOperands(); i != e && Rank != MaxRank; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="uncoveredLine">    Rank = std::max(Rank, getRank(I->getOperand(i)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  // If this is a 'not' or 'neg' instruction, do not count it for rank. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">  // assures us that X and ~X will have the same rank.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="uncoveredLine">  if (!match(I, m_Not(m_Value())) && !match(I, m_Neg(m_Value())) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="uncoveredLine">      !match(I, m_FNeg(m_Value())))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="uncoveredLine">    ++Rank;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Calculated Rank[" << V->getName() << "] = " << Rank</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">                    << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="uncoveredLine">  return ValueRankMap[I] = Rank;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">// Canonicalize constants to RHS.  Otherwise, sort the operands by rank.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">void ReassociatePass::canonicalizeOperands(Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="uncoveredLine">  assert(isa<BinaryOperator>(I) && "Expected binary operator.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="uncoveredLine">  assert(I->isCommutative() && "Expected commutative operator.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="uncoveredLine">  Value *LHS = I->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">  Value *RHS = I->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="uncoveredLine">  if (LHS == RHS || isa<Constant>(RHS))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="uncoveredLine">  if (isa<Constant>(LHS) || getRank(RHS) < getRank(LHS))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="uncoveredLine">    cast<BinaryOperator>(I)->swapOperands();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">static BinaryOperator *CreateAdd(Value *S1, Value *S2, const Twine &Name,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">                                 Instruction *InsertBefore, Value *FlagsOp) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="uncoveredLine">  if (S1->getType()->isIntOrIntVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="uncoveredLine">    return BinaryOperator::CreateAdd(S1, S2, Name, InsertBefore);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">    BinaryOperator *Res =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="uncoveredLine">        BinaryOperator::CreateFAdd(S1, S2, Name, InsertBefore);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">    Res->setFastMathFlags(cast<FPMathOperator>(FlagsOp)->getFastMathFlags());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">    return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">static BinaryOperator *CreateMul(Value *S1, Value *S2, const Twine &Name,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">                                 Instruction *InsertBefore, Value *FlagsOp) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="uncoveredLine">  if (S1->getType()->isIntOrIntVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="uncoveredLine">    return BinaryOperator::CreateMul(S1, S2, Name, InsertBefore);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">  else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">    BinaryOperator *Res =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="uncoveredLine">      BinaryOperator::CreateFMul(S1, S2, Name, InsertBefore);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="uncoveredLine">    Res->setFastMathFlags(cast<FPMathOperator>(FlagsOp)->getFastMathFlags());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="uncoveredLine">    return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="uncoveredLine">static Instruction *CreateNeg(Value *S1, const Twine &Name,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">                              Instruction *InsertBefore, Value *FlagsOp) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="uncoveredLine">  if (S1->getType()->isIntOrIntVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="uncoveredLine">    return BinaryOperator::CreateNeg(S1, Name, InsertBefore);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="uncoveredLine">  if (auto *FMFSource = dyn_cast<Instruction>(FlagsOp))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="uncoveredLine">    return UnaryOperator::CreateFNegFMF(S1, FMFSource, Name, InsertBefore);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="uncoveredLine">  return UnaryOperator::CreateFNeg(S1, Name, InsertBefore);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">/// Replace 0-X with X*-1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="uncoveredLine">static BinaryOperator *LowerNegateToMultiply(Instruction *Neg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="uncoveredLine">  assert((isa<UnaryOperator>(Neg) || isa<BinaryOperator>(Neg)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">         "Expected a Negate!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  // FIXME: It's not safe to lower a unary FNeg into a FMul by -1.0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="uncoveredLine">  unsigned OpNo = isa<BinaryOperator>(Neg) ? 1 : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="uncoveredLine">  Type *Ty = Neg->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="uncoveredLine">  Constant *NegOne = Ty->isIntOrIntVectorTy() ?</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="uncoveredLine">    ConstantInt::getAllOnesValue(Ty) : ConstantFP::get(Ty, -1.0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="uncoveredLine">  BinaryOperator *Res = CreateMul(Neg->getOperand(OpNo), NegOne, "", Neg, Neg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">  Neg->setOperand(OpNo, Constant::getNullValue(Ty)); // Drop use of op.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="uncoveredLine">  Res->takeName(Neg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="uncoveredLine">  Neg->replaceAllUsesWith(Res);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">  Res->setDebugLoc(Neg->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="uncoveredLine">  return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">/// Returns k such that lambda(2^Bitwidth) = 2^k, where lambda is the Carmichael</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">/// function. This means that x^(2^k) === 1 mod 2^Bitwidth for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">/// every odd x, i.e. x^(2^k) = 1 for every odd x in Bitwidth-bit arithmetic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="">/// Note that 0 <= k < Bitwidth, and if Bitwidth > 3 then x^(2^k) = 0 for every</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">/// even x in Bitwidth-bit arithmetic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">static unsigned CarmichaelShift(unsigned Bitwidth) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">  if (Bitwidth < 3)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="uncoveredLine">    return Bitwidth - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="uncoveredLine">  return Bitwidth - 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">/// Add the extra weight 'RHS' to the existing weight 'LHS',</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">/// reducing the combined weight using any special properties of the operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">/// The existing weight LHS represents the computation X op X op ... op X where</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">/// X occurs LHS times.  The combined weight represents  X op X op ... op X with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">/// X occurring LHS + RHS times.  If op is "Xor" for example then the combined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">/// operation is equivalent to X if LHS + RHS is odd, or 0 if LHS + RHS is even;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">/// the routine returns 1 in LHS in the first case, and 0 in LHS in the second.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="uncoveredLine">static void IncorporateWeight(APInt &LHS, const APInt &RHS, unsigned Opcode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">  // If we were working with infinite precision arithmetic then the combined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">  // weight would be LHS + RHS.  But we are using finite precision arithmetic,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">  // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">  // for nilpotent operations and addition, but not for idempotent operations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">  // and multiplication), so it is important to correctly reduce the combined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">  // weight back into range if wrapping would be wrong.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">  // If RHS is zero then the weight didn't change.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="uncoveredLine">  if (RHS.isMinValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">  // If LHS is zero then the combined weight is RHS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">  if (LHS.isMinValue()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="uncoveredLine">    LHS = RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">  // From this point on we know that neither LHS nor RHS is zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="uncoveredLine">  if (Instruction::isIdempotent(Opcode)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">    // Idempotent means X op X === X, so any non-zero weight is equivalent to a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">    // weight of 1.  Keeping weights at zero or one also means that wrapping is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">    // not a problem.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="uncoveredLine">    assert(LHS == 1 && RHS == 1 && "Weights not reduced!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="uncoveredLine">    return; // Return a weight of 1.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="uncoveredLine">  if (Instruction::isNilpotent(Opcode)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">    // Nilpotent means X op X === 0, so reduce weights modulo 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="uncoveredLine">    assert(LHS == 1 && RHS == 1 && "Weights not reduced!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="uncoveredLine">    LHS = 0; // 1 + 1 === 0 modulo 2.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">  if (Opcode == Instruction::Add || Opcode == Instruction::FAdd) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">    // TODO: Reduce the weight by exploiting nsw/nuw?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="uncoveredLine">    LHS += RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="uncoveredLine">  assert((Opcode == Instruction::Mul || Opcode == Instruction::FMul) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">         "Unknown associative operation!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">  unsigned Bitwidth = LHS.getBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">  // If CM is the Carmichael number then a weight W satisfying W >= CM+Bitwidth</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">  // can be replaced with W-CM.  That's because x^W=x^(W-CM) for every Bitwidth</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">  // bit number x, since either x is odd in which case x^CM = 1, or x is even in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">  // which case both x^W and x^(W - CM) are zero.  By subtracting off multiples</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">  // of CM like this weights can always be reduced to the range [0, CM+Bitwidth)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">  // which by a happy accident means that they can always be represented using</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">  // Bitwidth bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">  // TODO: Reduce the weight by exploiting nsw/nuw?  (Could do much better than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">  // the Carmichael number).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="uncoveredLine">  if (Bitwidth > 3) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">    /// CM - The value of Carmichael's lambda function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="uncoveredLine">    APInt CM = APInt::getOneBitSet(Bitwidth, CarmichaelShift(Bitwidth));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">    // Any weight W >= Threshold can be replaced with W - CM.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="uncoveredLine">    APInt Threshold = CM + Bitwidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">    assert(LHS.ult(Threshold) && RHS.ult(Threshold) && "Weights not reduced!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">    // For Bitwidth 4 or more the following sum does not overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">    LHS += RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="uncoveredLine">    while (LHS.uge(Threshold))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">      LHS -= CM;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="uncoveredLine">  } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">    // To avoid problems with overflow do everything the same as above but using</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">    // a larger type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">    unsigned CM = 1U << CarmichaelShift(Bitwidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">    unsigned Threshold = CM + Bitwidth;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">    assert(LHS.getZExtValue() < Threshold && RHS.getZExtValue() < Threshold &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">           "Weights not reduced!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">    unsigned Total = LHS.getZExtValue() + RHS.getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="uncoveredLine">    while (Total >= Threshold)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">      Total -= CM;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">    LHS = Total;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">using RepeatedValue = std::pair<Value*, APInt>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">/// Given an associative binary expression, return the leaf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">/// nodes in Ops along with their weights (how many times the leaf occurs).  The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">/// original expression is the same as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">///   (Ops[0].first op Ops[0].first op ... Ops[0].first)  <- Ops[0].second times</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">/// op</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">///   (Ops[1].first op Ops[1].first op ... Ops[1].first)  <- Ops[1].second times</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">/// op</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">///   ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">/// op</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">///   (Ops[N].first op Ops[N].first op ... Ops[N].first)  <- Ops[N].second times</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="">/// Note that the values Ops[0].first, ..., Ops[N].first are all distinct.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">/// This routine may modify the function, in which case it returns 'true'.  The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="">/// changes it makes may well be destructive, changing the value computed by 'I'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">/// to something completely different.  Thus if the routine returns 'true' then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">/// you MUST either replace I with a new expression computed from the Ops array,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">/// or use RewriteExprTree to put the values back in.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">/// A leaf node is either not a binary operation of the same kind as the root</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">/// node 'I' (i.e. is not a binary operator at all, or is, but with a different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">/// opcode), or is the same kind of binary operator but has a use which either</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">/// does not belong to the expression, or does belong to the expression but is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">/// a leaf node.  Every leaf node has at least one use that is a non-leaf node</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">/// of the expression, while for non-leaf nodes (except for the root 'I') every</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">/// use is a non-leaf node of the expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">/// For example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">///           expression graph        node names</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">///                     +        |        I</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">///                    / \       |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">///                   +   +      |      A,  B</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">///                  / \ / \     |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">///                 *   +   *    |    C,  D,  E</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">///                / \ / \ / \   |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">///                   +   *      |      F,  G</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">/// The leaf nodes are C, E, F and G.  The Ops array will contain (maybe not in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">/// that order) (C, 1), (E, 1), (F, 2), (G, 2).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">/// The expression is maximal: if some instruction is a binary operator of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">/// same kind as 'I', and all of its uses are non-leaf nodes of the expression,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">/// then the instruction also belongs to the expression, is not a leaf node of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">/// it, and its operands also belong to the expression (but may be leaf nodes).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="">/// NOTE: This routine will set operands of non-leaf non-root nodes to undef in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">/// order to ensure that every non-root node in the expression has *exactly one*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">/// use by a non-leaf node of the expression.  This destruction means that the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">/// caller MUST either replace 'I' with a new expression or use something like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">/// RewriteExprTree to put the values back in if the routine indicates that it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">/// made a change by returning 'true'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">/// In the above example either the right operand of A or the left operand of B</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">/// will be replaced by undef.  If it is B's operand then this gives:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">///                     +        |        I</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">///                    / \       |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">///                   +   +      |      A,  B - operand of B replaced with undef</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">///                  / \   \     |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">///                 *   +   *    |    C,  D,  E</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">///                / \ / \ / \   |</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">///                   +   *      |      F,  G</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">/// Note that such undef operands can only be reached by passing through 'I'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">/// For example, if you visit operands recursively starting from a leaf node</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">/// then you will never see such an undef operand unless you get back to 'I',</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">/// which requires passing through a phi node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="">/// Note that this routine may also mutate binary operators of the wrong type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">/// that have all uses inside the expression (i.e. only used by non-leaf nodes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">/// of the expression) if it can turn them into binary operators of the right</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">/// type and thus make the expression bigger.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="uncoveredLine">static bool LinearizeExprTree(Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">                              SmallVectorImpl<RepeatedValue> &Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">                              ReassociatePass::OrderedSet &ToRedo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="uncoveredLine">  assert((isa<UnaryOperator>(I) || isa<BinaryOperator>(I)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">         "Expected a UnaryOperator or BinaryOperator!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "LINEARIZE: " << *I << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="uncoveredLine">  unsigned Bitwidth = I->getType()->getScalarType()->getPrimitiveSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">  unsigned Opcode = I->getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="uncoveredLine">  assert(I->isAssociative() && I->isCommutative() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">         "Expected an associative and commutative operation!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">  // Visit all operands of the expression, keeping track of their weight (the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">  // number of paths from the expression root to the operand, or if you like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">  // the number of times that operand occurs in the linearized expression).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">  // For example, if I = X + A, where X = A + B, then I, X and B have weight 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">  // while A has weight two.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">  // Worklist of non-leaf nodes (their operands are in the expression too) along</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">  // with their weights, representing a certain number of paths to the operator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">  // If an operator occurs in the worklist multiple times then we found multiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">  // ways to get to it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="uncoveredLine">  SmallVector<std::pair<Instruction*, APInt>, 8> Worklist; // (Op, Weight)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="uncoveredLine">  Worklist.push_back(std::make_pair(I, APInt(Bitwidth, 1)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">  // Leaves of the expression are values that either aren't the right kind of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">  // operation (eg: a constant, or a multiply in an add tree), or are, but have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">  // some uses that are not inside the expression.  For example, in I = X + X,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">  // X = A + B, the value X has two uses (by I) that are in the expression.  If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">  // X has any other uses, for example in a return instruction, then we consider</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">  // X to be a leaf, and won't analyze it further.  When we first visit a value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">  // if it has more than one use then at first we conservatively consider it to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">  // be a leaf.  Later, as the expression is explored, we may discover some more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">  // uses of the value from inside the expression.  If all uses turn out to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">  // from within the expression (and the value is a binary operator of the right</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">  // kind) then the value is no longer considered to be a leaf, and its operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">  // are explored.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">  // Leaves - Keeps track of the set of putative leaves as well as the number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">  // paths to each leaf seen so far.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">  using LeafMap = DenseMap<Value *, APInt>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">  LeafMap Leaves; // Leaf -> Total weight so far.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="uncoveredLine">  SmallVector<Value *, 8> LeafOrder; // Ensure deterministic leaf output order.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="uncoveredLine">  SmallPtrSet<Value *, 8> Visited; // For checking the iteration scheme.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">    std::pair<Instruction*, APInt> P = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="uncoveredLine">    I = P.first; // We examine the operands of this binary operator.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="uncoveredLine">    for (unsigned OpIdx = 0; OpIdx < I->getNumOperands(); ++OpIdx) { // Visit operands.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="uncoveredLine">      Value *Op = I->getOperand(OpIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="uncoveredLine">      APInt Weight = P.second; // Number of paths to this operand.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "OPERAND: " << *Op << " (" << Weight << ")\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="uncoveredLine">      assert(!Op->use_empty() && "No uses, so how did we get to it?!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">      // If this is a binary operation of the right kind with only one use then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">      // add its operands to the expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="uncoveredLine">      if (BinaryOperator *BO = isReassociableOp(Op, Opcode)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="uncoveredLine">        assert(Visited.insert(Op).second && "Not first visit!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "DIRECT ADD: " << *Op << " (" << Weight << ")\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">        Worklist.push_back(std::make_pair(BO, Weight));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="">      // Appears to be a leaf.  Is the operand already in the set of leaves?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="uncoveredLine">      LeafMap::iterator It = Leaves.find(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">      if (It == Leaves.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">        // Not in the leaf map.  Must be the first time we saw this operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="uncoveredLine">        assert(Visited.insert(Op).second && "Not first visit!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">        if (!Op->hasOneUse()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">          // This value has uses not accounted for by the expression, so it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">          // not safe to modify.  Mark it as being a leaf.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">                     << "ADD USES LEAF: " << *Op << " (" << Weight << ")\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="uncoveredLine">          LeafOrder.push_back(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="uncoveredLine">          Leaves[Op] = Weight;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">        // No uses outside the expression, try morphing it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">        // Already in the leaf map.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">        assert(It != Leaves.end() && Visited.count(Op) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">               "In leaf map but not visited!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">        // Update the number of paths to the leaf.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="uncoveredLine">        IncorporateWeight(It->second, Weight, Opcode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">#if 0   // TODO: Re-enable once PR13021 is fixed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">        // The leaf already has one use from inside the expression.  As we want</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">        // exactly one such use, drop this new use of the leaf.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">        assert(!Op->hasOneUse() && "Only one use, but we got here twice!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">        I->setOperand(OpIdx, UndefValue::get(I->getType()));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">        Changed = true;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">        // If the leaf is a binary operation of the right kind and we now see</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">        // that its multiple original uses were in fact all by nodes belonging</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">        // to the expression, then no longer consider it to be a leaf and add</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">        // its operands to the expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">        if (BinaryOperator *BO = isReassociableOp(Op, Opcode)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">          LLVM_DEBUG(dbgs() << "UNLEAF: " << *Op << " (" << It->second << ")\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">          Worklist.push_back(std::make_pair(BO, It->second));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">          Leaves.erase(It);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">          continue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">        // If we still have uses that are not accounted for by the expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">        // then it is not safe to modify the value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">        if (!Op->hasOneUse())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">        // No uses outside the expression, try morphing it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="uncoveredLine">        Weight = It->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="uncoveredLine">        Leaves.erase(It); // Since the value may be morphed below.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">      // At this point we have a value which, first of all, is not a binary</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">      // expression of the right kind, and secondly, is only used inside the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">      // expression.  This means that it can safely be modified.  See if we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">      // can usefully morph it into an expression of the right kind.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="uncoveredLine">      assert((!isa<Instruction>(Op) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="">              cast<Instruction>(Op)->getOpcode() != Opcode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">              || (isa<FPMathOperator>(Op) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">                  !hasFPAssociativeFlags(cast<Instruction>(Op)))) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">             "Should have been handled above!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">      assert(Op->hasOneUse() && "Has uses outside the expression tree!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">      // If this is a multiply expression, turn any internal negations into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">      // multiplies by -1 so they can be reassociated.  Add any users of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">      // newly created multiplication by -1 to the redo list, so any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">      // reassociation opportunities that are exposed will be reassociated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">      // further.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">      Instruction *Neg;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="uncoveredLine">      if (((Opcode == Instruction::Mul && match(Op, m_Neg(m_Value()))) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="uncoveredLine">           (Opcode == Instruction::FMul && match(Op, m_FNeg(m_Value())))) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="uncoveredLine">           match(Op, m_Instruction(Neg))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">                   << "MORPH LEAF: " << *Op << " (" << Weight << ") TO ");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">        Instruction *Mul = LowerNegateToMultiply(Neg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << *Mul << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">        Worklist.push_back(std::make_pair(Mul, Weight));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="uncoveredLine">        for (User *U : Mul->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="uncoveredLine">          if (BinaryOperator *UserBO = dyn_cast<BinaryOperator>(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="uncoveredLine">            ToRedo.insert(UserBO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="uncoveredLine">        ToRedo.insert(Neg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="uncoveredLine">        Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">      // Failed to morph into an expression of the right type.  This really is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">      // a leaf.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "ADD LEAF: " << *Op << " (" << Weight << ")\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="uncoveredLine">      assert(!isReassociableOp(Op, Opcode) && "Value was morphed?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">      LeafOrder.push_back(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="uncoveredLine">      Leaves[Op] = Weight;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="">  // The leaves, repeated according to their weights, represent the linearized</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">  // form of the expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="uncoveredLine">  for (Value *V : LeafOrder) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="uncoveredLine">    LeafMap::iterator It = Leaves.find(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="uncoveredLine">    if (It == Leaves.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">      // Node initially thought to be a leaf wasn't.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="uncoveredLine">    assert(!isReassociableOp(V, Opcode) && "Shouldn't be a leaf!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="uncoveredLine">    APInt Weight = It->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="uncoveredLine">    if (Weight.isMinValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">      // Leaf already output or weight reduction eliminated it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">    // Ensure the leaf is only output once.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="uncoveredLine">    It->second = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">    Ops.push_back(std::make_pair(V, Weight));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">  // For nilpotent operations or addition there may be no operands, for example</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">  // because the expression was "X xor X" or consisted of 2^Bitwidth additions:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">  // in both cases the weight reduces to 0 causing the value to be skipped.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="uncoveredLine">  if (Ops.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="uncoveredLine">    Constant *Identity = ConstantExpr::getBinOpIdentity(Opcode, I->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">    assert(Identity && "Associative operation without identity!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="uncoveredLine">    Ops.emplace_back(Identity, APInt(Bitwidth, 1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">/// Now that the operands for this expression tree are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">/// linearized and optimized, emit them in-order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="uncoveredLine">void ReassociatePass::RewriteExprTree(BinaryOperator *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">                                      SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">  assert(Ops.size() > 1 && "Single values should be used directly!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="">  // Since our optimizations should never increase the number of operations, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">  // new expression can usually be written reusing the existing binary operators</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">  // from the original expression tree, without creating any new instructions,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">  // though the rewritten expression may have a completely different topology.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">  // We take care to not change anything if the new expression will be the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">  // as the original.  If more than trivial changes (like commuting operands)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">  // were made then we are obliged to clear out any optional subclass data like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">  // nsw flags.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="">  /// NodesToRewrite - Nodes from the original expression available for writing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">  /// the new expression into.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">  SmallVector<BinaryOperator*, 8> NodesToRewrite;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">  unsigned Opcode = I->getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="uncoveredLine">  BinaryOperator *Op = I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">  /// NotRewritable - The operands being written will be the leaves of the new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">  /// expression and must not be used as inner nodes (via NodesToRewrite) by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">  /// mistake.  Inner nodes are always reassociable, and usually leaves are not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">  /// (if they were they would have been incorporated into the expression and so</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">  /// would not be leaves), so most of the time there is no danger of this.  But</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">  /// in rare cases a leaf may become reassociable if an optimization kills uses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">  /// of it, or it may momentarily become reassociable during rewriting (below)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">  /// due it being removed as an operand of one of its uses.  Ensure that misuse</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">  /// of leaf nodes as inner nodes cannot occur by remembering all of the future</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">  /// leaves and refusing to reuse any of them as inner nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="uncoveredLine">  SmallPtrSet<Value*, 8> NotRewritable;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">    NotRewritable.insert(Ops[i].Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">  // ExpressionChangedStart - Non-null if the rewritten expression differs from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">  // the original in some non-trivial way, requiring the clearing of optional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">  // flags. Flags are cleared from the operator in ExpressionChangedStart up to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">  // ExpressionChangedEnd inclusive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="uncoveredLine">  BinaryOperator *ExpressionChangedStart = nullptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="uncoveredLine">                 *ExpressionChangedEnd = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="uncoveredLine">  for (unsigned i = 0; ; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">    // The last operation (which comes earliest in the IR) is special as both</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">    // operands will come from Ops, rather than just one with the other being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="">    // a subexpression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">    if (i+2 == Ops.size()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">      Value *NewLHS = Ops[i].Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="uncoveredLine">      Value *NewRHS = Ops[i+1].Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">      Value *OldLHS = Op->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="uncoveredLine">      Value *OldRHS = Op->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="uncoveredLine">      if (NewLHS == OldLHS && NewRHS == OldRHS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">        // Nothing changed, leave it alone.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">      if (NewLHS == OldRHS && NewRHS == OldLHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">        // The order of the operands was reversed.  Swap them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="uncoveredLine">        Op->swapOperands();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="uncoveredLine">        MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">        ++NumChanged;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="">      // The new operation differs non-trivially from the original. Overwrite</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">      // the old operands with the new ones.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="uncoveredLine">      if (NewLHS != OldLHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="uncoveredLine">        BinaryOperator *BO = isReassociableOp(OldLHS, Opcode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="uncoveredLine">        if (BO && !NotRewritable.count(BO))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="uncoveredLine">          NodesToRewrite.push_back(BO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">        Op->setOperand(0, NewLHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="uncoveredLine">      if (NewRHS != OldRHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">        BinaryOperator *BO = isReassociableOp(OldRHS, Opcode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="uncoveredLine">        if (BO && !NotRewritable.count(BO))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="uncoveredLine">          NodesToRewrite.push_back(BO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="uncoveredLine">        Op->setOperand(1, NewRHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="uncoveredLine">      ExpressionChangedStart = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">      if (!ExpressionChangedEnd)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="uncoveredLine">        ExpressionChangedEnd = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">      MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">      ++NumChanged;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">    // Not the last operation.  The left-hand side will be a sub-expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">    // while the right-hand side will be the current element of Ops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="uncoveredLine">    Value *NewRHS = Ops[i].Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="uncoveredLine">    if (NewRHS != Op->getOperand(1)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="uncoveredLine">      if (NewRHS == Op->getOperand(0)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">        // The new right-hand side was already present as the left operand.  If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">        // we are lucky then swapping the operands will sort out both of them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="uncoveredLine">        Op->swapOperands();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">        // Overwrite with the new right-hand side.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="uncoveredLine">        BinaryOperator *BO = isReassociableOp(Op->getOperand(1), Opcode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="uncoveredLine">        if (BO && !NotRewritable.count(BO))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">          NodesToRewrite.push_back(BO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="uncoveredLine">        Op->setOperand(1, NewRHS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="uncoveredLine">        ExpressionChangedStart = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="uncoveredLine">        if (!ExpressionChangedEnd)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="uncoveredLine">          ExpressionChangedEnd = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="uncoveredLine">      MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">      ++NumChanged;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">    // Now deal with the left-hand side.  If this is already an operation node</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">    // from the original expression then just rewrite the rest of the expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">    // into it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">    BinaryOperator *BO = isReassociableOp(Op->getOperand(0), Opcode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">    if (BO && !NotRewritable.count(BO)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="uncoveredLine">      Op = BO;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">    // Otherwise, grab a spare node from the original expression and use that as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">    // the left-hand side.  If there are no nodes left then the optimizers made</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">    // an expression with more nodes than the original!  This usually means that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">    // they did something stupid but it might mean that the problem was just too</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">    // hard (finding the mimimal number of multiplications needed to realize a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">    // multiplication expression is NP-complete).  Whatever the reason, smart or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="">    // stupid, create a new node if there are none left.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">    BinaryOperator *NewOp;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">    if (NodesToRewrite.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="uncoveredLine">      Constant *Undef = UndefValue::get(I->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="uncoveredLine">      NewOp = BinaryOperator::Create(Instruction::BinaryOps(Opcode),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">                                     Undef, Undef, "", I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="uncoveredLine">      if (isa<FPMathOperator>(NewOp))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="uncoveredLine">        NewOp->setFastMathFlags(I->getFastMathFlags());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="uncoveredLine">      NewOp = NodesToRewrite.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="uncoveredLine">    Op->setOperand(0, NewOp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">    ExpressionChangedStart = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="uncoveredLine">    if (!ExpressionChangedEnd)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="uncoveredLine">      ExpressionChangedEnd = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="uncoveredLine">    MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">    ++NumChanged;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="uncoveredLine">    Op = NewOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">  // If the expression changed non-trivially then clear out all subclass data</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">  // starting from the operator specified in ExpressionChanged, and compactify</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">  // the operators to just before the expression root to guarantee that the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">  // expression tree is dominated by all of Ops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="uncoveredLine">  if (ExpressionChangedStart) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="uncoveredLine">    bool ClearFlags = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="">    do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">      // Preserve FastMathFlags.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="uncoveredLine">      if (ClearFlags) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="uncoveredLine">        if (isa<FPMathOperator>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="uncoveredLine">          FastMathFlags Flags = I->getFastMathFlags();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">          ExpressionChangedStart->clearSubclassOptionalData();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="uncoveredLine">          ExpressionChangedStart->setFastMathFlags(Flags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">        } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">          ExpressionChangedStart->clearSubclassOptionalData();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="uncoveredLine">      if (ExpressionChangedStart == ExpressionChangedEnd)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="uncoveredLine">        ClearFlags = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">      if (ExpressionChangedStart == I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">      // Discard any debug info related to the expressions that has changed (we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="">      // can leave debug info related to the root and any operation that didn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="">      // change, since the result of the expression tree should be the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="">      // even after reassociation).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="uncoveredLine">      if (ClearFlags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="uncoveredLine">        replaceDbgUsesWithUndef(ExpressionChangedStart);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="uncoveredLine">      ExpressionChangedStart->moveBefore(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">      ExpressionChangedStart =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="uncoveredLine">          cast<BinaryOperator>(*ExpressionChangedStart->user_begin());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">    } while (true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">  // Throw away any left over nodes from the original expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = NodesToRewrite.size(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="uncoveredLine">    RedoInsts.insert(NodesToRewrite[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="">/// Insert instructions before the instruction pointed to by BI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">/// that computes the negative version of the value specified.  The negative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">/// version of the value is returned, and BI is left pointing at the instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">/// that should be processed next by the reassociation pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">/// Also add intermediate instructions to the redo list that are modified while</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">/// pushing the negates through adds.  These will be revisited to see if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="">/// additional opportunities have been exposed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="uncoveredLine">static Value *NegateValue(Value *V, Instruction *BI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">                          ReassociatePass::OrderedSet &ToRedo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="uncoveredLine">  if (auto *C = dyn_cast<Constant>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="uncoveredLine">    const DataLayout &DL = BI->getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="uncoveredLine">    Constant *Res = C->getType()->isFPOrFPVectorTy()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="uncoveredLine">                        ? ConstantFoldUnaryOpOperand(Instruction::FNeg, C, DL)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="uncoveredLine">                        : ConstantExpr::getNeg(C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="uncoveredLine">    if (Res)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">      return Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">  // We are trying to expose opportunity for reassociation.  One of the things</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="">  // that we want to do to achieve this is to push a negation as deep into an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">  // expression chain as possible, to expose the add instructions.  In practice,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">  // this means that we turn this:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="">  //   X = -(A+12+C+D)   into    X = -A + -12 + -C + -D = -12 + -A + -C + -D</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">  // so that later, a: Y = 12+X could get reassociated with the -12 to eliminate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="">  // the constants.  We assume that instcombine will clean up the mess later if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">  // we introduce tons of unnecessary negation instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">  if (BinaryOperator *I =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">          isReassociableOp(V, Instruction::Add, Instruction::FAdd)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">    // Push the negates through the add.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">    I->setOperand(0, NegateValue(I->getOperand(0), BI, ToRedo));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">    I->setOperand(1, NegateValue(I->getOperand(1), BI, ToRedo));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="uncoveredLine">    if (I->getOpcode() == Instruction::Add) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="uncoveredLine">      I->setHasNoUnsignedWrap(false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="uncoveredLine">      I->setHasNoSignedWrap(false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">    // We must move the add instruction here, because the neg instructions do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">    // not dominate the old add instruction in general.  By moving it, we are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">    // assured that the neg instructions we just inserted dominate the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">    // instruction we are about to insert after them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="uncoveredLine">    I->moveBefore(BI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="uncoveredLine">    I->setName(I->getName()+".neg");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">    // Add the intermediate negates to the redo list as processing them later</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">    // could expose more reassociating opportunities.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="uncoveredLine">    ToRedo.insert(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="uncoveredLine">    return I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">  // Okay, we need to materialize a negated version of V with an instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="">  // Scan the use lists of V to see if we have one already.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="uncoveredLine">  for (User *U : V->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="uncoveredLine">    if (!match(U, m_Neg(m_Value())) && !match(U, m_FNeg(m_Value())))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">    // We found one!  Now we have to make sure that the definition dominates</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">    // this use.  We do this by moving it to the entry block (if it is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">    // non-instruction value) or right after the definition.  These negates will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">    // be zapped by reassociate later, so we don't need much finesse here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">    Instruction *TheNeg = dyn_cast<Instruction>(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="">    // We can't safely propagate a vector zero constant with poison/undef lanes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">    Constant *C;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="uncoveredLine">    if (match(TheNeg, m_BinOp(m_Constant(C), m_Value())) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="uncoveredLine">        C->containsUndefOrPoisonElement())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="">    // Verify that the negate is in this function, V might be a constant expr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">    if (!TheNeg ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">        TheNeg->getParent()->getParent() != BI->getParent()->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="">    Instruction *InsertPt;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">    if (Instruction *InstInput = dyn_cast<Instruction>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="uncoveredLine">      InsertPt = InstInput->getInsertionPointAfterDef();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="uncoveredLine">      if (!InsertPt)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="uncoveredLine">      InsertPt = &*TheNeg->getFunction()->getEntryBlock().begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="uncoveredLine">    TheNeg->moveBefore(InsertPt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="uncoveredLine">    if (TheNeg->getOpcode() == Instruction::Sub) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="uncoveredLine">      TheNeg->setHasNoUnsignedWrap(false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="uncoveredLine">      TheNeg->setHasNoSignedWrap(false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="uncoveredLine">      TheNeg->andIRFlags(BI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="uncoveredLine">    ToRedo.insert(TheNeg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="uncoveredLine">    return TheNeg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">  // Insert a 'neg' instruction that subtracts the value from zero to get the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="">  // negation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">  Instruction *NewNeg = CreateNeg(V, V->getName() + ".neg", BI, BI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">  ToRedo.insert(NewNeg);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="uncoveredLine">  return NewNeg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">// See if this `or` looks like an load widening reduction, i.e. that it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">// consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="">// ensure that the pattern is *really* a load widening reduction,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">// we do not ensure that it can really be replaced with a widened load,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">// only that it mostly looks like one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="uncoveredLine">static bool isLoadCombineCandidate(Instruction *Or) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="uncoveredLine">  SmallVector<Instruction *, 8> Worklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="uncoveredLine">  SmallSet<Instruction *, 8> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="uncoveredLine">  auto Enqueue = [&](Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">    auto *I = dyn_cast<Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">    // Each node of an `or` reduction must be an instruction,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="uncoveredLine">    if (!I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="uncoveredLine">      return false; // Node is certainly not part of an `or` load reduction.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="">    // Only process instructions we have never processed before.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="uncoveredLine">    if (Visited.insert(I).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="uncoveredLine">      Worklist.emplace_back(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="uncoveredLine">    return true; // Will need to look at parent nodes.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="uncoveredLine">  if (!Enqueue(Or))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="uncoveredLine">    return false; // Not an `or` reduction pattern.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="uncoveredLine">    auto *I = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="">    // Okay, which instruction is this node?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="uncoveredLine">    switch (I->getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="uncoveredLine">    case Instruction::Or:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">      // Got an `or` node. That's fine, just recurse into it's operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="uncoveredLine">      for (Value *Op : I->operands())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="uncoveredLine">        if (!Enqueue(Op))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="uncoveredLine">          return false; // Not an `or` reduction pattern.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="uncoveredLine">    case Instruction::Shl:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="">    case Instruction::ZExt:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">      // `shl`/`zext` nodes are fine, just recurse into their base operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">      if (!Enqueue(I->getOperand(0)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">        return false; // Not an `or` reduction pattern.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="uncoveredLine">    case Instruction::Load:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">      // Perfect, `load` node means we've reached an edge of the graph.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="uncoveredLine">    default:        // Unknown node.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="uncoveredLine">      return false; // Not an `or` reduction pattern.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="">/// Return true if it may be profitable to convert this (X|Y) into (X+Y).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="uncoveredLine">static bool shouldConvertOrWithNoCommonBitsToAdd(Instruction *Or) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">  // Don't bother to convert this up unless either the LHS is an associable add</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">  // or subtract or mul or if this is only used by one of the above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="">  // This is only a compile-time improvement, it is not needed for correctness!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="uncoveredLine">  auto isInteresting = [](Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="uncoveredLine">    for (auto Op : {Instruction::Add, Instruction::Sub, Instruction::Mul,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="uncoveredLine">                    Instruction::Shl})</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="uncoveredLine">      if (isReassociableOp(V, Op))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">  if (any_of(Or->operands(), isInteresting))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="uncoveredLine">  Value *VB = Or->user_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="uncoveredLine">  if (Or->hasOneUse() && isInteresting(VB))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">/// If we have (X|Y), and iff X and Y have no common bits set,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">/// transform this into (X+Y) to allow arithmetics reassociation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="uncoveredLine">static BinaryOperator *convertOrWithNoCommonBitsToAdd(Instruction *Or) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="">  // Convert an or into an add.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="">  BinaryOperator *New =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="uncoveredLine">      CreateAdd(Or->getOperand(0), Or->getOperand(1), "", Or, Or);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="uncoveredLine">  New->setHasNoSignedWrap();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="uncoveredLine">  New->setHasNoUnsignedWrap();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="uncoveredLine">  New->takeName(Or);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">  // Everyone now refers to the add instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">  Or->replaceAllUsesWith(New);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="uncoveredLine">  New->setDebugLoc(Or->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Converted or into an add: " << *New << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="uncoveredLine">  return New;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">/// Return true if we should break up this subtract of X-Y into (X + -Y).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="uncoveredLine">static bool ShouldBreakUpSubtract(Instruction *Sub) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">  // If this is a negation, we can't split it up!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="uncoveredLine">  if (match(Sub, m_Neg(m_Value())) || match(Sub, m_FNeg(m_Value()))) </td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">  // Don't breakup X - undef.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="uncoveredLine">  if (isa<UndefValue>(Sub->getOperand(1)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="">  // Don't bother to break this up unless either the LHS is an associable add or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="">  // subtract or if this is only used by one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="uncoveredLine">  Value *V0 = Sub->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="uncoveredLine">  if (isReassociableOp(V0, Instruction::Add, Instruction::FAdd) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="uncoveredLine">      isReassociableOp(V0, Instruction::Sub, Instruction::FSub))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="uncoveredLine">  Value *V1 = Sub->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="uncoveredLine">  if (isReassociableOp(V1, Instruction::Add, Instruction::FAdd) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="uncoveredLine">      isReassociableOp(V1, Instruction::Sub, Instruction::FSub))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="uncoveredLine">  Value *VB = Sub->user_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="uncoveredLine">  if (Sub->hasOneUse() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="uncoveredLine">      (isReassociableOp(VB, Instruction::Add, Instruction::FAdd) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="uncoveredLine">       isReassociableOp(VB, Instruction::Sub, Instruction::FSub)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="uncoveredLine">  return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">/// If we have (X-Y), and if either X is an add, or if this is only used by an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="">/// add, transform this into (X+(0-Y)) to promote better reassociation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">static BinaryOperator *BreakUpSubtract(Instruction *Sub,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">                                       ReassociatePass::OrderedSet &ToRedo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">  // Convert a subtract into an add and a neg instruction. This allows sub</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">  // instructions to be commuted with other add instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="">  // Calculate the negative value of Operand 1 of the sub instruction,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="">  // and set it as the RHS of the add instruction we just made.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="uncoveredLine">  Value *NegVal = NegateValue(Sub->getOperand(1), Sub, ToRedo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="uncoveredLine">  BinaryOperator *New = CreateAdd(Sub->getOperand(0), NegVal, "", Sub, Sub);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="uncoveredLine">  Sub->setOperand(0, Constant::getNullValue(Sub->getType())); // Drop use of op.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="uncoveredLine">  Sub->setOperand(1, Constant::getNullValue(Sub->getType())); // Drop use of op.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="uncoveredLine">  New->takeName(Sub);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">  // Everyone now refers to the add instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="uncoveredLine">  Sub->replaceAllUsesWith(New);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="uncoveredLine">  New->setDebugLoc(Sub->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Negated: " << *New << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="uncoveredLine">  return New;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="">/// If this is a shift of a reassociable multiply or is used by one, change</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="">/// this into a multiply by a constant to assist with further reassociation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="uncoveredLine">static BinaryOperator *ConvertShiftToMul(Instruction *Shl) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">  Constant *MulCst = ConstantInt::get(Shl->getType(), 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="uncoveredLine">  auto *SA = cast<ConstantInt>(Shl->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="uncoveredLine">  MulCst = ConstantExpr::getShl(MulCst, SA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">  BinaryOperator *Mul =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="uncoveredLine">    BinaryOperator::CreateMul(Shl->getOperand(0), MulCst, "", Shl);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">  Shl->setOperand(0, PoisonValue::get(Shl->getType())); // Drop use of op.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="uncoveredLine">  Mul->takeName(Shl);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">  // Everyone now refers to the mul instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="uncoveredLine">  Shl->replaceAllUsesWith(Mul);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="uncoveredLine">  Mul->setDebugLoc(Shl->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="">  // We can safely preserve the nuw flag in all cases.  It's also safe to turn a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="">  // nuw nsw shl into a nuw nsw mul.  However, nsw in isolation requires special</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">  // handling.  It can be preserved as long as we're not left shifting by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">  // bitwidth - 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="uncoveredLine">  bool NSW = cast<BinaryOperator>(Shl)->hasNoSignedWrap();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="uncoveredLine">  bool NUW = cast<BinaryOperator>(Shl)->hasNoUnsignedWrap();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="uncoveredLine">  unsigned BitWidth = Shl->getType()->getIntegerBitWidth();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="uncoveredLine">  if (NSW && (NUW || SA->getValue().ult(BitWidth - 1)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="uncoveredLine">    Mul->setHasNoSignedWrap(true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="uncoveredLine">  Mul->setHasNoUnsignedWrap(NUW);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="uncoveredLine">  return Mul;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="">/// Scan backwards and forwards among values with the same rank as element i</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="">/// to see if X exists.  If X does not exist, return i.  This is useful when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="">/// scanning for 'x' when we see '-x' because they both get the same rank.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="uncoveredLine">static unsigned FindInOperandList(const SmallVectorImpl<ValueEntry> &Ops,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">                                  unsigned i, Value *X) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="uncoveredLine">  unsigned XRank = Ops[i].Rank;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="uncoveredLine">  unsigned e = Ops.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="uncoveredLine">  for (unsigned j = i+1; j != e && Ops[j].Rank == XRank; ++j) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="uncoveredLine">    if (Ops[j].Op == X)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="uncoveredLine">      return j;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="uncoveredLine">    if (Instruction *I1 = dyn_cast<Instruction>(Ops[j].Op))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="uncoveredLine">      if (Instruction *I2 = dyn_cast<Instruction>(X))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="uncoveredLine">        if (I1->isIdenticalTo(I2))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="uncoveredLine">          return j;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">  // Scan backwards.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="uncoveredLine">  for (unsigned j = i-1; j != ~0U && Ops[j].Rank == XRank; --j) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="uncoveredLine">    if (Ops[j].Op == X)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="uncoveredLine">      return j;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="uncoveredLine">    if (Instruction *I1 = dyn_cast<Instruction>(Ops[j].Op))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="uncoveredLine">      if (Instruction *I2 = dyn_cast<Instruction>(X))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="uncoveredLine">        if (I1->isIdenticalTo(I2))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">          return j;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">  return i;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">/// Emit a tree of add instructions, summing Ops together</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">/// and returning the result.  Insert the tree before I.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="uncoveredLine">static Value *EmitAddTreeOfValues(Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="">                                  SmallVectorImpl<WeakTrackingVH> &Ops) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="uncoveredLine">  if (Ops.size() == 1) return Ops.back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="uncoveredLine">  Value *V1 = Ops.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="uncoveredLine">  Value *V2 = EmitAddTreeOfValues(I, Ops);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="uncoveredLine">  return CreateAdd(V2, V1, "reass.add", I, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">/// If V is an expression tree that is a multiplication sequence,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="">/// and if this sequence contains a multiply by Factor,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">/// remove Factor from the tree and return the new tree.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="uncoveredLine">Value *ReassociatePass::RemoveFactorFromExpression(Value *V, Value *Factor) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">  BinaryOperator *BO = isReassociableOp(V, Instruction::Mul, Instruction::FMul);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="uncoveredLine">  if (!BO)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="uncoveredLine">  SmallVector<RepeatedValue, 8> Tree;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">  MadeChange |= LinearizeExprTree(BO, Tree, RedoInsts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="uncoveredLine">  SmallVector<ValueEntry, 8> Factors;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="uncoveredLine">  Factors.reserve(Tree.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = Tree.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="uncoveredLine">    RepeatedValue E = Tree[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="uncoveredLine">    Factors.append(E.second.getZExtValue(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="">                   ValueEntry(getRank(E.first), E.first));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">  bool FoundFactor = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="uncoveredLine">  bool NeedsNegate = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = Factors.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="uncoveredLine">    if (Factors[i].Op == Factor) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="uncoveredLine">      FoundFactor = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="uncoveredLine">      Factors.erase(Factors.begin()+i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">    // If this is a negative version of this factor, remove it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">    if (ConstantInt *FC1 = dyn_cast<ConstantInt>(Factor)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="uncoveredLine">      if (ConstantInt *FC2 = dyn_cast<ConstantInt>(Factors[i].Op))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="uncoveredLine">        if (FC1->getValue() == -FC2->getValue()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">          FoundFactor = NeedsNegate = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="uncoveredLine">          Factors.erase(Factors.begin()+i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="uncoveredLine">    } else if (ConstantFP *FC1 = dyn_cast<ConstantFP>(Factor)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="uncoveredLine">      if (ConstantFP *FC2 = dyn_cast<ConstantFP>(Factors[i].Op)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="uncoveredLine">        const APFloat &F1 = FC1->getValueAPF();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="uncoveredLine">        APFloat F2(FC2->getValueAPF());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="uncoveredLine">        F2.changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">        if (F1 == F2) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">          FoundFactor = NeedsNegate = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="uncoveredLine">          Factors.erase(Factors.begin() + i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="uncoveredLine">  if (!FoundFactor) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">    // Make sure to restore the operands to the expression tree.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="uncoveredLine">    RewriteExprTree(BO, Factors);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="uncoveredLine">  BasicBlock::iterator InsertPt = ++BO->getIterator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="">  // If this was just a single multiply, remove the multiply and return the only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">  // remaining operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="uncoveredLine">  if (Factors.size() == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="uncoveredLine">    RedoInsts.insert(BO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="uncoveredLine">    V = Factors[0].Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="uncoveredLine">    RewriteExprTree(BO, Factors);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="uncoveredLine">    V = BO;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">  if (NeedsNegate)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="uncoveredLine">    V = CreateNeg(V, "neg", &*InsertPt, BO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="uncoveredLine">  return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="">/// If V is a single-use multiply, recursively add its operands as factors,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="">/// otherwise add V to the list of factors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">/// Ops is the top-level list of add operands we're trying to factor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="uncoveredLine">static void FindSingleUseMultiplyFactors(Value *V,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">                                         SmallVectorImpl<Value*> &Factors) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="uncoveredLine">  BinaryOperator *BO = isReassociableOp(V, Instruction::Mul, Instruction::FMul);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="uncoveredLine">  if (!BO) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="uncoveredLine">    Factors.push_back(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">  // Otherwise, add the LHS and RHS to the list of factors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="uncoveredLine">  FindSingleUseMultiplyFactors(BO->getOperand(1), Factors);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="uncoveredLine">  FindSingleUseMultiplyFactors(BO->getOperand(0), Factors);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="">/// This optimizes based on identities.  If it can be reduced to a single Value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">/// it is returned, otherwise the Ops list is mutated as necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="uncoveredLine">static Value *OptimizeAndOrXor(unsigned Opcode,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">                               SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">  // Scan the operand lists looking for X and ~X pairs, along with X,X pairs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="">  // If we find any, we can simplify the expression. X&~X == 0, X|~X == -1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="">    // First, check for X and ~X in the operand list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="uncoveredLine">    assert(i < Ops.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">    Value *X;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="uncoveredLine">    if (match(Ops[i].Op, m_Not(m_Value(X)))) {    // Cannot occur for ^.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="uncoveredLine">      unsigned FoundX = FindInOperandList(Ops, i, X);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">      if (FoundX != i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="uncoveredLine">        if (Opcode == Instruction::And)   // ...&X&~X = 0</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="uncoveredLine">          return Constant::getNullValue(X->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="uncoveredLine">        if (Opcode == Instruction::Or)    // ...|X|~X = -1</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">          return Constant::getAllOnesValue(X->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">    // Next, check for duplicate pairs of values, which we assume are next to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">    // each other, due to our sorting criteria.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="uncoveredLine">    assert(i < Ops.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="uncoveredLine">    if (i+1 != Ops.size() && Ops[i+1].Op == Ops[i].Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="uncoveredLine">      if (Opcode == Instruction::And || Opcode == Instruction::Or) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">        // Drop duplicate values for And and Or.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="uncoveredLine">        Ops.erase(Ops.begin()+i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="uncoveredLine">        --i; --e;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="uncoveredLine">        ++NumAnnihil;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">      // Drop pairs of values for Xor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="uncoveredLine">      assert(Opcode == Instruction::Xor);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="uncoveredLine">      if (e == 2)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="uncoveredLine">        return Constant::getNullValue(Ops[0].Op->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">      // Y ^ X^X -> Y</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="uncoveredLine">      Ops.erase(Ops.begin()+i, Ops.begin()+i+2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="uncoveredLine">      i -= 1; e -= 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="uncoveredLine">      ++NumAnnihil;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">/// Helper function of CombineXorOpnd(). It creates a bitwise-and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">/// instruction with the given two operands, and return the resulting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="">/// instruction. There are two special cases: 1) if the constant operand is 0,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="">/// it will return NULL. 2) if the constant is ~0, the symbolic operand will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">/// be returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="uncoveredLine">static Value *createAndInstr(Instruction *InsertBefore, Value *Opnd,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">                             const APInt &ConstOpnd) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="uncoveredLine">  if (ConstOpnd.isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="uncoveredLine">  if (ConstOpnd.isAllOnes())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="uncoveredLine">    return Opnd;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="uncoveredLine">  Instruction *I = BinaryOperator::CreateAnd(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="uncoveredLine">      Opnd, ConstantInt::get(Opnd->getType(), ConstOpnd), "and.ra",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">      InsertBefore);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="uncoveredLine">  I->setDebugLoc(InsertBefore->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="uncoveredLine">  return I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">// Helper function of OptimizeXor(). It tries to simplify "Opnd1 ^ ConstOpnd"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">// into "R ^ C", where C would be 0, and R is a symbolic value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="">// If it was successful, true is returned, and the "R" and "C" is returned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="">// via "Res" and "ConstOpnd", respectively; otherwise, false is returned,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">// and both "Res" and "ConstOpnd" remain unchanged.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="uncoveredLine">bool ReassociatePass::CombineXorOpnd(Instruction *I, XorOpnd *Opnd1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="">                                     APInt &ConstOpnd, Value *&Res) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="">  // Xor-Rule 1: (x | c1) ^ c2 = (x | c1) ^ (c1 ^ c1) ^ c2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">  //                       = ((x | c1) ^ c1) ^ (c1 ^ c2)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">  //                       = (x & ~c1) ^ (c1 ^ c2)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="">  // It is useful only when c1 == c2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="uncoveredLine">  if (!Opnd1->isOrExpr() || Opnd1->getConstPart().isZero())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="uncoveredLine">  if (!Opnd1->getValue()->hasOneUse())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="uncoveredLine">  const APInt &C1 = Opnd1->getConstPart();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="uncoveredLine">  if (C1 != ConstOpnd)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="uncoveredLine">  Value *X = Opnd1->getSymbolicPart();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="uncoveredLine">  Res = createAndInstr(I, X, ~C1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="">  // ConstOpnd was C2, now C1 ^ C2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="uncoveredLine">  ConstOpnd ^= C1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">  if (Instruction *T = dyn_cast<Instruction>(Opnd1->getValue()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="uncoveredLine">    RedoInsts.insert(T);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="">// Helper function of OptimizeXor(). It tries to simplify</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="">// "Opnd1 ^ Opnd2 ^ ConstOpnd" into "R ^ C", where C would be 0, and R is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="">// symbolic value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="">// If it was successful, true is returned, and the "R" and "C" is returned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="">// via "Res" and "ConstOpnd", respectively (If the entire expression is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="">// evaluated to a constant, the Res is set to NULL); otherwise, false is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="">// returned, and both "Res" and "ConstOpnd" remain unchanged.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="uncoveredLine">bool ReassociatePass::CombineXorOpnd(Instruction *I, XorOpnd *Opnd1,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="">                                     XorOpnd *Opnd2, APInt &ConstOpnd,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">                                     Value *&Res) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="uncoveredLine">  Value *X = Opnd1->getSymbolicPart();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="uncoveredLine">  if (X != Opnd2->getSymbolicPart())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="">  // This many instruction become dead.(At least "Opnd1 ^ Opnd2" will die.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="uncoveredLine">  int DeadInstNum = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="uncoveredLine">  if (Opnd1->getValue()->hasOneUse())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="uncoveredLine">    DeadInstNum++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="uncoveredLine">  if (Opnd2->getValue()->hasOneUse())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="uncoveredLine">    DeadInstNum++;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="">  // Xor-Rule 2:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">  //  (x | c1) ^ (x & c2)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="">  //   = (x|c1) ^ (x&c2) ^ (c1 ^ c1) = ((x|c1) ^ c1) ^ (x & c2) ^ c1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="">  //   = (x & ~c1) ^ (x & c2) ^ c1               // Xor-Rule 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">  //   = (x & c3) ^ c1, where c3 = ~c1 ^ c2      // Xor-rule 3</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="uncoveredLine">  if (Opnd1->isOrExpr() != Opnd2->isOrExpr()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="uncoveredLine">    if (Opnd2->isOrExpr())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="uncoveredLine">      std::swap(Opnd1, Opnd2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="uncoveredLine">    const APInt &C1 = Opnd1->getConstPart();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="uncoveredLine">    const APInt &C2 = Opnd2->getConstPart();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="uncoveredLine">    APInt C3((~C1) ^ C2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">    // Do not increase code size!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="uncoveredLine">    if (!C3.isZero() && !C3.isAllOnes()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="uncoveredLine">      int NewInstNum = ConstOpnd.getBoolValue() ? 1 : 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="uncoveredLine">      if (NewInstNum > DeadInstNum)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="uncoveredLine">    Res = createAndInstr(I, X, C3);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="uncoveredLine">    ConstOpnd ^= C1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="uncoveredLine">  } else if (Opnd1->isOrExpr()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="">    // Xor-Rule 3: (x | c1) ^ (x | c2) = (x & c3) ^ c3 where c3 = c1 ^ c2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="uncoveredLine">    const APInt &C1 = Opnd1->getConstPart();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="uncoveredLine">    const APInt &C2 = Opnd2->getConstPart();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="uncoveredLine">    APInt C3 = C1 ^ C2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">    // Do not increase code size</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="uncoveredLine">    if (!C3.isZero() && !C3.isAllOnes()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="uncoveredLine">      int NewInstNum = ConstOpnd.getBoolValue() ? 1 : 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="uncoveredLine">      if (NewInstNum > DeadInstNum)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="uncoveredLine">    Res = createAndInstr(I, X, C3);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="uncoveredLine">    ConstOpnd ^= C3;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="uncoveredLine">  } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="">    // Xor-Rule 4: (x & c1) ^ (x & c2) = (x & (c1^c2))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="uncoveredLine">    const APInt &C1 = Opnd1->getConstPart();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="uncoveredLine">    const APInt &C2 = Opnd2->getConstPart();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="uncoveredLine">    APInt C3 = C1 ^ C2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="uncoveredLine">    Res = createAndInstr(I, X, C3);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="">  // Put the original operands in the Redo list; hope they will be deleted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">  // as dead code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="uncoveredLine">  if (Instruction *T = dyn_cast<Instruction>(Opnd1->getValue()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="uncoveredLine">    RedoInsts.insert(T);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="uncoveredLine">  if (Instruction *T = dyn_cast<Instruction>(Opnd2->getValue()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="uncoveredLine">    RedoInsts.insert(T);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="">/// Optimize a series of operands to an 'xor' instruction. If it can be reduced</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="">/// to a single Value, it is returned, otherwise the Ops list is mutated as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="">/// necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="uncoveredLine">Value *ReassociatePass::OptimizeXor(Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="uncoveredLine">  if (Value *V = OptimizeAndOrXor(Instruction::Xor, Ops))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="uncoveredLine">  if (Ops.size() == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="uncoveredLine">  SmallVector<XorOpnd, 8> Opnds;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="uncoveredLine">  SmallVector<XorOpnd*, 8> OpndPtrs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="uncoveredLine">  Type *Ty = Ops[0].Op->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="uncoveredLine">  APInt ConstOpnd(Ty->getScalarSizeInBits(), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="">  // Step 1: Convert ValueEntry to XorOpnd</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="uncoveredLine">    Value *V = Ops[i].Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="">    const APInt *C;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="">    // TODO: Support non-splat vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="uncoveredLine">    if (match(V, m_APInt(C))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="uncoveredLine">      ConstOpnd ^= *C;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="uncoveredLine">      XorOpnd O(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">      O.setSymbolicRank(getRank(O.getSymbolicPart()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="uncoveredLine">      Opnds.push_back(O);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="">  // NOTE: From this point on, do *NOT* add/delete element to/from "Opnds".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="">  //  It would otherwise invalidate the "Opnds"'s iterator, and hence invalidate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">  //  the "OpndPtrs" as well. For the similar reason, do not fuse this loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="">  //  with the previous loop --- the iterator of the "Opnds" may be invalidated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="">  //  when new elements are added to the vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = Opnds.size(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="uncoveredLine">    OpndPtrs.push_back(&Opnds[i]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="">  // Step 2: Sort the Xor-Operands in a way such that the operands containing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="">  //  the same symbolic value cluster together. For instance, the input operand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="">  //  sequence ("x | 123", "y & 456", "x & 789") will be sorted into:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="">  //  ("x | 123", "x & 789", "y & 456").</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="">  //  The purpose is twofold:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="">  //  1) Cluster together the operands sharing the same symbolic-value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="">  //  2) Operand having smaller symbolic-value-rank is permuted earlier, which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="">  //     could potentially shorten crital path, and expose more loop-invariants.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="">  //     Note that values' rank are basically defined in RPO order (FIXME).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="">  //     So, if Rank(X) < Rank(Y) < Rank(Z), it means X is defined earlier</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="">  //     than Y which is defined earlier than Z. Permute "x | 1", "Y & 2",</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="">  //     "z" in the order of X-Y-Z is better than any other orders.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="uncoveredLine">  llvm::stable_sort(OpndPtrs, [](XorOpnd *LHS, XorOpnd *RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="uncoveredLine">    return LHS->getSymbolicRank() < RHS->getSymbolicRank();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="">  // Step 3: Combine adjacent operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="uncoveredLine">  XorOpnd *PrevOpnd = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = Opnds.size(); i < e; i++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">    XorOpnd *CurrOpnd = OpndPtrs[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">    // The combined value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="">    Value *CV;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="">    // Step 3.1: Try simplifying "CurrOpnd ^ ConstOpnd"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="uncoveredLine">    if (!ConstOpnd.isZero() && CombineXorOpnd(I, CurrOpnd, ConstOpnd, CV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="uncoveredLine">      Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="uncoveredLine">      if (CV)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="uncoveredLine">        *CurrOpnd = XorOpnd(CV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="">      else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="uncoveredLine">        CurrOpnd->Invalidate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="uncoveredLine">    if (!PrevOpnd || CurrOpnd->getSymbolicPart() != PrevOpnd->getSymbolicPart()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="uncoveredLine">      PrevOpnd = CurrOpnd;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="">    // step 3.2: When previous and current operands share the same symbolic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">    //  value, try to simplify "PrevOpnd ^ CurrOpnd ^ ConstOpnd"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="uncoveredLine">    if (CombineXorOpnd(I, CurrOpnd, PrevOpnd, ConstOpnd, CV)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="">      // Remove previous operand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="uncoveredLine">      PrevOpnd->Invalidate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="uncoveredLine">      if (CV) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="uncoveredLine">        *CurrOpnd = XorOpnd(CV);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="uncoveredLine">        PrevOpnd = CurrOpnd;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="uncoveredLine">        CurrOpnd->Invalidate();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="uncoveredLine">        PrevOpnd = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="uncoveredLine">      Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="">  // Step 4: Reassemble the Ops</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="uncoveredLine">  if (Changed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="uncoveredLine">    Ops.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="uncoveredLine">    for (const XorOpnd &O : Opnds) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="uncoveredLine">      if (O.isInvalid())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="uncoveredLine">      ValueEntry VE(getRank(O.getValue()), O.getValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="uncoveredLine">      Ops.push_back(VE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="uncoveredLine">    if (!ConstOpnd.isZero()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">      Value *C = ConstantInt::get(Ty, ConstOpnd);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="uncoveredLine">      ValueEntry VE(getRank(C), C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="uncoveredLine">      Ops.push_back(VE);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="uncoveredLine">    unsigned Sz = Ops.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="uncoveredLine">    if (Sz == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="uncoveredLine">      return Ops.back().Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="uncoveredLine">    if (Sz == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="uncoveredLine">      assert(ConstOpnd.isZero());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="uncoveredLine">      return ConstantInt::get(Ty, ConstOpnd);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="">/// Optimize a series of operands to an 'add' instruction.  This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="">/// optimizes based on identities.  If it can be reduced to a single Value, it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">/// is returned, otherwise the Ops list is mutated as necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="uncoveredLine">Value *ReassociatePass::OptimizeAdd(Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="">  // Scan the operand lists looking for X and -X pairs.  If we find any, we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="">  // can simplify expressions like X+-X == 0 and X+~X ==-1.  While we're at it,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="">  // scan for any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="">  // duplicates.  We want to canonicalize Y+Y+Y+Z -> 3*Y+Z.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="uncoveredLine">    Value *TheOp = Ops[i].Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="">    // Check to see if we've seen this operand before.  If so, we factor all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="">    // instances of the operand together.  Due to our sorting criteria, we know</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="">    // that these need to be next to each other in the vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="uncoveredLine">    if (i+1 != Ops.size() && Ops[i+1].Op == TheOp) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="">      // Rescan the list, remove all instances of this operand from the expr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="uncoveredLine">      unsigned NumFound = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="">      do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="uncoveredLine">        Ops.erase(Ops.begin()+i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="uncoveredLine">        ++NumFound;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="uncoveredLine">      } while (i != Ops.size() && Ops[i].Op == TheOp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "\nFACTORING [" << NumFound << "]: " << *TheOp</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="">                        << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="uncoveredLine">      ++NumFactor;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="">      // Insert a new multiply.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="uncoveredLine">      Type *Ty = TheOp->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="uncoveredLine">      Constant *C = Ty->isIntOrIntVectorTy() ?</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="uncoveredLine">        ConstantInt::get(Ty, NumFound) : ConstantFP::get(Ty, NumFound);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="uncoveredLine">      Instruction *Mul = CreateMul(TheOp, C, "factor", I, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="">      // Now that we have inserted a multiply, optimize it. This allows us to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="">      // handle cases that require multiple factoring steps, such as this:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="">      // (X*2) + (X*2) + (X*2) -> (X*2)*3 -> X*6</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="uncoveredLine">      RedoInsts.insert(Mul);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="">      // If every add operand was a duplicate, return the multiply.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="uncoveredLine">      if (Ops.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="uncoveredLine">        return Mul;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="">      // Otherwise, we had some input that didn't have the dupe, such as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="">      // "A + A + B" -> "A*2 + B".  Add the new multiply to the list of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="">      // things being added by this operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="uncoveredLine">      Ops.insert(Ops.begin(), ValueEntry(getRank(Mul), Mul));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="uncoveredLine">      --i;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="uncoveredLine">      e = Ops.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="">    // Check for X and -X or X and ~X in the operand list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="">    Value *X;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="uncoveredLine">    if (!match(TheOp, m_Neg(m_Value(X))) && !match(TheOp, m_Not(m_Value(X))) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="uncoveredLine">        !match(TheOp, m_FNeg(m_Value(X))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="uncoveredLine">    unsigned FoundX = FindInOperandList(Ops, i, X);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="uncoveredLine">    if (FoundX == i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="">    // Remove X and -X from the operand list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="uncoveredLine">    if (Ops.size() == 2 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="uncoveredLine">        (match(TheOp, m_Neg(m_Value())) || match(TheOp, m_FNeg(m_Value()))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="uncoveredLine">      return Constant::getNullValue(X->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="">    // Remove X and ~X from the operand list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="uncoveredLine">    if (Ops.size() == 2 && match(TheOp, m_Not(m_Value())))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="uncoveredLine">      return Constant::getAllOnesValue(X->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="uncoveredLine">    Ops.erase(Ops.begin()+i);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="uncoveredLine">    if (i < FoundX)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">      --FoundX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="uncoveredLine">      --i;   // Need to back up an extra one.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="uncoveredLine">    Ops.erase(Ops.begin()+FoundX);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="uncoveredLine">    ++NumAnnihil;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="uncoveredLine">    --i;     // Revisit element.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="uncoveredLine">    e -= 2;  // Removed two elements.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="">    // if X and ~X we append -1 to the operand list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="uncoveredLine">    if (match(TheOp, m_Not(m_Value()))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="uncoveredLine">      Value *V = Constant::getAllOnesValue(X->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="uncoveredLine">      Ops.insert(Ops.end(), ValueEntry(getRank(V), V));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="uncoveredLine">      e += 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="">  // Scan the operand list, checking to see if there are any common factors</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="">  // between operands.  Consider something like A*A+A*B*C+D.  We would like to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="">  // reassociate this to A*(A+B*C)+D, which reduces the number of multiplies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="">  // To efficiently find this, we count the number of times a factor occurs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="">  // for any ADD operands that are MULs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="uncoveredLine">  DenseMap<Value*, unsigned> FactorOccurrences;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="">  // Keep track of each multiply we see, to avoid triggering on (X*4)+(X*4)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="">  // where they are actually the same multiply.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">  unsigned MaxOcc = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="uncoveredLine">  Value *MaxOccVal = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="">    BinaryOperator *BOp =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="uncoveredLine">        isReassociableOp(Ops[i].Op, Instruction::Mul, Instruction::FMul);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="uncoveredLine">    if (!BOp)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="">    // Compute all of the factors of this added value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="uncoveredLine">    SmallVector<Value*, 8> Factors;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="uncoveredLine">    FindSingleUseMultiplyFactors(BOp, Factors);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="uncoveredLine">    assert(Factors.size() > 1 && "Bad linearize!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="">    // Add one to FactorOccurrences for each unique factor in this op.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="uncoveredLine">    SmallPtrSet<Value*, 8> Duplicates;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="uncoveredLine">    for (Value *Factor : Factors) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="uncoveredLine">      if (!Duplicates.insert(Factor).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="uncoveredLine">      unsigned Occ = ++FactorOccurrences[Factor];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="uncoveredLine">      if (Occ > MaxOcc) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="uncoveredLine">        MaxOcc = Occ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="uncoveredLine">        MaxOccVal = Factor;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="">      // If Factor is a negative constant, add the negated value as a factor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="">      // because we can percolate the negate out.  Watch for minint, which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="">      // cannot be positivified.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="uncoveredLine">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Factor)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="uncoveredLine">        if (CI->isNegative() && !CI->isMinValue(true)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="uncoveredLine">          Factor = ConstantInt::get(CI->getContext(), -CI->getValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="uncoveredLine">          if (!Duplicates.insert(Factor).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="uncoveredLine">          unsigned Occ = ++FactorOccurrences[Factor];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="uncoveredLine">          if (Occ > MaxOcc) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="uncoveredLine">            MaxOcc = Occ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="uncoveredLine">            MaxOccVal = Factor;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="uncoveredLine">      } else if (ConstantFP *CF = dyn_cast<ConstantFP>(Factor)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="uncoveredLine">        if (CF->isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="uncoveredLine">          APFloat F(CF->getValueAPF());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="uncoveredLine">          F.changeSign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="uncoveredLine">          Factor = ConstantFP::get(CF->getContext(), F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="uncoveredLine">          if (!Duplicates.insert(Factor).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="uncoveredLine">          unsigned Occ = ++FactorOccurrences[Factor];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="uncoveredLine">          if (Occ > MaxOcc) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="uncoveredLine">            MaxOcc = Occ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="uncoveredLine">            MaxOccVal = Factor;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="uncoveredLine">        }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="">  // If any factor occurred more than one time, we can pull it out.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="uncoveredLine">  if (MaxOcc > 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "\nFACTORING [" << MaxOcc << "]: " << *MaxOccVal</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="">                      << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="uncoveredLine">    ++NumFactor;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="">    // Create a new instruction that uses the MaxOccVal twice.  If we don't do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="">    // this, we could otherwise run into situations where removing a factor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="">    // from an expression will drop a use of maxocc, and this can cause</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="">    // RemoveFactorFromExpression on successive values to behave differently.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">    Instruction *DummyInst =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="uncoveredLine">        I->getType()->isIntOrIntVectorTy()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="uncoveredLine">            ? BinaryOperator::CreateAdd(MaxOccVal, MaxOccVal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="uncoveredLine">            : BinaryOperator::CreateFAdd(MaxOccVal, MaxOccVal);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="uncoveredLine">    SmallVector<WeakTrackingVH, 4> NewMulOps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="uncoveredLine">    for (unsigned i = 0; i != Ops.size(); ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="">      // Only try to remove factors from expressions we're allowed to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="">      BinaryOperator *BOp =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="uncoveredLine">          isReassociableOp(Ops[i].Op, Instruction::Mul, Instruction::FMul);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="uncoveredLine">      if (!BOp)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="uncoveredLine">      if (Value *V = RemoveFactorFromExpression(Ops[i].Op, MaxOccVal)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="">        // The factorized operand may occur several times.  Convert them all in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="">        // one fell swoop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="uncoveredLine">        for (unsigned j = Ops.size(); j != i;) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="uncoveredLine">          --j;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="uncoveredLine">          if (Ops[j].Op == Ops[i].Op) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="uncoveredLine">            NewMulOps.push_back(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="uncoveredLine">            Ops.erase(Ops.begin()+j);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="uncoveredLine">        --i;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="">    // No need for extra uses anymore.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="uncoveredLine">    DummyInst->deleteValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="uncoveredLine">    unsigned NumAddedValues = NewMulOps.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="uncoveredLine">    Value *V = EmitAddTreeOfValues(I, NewMulOps);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="">    // Now that we have inserted the add tree, optimize it. This allows us to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="">    // handle cases that require multiple factoring steps, such as this:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="">    // A*A*B + A*A*C   -->   A*(A*B+A*C)   -->   A*(A*(B+C))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="uncoveredLine">    assert(NumAddedValues > 1 && "Each occurrence should contribute a value");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="">    (void)NumAddedValues;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="uncoveredLine">    if (Instruction *VI = dyn_cast<Instruction>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="uncoveredLine">      RedoInsts.insert(VI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="">    // Create the multiply.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="uncoveredLine">    Instruction *V2 = CreateMul(V, MaxOccVal, "reass.mul", I, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="">    // Rerun associate on the multiply in case the inner expression turned into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="">    // a multiply.  We want to make sure that we keep things in canonical form.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="uncoveredLine">    RedoInsts.insert(V2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="">    // If every add operand included the factor (e.g. "A*B + A*C"), then the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="">    // entire result expression is just the multiply "A*(B+C)".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="uncoveredLine">    if (Ops.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="uncoveredLine">      return V2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="">    // Otherwise, we had some input that didn't have the factor, such as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="">    // "A*B + A*C + D" -> "A*(B+C) + D".  Add the new multiply to the list of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="">    // things being added by this operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="uncoveredLine">    Ops.insert(Ops.begin(), ValueEntry(getRank(V2), V2));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">/// Build up a vector of value/power pairs factoring a product.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="">/// Given a series of multiplication operands, build a vector of factors and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="">/// the powers each is raised to when forming the final product. Sort them in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="">/// the order of descending power.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="">///      (x*x)          -> [(x, 2)]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="">///     ((x*x)*x)       -> [(x, 3)]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="">///   ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="">/// \returns Whether any factors have a power greater than one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="uncoveredLine">static bool collectMultiplyFactors(SmallVectorImpl<ValueEntry> &Ops,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="">                                   SmallVectorImpl<Factor> &Factors) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="">  // FIXME: Have Ops be (ValueEntry, Multiplicity) pairs, simplifying this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="">  // Compute the sum of powers of simplifiable factors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="uncoveredLine">  unsigned FactorPowerSum = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="uncoveredLine">  for (unsigned Idx = 1, Size = Ops.size(); Idx < Size; ++Idx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="uncoveredLine">    Value *Op = Ops[Idx-1].Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="">    // Count the number of occurrences of this value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="uncoveredLine">    unsigned Count = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="uncoveredLine">    for (; Idx < Size && Ops[Idx].Op == Op; ++Idx)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="uncoveredLine">      ++Count;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="">    // Track for simplification all factors which occur 2 or more times.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="uncoveredLine">    if (Count > 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="uncoveredLine">      FactorPowerSum += Count;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="">  // We can only simplify factors if the sum of the powers of our simplifiable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="">  // factors is 4 or higher. When that is the case, we will *always* have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="">  // a simplification. This is an important invariant to prevent cyclicly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="">  // trying to simplify already minimal formations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="uncoveredLine">  if (FactorPowerSum < 4)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="">  // Now gather the simplifiable factors, removing them from Ops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="uncoveredLine">  FactorPowerSum = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="uncoveredLine">  for (unsigned Idx = 1; Idx < Ops.size(); ++Idx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="uncoveredLine">    Value *Op = Ops[Idx-1].Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="">    // Count the number of occurrences of this value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="uncoveredLine">    unsigned Count = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="uncoveredLine">    for (; Idx < Ops.size() && Ops[Idx].Op == Op; ++Idx)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="uncoveredLine">      ++Count;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="uncoveredLine">    if (Count == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="">    // Move an even number of occurrences to Factors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="uncoveredLine">    Count &= ~1U;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="uncoveredLine">    Idx -= Count;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="uncoveredLine">    FactorPowerSum += Count;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="uncoveredLine">    Factors.push_back(Factor(Op, Count));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="uncoveredLine">    Ops.erase(Ops.begin()+Idx, Ops.begin()+Idx+Count);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">  // None of the adjustments above should have reduced the sum of factor powers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="">  // below our mininum of '4'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="uncoveredLine">  assert(FactorPowerSum >= 4);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="uncoveredLine">  llvm::stable_sort(Factors, [](const Factor &LHS, const Factor &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="uncoveredLine">    return LHS.Power > RHS.Power;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="">/// Build a tree of multiplies, computing the product of Ops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="uncoveredLine">static Value *buildMultiplyTree(IRBuilderBase &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="">                                SmallVectorImpl<Value*> &Ops) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="uncoveredLine">  if (Ops.size() == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="uncoveredLine">    return Ops.back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="uncoveredLine">  Value *LHS = Ops.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="">  do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="uncoveredLine">    if (LHS->getType()->isIntOrIntVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="uncoveredLine">      LHS = Builder.CreateMul(LHS, Ops.pop_back_val());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="uncoveredLine">      LHS = Builder.CreateFMul(LHS, Ops.pop_back_val());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="uncoveredLine">  } while (!Ops.empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="uncoveredLine">  return LHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="">/// Build a minimal multiplication DAG for (a^x)*(b^y)*(c^z)*...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="">/// Given a vector of values raised to various powers, where no two values are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="">/// equal and the powers are sorted in decreasing order, compute the minimal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="">/// DAG of multiplies to compute the final product, and return that product</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="">/// value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="">Value *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="uncoveredLine">ReassociatePass::buildMinimalMultiplyDAG(IRBuilderBase &Builder,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="">                                         SmallVectorImpl<Factor> &Factors) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="uncoveredLine">  assert(Factors[0].Power);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="uncoveredLine">  SmallVector<Value *, 4> OuterProduct;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="uncoveredLine">  for (unsigned LastIdx = 0, Idx = 1, Size = Factors.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="uncoveredLine">       Idx < Size && Factors[Idx].Power > 0; ++Idx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="uncoveredLine">    if (Factors[Idx].Power != Factors[LastIdx].Power) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="uncoveredLine">      LastIdx = Idx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="">    // We want to multiply across all the factors with the same power so that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="">    // we can raise them to that power as a single entity. Build a mini tree</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="">    // for that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="uncoveredLine">    SmallVector<Value *, 4> InnerProduct;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="uncoveredLine">    InnerProduct.push_back(Factors[LastIdx].Base);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="">    do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="uncoveredLine">      InnerProduct.push_back(Factors[Idx].Base);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="uncoveredLine">      ++Idx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="uncoveredLine">    } while (Idx < Size && Factors[Idx].Power == Factors[LastIdx].Power);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">    // Reset the base value of the first factor to the new expression tree.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="">    // We'll remove all the factors with the same power in a second pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="uncoveredLine">    Value *M = Factors[LastIdx].Base = buildMultiplyTree(Builder, InnerProduct);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="uncoveredLine">    if (Instruction *MI = dyn_cast<Instruction>(M))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="uncoveredLine">      RedoInsts.insert(MI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="uncoveredLine">    LastIdx = Idx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="">  // Unique factors with equal powers -- we've folded them into the first one's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="">  // base.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="uncoveredLine">  Factors.erase(std::unique(Factors.begin(), Factors.end(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="uncoveredLine">                            [](const Factor &LHS, const Factor &RHS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="uncoveredLine">                              return LHS.Power == RHS.Power;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="">                            }),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="uncoveredLine">                Factors.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="">  // Iteratively collect the base of each factor with an add power into the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="">  // outer product, and halve each power in preparation for squaring the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="">  // expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="uncoveredLine">  for (Factor &F : Factors) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="uncoveredLine">    if (F.Power & 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="uncoveredLine">      OuterProduct.push_back(F.Base);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="uncoveredLine">    F.Power >>= 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="uncoveredLine">  if (Factors[0].Power) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="uncoveredLine">    Value *SquareRoot = buildMinimalMultiplyDAG(Builder, Factors);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="uncoveredLine">    OuterProduct.push_back(SquareRoot);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="uncoveredLine">    OuterProduct.push_back(SquareRoot);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="uncoveredLine">  if (OuterProduct.size() == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="uncoveredLine">    return OuterProduct.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="uncoveredLine">  Value *V = buildMultiplyTree(Builder, OuterProduct);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="uncoveredLine">  return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="uncoveredLine">Value *ReassociatePass::OptimizeMul(BinaryOperator *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="">  // We can only optimize the multiplies when there is a chain of more than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="">  // three, such that a balanced tree might require fewer total multiplies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="uncoveredLine">  if (Ops.size() < 4)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="">  // Try to turn linear trees of multiplies without other uses of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="">  // intermediate stages into minimal multiply DAGs with perfect sub-expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="">  // re-use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="uncoveredLine">  SmallVector<Factor, 4> Factors;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="uncoveredLine">  if (!collectMultiplyFactors(Ops, Factors))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="uncoveredLine">    return nullptr; // All distinct factors, so nothing left for us to do.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="">  // The reassociate transformation for FP operations is performed only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="">  // if unsafe algebra is permitted by FastMathFlags. Propagate those flags</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="">  // to the newly generated operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="uncoveredLine">  if (auto FPI = dyn_cast<FPMathOperator>(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="uncoveredLine">    Builder.setFastMathFlags(FPI->getFastMathFlags());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="uncoveredLine">  Value *V = buildMinimalMultiplyDAG(Builder, Factors);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="uncoveredLine">  if (Ops.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="uncoveredLine">  ValueEntry NewEntry = ValueEntry(getRank(V), V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="uncoveredLine">  Ops.insert(llvm::lower_bound(Ops, NewEntry), NewEntry);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="uncoveredLine">Value *ReassociatePass::OptimizeExpression(BinaryOperator *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="">                                           SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="">  // Now that we have the linearized expression tree, try to optimize it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="">  // Start by folding any constants that we found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="uncoveredLine">  const DataLayout &DL = I->getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="uncoveredLine">  Constant *Cst = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="uncoveredLine">  unsigned Opcode = I->getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="uncoveredLine">  while (!Ops.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="uncoveredLine">    if (auto *C = dyn_cast<Constant>(Ops.back().Op)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="uncoveredLine">      if (!Cst) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="uncoveredLine">        Ops.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="uncoveredLine">        Cst = C;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="uncoveredLine">      if (Constant *Res = ConstantFoldBinaryOpOperands(Opcode, C, Cst, DL)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="uncoveredLine">        Ops.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="uncoveredLine">        Cst = Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="">  // If there was nothing but constants then we are done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="uncoveredLine">  if (Ops.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="uncoveredLine">    return Cst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="">  // Put the combined constant back at the end of the operand list, except if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="">  // there is no point.  For example, an add of 0 gets dropped here, while a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">  // multiplication by zero turns the whole expression into zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="uncoveredLine">  if (Cst && Cst != ConstantExpr::getBinOpIdentity(Opcode, I->getType())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="uncoveredLine">    if (Cst == ConstantExpr::getBinOpAbsorber(Opcode, I->getType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="uncoveredLine">      return Cst;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="uncoveredLine">    Ops.push_back(ValueEntry(0, Cst));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="uncoveredLine">  if (Ops.size() == 1) return Ops[0].Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="">  // Handle destructive annihilation due to identities between elements in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="">  // argument list here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="uncoveredLine">  unsigned NumOps = Ops.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="uncoveredLine">  switch (Opcode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="uncoveredLine">  default: break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="uncoveredLine">  case Instruction::And:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="">  case Instruction::Or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="uncoveredLine">    if (Value *Result = OptimizeAndOrXor(Opcode, Ops))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="uncoveredLine">      return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="uncoveredLine">  case Instruction::Xor:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="uncoveredLine">    if (Value *Result = OptimizeXor(I, Ops))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="uncoveredLine">      return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="uncoveredLine">  case Instruction::Add:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="">  case Instruction::FAdd:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="uncoveredLine">    if (Value *Result = OptimizeAdd(I, Ops))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="uncoveredLine">      return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="uncoveredLine">  case Instruction::Mul:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="">  case Instruction::FMul:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="uncoveredLine">    if (Value *Result = OptimizeMul(I, Ops))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="uncoveredLine">      return Result;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="uncoveredLine">    break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="uncoveredLine">  if (Ops.size() != NumOps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="uncoveredLine">    return OptimizeExpression(I, Ops);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="">// Remove dead instructions and if any operands are trivially dead add them to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="">// Insts so they will be removed as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="uncoveredLine">void ReassociatePass::RecursivelyEraseDeadInsts(Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="">                                                OrderedSet &Insts) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="uncoveredLine">  assert(isInstructionTriviallyDead(I) && "Trivially dead instructions only!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="uncoveredLine">  SmallVector<Value *, 4> Ops(I->operands());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="uncoveredLine">  ValueRankMap.erase(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="uncoveredLine">  Insts.remove(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="uncoveredLine">  RedoInsts.remove(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="uncoveredLine">  llvm::salvageDebugInfo(*I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="uncoveredLine">  I->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="uncoveredLine">  for (auto *Op : Ops)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="uncoveredLine">    if (Instruction *OpInst = dyn_cast<Instruction>(Op))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="uncoveredLine">      if (OpInst->use_empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="uncoveredLine">        Insts.insert(OpInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="">/// Zap the given instruction, adding interesting operands to the work list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="uncoveredLine">void ReassociatePass::EraseInst(Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="uncoveredLine">  assert(isInstructionTriviallyDead(I) && "Trivially dead instructions only!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Erasing dead inst: "; I->dump());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="uncoveredLine">  SmallVector<Value *, 8> Ops(I->operands());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">  // Erase the dead instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="uncoveredLine">  ValueRankMap.erase(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="uncoveredLine">  RedoInsts.remove(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="uncoveredLine">  llvm::salvageDebugInfo(*I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="uncoveredLine">  I->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="">  // Optimize its operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="uncoveredLine">  SmallPtrSet<Instruction *, 8> Visited; // Detect self-referential nodes.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="uncoveredLine">    if (Instruction *Op = dyn_cast<Instruction>(Ops[i])) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="">      // If this is a node in an expression tree, climb to the expression root</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="">      // and add that since that's where optimization actually happens.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="uncoveredLine">      unsigned Opcode = Op->getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="uncoveredLine">      while (Op->hasOneUse() && Op->user_back()->getOpcode() == Opcode &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="uncoveredLine">             Visited.insert(Op).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="uncoveredLine">        Op = Op->user_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="">      // The instruction we're going to push may be coming from a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="">      // dead block, and Reassociate skips the processing of unreachable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="">      // blocks because it's a waste of time and also because it can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="">      // lead to infinite loop due to LLVM's non-standard definition</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="">      // of dominance.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="uncoveredLine">      if (ValueRankMap.contains(Op))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="uncoveredLine">        RedoInsts.insert(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="uncoveredLine">  MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="">/// Recursively analyze an expression to build a list of instructions that have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="">/// negative floating-point constant operands. The caller can then transform</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="">/// the list to create positive constants for better reassociation and CSE.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="uncoveredLine">static void getNegatibleInsts(Value *V,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="">                              SmallVectorImpl<Instruction *> &Candidates) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="">  // Handle only one-use instructions. Combining negations does not justify</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="">  // replicating instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="">  Instruction *I;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="uncoveredLine">  if (!match(V, m_OneUse(m_Instruction(I))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="">  // Handle expressions of multiplications and divisions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="">  // TODO: This could look through floating-point casts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="">  const APFloat *C;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="uncoveredLine">  switch (I->getOpcode()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="uncoveredLine">    case Instruction::FMul:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="">      // Not expecting non-canonical code here. Bail out and wait.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="uncoveredLine">      if (match(I->getOperand(0), m_Constant()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="uncoveredLine">      if (match(I->getOperand(1), m_APFloat(C)) && C->isNegative()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="uncoveredLine">        Candidates.push_back(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "FMul with negative constant: " << *I << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="uncoveredLine">      getNegatibleInsts(I->getOperand(0), Candidates);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="uncoveredLine">      getNegatibleInsts(I->getOperand(1), Candidates);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="uncoveredLine">    case Instruction::FDiv:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="">      // Not expecting non-canonical code here. Bail out and wait.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="uncoveredLine">      if (match(I->getOperand(0), m_Constant()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="uncoveredLine">          match(I->getOperand(1), m_Constant()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="uncoveredLine">      if ((match(I->getOperand(0), m_APFloat(C)) && C->isNegative()) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="uncoveredLine">          (match(I->getOperand(1), m_APFloat(C)) && C->isNegative())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="uncoveredLine">        Candidates.push_back(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "FDiv with negative constant: " << *I << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="uncoveredLine">      getNegatibleInsts(I->getOperand(0), Candidates);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="uncoveredLine">      getNegatibleInsts(I->getOperand(1), Candidates);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="">/// Given an fadd/fsub with an operand that is a one-use instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="">/// (the fadd/fsub), try to change negative floating-point constants into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="">/// positive constants to increase potential for reassociation and CSE.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="uncoveredLine">Instruction *ReassociatePass::canonicalizeNegFPConstantsForOp(Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="">                                                              Instruction *Op,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="">                                                              Value *OtherOp) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="uncoveredLine">  assert((I->getOpcode() == Instruction::FAdd ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="">          I->getOpcode() == Instruction::FSub) && "Expected fadd/fsub");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="">  // Collect instructions with negative FP constants from the subtree that ends</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="">  // in Op.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="uncoveredLine">  SmallVector<Instruction *, 4> Candidates;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="uncoveredLine">  getNegatibleInsts(Op, Candidates);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="uncoveredLine">  if (Candidates.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="">  // Don't canonicalize x + (-Constant * y) -> x - (Constant * y), if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="">  // resulting subtract will be broken up later.  This can get us into an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="">  // infinite loop during reassociation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="uncoveredLine">  bool IsFSub = I->getOpcode() == Instruction::FSub;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="uncoveredLine">  bool NeedsSubtract = !IsFSub && Candidates.size() % 2 == 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="uncoveredLine">  if (NeedsSubtract && ShouldBreakUpSubtract(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="uncoveredLine">  for (Instruction *Negatible : Candidates) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="">    const APFloat *C;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="uncoveredLine">    if (match(Negatible->getOperand(0), m_APFloat(C))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="uncoveredLine">      assert(!match(Negatible->getOperand(1), m_Constant()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="">             "Expecting only 1 constant operand");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="uncoveredLine">      assert(C->isNegative() && "Expected negative FP constant");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="uncoveredLine">      Negatible->setOperand(0, ConstantFP::get(Negatible->getType(), abs(*C)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="uncoveredLine">      MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="uncoveredLine">    if (match(Negatible->getOperand(1), m_APFloat(C))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="uncoveredLine">      assert(!match(Negatible->getOperand(0), m_Constant()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="">             "Expecting only 1 constant operand");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="uncoveredLine">      assert(C->isNegative() && "Expected negative FP constant");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="uncoveredLine">      Negatible->setOperand(1, ConstantFP::get(Negatible->getType(), abs(*C)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="uncoveredLine">      MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="uncoveredLine">  assert(MadeChange == true && "Negative constant candidate was not changed");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="">  // Negations cancelled out.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="uncoveredLine">  if (Candidates.size() % 2 == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="uncoveredLine">    return I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="">  // Negate the final operand in the expression by flipping the opcode of this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="">  // fadd/fsub.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="uncoveredLine">  assert(Candidates.size() % 2 == 1 && "Expected odd number");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="uncoveredLine">  IRBuilder<> Builder(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="uncoveredLine">  Value *NewInst = IsFSub ? Builder.CreateFAddFMF(OtherOp, Op, I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="uncoveredLine">                          : Builder.CreateFSubFMF(OtherOp, Op, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="uncoveredLine">  I->replaceAllUsesWith(NewInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="uncoveredLine">  RedoInsts.insert(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="uncoveredLine">  return dyn_cast<Instruction>(NewInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="">/// Canonicalize expressions that contain a negative floating-point constant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="">/// of the following form:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="">///   OtherOp + (subtree) -> OtherOp {+/-} (canonical subtree)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="">///   (subtree) + OtherOp -> OtherOp {+/-} (canonical subtree)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="">///   OtherOp - (subtree) -> OtherOp {+/-} (canonical subtree)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="">/// The fadd/fsub opcode may be switched to allow folding a negation into the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="">/// input instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="uncoveredLine">Instruction *ReassociatePass::canonicalizeNegFPConstants(Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Combine negations for: " << *I << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="">  Value *X;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="">  Instruction *Op;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="uncoveredLine">  if (match(I, m_FAdd(m_Value(X), m_OneUse(m_Instruction(Op)))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="uncoveredLine">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="uncoveredLine">      I = R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="uncoveredLine">  if (match(I, m_FAdd(m_OneUse(m_Instruction(Op)), m_Value(X))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="uncoveredLine">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="uncoveredLine">      I = R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="uncoveredLine">  if (match(I, m_FSub(m_Value(X), m_OneUse(m_Instruction(Op)))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="uncoveredLine">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="uncoveredLine">      I = R;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="uncoveredLine">  return I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="">/// Inspect and optimize the given instruction. Note that erasing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="">/// instructions is not allowed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="uncoveredLine">void ReassociatePass::OptimizeInst(Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="">  // Only consider operations that we understand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="uncoveredLine">  if (!isa<UnaryOperator>(I) && !isa<BinaryOperator>(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="uncoveredLine">  if (I->getOpcode() == Instruction::Shl && isa<ConstantInt>(I->getOperand(1)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="">    // If an operand of this shift is a reassociable multiply, or if the shift</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="">    // is used by a reassociable multiply or add, turn into a multiply.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="uncoveredLine">    if (isReassociableOp(I->getOperand(0), Instruction::Mul) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="uncoveredLine">        (I->hasOneUse() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="uncoveredLine">         (isReassociableOp(I->user_back(), Instruction::Mul) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="uncoveredLine">          isReassociableOp(I->user_back(), Instruction::Add)))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="uncoveredLine">      Instruction *NI = ConvertShiftToMul(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="uncoveredLine">      RedoInsts.insert(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="uncoveredLine">      MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="uncoveredLine">      I = NI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="">  // Commute binary operators, to canonicalize the order of their operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="">  // This can potentially expose more CSE opportunities, and makes writing other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="">  // transformations simpler.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="uncoveredLine">  if (I->isCommutative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="uncoveredLine">    canonicalizeOperands(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="">  // Canonicalize negative constants out of expressions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="uncoveredLine">  if (Instruction *Res = canonicalizeNegFPConstants(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="uncoveredLine">    I = Res;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="">  // Don't optimize floating-point instructions unless they have the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="">  // appropriate FastMathFlags for reassociation enabled.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="uncoveredLine">  if (isa<FPMathOperator>(I) && !hasFPAssociativeFlags(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="">  // Do not reassociate boolean (i1) expressions.  We want to preserve the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="">  // original order of evaluation for short-circuited comparisons that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="">  // SimplifyCFG has folded to AND/OR expressions.  If the expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="">  // is not further optimized, it is likely to be transformed back to a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="">  // short-circuited form for code gen, and the source order may have been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="">  // optimized for the most likely conditions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="uncoveredLine">  if (I->getType()->isIntegerTy(1))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">  // If this is a bitwise or instruction of operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="">  // with no common bits set, convert it to X+Y.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="uncoveredLine">  if (I->getOpcode() == Instruction::Or &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="uncoveredLine">      shouldConvertOrWithNoCommonBitsToAdd(I) && !isLoadCombineCandidate(I) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="uncoveredLine">      haveNoCommonBitsSet(I->getOperand(0), I->getOperand(1),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="">                          I->getModule()->getDataLayout(), /*AC=*/nullptr, I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="">                          /*DT=*/nullptr)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="uncoveredLine">    Instruction *NI = convertOrWithNoCommonBitsToAdd(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="uncoveredLine">    RedoInsts.insert(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="uncoveredLine">    MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="uncoveredLine">    I = NI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="">  // If this is a subtract instruction which is not already in negate form,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="">  // see if we can convert it to X+-Y.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="uncoveredLine">  if (I->getOpcode() == Instruction::Sub) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="uncoveredLine">    if (ShouldBreakUpSubtract(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">      Instruction *NI = BreakUpSubtract(I, RedoInsts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="uncoveredLine">      RedoInsts.insert(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="uncoveredLine">      MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="uncoveredLine">      I = NI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="uncoveredLine">    } else if (match(I, m_Neg(m_Value()))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="">      // Otherwise, this is a negation.  See if the operand is a multiply tree</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="">      // and if this is not an inner node of a multiply tree.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="uncoveredLine">      if (isReassociableOp(I->getOperand(1), Instruction::Mul) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="uncoveredLine">          (!I->hasOneUse() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="uncoveredLine">           !isReassociableOp(I->user_back(), Instruction::Mul))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="uncoveredLine">        Instruction *NI = LowerNegateToMultiply(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="">        // If the negate was simplified, revisit the users to see if we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="">        // reassociate further.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="uncoveredLine">        for (User *U : NI->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="uncoveredLine">          if (BinaryOperator *Tmp = dyn_cast<BinaryOperator>(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="uncoveredLine">            RedoInsts.insert(Tmp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="uncoveredLine">        RedoInsts.insert(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="uncoveredLine">        MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="uncoveredLine">        I = NI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="uncoveredLine">  } else if (I->getOpcode() == Instruction::FNeg ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="uncoveredLine">             I->getOpcode() == Instruction::FSub) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="uncoveredLine">    if (ShouldBreakUpSubtract(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="uncoveredLine">      Instruction *NI = BreakUpSubtract(I, RedoInsts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="uncoveredLine">      RedoInsts.insert(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="uncoveredLine">      MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="uncoveredLine">      I = NI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="uncoveredLine">    } else if (match(I, m_FNeg(m_Value()))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="">      // Otherwise, this is a negation.  See if the operand is a multiply tree</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="">      // and if this is not an inner node of a multiply tree.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="uncoveredLine">      Value *Op = isa<BinaryOperator>(I) ? I->getOperand(1) :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="uncoveredLine">                                           I->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="uncoveredLine">      if (isReassociableOp(Op, Instruction::FMul) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="uncoveredLine">          (!I->hasOneUse() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="uncoveredLine">           !isReassociableOp(I->user_back(), Instruction::FMul))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="">        // If the negate was simplified, revisit the users to see if we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="">        // reassociate further.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="uncoveredLine">        Instruction *NI = LowerNegateToMultiply(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="uncoveredLine">        for (User *U : NI->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="uncoveredLine">          if (BinaryOperator *Tmp = dyn_cast<BinaryOperator>(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="uncoveredLine">            RedoInsts.insert(Tmp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="uncoveredLine">        RedoInsts.insert(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="uncoveredLine">        MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="uncoveredLine">        I = NI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="">  // If this instruction is an associative binary operator, process it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="uncoveredLine">  if (!I->isAssociative()) return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="uncoveredLine">  BinaryOperator *BO = cast<BinaryOperator>(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="">  // If this is an interior node of a reassociable tree, ignore it until we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="">  // get to the root of the tree, to avoid N^2 analysis.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="uncoveredLine">  unsigned Opcode = BO->getOpcode();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="uncoveredLine">  if (BO->hasOneUse() && BO->user_back()->getOpcode() == Opcode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="">    // During the initial run we will get to the root of the tree.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="">    // But if we get here while we are redoing instructions, there is no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="">    // guarantee that the root will be visited. So Redo later</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="uncoveredLine">    if (BO->user_back() != BO &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="uncoveredLine">        BO->getParent() == BO->user_back()->getParent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="uncoveredLine">      RedoInsts.insert(BO->user_back());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="">  // If this is an add tree that is used by a sub instruction, ignore it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="">  // until we process the subtract.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="uncoveredLine">  if (BO->hasOneUse() && BO->getOpcode() == Instruction::Add &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="uncoveredLine">      cast<Instruction>(BO->user_back())->getOpcode() == Instruction::Sub)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="uncoveredLine">  if (BO->hasOneUse() && BO->getOpcode() == Instruction::FAdd &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="uncoveredLine">      cast<Instruction>(BO->user_back())->getOpcode() == Instruction::FSub)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="uncoveredLine">  ReassociateExpression(BO);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="uncoveredLine">void ReassociatePass::ReassociateExpression(BinaryOperator *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="">  // First, walk the expression tree, linearizing the tree, collecting the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="">  // operand information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="uncoveredLine">  SmallVector<RepeatedValue, 8> Tree;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="uncoveredLine">  MadeChange |= LinearizeExprTree(I, Tree, RedoInsts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="uncoveredLine">  SmallVector<ValueEntry, 8> Ops;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="uncoveredLine">  Ops.reserve(Tree.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="uncoveredLine">  for (const RepeatedValue &E : Tree)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="uncoveredLine">    Ops.append(E.second.getZExtValue(), ValueEntry(getRank(E.first), E.first));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "RAIn:\t"; PrintOps(I, Ops); dbgs() << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="">  // Now that we have linearized the tree to a list and have gathered all of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="">  // the operands and their ranks, sort the operands by their rank.  Use a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="">  // stable_sort so that values with equal ranks will have their relative</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="">  // positions maintained (and so the compiler is deterministic).  Note that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="">  // this sorts so that the highest ranking values end up at the beginning of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="">  // the vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="uncoveredLine">  llvm::stable_sort(Ops);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="">  // Now that we have the expression tree in a convenient</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="">  // sorted form, optimize it globally if possible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="uncoveredLine">  if (Value *V = OptimizeExpression(I, Ops)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="uncoveredLine">    if (V == I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="">      // Self-referential expression in unreachable code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="">    // This expression tree simplified to something that isn't a tree,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="">    // eliminate it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Reassoc to scalar: " << *V << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="uncoveredLine">    I->replaceAllUsesWith(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="uncoveredLine">    if (Instruction *VI = dyn_cast<Instruction>(V))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="uncoveredLine">      if (I->getDebugLoc())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="uncoveredLine">        VI->setDebugLoc(I->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="uncoveredLine">    RedoInsts.insert(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="uncoveredLine">    ++NumAnnihil;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="">  // We want to sink immediates as deeply as possible except in the case where</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="">  // this is a multiply tree used only by an add, and the immediate is a -1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="">  // In this case we reassociate to put the negation on the outside so that we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="">  // can fold the negation into the add: (-X)*Y + Z -> Z-X*Y</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="uncoveredLine">  if (I->hasOneUse()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="uncoveredLine">    if (I->getOpcode() == Instruction::Mul &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="uncoveredLine">        cast<Instruction>(I->user_back())->getOpcode() == Instruction::Add &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="uncoveredLine">        isa<ConstantInt>(Ops.back().Op) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="uncoveredLine">        cast<ConstantInt>(Ops.back().Op)->isMinusOne()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="uncoveredLine">      ValueEntry Tmp = Ops.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="uncoveredLine">      Ops.insert(Ops.begin(), Tmp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="uncoveredLine">    } else if (I->getOpcode() == Instruction::FMul &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="uncoveredLine">               cast<Instruction>(I->user_back())->getOpcode() ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="uncoveredLine">                   Instruction::FAdd &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="uncoveredLine">               isa<ConstantFP>(Ops.back().Op) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="uncoveredLine">               cast<ConstantFP>(Ops.back().Op)->isExactlyValue(-1.0)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="uncoveredLine">      ValueEntry Tmp = Ops.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="uncoveredLine">      Ops.insert(Ops.begin(), Tmp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "RAOut:\t"; PrintOps(I, Ops); dbgs() << '\n');</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="uncoveredLine">  if (Ops.size() == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="uncoveredLine">    if (Ops[0].Op == I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="">      // Self-referential expression in unreachable code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="">    // This expression tree simplified to something that isn't a tree,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="">    // eliminate it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="uncoveredLine">    I->replaceAllUsesWith(Ops[0].Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="uncoveredLine">    if (Instruction *OI = dyn_cast<Instruction>(Ops[0].Op))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="uncoveredLine">      OI->setDebugLoc(I->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="uncoveredLine">    RedoInsts.insert(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="uncoveredLine">  if (Ops.size() > 2 && Ops.size() <= GlobalReassociateLimit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="">    // Find the pair with the highest count in the pairmap and move it to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="">    // back of the list so that it can later be CSE'd.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="">    // example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="">    //   a*b*c*d*e</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="">    // if c*e is the most "popular" pair, we can express this as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="">    //   (((c*e)*d)*b)*a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="uncoveredLine">    unsigned Max = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="uncoveredLine">    unsigned BestRank = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="uncoveredLine">    std::pair<unsigned, unsigned> BestPair;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="uncoveredLine">    unsigned Idx = I->getOpcode() - Instruction::BinaryOpsBegin;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="uncoveredLine">    unsigned LimitIdx = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="">    // With the CSE-driven heuristic, we are about to slap two values at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="">    // beginning of the expression whereas they could live very late in the CFG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="">    // When using the CSE-local heuristic we avoid creating dependences from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="">    // completely unrelated part of the CFG by limiting the expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="">    // reordering on the values that live in the first seen basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="">    // The main idea is that we want to avoid forming expressions that would</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="">    // become loop dependent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="uncoveredLine">    if (UseCSELocalOpt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="uncoveredLine">      const BasicBlock *FirstSeenBB = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="uncoveredLine">      int StartIdx = Ops.size() - 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="">      // Skip the first value of the expression since we need at least two</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="">      // values to materialize an expression. I.e., even if this value is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="">      // anchored in a different basic block, the actual first sub expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="">      // will be anchored on the second value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="uncoveredLine">      for (int i = StartIdx - 1; i != -1; --i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="uncoveredLine">        const Value *Val = Ops[i].Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="uncoveredLine">        const auto *CurrLeafInstr = dyn_cast<Instruction>(Val);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="uncoveredLine">        const BasicBlock *SeenBB = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="uncoveredLine">        if (!CurrLeafInstr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="">          // The value is free of any CFG dependencies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="">          // Do as if it lives in the entry block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="">          //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="">          // We do this to make sure all the values falling on this path are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="">          // seen through the same anchor point. The rationale is these values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="">          // can be combined together to from a sub expression free of any CFG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="">          // dependencies so we want them to stay together.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="">          // We could be cleverer and postpone the anchor down to the first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="">          // anchored value, but that's likely complicated to get right.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="">          // E.g., we wouldn't want to do that if that means being stuck in a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="">          // loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="">          //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="">          // For instance, we wouldn't want to change:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="">          // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="">          // into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="">          // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="">          // Because all the sub expressions with arg2..N would be stuck between</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="">          // two loop dependent values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="uncoveredLine">          SeenBB = &I->getParent()->getParent()->getEntryBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="uncoveredLine">          SeenBB = CurrLeafInstr->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="uncoveredLine">        if (!FirstSeenBB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="uncoveredLine">          FirstSeenBB = SeenBB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="uncoveredLine">        if (FirstSeenBB != SeenBB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="">          // ith value is in a different basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="">          // Rewind the index once to point to the last value on the same basic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="">          // block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="uncoveredLine">          LimitIdx = i + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="uncoveredLine">          LLVM_DEBUG(dbgs() << "CSE reordering: Consider values between ["</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="">                            << LimitIdx << ", " << StartIdx << "]\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="uncoveredLine">    for (unsigned i = Ops.size() - 1; i > LimitIdx; --i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="">      // We must use int type to go below zero when LimitIdx is 0.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="uncoveredLine">      for (int j = i - 1; j >= (int)LimitIdx; --j) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="uncoveredLine">        unsigned Score = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="uncoveredLine">        Value *Op0 = Ops[i].Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="uncoveredLine">        Value *Op1 = Ops[j].Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="uncoveredLine">        if (std::less<Value *>()(Op1, Op0))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="uncoveredLine">          std::swap(Op0, Op1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="uncoveredLine">        auto it = PairMap[Idx].find({Op0, Op1});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="uncoveredLine">        if (it != PairMap[Idx].end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="">          // Functions like BreakUpSubtract() can erase the Values we're using</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="">          // as keys and create new Values after we built the PairMap. There's a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="">          // small chance that the new nodes can have the same address as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="">          // something already in the table. We shouldn't accumulate the stored</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="">          // score in that case as it refers to the wrong Value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="uncoveredLine">          if (it->second.isValid())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="uncoveredLine">            Score += it->second.Score;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="uncoveredLine">        unsigned MaxRank = std::max(Ops[i].Rank, Ops[j].Rank);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="">        // By construction, the operands are sorted in reverse order of their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="">        // topological order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="">        // So we tend to form (sub) expressions with values that are close to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="">        // each other.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="">        //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="">        // Now to expose more CSE opportunities we want to expose the pair of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="">        // operands that occur the most (as statically computed in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="">        // BuildPairMap.) as the first sub-expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="">        //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="">        // If two pairs occur as many times, we pick the one with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="">        // lowest rank, meaning the one with both operands appearing first in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="">        // the topological order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="uncoveredLine">        if (Score > Max || (Score == Max && MaxRank < BestRank)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="uncoveredLine">          BestPair = {j, i};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="uncoveredLine">          Max = Score;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="uncoveredLine">          BestRank = MaxRank;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="uncoveredLine">    if (Max > 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="uncoveredLine">      auto Op0 = Ops[BestPair.first];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="uncoveredLine">      auto Op1 = Ops[BestPair.second];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="uncoveredLine">      Ops.erase(&Ops[BestPair.second]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="uncoveredLine">      Ops.erase(&Ops[BestPair.first]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="uncoveredLine">      Ops.push_back(Op0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="uncoveredLine">      Ops.push_back(Op1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "RAOut after CSE reorder:\t"; PrintOps(I, Ops);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="">             dbgs() << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="">  // Now that we ordered and optimized the expressions, splat them back into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="">  // the expression tree, removing any unneeded nodes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="uncoveredLine">  RewriteExprTree(I, Ops);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="">void</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="uncoveredLine">ReassociatePass::BuildPairMap(ReversePostOrderTraversal<Function *> &RPOT) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="">  // Make a "pairmap" of how often each operand pair occurs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="uncoveredLine">  for (BasicBlock *BI : RPOT) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="uncoveredLine">    for (Instruction &I : *BI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="uncoveredLine">      if (!I.isAssociative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="">      // Ignore nodes that aren't at the root of trees.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="uncoveredLine">      if (I.hasOneUse() && I.user_back()->getOpcode() == I.getOpcode())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="">      // Collect all operands in a single reassociable expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="">      // Since Reassociate has already been run once, we can assume things</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="">      // are already canonical according to Reassociation's regime.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="uncoveredLine">      SmallVector<Value *, 8> Worklist = { I.getOperand(0), I.getOperand(1) };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="uncoveredLine">      SmallVector<Value *, 8> Ops;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="uncoveredLine">      while (!Worklist.empty() && Ops.size() <= GlobalReassociateLimit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="uncoveredLine">        Value *Op = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="uncoveredLine">        Instruction *OpI = dyn_cast<Instruction>(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="uncoveredLine">        if (!OpI || OpI->getOpcode() != I.getOpcode() || !OpI->hasOneUse()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="uncoveredLine">          Ops.push_back(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="">        // Be paranoid about self-referencing expressions in unreachable code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="uncoveredLine">        if (OpI->getOperand(0) != OpI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="uncoveredLine">          Worklist.push_back(OpI->getOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="uncoveredLine">        if (OpI->getOperand(1) != OpI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="uncoveredLine">          Worklist.push_back(OpI->getOperand(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="">      // Skip extremely long expressions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="uncoveredLine">      if (Ops.size() > GlobalReassociateLimit)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="">      // Add all pairwise combinations of operands to the pair map.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="uncoveredLine">      unsigned BinaryIdx = I.getOpcode() - Instruction::BinaryOpsBegin;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="uncoveredLine">      SmallSet<std::pair<Value *, Value*>, 32> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="uncoveredLine">      for (unsigned i = 0; i < Ops.size() - 1; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="uncoveredLine">        for (unsigned j = i + 1; j < Ops.size(); ++j) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="">          // Canonicalize operand orderings.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="uncoveredLine">          Value *Op0 = Ops[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="uncoveredLine">          Value *Op1 = Ops[j];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="uncoveredLine">          if (std::less<Value *>()(Op1, Op0))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="uncoveredLine">            std::swap(Op0, Op1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="uncoveredLine">          if (!Visited.insert({Op0, Op1}).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="uncoveredLine">          auto res = PairMap[BinaryIdx].insert({{Op0, Op1}, {Op0, Op1, 1}});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="uncoveredLine">          if (!res.second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="">            // If either key value has been erased then we've got the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="">            // address by coincidence. That can't happen here because nothing is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="">            // erasing values but it can happen by the time we're querying the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="">            // map.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="uncoveredLine">            assert(res.first->second.isValid() && "WeakVH invalidated");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="uncoveredLine">            ++res.first->second.Score;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="uncoveredLine">PreservedAnalyses ReassociatePass::run(Function &F, FunctionAnalysisManager &) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="">  // Get the functions basic blocks in Reverse Post Order. This order is used by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="">  // BuildRankMap to pre calculate ranks correctly. It also excludes dead basic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="">  // blocks (it has been seen that the analysis in this pass could hang when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="">  // analysing dead basic blocks).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="uncoveredLine">  ReversePostOrderTraversal<Function *> RPOT(&F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="">  // Calculate the rank map for F.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="uncoveredLine">  BuildRankMap(F, RPOT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="">  // Build the pair map before running reassociate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="">  // Technically this would be more accurate if we did it after one round</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="">  // of reassociation, but in practice it doesn't seem to help much on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="">  // real-world code, so don't waste the compile time running reassociate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="">  // twice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="">  // If a user wants, they could expicitly run reassociate twice in their</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="">  // pass pipeline for further potential gains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="">  // It might also be possible to update the pair map during runtime, but the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="">  // overhead of that may be large if there's many reassociable chains.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="uncoveredLine">  BuildPairMap(RPOT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="uncoveredLine">  MadeChange = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="">  // Traverse the same blocks that were analysed by BuildRankMap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="uncoveredLine">  for (BasicBlock *BI : RPOT) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="uncoveredLine">    assert(RankMap.count(&*BI) && "BB should be ranked.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="">    // Optimize every instruction in the basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="uncoveredLine">    for (BasicBlock::iterator II = BI->begin(), IE = BI->end(); II != IE;)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="uncoveredLine">      if (isInstructionTriviallyDead(&*II)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="uncoveredLine">        EraseInst(&*II++);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="uncoveredLine">        OptimizeInst(&*II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="uncoveredLine">        assert(II->getParent() == &*BI && "Moved to a different block!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="uncoveredLine">        ++II;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="">    // Make a copy of all the instructions to be redone so we can remove dead</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="">    // instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="uncoveredLine">    OrderedSet ToRedo(RedoInsts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="">    // Iterate over all instructions to be reevaluated and remove trivially dead</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="">    // instructions. If any operand of the trivially dead instruction becomes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="">    // dead mark it for deletion as well. Continue this process until all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="">    // trivially dead instructions have been removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="uncoveredLine">    while (!ToRedo.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="uncoveredLine">      Instruction *I = ToRedo.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="uncoveredLine">      if (isInstructionTriviallyDead(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="uncoveredLine">        RecursivelyEraseDeadInsts(I, ToRedo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="uncoveredLine">        MadeChange = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="">    // Now that we have removed dead instructions, we can reoptimize the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="">    // remaining instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="uncoveredLine">    while (!RedoInsts.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="uncoveredLine">      Instruction *I = RedoInsts.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="uncoveredLine">      RedoInsts.erase(RedoInsts.begin());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="uncoveredLine">      if (isInstructionTriviallyDead(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="uncoveredLine">        EraseInst(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="uncoveredLine">        OptimizeInst(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="">  // We are done with the rank map and pair map.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="uncoveredLine">  RankMap.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="uncoveredLine">  ValueRankMap.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="uncoveredLine">  for (auto &Entry : PairMap)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="uncoveredLine">    Entry.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="uncoveredLine">  if (MadeChange) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="uncoveredLine">    PreservedAnalyses PA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="uncoveredLine">    PA.preserveSet<CFGAnalyses>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="uncoveredLine">    return PA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="uncoveredLine">  return PreservedAnalyses::all();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="">  class ReassociateLegacyPass : public FunctionPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="">    ReassociatePass Impl;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="">    static char ID; // Pass identification, replacement for typeid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="uncoveredLine">    ReassociateLegacyPass() : FunctionPass(ID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="uncoveredLine">      initializeReassociateLegacyPassPass(*PassRegistry::getPassRegistry());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="uncoveredLine">    bool runOnFunction(Function &F) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="uncoveredLine">      if (skipFunction(F))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="uncoveredLine">      FunctionAnalysisManager DummyFAM;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="uncoveredLine">      auto PA = Impl.run(F, DummyFAM);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="uncoveredLine">      return !PA.areAllPreserved();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="uncoveredLine">    void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="uncoveredLine">      AU.setPreservesCFG();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="uncoveredLine">      AU.addPreserved<AAResultsWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="uncoveredLine">      AU.addPreserved<BasicAAWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="uncoveredLine">      AU.addPreserved<GlobalsAAWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="">char ReassociateLegacyPass::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="coveredLine">INITIALIZE_PASS(ReassociateLegacyPass, "reassociate",</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="">                "Reassociate expressions", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="">// Public interface to the Reassociate pass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="uncoveredLine">FunctionPass *llvm::createReassociatePass() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="uncoveredLine">  return new ReassociateLegacyPass();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL8PrintOpsPN4llvm11InstructionERKNS_15SmallVectorImplINS_11reassociate10ValueEntryEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm11reassociate7XorOpnd9isInvalidEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm11reassociate7XorOpnd8isOrExprEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm11reassociate7XorOpnd8getValueEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm11reassociate7XorOpnd15getSymbolicPartEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm11reassociate7XorOpnd15getSymbolicRankEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm11reassociate7XorOpnd12getConstPartEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11reassociate7XorOpnd10InvalidateEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11reassociate7XorOpnd15setSymbolicRankEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm11reassociate7XorOpndC2EPNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL21hasFPAssociativeFlagsPN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL16isReassociableOpPN4llvm5ValueEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL16isReassociableOpPN4llvm5ValueEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass12BuildRankMapERNS_8FunctionERNS_25ReversePostOrderTraversalIPS1_NS_11GraphTraitsIS4_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass7getRankEPNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass20canonicalizeOperandsEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL9CreateAddPN4llvm5ValueES1_RKNS_5TwineEPNS_11InstructionES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL9CreateMulPN4llvm5ValueES1_RKNS_5TwineEPNS_11InstructionES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL9CreateNegPN4llvm5ValueERKNS_5TwineEPNS_11InstructionES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL21LowerNegateToMultiplyPN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15CarmichaelShiftj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL17IncorporateWeightRN4llvm5APIntERKS0_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL17LinearizeExprTreePN4llvm11InstructionERNS_15SmallVectorImplISt4pairIPNS_5ValueENS_5APIntEEEERNS_9SetVectorINS_11AssertingVHIS0_EESt5dequeISC_SaISC_EENS_8DenseSetISC_NS_12DenseMapInfoISC_vEEEELj0EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass15RewriteExprTreeEPNS_14BinaryOperatorERNS_15SmallVectorImplINS_11reassociate10ValueEntryEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL11NegateValuePN4llvm5ValueEPNS_11InstructionERNS_9SetVectorINS_11AssertingVHIS2_EESt5dequeIS6_SaIS6_EENS_8DenseSetIS6_NS_12DenseMapInfoIS6_vEEEELj0EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL22isLoadCombineCandidatePN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL22isLoadCombineCandidatePN4llvm11InstructionEENKUlPNS_5ValueEE_clES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL36shouldConvertOrWithNoCommonBitsToAddPN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL36shouldConvertOrWithNoCommonBitsToAddPN4llvm11InstructionEENKUlPNS_5ValueEE_clES3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL30convertOrWithNoCommonBitsToAddPN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL21ShouldBreakUpSubtractPN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15BreakUpSubtractPN4llvm11InstructionERNS_9SetVectorINS_11AssertingVHIS0_EESt5dequeIS4_SaIS4_EENS_8DenseSetIS4_NS_12DenseMapInfoIS4_vEEEELj0EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL17ConvertShiftToMulPN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL17FindInOperandListRKN4llvm15SmallVectorImplINS_11reassociate10ValueEntryEEEjPNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL19EmitAddTreeOfValuesPN4llvm11InstructionERNS_15SmallVectorImplINS_14WeakTrackingVHEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass26RemoveFactorFromExpressionEPNS_5ValueES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL28FindSingleUseMultiplyFactorsPN4llvm5ValueERNS_15SmallVectorImplIS1_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL16OptimizeAndOrXorjRN4llvm15SmallVectorImplINS_11reassociate10ValueEntryEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL14createAndInstrPN4llvm11InstructionEPNS_5ValueERKNS_5APIntE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass14CombineXorOpndEPNS_11InstructionEPNS_11reassociate7XorOpndERNS_5APIntERPNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass14CombineXorOpndEPNS_11InstructionEPNS_11reassociate7XorOpndES5_RNS_5APIntERPNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass11OptimizeXorEPNS_11InstructionERNS_15SmallVectorImplINS_11reassociate10ValueEntryEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15ReassociatePass11OptimizeXorEPNS_11InstructionERNS_15SmallVectorImplINS_11reassociate10ValueEntryEEEENKUlPNS4_7XorOpndES9_E_clES9_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass11OptimizeAddEPNS_11InstructionERNS_15SmallVectorImplINS_11reassociate10ValueEntryEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL22collectMultiplyFactorsRN4llvm15SmallVectorImplINS_11reassociate10ValueEntryEEERNS0_INS1_6FactorEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL22collectMultiplyFactorsRN4llvm15SmallVectorImplINS_11reassociate10ValueEntryEEERNS0_INS1_6FactorEEEENKUlRKS5_S9_E_clES9_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL17buildMultiplyTreeRN4llvm13IRBuilderBaseERNS_15SmallVectorImplIPNS_5ValueEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass23buildMinimalMultiplyDAGERNS_13IRBuilderBaseERNS_15SmallVectorImplINS_11reassociate6FactorEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm15ReassociatePass23buildMinimalMultiplyDAGERNS_13IRBuilderBaseERNS_15SmallVectorImplINS_11reassociate6FactorEEEENKUlRKS5_S9_E_clES9_S9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass11OptimizeMulEPNS_14BinaryOperatorERNS_15SmallVectorImplINS_11reassociate10ValueEntryEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass18OptimizeExpressionEPNS_14BinaryOperatorERNS_15SmallVectorImplINS_11reassociate10ValueEntryEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass25RecursivelyEraseDeadInstsEPNS_11InstructionERNS_9SetVectorINS_11AssertingVHIS1_EESt5dequeIS5_SaIS5_EENS_8DenseSetIS5_NS_12DenseMapInfoIS5_vEEEELj0EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass9EraseInstEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL17getNegatibleInstsPN4llvm5ValueERNS_15SmallVectorImplIPNS_11InstructionEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass31canonicalizeNegFPConstantsForOpEPNS_11InstructionES2_PNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass26canonicalizeNegFPConstantsEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass12OptimizeInstEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass21ReassociateExpressionEPNS_14BinaryOperatorE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass12BuildPairMapERNS_25ReversePostOrderTraversalIPNS_8FunctionENS_11GraphTraitsIS3_EEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ReassociatePass3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_121ReassociateLegacyPassC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_121ReassociateLegacyPass13runOnFunctionERN4llvm8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_121ReassociateLegacyPass16getAnalysisUsageERN4llvm13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm35initializeReassociateLegacyPassPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL39initializeReassociateLegacyPassPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm21createReassociatePassEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- Reassociate.cpp - Reassociate binary expressions -------------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- Reassociate.cpp - Reassociate binary expressions -------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This pass reassociates commutative expressions in an order that is designed</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This pass reassociates commutative expressions in an order that is designed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// to promote better constant propagation, GCSE, LICM, PRE, etc.</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// to promote better constant propagation, GCSE, LICM, PRE, etc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">//</td>
    <td class="lineNumber">11</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">// For example: 4 + (x + 5) -> x + (4 + 5)</td>
    <td class="lineNumber">12</td>
    <td class="codeline">// For example: 4 + (x + 5) -> x + (4 + 5)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">// In the implementation of this algorithm, constants are assigned rank = 0,</td>
    <td class="lineNumber">14</td>
    <td class="codeline">// In the implementation of this algorithm, constants are assigned rank = 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">// function arguments are rank = 1, and other values are assigned ranks</td>
    <td class="lineNumber">15</td>
    <td class="codeline">// function arguments are rank = 1, and other values are assigned ranks</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">// corresponding to the reverse post order traversal of current function</td>
    <td class="lineNumber">16</td>
    <td class="codeline">// corresponding to the reverse post order traversal of current function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">// (starting at 2), which effectively gives values in deep loops higher rank</td>
    <td class="lineNumber">17</td>
    <td class="codeline">// (starting at 2), which effectively gives values in deep loops higher rank</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">// than values not in loops.</td>
    <td class="lineNumber">18</td>
    <td class="codeline">// than values not in loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">//</td>
    <td class="lineNumber">19</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">20</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline"></td>
    <td class="lineNumber">21</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Transforms/Scalar/Reassociate.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/Transforms/Scalar/Reassociate.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/ADT/APFloat.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/ADT/APFloat.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/PostOrderIterator.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/PostOrderIterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/ADT/SmallSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/Analysis/BasicAliasAnalysis.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/Analysis/BasicAliasAnalysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/Analysis/ConstantFolding.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/Analysis/ConstantFolding.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/Analysis/GlobalsModRef.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/Analysis/GlobalsModRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/Argument.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/Argument.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/CFG.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/CFG.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/IR/Constant.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/IR/Operator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/IR/PatternMatch.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/IR/User.h"</td>
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/IR/User.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/IR/ValueHandle.h"</td>
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/IR/ValueHandle.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">54</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">55</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">56</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">57</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">#include "llvm/Transforms/Scalar.h"</td>
    <td class="lineNumber">58</td>
    <td class="codeline">#include "llvm/Transforms/Scalar.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">59</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">60</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">61</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">62</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline"></td>
    <td class="lineNumber">63</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">64</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">using namespace reassociate;</td>
    <td class="lineNumber">65</td>
    <td class="codeline">using namespace reassociate;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">using namespace PatternMatch;</td>
    <td class="lineNumber">66</td>
    <td class="codeline">using namespace PatternMatch;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline"></td>
    <td class="lineNumber">67</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">#define DEBUG_TYPE "reassociate"</td>
    <td class="lineNumber">68</td>
    <td class="codeline">#define DEBUG_TYPE "reassociate"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline"></td>
    <td class="lineNumber">69</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">STATISTIC(NumChanged, "Number of insts reassociated");</td>
    <td class="lineNumber">70</td>
    <td class="codeline">STATISTIC(NumChanged, "Number of insts reassociated");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">STATISTIC(NumAnnihil, "Number of expr tree annihilated");</td>
    <td class="lineNumber">71</td>
    <td class="codeline">STATISTIC(NumAnnihil, "Number of expr tree annihilated");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">STATISTIC(NumFactor , "Number of multiplies factored");</td>
    <td class="lineNumber">72</td>
    <td class="codeline">STATISTIC(NumFactor , "Number of multiplies factored");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline"></td>
    <td class="lineNumber">73</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">static cl::opt<bool></td>
    <td class="lineNumber">74</td>
    <td class="codeline">static cl::opt<bool></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">    UseCSELocalOpt(DEBUG_TYPE "-use-cse-local",</td>
    <td class="lineNumber">75</td>
    <td class="codeline">    UseCSELocalOpt(DEBUG_TYPE "-use-cse-local",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">                   cl::desc("Only reorder expressions within a basic block "</td>
    <td class="lineNumber">76</td>
    <td class="codeline">                   cl::desc("Only reorder expressions within a basic block "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">                            "when exposing CSE opportunities"),</td>
    <td class="lineNumber">77</td>
    <td class="codeline">                            "when exposing CSE opportunities"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">                   cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">78</td>
    <td class="codeline">                   cl::init(true), cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline"></td>
    <td class="lineNumber">79</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">80</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">/// Print out the expression identified in the Ops list.</td>
    <td class="lineNumber">81</td>
    <td class="codeline">/// Print out the expression identified in the Ops list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">static void PrintOps(Instruction *I, const SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">82</td>
    <td class="codeline">static void PrintOps(Instruction *I, const SmallVectorImpl<ValueEntry> &Ops) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">  Module *M = I->getModule();</td>
    <td class="lineNumber">83</td>
    <td class="codeline">  Module *M = I->getModule();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">  dbgs() << Instruction::getOpcodeName(I->getOpcode()) << " "</td>
    <td class="lineNumber">84</td>
    <td class="codeline">  dbgs() << Instruction::getOpcodeName(I->getOpcode()) << " "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">       << *Ops[0].Op->getType() << '\t';</td>
    <td class="lineNumber">85</td>
    <td class="codeline">       << *Ops[0].Op->getType() << '\t';</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">86</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">    dbgs() << "[ ";</td>
    <td class="lineNumber">87</td>
    <td class="codeline">    dbgs() << "[ ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">    Ops[i].Op->printAsOperand(dbgs(), false, M);</td>
    <td class="lineNumber">88</td>
    <td class="codeline">    Ops[i].Op->printAsOperand(dbgs(), false, M);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">    dbgs() << ", #" << Ops[i].Rank << "] ";</td>
    <td class="lineNumber">89</td>
    <td class="codeline">    dbgs() << ", #" << Ops[i].Rank << "] ";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">90</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">}</td>
    <td class="lineNumber">91</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">92</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline"></td>
    <td class="lineNumber">93</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">/// Utility class representing a non-constant Xor-operand. We classify</td>
    <td class="lineNumber">94</td>
    <td class="codeline">/// Utility class representing a non-constant Xor-operand. We classify</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">/// non-constant Xor-Operands into two categories:</td>
    <td class="lineNumber">95</td>
    <td class="codeline">/// non-constant Xor-Operands into two categories:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">///  C1) The operand is in the form "X & C", where C is a constant and C != ~0</td>
    <td class="lineNumber">96</td>
    <td class="codeline">///  C1) The operand is in the form "X & C", where C is a constant and C != ~0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">///  C2)</td>
    <td class="lineNumber">97</td>
    <td class="codeline">///  C2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">///    C2.1) The operand is in the form of "X | C", where C is a non-zero</td>
    <td class="lineNumber">98</td>
    <td class="codeline">///    C2.1) The operand is in the form of "X | C", where C is a non-zero</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">///          constant.</td>
    <td class="lineNumber">99</td>
    <td class="codeline">///          constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">///    C2.2) Any operand E which doesn't fall into C1 and C2.1, we view this</td>
    <td class="lineNumber">100</td>
    <td class="codeline">///    C2.2) Any operand E which doesn't fall into C1 and C2.1, we view this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">///          operand as "E | 0"</td>
    <td class="lineNumber">101</td>
    <td class="codeline">///          operand as "E | 0"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">class llvm::reassociate::XorOpnd {</td>
    <td class="lineNumber">102</td>
    <td class="codeline">class llvm::reassociate::XorOpnd {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">103</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">  XorOpnd(Value *V);</td>
    <td class="lineNumber">104</td>
    <td class="codeline">  XorOpnd(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline"></td>
    <td class="lineNumber">105</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">  bool isInvalid() const { return SymbolicPart == nullptr; }</td>
    <td class="lineNumber">106</td>
    <td class="codeline">  bool isInvalid() const { return SymbolicPart == nullptr; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">  bool isOrExpr() const { return isOr; }</td>
    <td class="lineNumber">107</td>
    <td class="codeline">  bool isOrExpr() const { return isOr; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">  Value *getValue() const { return OrigVal; }</td>
    <td class="lineNumber">108</td>
    <td class="codeline">  Value *getValue() const { return OrigVal; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">  Value *getSymbolicPart() const { return SymbolicPart; }</td>
    <td class="lineNumber">109</td>
    <td class="codeline">  Value *getSymbolicPart() const { return SymbolicPart; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  unsigned getSymbolicRank() const { return SymbolicRank; }</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  unsigned getSymbolicRank() const { return SymbolicRank; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">  const APInt &getConstPart() const { return ConstPart; }</td>
    <td class="lineNumber">111</td>
    <td class="codeline">  const APInt &getConstPart() const { return ConstPart; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline"></td>
    <td class="lineNumber">112</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">  void Invalidate() { SymbolicPart = OrigVal = nullptr; }</td>
    <td class="lineNumber">113</td>
    <td class="codeline">  void Invalidate() { SymbolicPart = OrigVal = nullptr; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  void setSymbolicRank(unsigned R) { SymbolicRank = R; }</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  void setSymbolicRank(unsigned R) { SymbolicRank = R; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline"></td>
    <td class="lineNumber">115</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">116</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  Value *OrigVal;</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  Value *OrigVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  Value *SymbolicPart;</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  Value *SymbolicPart;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">  APInt ConstPart;</td>
    <td class="lineNumber">119</td>
    <td class="codeline">  APInt ConstPart;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">  unsigned SymbolicRank;</td>
    <td class="lineNumber">120</td>
    <td class="codeline">  unsigned SymbolicRank;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  bool isOr;</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  bool isOr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">};</td>
    <td class="lineNumber">122</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline"></td>
    <td class="lineNumber">123</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">XorOpnd::XorOpnd(Value *V) {</td>
    <td class="lineNumber">124</td>
    <td class="codeline">XorOpnd::XorOpnd(Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">  assert(!isa<ConstantInt>(V) && "No ConstantInt");</td>
    <td class="lineNumber">125</td>
    <td class="codeline">  assert(!isa<ConstantInt>(V) && "No ConstantInt");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  OrigVal = V;</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  OrigVal = V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  Instruction *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  Instruction *I = dyn_cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  SymbolicRank = 0;</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  SymbolicRank = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline"></td>
    <td class="lineNumber">129</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  if (I && (I->getOpcode() == Instruction::Or ||</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  if (I && (I->getOpcode() == Instruction::Or ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">            I->getOpcode() == Instruction::And)) {</td>
    <td class="lineNumber">131</td>
    <td class="codeline">            I->getOpcode() == Instruction::And)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">    Value *V0 = I->getOperand(0);</td>
    <td class="lineNumber">132</td>
    <td class="codeline">    Value *V0 = I->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">    Value *V1 = I->getOperand(1);</td>
    <td class="lineNumber">133</td>
    <td class="codeline">    Value *V1 = I->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">    const APInt *C;</td>
    <td class="lineNumber">134</td>
    <td class="codeline">    const APInt *C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">    if (match(V0, m_APInt(C)))</td>
    <td class="lineNumber">135</td>
    <td class="codeline">    if (match(V0, m_APInt(C)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">      std::swap(V0, V1);</td>
    <td class="lineNumber">136</td>
    <td class="codeline">      std::swap(V0, V1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">    if (match(V1, m_APInt(C))) {</td>
    <td class="lineNumber">138</td>
    <td class="codeline">    if (match(V1, m_APInt(C))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">      ConstPart = *C;</td>
    <td class="lineNumber">139</td>
    <td class="codeline">      ConstPart = *C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">      SymbolicPart = V0;</td>
    <td class="lineNumber">140</td>
    <td class="codeline">      SymbolicPart = V0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">      isOr = (I->getOpcode() == Instruction::Or);</td>
    <td class="lineNumber">141</td>
    <td class="codeline">      isOr = (I->getOpcode() == Instruction::Or);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">142</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">143</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">  // view the operand as "V | 0"</td>
    <td class="lineNumber">146</td>
    <td class="codeline">  // view the operand as "V | 0"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  SymbolicPart = V;</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  SymbolicPart = V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">  ConstPart = APInt::getZero(V->getType()->getScalarSizeInBits());</td>
    <td class="lineNumber">148</td>
    <td class="codeline">  ConstPart = APInt::getZero(V->getType()->getScalarSizeInBits());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">  isOr = true;</td>
    <td class="lineNumber">149</td>
    <td class="codeline">  isOr = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">}</td>
    <td class="lineNumber">150</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline"></td>
    <td class="lineNumber">151</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">/// Return true if I is an instruction with the FastMathFlags that are needed</td>
    <td class="lineNumber">152</td>
    <td class="codeline">/// Return true if I is an instruction with the FastMathFlags that are needed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">/// for general reassociation set.  This is not the same as testing</td>
    <td class="lineNumber">153</td>
    <td class="codeline">/// for general reassociation set.  This is not the same as testing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">/// Instruction::isAssociative() because it includes operations like fsub.</td>
    <td class="lineNumber">154</td>
    <td class="codeline">/// Instruction::isAssociative() because it includes operations like fsub.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">/// (This routine is only intended to be called for floating-point operations.)</td>
    <td class="lineNumber">155</td>
    <td class="codeline">/// (This routine is only intended to be called for floating-point operations.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">static bool hasFPAssociativeFlags(Instruction *I) {</td>
    <td class="lineNumber">156</td>
    <td class="codeline">static bool hasFPAssociativeFlags(Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  assert(I && isa<FPMathOperator>(I) && "Should only check FP ops");</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  assert(I && isa<FPMathOperator>(I) && "Should only check FP ops");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">  return I->hasAllowReassoc() && I->hasNoSignedZeros();</td>
    <td class="lineNumber">158</td>
    <td class="codeline">  return I->hasAllowReassoc() && I->hasNoSignedZeros();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">}</td>
    <td class="lineNumber">159</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">/// Return true if V is an instruction of the specified opcode and if it</td>
    <td class="lineNumber">161</td>
    <td class="codeline">/// Return true if V is an instruction of the specified opcode and if it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">/// only has one use.</td>
    <td class="lineNumber">162</td>
    <td class="codeline">/// only has one use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">static BinaryOperator *isReassociableOp(Value *V, unsigned Opcode) {</td>
    <td class="lineNumber">163</td>
    <td class="codeline">static BinaryOperator *isReassociableOp(Value *V, unsigned Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  auto *BO = dyn_cast<BinaryOperator>(V);</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  auto *BO = dyn_cast<BinaryOperator>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">  if (BO && BO->hasOneUse() && BO->getOpcode() == Opcode)</td>
    <td class="lineNumber">165</td>
    <td class="codeline">  if (BO && BO->hasOneUse() && BO->getOpcode() == Opcode)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">    if (!isa<FPMathOperator>(BO) || hasFPAssociativeFlags(BO))</td>
    <td class="lineNumber">166</td>
    <td class="codeline">    if (!isa<FPMathOperator>(BO) || hasFPAssociativeFlags(BO))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">      return BO;</td>
    <td class="lineNumber">167</td>
    <td class="codeline">      return BO;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">}</td>
    <td class="lineNumber">169</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline"></td>
    <td class="lineNumber">170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">static BinaryOperator *isReassociableOp(Value *V, unsigned Opcode1,</td>
    <td class="lineNumber">171</td>
    <td class="codeline">static BinaryOperator *isReassociableOp(Value *V, unsigned Opcode1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">                                        unsigned Opcode2) {</td>
    <td class="lineNumber">172</td>
    <td class="codeline">                                        unsigned Opcode2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">  auto *BO = dyn_cast<BinaryOperator>(V);</td>
    <td class="lineNumber">173</td>
    <td class="codeline">  auto *BO = dyn_cast<BinaryOperator>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  if (BO && BO->hasOneUse() &&</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  if (BO && BO->hasOneUse() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">      (BO->getOpcode() == Opcode1 || BO->getOpcode() == Opcode2))</td>
    <td class="lineNumber">175</td>
    <td class="codeline">      (BO->getOpcode() == Opcode1 || BO->getOpcode() == Opcode2))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">    if (!isa<FPMathOperator>(BO) || hasFPAssociativeFlags(BO))</td>
    <td class="lineNumber">176</td>
    <td class="codeline">    if (!isa<FPMathOperator>(BO) || hasFPAssociativeFlags(BO))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">      return BO;</td>
    <td class="lineNumber">177</td>
    <td class="codeline">      return BO;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">}</td>
    <td class="lineNumber">179</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline"></td>
    <td class="lineNumber">180</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">void ReassociatePass::BuildRankMap(Function &F,</td>
    <td class="lineNumber">181</td>
    <td class="codeline">void ReassociatePass::BuildRankMap(Function &F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">                                   ReversePostOrderTraversal<Function*> &RPOT) {</td>
    <td class="lineNumber">182</td>
    <td class="codeline">                                   ReversePostOrderTraversal<Function*> &RPOT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  unsigned Rank = 2;</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  unsigned Rank = 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline"></td>
    <td class="lineNumber">184</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  // Assign distinct ranks to function arguments.</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  // Assign distinct ranks to function arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">  for (auto &Arg : F.args()) {</td>
    <td class="lineNumber">186</td>
    <td class="codeline">  for (auto &Arg : F.args()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">    ValueRankMap[&Arg] = ++Rank;</td>
    <td class="lineNumber">187</td>
    <td class="codeline">    ValueRankMap[&Arg] = ++Rank;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Calculated Rank[" << Arg.getName() << "] = " << Rank</td>
    <td class="lineNumber">188</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Calculated Rank[" << Arg.getName() << "] = " << Rank</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">                      << "\n");</td>
    <td class="lineNumber">189</td>
    <td class="codeline">                      << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline"></td>
    <td class="lineNumber">191</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">  // Traverse basic blocks in ReversePostOrder.</td>
    <td class="lineNumber">192</td>
    <td class="codeline">  // Traverse basic blocks in ReversePostOrder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  for (BasicBlock *BB : RPOT) {</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  for (BasicBlock *BB : RPOT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">    unsigned BBRank = RankMap[BB] = ++Rank << 16;</td>
    <td class="lineNumber">194</td>
    <td class="codeline">    unsigned BBRank = RankMap[BB] = ++Rank << 16;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline"></td>
    <td class="lineNumber">195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">    // Walk the basic block, adding precomputed ranks for any instructions that</td>
    <td class="lineNumber">196</td>
    <td class="codeline">    // Walk the basic block, adding precomputed ranks for any instructions that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">    // we cannot move.  This ensures that the ranks for these instructions are</td>
    <td class="lineNumber">197</td>
    <td class="codeline">    // we cannot move.  This ensures that the ranks for these instructions are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">    // all different in the block.</td>
    <td class="lineNumber">198</td>
    <td class="codeline">    // all different in the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">    for (Instruction &I : *BB)</td>
    <td class="lineNumber">199</td>
    <td class="codeline">    for (Instruction &I : *BB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">      if (mayHaveNonDefUseDependency(I))</td>
    <td class="lineNumber">200</td>
    <td class="codeline">      if (mayHaveNonDefUseDependency(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">        ValueRankMap[&I] = ++BBRank;</td>
    <td class="lineNumber">201</td>
    <td class="codeline">        ValueRankMap[&I] = ++BBRank;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">202</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">}</td>
    <td class="lineNumber">203</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">unsigned ReassociatePass::getRank(Value *V) {</td>
    <td class="lineNumber">205</td>
    <td class="codeline">unsigned ReassociatePass::getRank(Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  Instruction *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  Instruction *I = dyn_cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  if (!I) {</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  if (!I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">    if (isa<Argument>(V)) return ValueRankMap[V];   // Function argument.</td>
    <td class="lineNumber">208</td>
    <td class="codeline">    if (isa<Argument>(V)) return ValueRankMap[V];   // Function argument.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">    return 0;  // Otherwise it's a global or constant, rank 0.</td>
    <td class="lineNumber">209</td>
    <td class="codeline">    return 0;  // Otherwise it's a global or constant, rank 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">210</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline"></td>
    <td class="lineNumber">211</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  if (unsigned Rank = ValueRankMap[I])</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  if (unsigned Rank = ValueRankMap[I])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">    return Rank;    // Rank already known?</td>
    <td class="lineNumber">213</td>
    <td class="codeline">    return Rank;    // Rank already known?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">  // If this is an expression, return the 1+MAX(rank(LHS), rank(RHS)) so that</td>
    <td class="lineNumber">215</td>
    <td class="codeline">  // If this is an expression, return the 1+MAX(rank(LHS), rank(RHS)) so that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">  // we can reassociate expressions for code motion!  Since we do not recurse</td>
    <td class="lineNumber">216</td>
    <td class="codeline">  // we can reassociate expressions for code motion!  Since we do not recurse</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  // for PHI nodes, we cannot have infinite recursion here, because there</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  // for PHI nodes, we cannot have infinite recursion here, because there</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  // cannot be loops in the value graph that do not go through PHI nodes.</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  // cannot be loops in the value graph that do not go through PHI nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  unsigned Rank = 0, MaxRank = RankMap[I->getParent()];</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  unsigned Rank = 0, MaxRank = RankMap[I->getParent()];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">  for (unsigned i = 0, e = I->getNumOperands(); i != e && Rank != MaxRank; ++i)</td>
    <td class="lineNumber">220</td>
    <td class="codeline">  for (unsigned i = 0, e = I->getNumOperands(); i != e && Rank != MaxRank; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">    Rank = std::max(Rank, getRank(I->getOperand(i)));</td>
    <td class="lineNumber">221</td>
    <td class="codeline">    Rank = std::max(Rank, getRank(I->getOperand(i)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline"></td>
    <td class="lineNumber">222</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  // If this is a 'not' or 'neg' instruction, do not count it for rank. This</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  // If this is a 'not' or 'neg' instruction, do not count it for rank. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">  // assures us that X and ~X will have the same rank.</td>
    <td class="lineNumber">224</td>
    <td class="codeline">  // assures us that X and ~X will have the same rank.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">  if (!match(I, m_Not(m_Value())) && !match(I, m_Neg(m_Value())) &&</td>
    <td class="lineNumber">225</td>
    <td class="codeline">  if (!match(I, m_Not(m_Value())) && !match(I, m_Neg(m_Value())) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">      !match(I, m_FNeg(m_Value())))</td>
    <td class="lineNumber">226</td>
    <td class="codeline">      !match(I, m_FNeg(m_Value())))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">    ++Rank;</td>
    <td class="lineNumber">227</td>
    <td class="codeline">    ++Rank;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline"></td>
    <td class="lineNumber">228</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Calculated Rank[" << V->getName() << "] = " << Rank</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Calculated Rank[" << V->getName() << "] = " << Rank</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">                    << "\n");</td>
    <td class="lineNumber">230</td>
    <td class="codeline">                    << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline"></td>
    <td class="lineNumber">231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  return ValueRankMap[I] = Rank;</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  return ValueRankMap[I] = Rank;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">}</td>
    <td class="lineNumber">233</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline"></td>
    <td class="lineNumber">234</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">// Canonicalize constants to RHS.  Otherwise, sort the operands by rank.</td>
    <td class="lineNumber">235</td>
    <td class="codeline">// Canonicalize constants to RHS.  Otherwise, sort the operands by rank.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">void ReassociatePass::canonicalizeOperands(Instruction *I) {</td>
    <td class="lineNumber">236</td>
    <td class="codeline">void ReassociatePass::canonicalizeOperands(Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  assert(isa<BinaryOperator>(I) && "Expected binary operator.");</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  assert(isa<BinaryOperator>(I) && "Expected binary operator.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  assert(I->isCommutative() && "Expected commutative operator.");</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  assert(I->isCommutative() && "Expected commutative operator.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline"></td>
    <td class="lineNumber">239</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  Value *LHS = I->getOperand(0);</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  Value *LHS = I->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  Value *RHS = I->getOperand(1);</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  Value *RHS = I->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  if (LHS == RHS || isa<Constant>(RHS))</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  if (LHS == RHS || isa<Constant>(RHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">243</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  if (isa<Constant>(LHS) || getRank(RHS) < getRank(LHS))</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  if (isa<Constant>(LHS) || getRank(RHS) < getRank(LHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">    cast<BinaryOperator>(I)->swapOperands();</td>
    <td class="lineNumber">245</td>
    <td class="codeline">    cast<BinaryOperator>(I)->swapOperands();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">}</td>
    <td class="lineNumber">246</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline"></td>
    <td class="lineNumber">247</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">static BinaryOperator *CreateAdd(Value *S1, Value *S2, const Twine &Name,</td>
    <td class="lineNumber">248</td>
    <td class="codeline">static BinaryOperator *CreateAdd(Value *S1, Value *S2, const Twine &Name,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">                                 Instruction *InsertBefore, Value *FlagsOp) {</td>
    <td class="lineNumber">249</td>
    <td class="codeline">                                 Instruction *InsertBefore, Value *FlagsOp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  if (S1->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  if (S1->getType()->isIntOrIntVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">    return BinaryOperator::CreateAdd(S1, S2, Name, InsertBefore);</td>
    <td class="lineNumber">251</td>
    <td class="codeline">    return BinaryOperator::CreateAdd(S1, S2, Name, InsertBefore);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  else {</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">    BinaryOperator *Res =</td>
    <td class="lineNumber">253</td>
    <td class="codeline">    BinaryOperator *Res =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">        BinaryOperator::CreateFAdd(S1, S2, Name, InsertBefore);</td>
    <td class="lineNumber">254</td>
    <td class="codeline">        BinaryOperator::CreateFAdd(S1, S2, Name, InsertBefore);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">    Res->setFastMathFlags(cast<FPMathOperator>(FlagsOp)->getFastMathFlags());</td>
    <td class="lineNumber">255</td>
    <td class="codeline">    Res->setFastMathFlags(cast<FPMathOperator>(FlagsOp)->getFastMathFlags());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">    return Res;</td>
    <td class="lineNumber">256</td>
    <td class="codeline">    return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">}</td>
    <td class="lineNumber">258</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">static BinaryOperator *CreateMul(Value *S1, Value *S2, const Twine &Name,</td>
    <td class="lineNumber">260</td>
    <td class="codeline">static BinaryOperator *CreateMul(Value *S1, Value *S2, const Twine &Name,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">                                 Instruction *InsertBefore, Value *FlagsOp) {</td>
    <td class="lineNumber">261</td>
    <td class="codeline">                                 Instruction *InsertBefore, Value *FlagsOp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  if (S1->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  if (S1->getType()->isIntOrIntVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">    return BinaryOperator::CreateMul(S1, S2, Name, InsertBefore);</td>
    <td class="lineNumber">263</td>
    <td class="codeline">    return BinaryOperator::CreateMul(S1, S2, Name, InsertBefore);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  else {</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">    BinaryOperator *Res =</td>
    <td class="lineNumber">265</td>
    <td class="codeline">    BinaryOperator *Res =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">      BinaryOperator::CreateFMul(S1, S2, Name, InsertBefore);</td>
    <td class="lineNumber">266</td>
    <td class="codeline">      BinaryOperator::CreateFMul(S1, S2, Name, InsertBefore);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">    Res->setFastMathFlags(cast<FPMathOperator>(FlagsOp)->getFastMathFlags());</td>
    <td class="lineNumber">267</td>
    <td class="codeline">    Res->setFastMathFlags(cast<FPMathOperator>(FlagsOp)->getFastMathFlags());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">    return Res;</td>
    <td class="lineNumber">268</td>
    <td class="codeline">    return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">}</td>
    <td class="lineNumber">270</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">static Instruction *CreateNeg(Value *S1, const Twine &Name,</td>
    <td class="lineNumber">272</td>
    <td class="codeline">static Instruction *CreateNeg(Value *S1, const Twine &Name,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">                              Instruction *InsertBefore, Value *FlagsOp) {</td>
    <td class="lineNumber">273</td>
    <td class="codeline">                              Instruction *InsertBefore, Value *FlagsOp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  if (S1->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  if (S1->getType()->isIntOrIntVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">    return BinaryOperator::CreateNeg(S1, Name, InsertBefore);</td>
    <td class="lineNumber">275</td>
    <td class="codeline">    return BinaryOperator::CreateNeg(S1, Name, InsertBefore);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline"></td>
    <td class="lineNumber">276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">  if (auto *FMFSource = dyn_cast<Instruction>(FlagsOp))</td>
    <td class="lineNumber">277</td>
    <td class="codeline">  if (auto *FMFSource = dyn_cast<Instruction>(FlagsOp))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">    return UnaryOperator::CreateFNegFMF(S1, FMFSource, Name, InsertBefore);</td>
    <td class="lineNumber">278</td>
    <td class="codeline">    return UnaryOperator::CreateFNegFMF(S1, FMFSource, Name, InsertBefore);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline"></td>
    <td class="lineNumber">279</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  return UnaryOperator::CreateFNeg(S1, Name, InsertBefore);</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  return UnaryOperator::CreateFNeg(S1, Name, InsertBefore);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">}</td>
    <td class="lineNumber">281</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">/// Replace 0-X with X*-1.</td>
    <td class="lineNumber">283</td>
    <td class="codeline">/// Replace 0-X with X*-1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">static BinaryOperator *LowerNegateToMultiply(Instruction *Neg) {</td>
    <td class="lineNumber">284</td>
    <td class="codeline">static BinaryOperator *LowerNegateToMultiply(Instruction *Neg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  assert((isa<UnaryOperator>(Neg) || isa<BinaryOperator>(Neg)) &&</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  assert((isa<UnaryOperator>(Neg) || isa<BinaryOperator>(Neg)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">         "Expected a Negate!");</td>
    <td class="lineNumber">286</td>
    <td class="codeline">         "Expected a Negate!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  // FIXME: It's not safe to lower a unary FNeg into a FMul by -1.0.</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  // FIXME: It's not safe to lower a unary FNeg into a FMul by -1.0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  unsigned OpNo = isa<BinaryOperator>(Neg) ? 1 : 0;</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  unsigned OpNo = isa<BinaryOperator>(Neg) ? 1 : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  Type *Ty = Neg->getType();</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  Type *Ty = Neg->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">  Constant *NegOne = Ty->isIntOrIntVectorTy() ?</td>
    <td class="lineNumber">290</td>
    <td class="codeline">  Constant *NegOne = Ty->isIntOrIntVectorTy() ?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">    ConstantInt::getAllOnesValue(Ty) : ConstantFP::get(Ty, -1.0);</td>
    <td class="lineNumber">291</td>
    <td class="codeline">    ConstantInt::getAllOnesValue(Ty) : ConstantFP::get(Ty, -1.0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  BinaryOperator *Res = CreateMul(Neg->getOperand(OpNo), NegOne, "", Neg, Neg);</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  BinaryOperator *Res = CreateMul(Neg->getOperand(OpNo), NegOne, "", Neg, Neg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  Neg->setOperand(OpNo, Constant::getNullValue(Ty)); // Drop use of op.</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  Neg->setOperand(OpNo, Constant::getNullValue(Ty)); // Drop use of op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  Res->takeName(Neg);</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  Res->takeName(Neg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  Neg->replaceAllUsesWith(Res);</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  Neg->replaceAllUsesWith(Res);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">  Res->setDebugLoc(Neg->getDebugLoc());</td>
    <td class="lineNumber">297</td>
    <td class="codeline">  Res->setDebugLoc(Neg->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  return Res;</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">}</td>
    <td class="lineNumber">299</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline"></td>
    <td class="lineNumber">300</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">/// Returns k such that lambda(2^Bitwidth) = 2^k, where lambda is the Carmichael</td>
    <td class="lineNumber">301</td>
    <td class="codeline">/// Returns k such that lambda(2^Bitwidth) = 2^k, where lambda is the Carmichael</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">/// function. This means that x^(2^k) === 1 mod 2^Bitwidth for</td>
    <td class="lineNumber">302</td>
    <td class="codeline">/// function. This means that x^(2^k) === 1 mod 2^Bitwidth for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">/// every odd x, i.e. x^(2^k) = 1 for every odd x in Bitwidth-bit arithmetic.</td>
    <td class="lineNumber">303</td>
    <td class="codeline">/// every odd x, i.e. x^(2^k) = 1 for every odd x in Bitwidth-bit arithmetic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">/// Note that 0 <= k < Bitwidth, and if Bitwidth > 3 then x^(2^k) = 0 for every</td>
    <td class="lineNumber">304</td>
    <td class="codeline">/// Note that 0 <= k < Bitwidth, and if Bitwidth > 3 then x^(2^k) = 0 for every</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">/// even x in Bitwidth-bit arithmetic.</td>
    <td class="lineNumber">305</td>
    <td class="codeline">/// even x in Bitwidth-bit arithmetic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">static unsigned CarmichaelShift(unsigned Bitwidth) {</td>
    <td class="lineNumber">306</td>
    <td class="codeline">static unsigned CarmichaelShift(unsigned Bitwidth) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  if (Bitwidth < 3)</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  if (Bitwidth < 3)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    return Bitwidth - 1;</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    return Bitwidth - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  return Bitwidth - 2;</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  return Bitwidth - 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">}</td>
    <td class="lineNumber">310</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">/// Add the extra weight 'RHS' to the existing weight 'LHS',</td>
    <td class="lineNumber">312</td>
    <td class="codeline">/// Add the extra weight 'RHS' to the existing weight 'LHS',</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">/// reducing the combined weight using any special properties of the operation.</td>
    <td class="lineNumber">313</td>
    <td class="codeline">/// reducing the combined weight using any special properties of the operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">/// The existing weight LHS represents the computation X op X op ... op X where</td>
    <td class="lineNumber">314</td>
    <td class="codeline">/// The existing weight LHS represents the computation X op X op ... op X where</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">/// X occurs LHS times.  The combined weight represents  X op X op ... op X with</td>
    <td class="lineNumber">315</td>
    <td class="codeline">/// X occurs LHS times.  The combined weight represents  X op X op ... op X with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">/// X occurring LHS + RHS times.  If op is "Xor" for example then the combined</td>
    <td class="lineNumber">316</td>
    <td class="codeline">/// X occurring LHS + RHS times.  If op is "Xor" for example then the combined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">/// operation is equivalent to X if LHS + RHS is odd, or 0 if LHS + RHS is even;</td>
    <td class="lineNumber">317</td>
    <td class="codeline">/// operation is equivalent to X if LHS + RHS is odd, or 0 if LHS + RHS is even;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">/// the routine returns 1 in LHS in the first case, and 0 in LHS in the second.</td>
    <td class="lineNumber">318</td>
    <td class="codeline">/// the routine returns 1 in LHS in the first case, and 0 in LHS in the second.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">static void IncorporateWeight(APInt &LHS, const APInt &RHS, unsigned Opcode) {</td>
    <td class="lineNumber">319</td>
    <td class="codeline">static void IncorporateWeight(APInt &LHS, const APInt &RHS, unsigned Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">  // If we were working with infinite precision arithmetic then the combined</td>
    <td class="lineNumber">320</td>
    <td class="codeline">  // If we were working with infinite precision arithmetic then the combined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">  // weight would be LHS + RHS.  But we are using finite precision arithmetic,</td>
    <td class="lineNumber">321</td>
    <td class="codeline">  // weight would be LHS + RHS.  But we are using finite precision arithmetic,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">  // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct</td>
    <td class="lineNumber">322</td>
    <td class="codeline">  // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">  // for nilpotent operations and addition, but not for idempotent operations</td>
    <td class="lineNumber">323</td>
    <td class="codeline">  // for nilpotent operations and addition, but not for idempotent operations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">  // and multiplication), so it is important to correctly reduce the combined</td>
    <td class="lineNumber">324</td>
    <td class="codeline">  // and multiplication), so it is important to correctly reduce the combined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">  // weight back into range if wrapping would be wrong.</td>
    <td class="lineNumber">325</td>
    <td class="codeline">  // weight back into range if wrapping would be wrong.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline"></td>
    <td class="lineNumber">326</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">  // If RHS is zero then the weight didn't change.</td>
    <td class="lineNumber">327</td>
    <td class="codeline">  // If RHS is zero then the weight didn't change.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">  if (RHS.isMinValue())</td>
    <td class="lineNumber">328</td>
    <td class="codeline">  if (RHS.isMinValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">329</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  // If LHS is zero then the combined weight is RHS.</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  // If LHS is zero then the combined weight is RHS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">  if (LHS.isMinValue()) {</td>
    <td class="lineNumber">331</td>
    <td class="codeline">  if (LHS.isMinValue()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">    LHS = RHS;</td>
    <td class="lineNumber">332</td>
    <td class="codeline">    LHS = RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">333</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">334</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">  // From this point on we know that neither LHS nor RHS is zero.</td>
    <td class="lineNumber">335</td>
    <td class="codeline">  // From this point on we know that neither LHS nor RHS is zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
    <td class="lineNumber">336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  if (Instruction::isIdempotent(Opcode)) {</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  if (Instruction::isIdempotent(Opcode)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">    // Idempotent means X op X === X, so any non-zero weight is equivalent to a</td>
    <td class="lineNumber">338</td>
    <td class="codeline">    // Idempotent means X op X === X, so any non-zero weight is equivalent to a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">    // weight of 1.  Keeping weights at zero or one also means that wrapping is</td>
    <td class="lineNumber">339</td>
    <td class="codeline">    // weight of 1.  Keeping weights at zero or one also means that wrapping is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">    // not a problem.</td>
    <td class="lineNumber">340</td>
    <td class="codeline">    // not a problem.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">    assert(LHS == 1 && RHS == 1 && "Weights not reduced!");</td>
    <td class="lineNumber">341</td>
    <td class="codeline">    assert(LHS == 1 && RHS == 1 && "Weights not reduced!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">    return; // Return a weight of 1.</td>
    <td class="lineNumber">342</td>
    <td class="codeline">    return; // Return a weight of 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">343</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">  if (Instruction::isNilpotent(Opcode)) {</td>
    <td class="lineNumber">344</td>
    <td class="codeline">  if (Instruction::isNilpotent(Opcode)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">    // Nilpotent means X op X === 0, so reduce weights modulo 2.</td>
    <td class="lineNumber">345</td>
    <td class="codeline">    // Nilpotent means X op X === 0, so reduce weights modulo 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">    assert(LHS == 1 && RHS == 1 && "Weights not reduced!");</td>
    <td class="lineNumber">346</td>
    <td class="codeline">    assert(LHS == 1 && RHS == 1 && "Weights not reduced!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">    LHS = 0; // 1 + 1 === 0 modulo 2.</td>
    <td class="lineNumber">347</td>
    <td class="codeline">    LHS = 0; // 1 + 1 === 0 modulo 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">348</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">349</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">  if (Opcode == Instruction::Add || Opcode == Instruction::FAdd) {</td>
    <td class="lineNumber">350</td>
    <td class="codeline">  if (Opcode == Instruction::Add || Opcode == Instruction::FAdd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">    // TODO: Reduce the weight by exploiting nsw/nuw?</td>
    <td class="lineNumber">351</td>
    <td class="codeline">    // TODO: Reduce the weight by exploiting nsw/nuw?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">    LHS += RHS;</td>
    <td class="lineNumber">352</td>
    <td class="codeline">    LHS += RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">353</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">354</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline"></td>
    <td class="lineNumber">355</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">  assert((Opcode == Instruction::Mul || Opcode == Instruction::FMul) &&</td>
    <td class="lineNumber">356</td>
    <td class="codeline">  assert((Opcode == Instruction::Mul || Opcode == Instruction::FMul) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">         "Unknown associative operation!");</td>
    <td class="lineNumber">357</td>
    <td class="codeline">         "Unknown associative operation!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">  unsigned Bitwidth = LHS.getBitWidth();</td>
    <td class="lineNumber">358</td>
    <td class="codeline">  unsigned Bitwidth = LHS.getBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">  // If CM is the Carmichael number then a weight W satisfying W >= CM+Bitwidth</td>
    <td class="lineNumber">359</td>
    <td class="codeline">  // If CM is the Carmichael number then a weight W satisfying W >= CM+Bitwidth</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">  // can be replaced with W-CM.  That's because x^W=x^(W-CM) for every Bitwidth</td>
    <td class="lineNumber">360</td>
    <td class="codeline">  // can be replaced with W-CM.  That's because x^W=x^(W-CM) for every Bitwidth</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">  // bit number x, since either x is odd in which case x^CM = 1, or x is even in</td>
    <td class="lineNumber">361</td>
    <td class="codeline">  // bit number x, since either x is odd in which case x^CM = 1, or x is even in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">  // which case both x^W and x^(W - CM) are zero.  By subtracting off multiples</td>
    <td class="lineNumber">362</td>
    <td class="codeline">  // which case both x^W and x^(W - CM) are zero.  By subtracting off multiples</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">  // of CM like this weights can always be reduced to the range [0, CM+Bitwidth)</td>
    <td class="lineNumber">363</td>
    <td class="codeline">  // of CM like this weights can always be reduced to the range [0, CM+Bitwidth)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">  // which by a happy accident means that they can always be represented using</td>
    <td class="lineNumber">364</td>
    <td class="codeline">  // which by a happy accident means that they can always be represented using</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">  // Bitwidth bits.</td>
    <td class="lineNumber">365</td>
    <td class="codeline">  // Bitwidth bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">  // TODO: Reduce the weight by exploiting nsw/nuw?  (Could do much better than</td>
    <td class="lineNumber">366</td>
    <td class="codeline">  // TODO: Reduce the weight by exploiting nsw/nuw?  (Could do much better than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">  // the Carmichael number).</td>
    <td class="lineNumber">367</td>
    <td class="codeline">  // the Carmichael number).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">  if (Bitwidth > 3) {</td>
    <td class="lineNumber">368</td>
    <td class="codeline">  if (Bitwidth > 3) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">    /// CM - The value of Carmichael's lambda function.</td>
    <td class="lineNumber">369</td>
    <td class="codeline">    /// CM - The value of Carmichael's lambda function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">    APInt CM = APInt::getOneBitSet(Bitwidth, CarmichaelShift(Bitwidth));</td>
    <td class="lineNumber">370</td>
    <td class="codeline">    APInt CM = APInt::getOneBitSet(Bitwidth, CarmichaelShift(Bitwidth));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">    // Any weight W >= Threshold can be replaced with W - CM.</td>
    <td class="lineNumber">371</td>
    <td class="codeline">    // Any weight W >= Threshold can be replaced with W - CM.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">    APInt Threshold = CM + Bitwidth;</td>
    <td class="lineNumber">372</td>
    <td class="codeline">    APInt Threshold = CM + Bitwidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">    assert(LHS.ult(Threshold) && RHS.ult(Threshold) && "Weights not reduced!");</td>
    <td class="lineNumber">373</td>
    <td class="codeline">    assert(LHS.ult(Threshold) && RHS.ult(Threshold) && "Weights not reduced!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">    // For Bitwidth 4 or more the following sum does not overflow.</td>
    <td class="lineNumber">374</td>
    <td class="codeline">    // For Bitwidth 4 or more the following sum does not overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">    LHS += RHS;</td>
    <td class="lineNumber">375</td>
    <td class="codeline">    LHS += RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">    while (LHS.uge(Threshold))</td>
    <td class="lineNumber">376</td>
    <td class="codeline">    while (LHS.uge(Threshold))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">      LHS -= CM;</td>
    <td class="lineNumber">377</td>
    <td class="codeline">      LHS -= CM;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">378</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">    // To avoid problems with overflow do everything the same as above but using</td>
    <td class="lineNumber">379</td>
    <td class="codeline">    // To avoid problems with overflow do everything the same as above but using</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">    // a larger type.</td>
    <td class="lineNumber">380</td>
    <td class="codeline">    // a larger type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">    unsigned CM = 1U << CarmichaelShift(Bitwidth);</td>
    <td class="lineNumber">381</td>
    <td class="codeline">    unsigned CM = 1U << CarmichaelShift(Bitwidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">    unsigned Threshold = CM + Bitwidth;</td>
    <td class="lineNumber">382</td>
    <td class="codeline">    unsigned Threshold = CM + Bitwidth;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">    assert(LHS.getZExtValue() < Threshold && RHS.getZExtValue() < Threshold &&</td>
    <td class="lineNumber">383</td>
    <td class="codeline">    assert(LHS.getZExtValue() < Threshold && RHS.getZExtValue() < Threshold &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">           "Weights not reduced!");</td>
    <td class="lineNumber">384</td>
    <td class="codeline">           "Weights not reduced!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">    unsigned Total = LHS.getZExtValue() + RHS.getZExtValue();</td>
    <td class="lineNumber">385</td>
    <td class="codeline">    unsigned Total = LHS.getZExtValue() + RHS.getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">    while (Total >= Threshold)</td>
    <td class="lineNumber">386</td>
    <td class="codeline">    while (Total >= Threshold)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">      Total -= CM;</td>
    <td class="lineNumber">387</td>
    <td class="codeline">      Total -= CM;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">    LHS = Total;</td>
    <td class="lineNumber">388</td>
    <td class="codeline">    LHS = Total;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">389</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">}</td>
    <td class="lineNumber">390</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline"></td>
    <td class="lineNumber">391</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">using RepeatedValue = std::pair<Value*, APInt>;</td>
    <td class="lineNumber">392</td>
    <td class="codeline">using RepeatedValue = std::pair<Value*, APInt>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline"></td>
    <td class="lineNumber">393</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">/// Given an associative binary expression, return the leaf</td>
    <td class="lineNumber">394</td>
    <td class="codeline">/// Given an associative binary expression, return the leaf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">/// nodes in Ops along with their weights (how many times the leaf occurs).  The</td>
    <td class="lineNumber">395</td>
    <td class="codeline">/// nodes in Ops along with their weights (how many times the leaf occurs).  The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">/// original expression is the same as</td>
    <td class="lineNumber">396</td>
    <td class="codeline">/// original expression is the same as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">///   (Ops[0].first op Ops[0].first op ... Ops[0].first)  <- Ops[0].second times</td>
    <td class="lineNumber">397</td>
    <td class="codeline">///   (Ops[0].first op Ops[0].first op ... Ops[0].first)  <- Ops[0].second times</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">/// op</td>
    <td class="lineNumber">398</td>
    <td class="codeline">/// op</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">///   (Ops[1].first op Ops[1].first op ... Ops[1].first)  <- Ops[1].second times</td>
    <td class="lineNumber">399</td>
    <td class="codeline">///   (Ops[1].first op Ops[1].first op ... Ops[1].first)  <- Ops[1].second times</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">/// op</td>
    <td class="lineNumber">400</td>
    <td class="codeline">/// op</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">///   ...</td>
    <td class="lineNumber">401</td>
    <td class="codeline">///   ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">/// op</td>
    <td class="lineNumber">402</td>
    <td class="codeline">/// op</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">///   (Ops[N].first op Ops[N].first op ... Ops[N].first)  <- Ops[N].second times</td>
    <td class="lineNumber">403</td>
    <td class="codeline">///   (Ops[N].first op Ops[N].first op ... Ops[N].first)  <- Ops[N].second times</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">///</td>
    <td class="lineNumber">404</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">/// Note that the values Ops[0].first, ..., Ops[N].first are all distinct.</td>
    <td class="lineNumber">405</td>
    <td class="codeline">/// Note that the values Ops[0].first, ..., Ops[N].first are all distinct.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">///</td>
    <td class="lineNumber">406</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">/// This routine may modify the function, in which case it returns 'true'.  The</td>
    <td class="lineNumber">407</td>
    <td class="codeline">/// This routine may modify the function, in which case it returns 'true'.  The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">/// changes it makes may well be destructive, changing the value computed by 'I'</td>
    <td class="lineNumber">408</td>
    <td class="codeline">/// changes it makes may well be destructive, changing the value computed by 'I'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">/// to something completely different.  Thus if the routine returns 'true' then</td>
    <td class="lineNumber">409</td>
    <td class="codeline">/// to something completely different.  Thus if the routine returns 'true' then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">/// you MUST either replace I with a new expression computed from the Ops array,</td>
    <td class="lineNumber">410</td>
    <td class="codeline">/// you MUST either replace I with a new expression computed from the Ops array,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">/// or use RewriteExprTree to put the values back in.</td>
    <td class="lineNumber">411</td>
    <td class="codeline">/// or use RewriteExprTree to put the values back in.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">///</td>
    <td class="lineNumber">412</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">/// A leaf node is either not a binary operation of the same kind as the root</td>
    <td class="lineNumber">413</td>
    <td class="codeline">/// A leaf node is either not a binary operation of the same kind as the root</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">/// node 'I' (i.e. is not a binary operator at all, or is, but with a different</td>
    <td class="lineNumber">414</td>
    <td class="codeline">/// node 'I' (i.e. is not a binary operator at all, or is, but with a different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">/// opcode), or is the same kind of binary operator but has a use which either</td>
    <td class="lineNumber">415</td>
    <td class="codeline">/// opcode), or is the same kind of binary operator but has a use which either</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">/// does not belong to the expression, or does belong to the expression but is</td>
    <td class="lineNumber">416</td>
    <td class="codeline">/// does not belong to the expression, or does belong to the expression but is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">/// a leaf node.  Every leaf node has at least one use that is a non-leaf node</td>
    <td class="lineNumber">417</td>
    <td class="codeline">/// a leaf node.  Every leaf node has at least one use that is a non-leaf node</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">/// of the expression, while for non-leaf nodes (except for the root 'I') every</td>
    <td class="lineNumber">418</td>
    <td class="codeline">/// of the expression, while for non-leaf nodes (except for the root 'I') every</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">/// use is a non-leaf node of the expression.</td>
    <td class="lineNumber">419</td>
    <td class="codeline">/// use is a non-leaf node of the expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">///</td>
    <td class="lineNumber">420</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">/// For example:</td>
    <td class="lineNumber">421</td>
    <td class="codeline">/// For example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">///           expression graph        node names</td>
    <td class="lineNumber">422</td>
    <td class="codeline">///           expression graph        node names</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">///</td>
    <td class="lineNumber">423</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">///                     +        |        I</td>
    <td class="lineNumber">424</td>
    <td class="codeline">///                     +        |        I</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">///                    / \       |</td>
    <td class="lineNumber">425</td>
    <td class="codeline">///                    / \       |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">///                   +   +      |      A,  B</td>
    <td class="lineNumber">426</td>
    <td class="codeline">///                   +   +      |      A,  B</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">///                  / \ / \     |</td>
    <td class="lineNumber">427</td>
    <td class="codeline">///                  / \ / \     |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">///                 *   +   *    |    C,  D,  E</td>
    <td class="lineNumber">428</td>
    <td class="codeline">///                 *   +   *    |    C,  D,  E</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">///                / \ / \ / \   |</td>
    <td class="lineNumber">429</td>
    <td class="codeline">///                / \ / \ / \   |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">///                   +   *      |      F,  G</td>
    <td class="lineNumber">430</td>
    <td class="codeline">///                   +   *      |      F,  G</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">///</td>
    <td class="lineNumber">431</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">/// The leaf nodes are C, E, F and G.  The Ops array will contain (maybe not in</td>
    <td class="lineNumber">432</td>
    <td class="codeline">/// The leaf nodes are C, E, F and G.  The Ops array will contain (maybe not in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">/// that order) (C, 1), (E, 1), (F, 2), (G, 2).</td>
    <td class="lineNumber">433</td>
    <td class="codeline">/// that order) (C, 1), (E, 1), (F, 2), (G, 2).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">///</td>
    <td class="lineNumber">434</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">/// The expression is maximal: if some instruction is a binary operator of the</td>
    <td class="lineNumber">435</td>
    <td class="codeline">/// The expression is maximal: if some instruction is a binary operator of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">/// same kind as 'I', and all of its uses are non-leaf nodes of the expression,</td>
    <td class="lineNumber">436</td>
    <td class="codeline">/// same kind as 'I', and all of its uses are non-leaf nodes of the expression,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">/// then the instruction also belongs to the expression, is not a leaf node of</td>
    <td class="lineNumber">437</td>
    <td class="codeline">/// then the instruction also belongs to the expression, is not a leaf node of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">/// it, and its operands also belong to the expression (but may be leaf nodes).</td>
    <td class="lineNumber">438</td>
    <td class="codeline">/// it, and its operands also belong to the expression (but may be leaf nodes).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">///</td>
    <td class="lineNumber">439</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">/// NOTE: This routine will set operands of non-leaf non-root nodes to undef in</td>
    <td class="lineNumber">440</td>
    <td class="codeline">/// NOTE: This routine will set operands of non-leaf non-root nodes to undef in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">/// order to ensure that every non-root node in the expression has *exactly one*</td>
    <td class="lineNumber">441</td>
    <td class="codeline">/// order to ensure that every non-root node in the expression has *exactly one*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">/// use by a non-leaf node of the expression.  This destruction means that the</td>
    <td class="lineNumber">442</td>
    <td class="codeline">/// use by a non-leaf node of the expression.  This destruction means that the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">/// caller MUST either replace 'I' with a new expression or use something like</td>
    <td class="lineNumber">443</td>
    <td class="codeline">/// caller MUST either replace 'I' with a new expression or use something like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">/// RewriteExprTree to put the values back in if the routine indicates that it</td>
    <td class="lineNumber">444</td>
    <td class="codeline">/// RewriteExprTree to put the values back in if the routine indicates that it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">/// made a change by returning 'true'.</td>
    <td class="lineNumber">445</td>
    <td class="codeline">/// made a change by returning 'true'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">///</td>
    <td class="lineNumber">446</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">/// In the above example either the right operand of A or the left operand of B</td>
    <td class="lineNumber">447</td>
    <td class="codeline">/// In the above example either the right operand of A or the left operand of B</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">/// will be replaced by undef.  If it is B's operand then this gives:</td>
    <td class="lineNumber">448</td>
    <td class="codeline">/// will be replaced by undef.  If it is B's operand then this gives:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">///</td>
    <td class="lineNumber">449</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">///                     +        |        I</td>
    <td class="lineNumber">450</td>
    <td class="codeline">///                     +        |        I</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">///                    / \       |</td>
    <td class="lineNumber">451</td>
    <td class="codeline">///                    / \       |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">///                   +   +      |      A,  B - operand of B replaced with undef</td>
    <td class="lineNumber">452</td>
    <td class="codeline">///                   +   +      |      A,  B - operand of B replaced with undef</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">///                  / \   \     |</td>
    <td class="lineNumber">453</td>
    <td class="codeline">///                  / \   \     |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">///                 *   +   *    |    C,  D,  E</td>
    <td class="lineNumber">454</td>
    <td class="codeline">///                 *   +   *    |    C,  D,  E</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">///                / \ / \ / \   |</td>
    <td class="lineNumber">455</td>
    <td class="codeline">///                / \ / \ / \   |</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">///                   +   *      |      F,  G</td>
    <td class="lineNumber">456</td>
    <td class="codeline">///                   +   *      |      F,  G</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">///</td>
    <td class="lineNumber">457</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">/// Note that such undef operands can only be reached by passing through 'I'.</td>
    <td class="lineNumber">458</td>
    <td class="codeline">/// Note that such undef operands can only be reached by passing through 'I'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">/// For example, if you visit operands recursively starting from a leaf node</td>
    <td class="lineNumber">459</td>
    <td class="codeline">/// For example, if you visit operands recursively starting from a leaf node</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">/// then you will never see such an undef operand unless you get back to 'I',</td>
    <td class="lineNumber">460</td>
    <td class="codeline">/// then you will never see such an undef operand unless you get back to 'I',</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">/// which requires passing through a phi node.</td>
    <td class="lineNumber">461</td>
    <td class="codeline">/// which requires passing through a phi node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">///</td>
    <td class="lineNumber">462</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">/// Note that this routine may also mutate binary operators of the wrong type</td>
    <td class="lineNumber">463</td>
    <td class="codeline">/// Note that this routine may also mutate binary operators of the wrong type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">/// that have all uses inside the expression (i.e. only used by non-leaf nodes</td>
    <td class="lineNumber">464</td>
    <td class="codeline">/// that have all uses inside the expression (i.e. only used by non-leaf nodes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">/// of the expression) if it can turn them into binary operators of the right</td>
    <td class="lineNumber">465</td>
    <td class="codeline">/// of the expression) if it can turn them into binary operators of the right</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">/// type and thus make the expression bigger.</td>
    <td class="lineNumber">466</td>
    <td class="codeline">/// type and thus make the expression bigger.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">static bool LinearizeExprTree(Instruction *I,</td>
    <td class="lineNumber">467</td>
    <td class="codeline">static bool LinearizeExprTree(Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">                              SmallVectorImpl<RepeatedValue> &Ops,</td>
    <td class="lineNumber">468</td>
    <td class="codeline">                              SmallVectorImpl<RepeatedValue> &Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">                              ReassociatePass::OrderedSet &ToRedo) {</td>
    <td class="lineNumber">469</td>
    <td class="codeline">                              ReassociatePass::OrderedSet &ToRedo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">  assert((isa<UnaryOperator>(I) || isa<BinaryOperator>(I)) &&</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  assert((isa<UnaryOperator>(I) || isa<BinaryOperator>(I)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">         "Expected a UnaryOperator or BinaryOperator!");</td>
    <td class="lineNumber">471</td>
    <td class="codeline">         "Expected a UnaryOperator or BinaryOperator!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LINEARIZE: " << *I << '\n');</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "LINEARIZE: " << *I << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  unsigned Bitwidth = I->getType()->getScalarType()->getPrimitiveSizeInBits();</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  unsigned Bitwidth = I->getType()->getScalarType()->getPrimitiveSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  unsigned Opcode = I->getOpcode();</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  unsigned Opcode = I->getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  assert(I->isAssociative() && I->isCommutative() &&</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  assert(I->isAssociative() && I->isCommutative() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">         "Expected an associative and commutative operation!");</td>
    <td class="lineNumber">476</td>
    <td class="codeline">         "Expected an associative and commutative operation!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline"></td>
    <td class="lineNumber">477</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  // Visit all operands of the expression, keeping track of their weight (the</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  // Visit all operands of the expression, keeping track of their weight (the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  // number of paths from the expression root to the operand, or if you like</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  // number of paths from the expression root to the operand, or if you like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">  // the number of times that operand occurs in the linearized expression).</td>
    <td class="lineNumber">480</td>
    <td class="codeline">  // the number of times that operand occurs in the linearized expression).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">  // For example, if I = X + A, where X = A + B, then I, X and B have weight 1</td>
    <td class="lineNumber">481</td>
    <td class="codeline">  // For example, if I = X + A, where X = A + B, then I, X and B have weight 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">  // while A has weight two.</td>
    <td class="lineNumber">482</td>
    <td class="codeline">  // while A has weight two.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline"></td>
    <td class="lineNumber">483</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">  // Worklist of non-leaf nodes (their operands are in the expression too) along</td>
    <td class="lineNumber">484</td>
    <td class="codeline">  // Worklist of non-leaf nodes (their operands are in the expression too) along</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">  // with their weights, representing a certain number of paths to the operator.</td>
    <td class="lineNumber">485</td>
    <td class="codeline">  // with their weights, representing a certain number of paths to the operator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  // If an operator occurs in the worklist multiple times then we found multiple</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  // If an operator occurs in the worklist multiple times then we found multiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  // ways to get to it.</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  // ways to get to it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">  SmallVector<std::pair<Instruction*, APInt>, 8> Worklist; // (Op, Weight)</td>
    <td class="lineNumber">488</td>
    <td class="codeline">  SmallVector<std::pair<Instruction*, APInt>, 8> Worklist; // (Op, Weight)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">  Worklist.push_back(std::make_pair(I, APInt(Bitwidth, 1)));</td>
    <td class="lineNumber">489</td>
    <td class="codeline">  Worklist.push_back(std::make_pair(I, APInt(Bitwidth, 1)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">490</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline"></td>
    <td class="lineNumber">491</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">  // Leaves of the expression are values that either aren't the right kind of</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  // Leaves of the expression are values that either aren't the right kind of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  // operation (eg: a constant, or a multiply in an add tree), or are, but have</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  // operation (eg: a constant, or a multiply in an add tree), or are, but have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  // some uses that are not inside the expression.  For example, in I = X + X,</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  // some uses that are not inside the expression.  For example, in I = X + X,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">  // X = A + B, the value X has two uses (by I) that are in the expression.  If</td>
    <td class="lineNumber">495</td>
    <td class="codeline">  // X = A + B, the value X has two uses (by I) that are in the expression.  If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  // X has any other uses, for example in a return instruction, then we consider</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  // X has any other uses, for example in a return instruction, then we consider</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">  // X to be a leaf, and won't analyze it further.  When we first visit a value,</td>
    <td class="lineNumber">497</td>
    <td class="codeline">  // X to be a leaf, and won't analyze it further.  When we first visit a value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">  // if it has more than one use then at first we conservatively consider it to</td>
    <td class="lineNumber">498</td>
    <td class="codeline">  // if it has more than one use then at first we conservatively consider it to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">  // be a leaf.  Later, as the expression is explored, we may discover some more</td>
    <td class="lineNumber">499</td>
    <td class="codeline">  // be a leaf.  Later, as the expression is explored, we may discover some more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">  // uses of the value from inside the expression.  If all uses turn out to be</td>
    <td class="lineNumber">500</td>
    <td class="codeline">  // uses of the value from inside the expression.  If all uses turn out to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">  // from within the expression (and the value is a binary operator of the right</td>
    <td class="lineNumber">501</td>
    <td class="codeline">  // from within the expression (and the value is a binary operator of the right</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">  // kind) then the value is no longer considered to be a leaf, and its operands</td>
    <td class="lineNumber">502</td>
    <td class="codeline">  // kind) then the value is no longer considered to be a leaf, and its operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">  // are explored.</td>
    <td class="lineNumber">503</td>
    <td class="codeline">  // are explored.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
    <td class="lineNumber">504</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">  // Leaves - Keeps track of the set of putative leaves as well as the number of</td>
    <td class="lineNumber">505</td>
    <td class="codeline">  // Leaves - Keeps track of the set of putative leaves as well as the number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">  // paths to each leaf seen so far.</td>
    <td class="lineNumber">506</td>
    <td class="codeline">  // paths to each leaf seen so far.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">  using LeafMap = DenseMap<Value *, APInt>;</td>
    <td class="lineNumber">507</td>
    <td class="codeline">  using LeafMap = DenseMap<Value *, APInt>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  LeafMap Leaves; // Leaf -> Total weight so far.</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  LeafMap Leaves; // Leaf -> Total weight so far.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  SmallVector<Value *, 8> LeafOrder; // Ensure deterministic leaf output order.</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  SmallVector<Value *, 8> LeafOrder; // Ensure deterministic leaf output order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline"></td>
    <td class="lineNumber">510</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">511</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  SmallPtrSet<Value *, 8> Visited; // For checking the iteration scheme.</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  SmallPtrSet<Value *, 8> Visited; // For checking the iteration scheme.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">513</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">514</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">    std::pair<Instruction*, APInt> P = Worklist.pop_back_val();</td>
    <td class="lineNumber">515</td>
    <td class="codeline">    std::pair<Instruction*, APInt> P = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">    I = P.first; // We examine the operands of this binary operator.</td>
    <td class="lineNumber">516</td>
    <td class="codeline">    I = P.first; // We examine the operands of this binary operator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">    for (unsigned OpIdx = 0; OpIdx < I->getNumOperands(); ++OpIdx) { // Visit operands.</td>
    <td class="lineNumber">518</td>
    <td class="codeline">    for (unsigned OpIdx = 0; OpIdx < I->getNumOperands(); ++OpIdx) { // Visit operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">      Value *Op = I->getOperand(OpIdx);</td>
    <td class="lineNumber">519</td>
    <td class="codeline">      Value *Op = I->getOperand(OpIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">      APInt Weight = P.second; // Number of paths to this operand.</td>
    <td class="lineNumber">520</td>
    <td class="codeline">      APInt Weight = P.second; // Number of paths to this operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "OPERAND: " << *Op << " (" << Weight << ")\n");</td>
    <td class="lineNumber">521</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "OPERAND: " << *Op << " (" << Weight << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">      assert(!Op->use_empty() && "No uses, so how did we get to it?!");</td>
    <td class="lineNumber">522</td>
    <td class="codeline">      assert(!Op->use_empty() && "No uses, so how did we get to it?!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline"></td>
    <td class="lineNumber">523</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">      // If this is a binary operation of the right kind with only one use then</td>
    <td class="lineNumber">524</td>
    <td class="codeline">      // If this is a binary operation of the right kind with only one use then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">      // add its operands to the expression.</td>
    <td class="lineNumber">525</td>
    <td class="codeline">      // add its operands to the expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">      if (BinaryOperator *BO = isReassociableOp(Op, Opcode)) {</td>
    <td class="lineNumber">526</td>
    <td class="codeline">      if (BinaryOperator *BO = isReassociableOp(Op, Opcode)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">        assert(Visited.insert(Op).second && "Not first visit!");</td>
    <td class="lineNumber">527</td>
    <td class="codeline">        assert(Visited.insert(Op).second && "Not first visit!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "DIRECT ADD: " << *Op << " (" << Weight << ")\n");</td>
    <td class="lineNumber">528</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "DIRECT ADD: " << *Op << " (" << Weight << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">        Worklist.push_back(std::make_pair(BO, Weight));</td>
    <td class="lineNumber">529</td>
    <td class="codeline">        Worklist.push_back(std::make_pair(BO, Weight));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">530</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">531</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline"></td>
    <td class="lineNumber">532</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">      // Appears to be a leaf.  Is the operand already in the set of leaves?</td>
    <td class="lineNumber">533</td>
    <td class="codeline">      // Appears to be a leaf.  Is the operand already in the set of leaves?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">      LeafMap::iterator It = Leaves.find(Op);</td>
    <td class="lineNumber">534</td>
    <td class="codeline">      LeafMap::iterator It = Leaves.find(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">      if (It == Leaves.end()) {</td>
    <td class="lineNumber">535</td>
    <td class="codeline">      if (It == Leaves.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">        // Not in the leaf map.  Must be the first time we saw this operand.</td>
    <td class="lineNumber">536</td>
    <td class="codeline">        // Not in the leaf map.  Must be the first time we saw this operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">        assert(Visited.insert(Op).second && "Not first visit!");</td>
    <td class="lineNumber">537</td>
    <td class="codeline">        assert(Visited.insert(Op).second && "Not first visit!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">        if (!Op->hasOneUse()) {</td>
    <td class="lineNumber">538</td>
    <td class="codeline">        if (!Op->hasOneUse()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">          // This value has uses not accounted for by the expression, so it is</td>
    <td class="lineNumber">539</td>
    <td class="codeline">          // This value has uses not accounted for by the expression, so it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">          // not safe to modify.  Mark it as being a leaf.</td>
    <td class="lineNumber">540</td>
    <td class="codeline">          // not safe to modify.  Mark it as being a leaf.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">541</td>
    <td class="codeline">          LLVM_DEBUG(dbgs()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">                     << "ADD USES LEAF: " << *Op << " (" << Weight << ")\n");</td>
    <td class="lineNumber">542</td>
    <td class="codeline">                     << "ADD USES LEAF: " << *Op << " (" << Weight << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">          LeafOrder.push_back(Op);</td>
    <td class="lineNumber">543</td>
    <td class="codeline">          LeafOrder.push_back(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">          Leaves[Op] = Weight;</td>
    <td class="lineNumber">544</td>
    <td class="codeline">          Leaves[Op] = Weight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">545</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">546</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">        // No uses outside the expression, try morphing it.</td>
    <td class="lineNumber">547</td>
    <td class="codeline">        // No uses outside the expression, try morphing it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">548</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">        // Already in the leaf map.</td>
    <td class="lineNumber">549</td>
    <td class="codeline">        // Already in the leaf map.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">        assert(It != Leaves.end() && Visited.count(Op) &&</td>
    <td class="lineNumber">550</td>
    <td class="codeline">        assert(It != Leaves.end() && Visited.count(Op) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">               "In leaf map but not visited!");</td>
    <td class="lineNumber">551</td>
    <td class="codeline">               "In leaf map but not visited!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline"></td>
    <td class="lineNumber">552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">        // Update the number of paths to the leaf.</td>
    <td class="lineNumber">553</td>
    <td class="codeline">        // Update the number of paths to the leaf.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">        IncorporateWeight(It->second, Weight, Opcode);</td>
    <td class="lineNumber">554</td>
    <td class="codeline">        IncorporateWeight(It->second, Weight, Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline"></td>
    <td class="lineNumber">555</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">#if 0   // TODO: Re-enable once PR13021 is fixed.</td>
    <td class="lineNumber">556</td>
    <td class="codeline">#if 0   // TODO: Re-enable once PR13021 is fixed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">        // The leaf already has one use from inside the expression.  As we want</td>
    <td class="lineNumber">557</td>
    <td class="codeline">        // The leaf already has one use from inside the expression.  As we want</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">        // exactly one such use, drop this new use of the leaf.</td>
    <td class="lineNumber">558</td>
    <td class="codeline">        // exactly one such use, drop this new use of the leaf.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">        assert(!Op->hasOneUse() && "Only one use, but we got here twice!");</td>
    <td class="lineNumber">559</td>
    <td class="codeline">        assert(!Op->hasOneUse() && "Only one use, but we got here twice!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">        I->setOperand(OpIdx, UndefValue::get(I->getType()));</td>
    <td class="lineNumber">560</td>
    <td class="codeline">        I->setOperand(OpIdx, UndefValue::get(I->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">        Changed = true;</td>
    <td class="lineNumber">561</td>
    <td class="codeline">        Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline"></td>
    <td class="lineNumber">562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">        // If the leaf is a binary operation of the right kind and we now see</td>
    <td class="lineNumber">563</td>
    <td class="codeline">        // If the leaf is a binary operation of the right kind and we now see</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">        // that its multiple original uses were in fact all by nodes belonging</td>
    <td class="lineNumber">564</td>
    <td class="codeline">        // that its multiple original uses were in fact all by nodes belonging</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">        // to the expression, then no longer consider it to be a leaf and add</td>
    <td class="lineNumber">565</td>
    <td class="codeline">        // to the expression, then no longer consider it to be a leaf and add</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">        // its operands to the expression.</td>
    <td class="lineNumber">566</td>
    <td class="codeline">        // its operands to the expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">        if (BinaryOperator *BO = isReassociableOp(Op, Opcode)) {</td>
    <td class="lineNumber">567</td>
    <td class="codeline">        if (BinaryOperator *BO = isReassociableOp(Op, Opcode)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << "UNLEAF: " << *Op << " (" << It->second << ")\n");</td>
    <td class="lineNumber">568</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << "UNLEAF: " << *Op << " (" << It->second << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">          Worklist.push_back(std::make_pair(BO, It->second));</td>
    <td class="lineNumber">569</td>
    <td class="codeline">          Worklist.push_back(std::make_pair(BO, It->second));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">          Leaves.erase(It);</td>
    <td class="lineNumber">570</td>
    <td class="codeline">          Leaves.erase(It);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">571</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">572</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">573</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline"></td>
    <td class="lineNumber">574</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">        // If we still have uses that are not accounted for by the expression</td>
    <td class="lineNumber">575</td>
    <td class="codeline">        // If we still have uses that are not accounted for by the expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">        // then it is not safe to modify the value.</td>
    <td class="lineNumber">576</td>
    <td class="codeline">        // then it is not safe to modify the value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">        if (!Op->hasOneUse())</td>
    <td class="lineNumber">577</td>
    <td class="codeline">        if (!Op->hasOneUse())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">578</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">        // No uses outside the expression, try morphing it.</td>
    <td class="lineNumber">580</td>
    <td class="codeline">        // No uses outside the expression, try morphing it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">        Weight = It->second;</td>
    <td class="lineNumber">581</td>
    <td class="codeline">        Weight = It->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">        Leaves.erase(It); // Since the value may be morphed below.</td>
    <td class="lineNumber">582</td>
    <td class="codeline">        Leaves.erase(It); // Since the value may be morphed below.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">583</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline"></td>
    <td class="lineNumber">584</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">      // At this point we have a value which, first of all, is not a binary</td>
    <td class="lineNumber">585</td>
    <td class="codeline">      // At this point we have a value which, first of all, is not a binary</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">      // expression of the right kind, and secondly, is only used inside the</td>
    <td class="lineNumber">586</td>
    <td class="codeline">      // expression of the right kind, and secondly, is only used inside the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">      // expression.  This means that it can safely be modified.  See if we</td>
    <td class="lineNumber">587</td>
    <td class="codeline">      // expression.  This means that it can safely be modified.  See if we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">      // can usefully morph it into an expression of the right kind.</td>
    <td class="lineNumber">588</td>
    <td class="codeline">      // can usefully morph it into an expression of the right kind.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">      assert((!isa<Instruction>(Op) ||</td>
    <td class="lineNumber">589</td>
    <td class="codeline">      assert((!isa<Instruction>(Op) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">              cast<Instruction>(Op)->getOpcode() != Opcode</td>
    <td class="lineNumber">590</td>
    <td class="codeline">              cast<Instruction>(Op)->getOpcode() != Opcode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">              || (isa<FPMathOperator>(Op) &&</td>
    <td class="lineNumber">591</td>
    <td class="codeline">              || (isa<FPMathOperator>(Op) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">                  !hasFPAssociativeFlags(cast<Instruction>(Op)))) &&</td>
    <td class="lineNumber">592</td>
    <td class="codeline">                  !hasFPAssociativeFlags(cast<Instruction>(Op)))) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">             "Should have been handled above!");</td>
    <td class="lineNumber">593</td>
    <td class="codeline">             "Should have been handled above!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">      assert(Op->hasOneUse() && "Has uses outside the expression tree!");</td>
    <td class="lineNumber">594</td>
    <td class="codeline">      assert(Op->hasOneUse() && "Has uses outside the expression tree!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline"></td>
    <td class="lineNumber">595</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">      // If this is a multiply expression, turn any internal negations into</td>
    <td class="lineNumber">596</td>
    <td class="codeline">      // If this is a multiply expression, turn any internal negations into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">      // multiplies by -1 so they can be reassociated.  Add any users of the</td>
    <td class="lineNumber">597</td>
    <td class="codeline">      // multiplies by -1 so they can be reassociated.  Add any users of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">      // newly created multiplication by -1 to the redo list, so any</td>
    <td class="lineNumber">598</td>
    <td class="codeline">      // newly created multiplication by -1 to the redo list, so any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">      // reassociation opportunities that are exposed will be reassociated</td>
    <td class="lineNumber">599</td>
    <td class="codeline">      // reassociation opportunities that are exposed will be reassociated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">      // further.</td>
    <td class="lineNumber">600</td>
    <td class="codeline">      // further.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">      Instruction *Neg;</td>
    <td class="lineNumber">601</td>
    <td class="codeline">      Instruction *Neg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">      if (((Opcode == Instruction::Mul && match(Op, m_Neg(m_Value()))) ||</td>
    <td class="lineNumber">602</td>
    <td class="codeline">      if (((Opcode == Instruction::Mul && match(Op, m_Neg(m_Value()))) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">           (Opcode == Instruction::FMul && match(Op, m_FNeg(m_Value())))) &&</td>
    <td class="lineNumber">603</td>
    <td class="codeline">           (Opcode == Instruction::FMul && match(Op, m_FNeg(m_Value())))) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">           match(Op, m_Instruction(Neg))) {</td>
    <td class="lineNumber">604</td>
    <td class="codeline">           match(Op, m_Instruction(Neg))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">        LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">605</td>
    <td class="codeline">        LLVM_DEBUG(dbgs()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">                   << "MORPH LEAF: " << *Op << " (" << Weight << ") TO ");</td>
    <td class="lineNumber">606</td>
    <td class="codeline">                   << "MORPH LEAF: " << *Op << " (" << Weight << ") TO ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">        Instruction *Mul = LowerNegateToMultiply(Neg);</td>
    <td class="lineNumber">607</td>
    <td class="codeline">        Instruction *Mul = LowerNegateToMultiply(Neg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << *Mul << '\n');</td>
    <td class="lineNumber">608</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << *Mul << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">        Worklist.push_back(std::make_pair(Mul, Weight));</td>
    <td class="lineNumber">609</td>
    <td class="codeline">        Worklist.push_back(std::make_pair(Mul, Weight));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">        for (User *U : Mul->users()) {</td>
    <td class="lineNumber">610</td>
    <td class="codeline">        for (User *U : Mul->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">          if (BinaryOperator *UserBO = dyn_cast<BinaryOperator>(U))</td>
    <td class="lineNumber">611</td>
    <td class="codeline">          if (BinaryOperator *UserBO = dyn_cast<BinaryOperator>(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">            ToRedo.insert(UserBO);</td>
    <td class="lineNumber">612</td>
    <td class="codeline">            ToRedo.insert(UserBO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">613</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">        ToRedo.insert(Neg);</td>
    <td class="lineNumber">614</td>
    <td class="codeline">        ToRedo.insert(Neg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">        Changed = true;</td>
    <td class="lineNumber">615</td>
    <td class="codeline">        Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">616</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">617</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">      // Failed to morph into an expression of the right type.  This really is</td>
    <td class="lineNumber">619</td>
    <td class="codeline">      // Failed to morph into an expression of the right type.  This really is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">      // a leaf.</td>
    <td class="lineNumber">620</td>
    <td class="codeline">      // a leaf.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "ADD LEAF: " << *Op << " (" << Weight << ")\n");</td>
    <td class="lineNumber">621</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "ADD LEAF: " << *Op << " (" << Weight << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">      assert(!isReassociableOp(Op, Opcode) && "Value was morphed?");</td>
    <td class="lineNumber">622</td>
    <td class="codeline">      assert(!isReassociableOp(Op, Opcode) && "Value was morphed?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">      LeafOrder.push_back(Op);</td>
    <td class="lineNumber">623</td>
    <td class="codeline">      LeafOrder.push_back(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">      Leaves[Op] = Weight;</td>
    <td class="lineNumber">624</td>
    <td class="codeline">      Leaves[Op] = Weight;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">625</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline"></td>
    <td class="lineNumber">627</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">  // The leaves, repeated according to their weights, represent the linearized</td>
    <td class="lineNumber">628</td>
    <td class="codeline">  // The leaves, repeated according to their weights, represent the linearized</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  // form of the expression.</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  // form of the expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">  for (Value *V : LeafOrder) {</td>
    <td class="lineNumber">630</td>
    <td class="codeline">  for (Value *V : LeafOrder) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">    LeafMap::iterator It = Leaves.find(V);</td>
    <td class="lineNumber">631</td>
    <td class="codeline">    LeafMap::iterator It = Leaves.find(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">    if (It == Leaves.end())</td>
    <td class="lineNumber">632</td>
    <td class="codeline">    if (It == Leaves.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">      // Node initially thought to be a leaf wasn't.</td>
    <td class="lineNumber">633</td>
    <td class="codeline">      // Node initially thought to be a leaf wasn't.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">634</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">    assert(!isReassociableOp(V, Opcode) && "Shouldn't be a leaf!");</td>
    <td class="lineNumber">635</td>
    <td class="codeline">    assert(!isReassociableOp(V, Opcode) && "Shouldn't be a leaf!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">    APInt Weight = It->second;</td>
    <td class="lineNumber">636</td>
    <td class="codeline">    APInt Weight = It->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">    if (Weight.isMinValue())</td>
    <td class="lineNumber">637</td>
    <td class="codeline">    if (Weight.isMinValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">      // Leaf already output or weight reduction eliminated it.</td>
    <td class="lineNumber">638</td>
    <td class="codeline">      // Leaf already output or weight reduction eliminated it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">639</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">    // Ensure the leaf is only output once.</td>
    <td class="lineNumber">640</td>
    <td class="codeline">    // Ensure the leaf is only output once.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">    It->second = 0;</td>
    <td class="lineNumber">641</td>
    <td class="codeline">    It->second = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">    Ops.push_back(std::make_pair(V, Weight));</td>
    <td class="lineNumber">642</td>
    <td class="codeline">    Ops.push_back(std::make_pair(V, Weight));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  // For nilpotent operations or addition there may be no operands, for example</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  // For nilpotent operations or addition there may be no operands, for example</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">  // because the expression was "X xor X" or consisted of 2^Bitwidth additions:</td>
    <td class="lineNumber">646</td>
    <td class="codeline">  // because the expression was "X xor X" or consisted of 2^Bitwidth additions:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  // in both cases the weight reduces to 0 causing the value to be skipped.</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  // in both cases the weight reduces to 0 causing the value to be skipped.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">  if (Ops.empty()) {</td>
    <td class="lineNumber">648</td>
    <td class="codeline">  if (Ops.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">    Constant *Identity = ConstantExpr::getBinOpIdentity(Opcode, I->getType());</td>
    <td class="lineNumber">649</td>
    <td class="codeline">    Constant *Identity = ConstantExpr::getBinOpIdentity(Opcode, I->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">    assert(Identity && "Associative operation without identity!");</td>
    <td class="lineNumber">650</td>
    <td class="codeline">    assert(Identity && "Associative operation without identity!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">    Ops.emplace_back(Identity, APInt(Bitwidth, 1));</td>
    <td class="lineNumber">651</td>
    <td class="codeline">    Ops.emplace_back(Identity, APInt(Bitwidth, 1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">652</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline"></td>
    <td class="lineNumber">653</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">}</td>
    <td class="lineNumber">655</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline"></td>
    <td class="lineNumber">656</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">/// Now that the operands for this expression tree are</td>
    <td class="lineNumber">657</td>
    <td class="codeline">/// Now that the operands for this expression tree are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">/// linearized and optimized, emit them in-order.</td>
    <td class="lineNumber">658</td>
    <td class="codeline">/// linearized and optimized, emit them in-order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">void ReassociatePass::RewriteExprTree(BinaryOperator *I,</td>
    <td class="lineNumber">659</td>
    <td class="codeline">void ReassociatePass::RewriteExprTree(BinaryOperator *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">                                      SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">660</td>
    <td class="codeline">                                      SmallVectorImpl<ValueEntry> &Ops) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">  assert(Ops.size() > 1 && "Single values should be used directly!");</td>
    <td class="lineNumber">661</td>
    <td class="codeline">  assert(Ops.size() > 1 && "Single values should be used directly!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline"></td>
    <td class="lineNumber">662</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">  // Since our optimizations should never increase the number of operations, the</td>
    <td class="lineNumber">663</td>
    <td class="codeline">  // Since our optimizations should never increase the number of operations, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">  // new expression can usually be written reusing the existing binary operators</td>
    <td class="lineNumber">664</td>
    <td class="codeline">  // new expression can usually be written reusing the existing binary operators</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">  // from the original expression tree, without creating any new instructions,</td>
    <td class="lineNumber">665</td>
    <td class="codeline">  // from the original expression tree, without creating any new instructions,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  // though the rewritten expression may have a completely different topology.</td>
    <td class="lineNumber">666</td>
    <td class="codeline">  // though the rewritten expression may have a completely different topology.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  // We take care to not change anything if the new expression will be the same</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  // We take care to not change anything if the new expression will be the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  // as the original.  If more than trivial changes (like commuting operands)</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  // as the original.  If more than trivial changes (like commuting operands)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">  // were made then we are obliged to clear out any optional subclass data like</td>
    <td class="lineNumber">669</td>
    <td class="codeline">  // were made then we are obliged to clear out any optional subclass data like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">  // nsw flags.</td>
    <td class="lineNumber">670</td>
    <td class="codeline">  // nsw flags.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline"></td>
    <td class="lineNumber">671</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">  /// NodesToRewrite - Nodes from the original expression available for writing</td>
    <td class="lineNumber">672</td>
    <td class="codeline">  /// NodesToRewrite - Nodes from the original expression available for writing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  /// the new expression into.</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  /// the new expression into.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  SmallVector<BinaryOperator*, 8> NodesToRewrite;</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  SmallVector<BinaryOperator*, 8> NodesToRewrite;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">  unsigned Opcode = I->getOpcode();</td>
    <td class="lineNumber">675</td>
    <td class="codeline">  unsigned Opcode = I->getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">  BinaryOperator *Op = I;</td>
    <td class="lineNumber">676</td>
    <td class="codeline">  BinaryOperator *Op = I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline"></td>
    <td class="lineNumber">677</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">  /// NotRewritable - The operands being written will be the leaves of the new</td>
    <td class="lineNumber">678</td>
    <td class="codeline">  /// NotRewritable - The operands being written will be the leaves of the new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  /// expression and must not be used as inner nodes (via NodesToRewrite) by</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  /// expression and must not be used as inner nodes (via NodesToRewrite) by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">  /// mistake.  Inner nodes are always reassociable, and usually leaves are not</td>
    <td class="lineNumber">680</td>
    <td class="codeline">  /// mistake.  Inner nodes are always reassociable, and usually leaves are not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">  /// (if they were they would have been incorporated into the expression and so</td>
    <td class="lineNumber">681</td>
    <td class="codeline">  /// (if they were they would have been incorporated into the expression and so</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">  /// would not be leaves), so most of the time there is no danger of this.  But</td>
    <td class="lineNumber">682</td>
    <td class="codeline">  /// would not be leaves), so most of the time there is no danger of this.  But</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">  /// in rare cases a leaf may become reassociable if an optimization kills uses</td>
    <td class="lineNumber">683</td>
    <td class="codeline">  /// in rare cases a leaf may become reassociable if an optimization kills uses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  /// of it, or it may momentarily become reassociable during rewriting (below)</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  /// of it, or it may momentarily become reassociable during rewriting (below)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">  /// due it being removed as an operand of one of its uses.  Ensure that misuse</td>
    <td class="lineNumber">685</td>
    <td class="codeline">  /// due it being removed as an operand of one of its uses.  Ensure that misuse</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  /// of leaf nodes as inner nodes cannot occur by remembering all of the future</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  /// of leaf nodes as inner nodes cannot occur by remembering all of the future</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">  /// leaves and refusing to reuse any of them as inner nodes.</td>
    <td class="lineNumber">687</td>
    <td class="codeline">  /// leaves and refusing to reuse any of them as inner nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">  SmallPtrSet<Value*, 8> NotRewritable;</td>
    <td class="lineNumber">688</td>
    <td class="codeline">  SmallPtrSet<Value*, 8> NotRewritable;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i)</td>
    <td class="lineNumber">689</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">    NotRewritable.insert(Ops[i].Op);</td>
    <td class="lineNumber">690</td>
    <td class="codeline">    NotRewritable.insert(Ops[i].Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  // ExpressionChangedStart - Non-null if the rewritten expression differs from</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  // ExpressionChangedStart - Non-null if the rewritten expression differs from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  // the original in some non-trivial way, requiring the clearing of optional</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  // the original in some non-trivial way, requiring the clearing of optional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  // flags. Flags are cleared from the operator in ExpressionChangedStart up to</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  // flags. Flags are cleared from the operator in ExpressionChangedStart up to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">  // ExpressionChangedEnd inclusive.</td>
    <td class="lineNumber">695</td>
    <td class="codeline">  // ExpressionChangedEnd inclusive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  BinaryOperator *ExpressionChangedStart = nullptr,</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  BinaryOperator *ExpressionChangedStart = nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">                 *ExpressionChangedEnd = nullptr;</td>
    <td class="lineNumber">697</td>
    <td class="codeline">                 *ExpressionChangedEnd = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  for (unsigned i = 0; ; ++i) {</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  for (unsigned i = 0; ; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">    // The last operation (which comes earliest in the IR) is special as both</td>
    <td class="lineNumber">699</td>
    <td class="codeline">    // The last operation (which comes earliest in the IR) is special as both</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">    // operands will come from Ops, rather than just one with the other being</td>
    <td class="lineNumber">700</td>
    <td class="codeline">    // operands will come from Ops, rather than just one with the other being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">    // a subexpression.</td>
    <td class="lineNumber">701</td>
    <td class="codeline">    // a subexpression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">    if (i+2 == Ops.size()) {</td>
    <td class="lineNumber">702</td>
    <td class="codeline">    if (i+2 == Ops.size()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">      Value *NewLHS = Ops[i].Op;</td>
    <td class="lineNumber">703</td>
    <td class="codeline">      Value *NewLHS = Ops[i].Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">      Value *NewRHS = Ops[i+1].Op;</td>
    <td class="lineNumber">704</td>
    <td class="codeline">      Value *NewRHS = Ops[i+1].Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">      Value *OldLHS = Op->getOperand(0);</td>
    <td class="lineNumber">705</td>
    <td class="codeline">      Value *OldLHS = Op->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">      Value *OldRHS = Op->getOperand(1);</td>
    <td class="lineNumber">706</td>
    <td class="codeline">      Value *OldRHS = Op->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline"></td>
    <td class="lineNumber">707</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">      if (NewLHS == OldLHS && NewRHS == OldRHS)</td>
    <td class="lineNumber">708</td>
    <td class="codeline">      if (NewLHS == OldLHS && NewRHS == OldRHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">        // Nothing changed, leave it alone.</td>
    <td class="lineNumber">709</td>
    <td class="codeline">        // Nothing changed, leave it alone.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">710</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">      if (NewLHS == OldRHS && NewRHS == OldLHS) {</td>
    <td class="lineNumber">712</td>
    <td class="codeline">      if (NewLHS == OldRHS && NewRHS == OldLHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">        // The order of the operands was reversed.  Swap them.</td>
    <td class="lineNumber">713</td>
    <td class="codeline">        // The order of the operands was reversed.  Swap them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td class="lineNumber">714</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">        Op->swapOperands();</td>
    <td class="lineNumber">715</td>
    <td class="codeline">        Op->swapOperands();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td class="lineNumber">716</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">        MadeChange = true;</td>
    <td class="lineNumber">717</td>
    <td class="codeline">        MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">        ++NumChanged;</td>
    <td class="lineNumber">718</td>
    <td class="codeline">        ++NumChanged;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">719</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">720</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline"></td>
    <td class="lineNumber">721</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">      // The new operation differs non-trivially from the original. Overwrite</td>
    <td class="lineNumber">722</td>
    <td class="codeline">      // The new operation differs non-trivially from the original. Overwrite</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">      // the old operands with the new ones.</td>
    <td class="lineNumber">723</td>
    <td class="codeline">      // the old operands with the new ones.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td class="lineNumber">724</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">      if (NewLHS != OldLHS) {</td>
    <td class="lineNumber">725</td>
    <td class="codeline">      if (NewLHS != OldLHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">        BinaryOperator *BO = isReassociableOp(OldLHS, Opcode);</td>
    <td class="lineNumber">726</td>
    <td class="codeline">        BinaryOperator *BO = isReassociableOp(OldLHS, Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">        if (BO && !NotRewritable.count(BO))</td>
    <td class="lineNumber">727</td>
    <td class="codeline">        if (BO && !NotRewritable.count(BO))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">          NodesToRewrite.push_back(BO);</td>
    <td class="lineNumber">728</td>
    <td class="codeline">          NodesToRewrite.push_back(BO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">        Op->setOperand(0, NewLHS);</td>
    <td class="lineNumber">729</td>
    <td class="codeline">        Op->setOperand(0, NewLHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">730</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">      if (NewRHS != OldRHS) {</td>
    <td class="lineNumber">731</td>
    <td class="codeline">      if (NewRHS != OldRHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">        BinaryOperator *BO = isReassociableOp(OldRHS, Opcode);</td>
    <td class="lineNumber">732</td>
    <td class="codeline">        BinaryOperator *BO = isReassociableOp(OldRHS, Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">        if (BO && !NotRewritable.count(BO))</td>
    <td class="lineNumber">733</td>
    <td class="codeline">        if (BO && !NotRewritable.count(BO))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">          NodesToRewrite.push_back(BO);</td>
    <td class="lineNumber">734</td>
    <td class="codeline">          NodesToRewrite.push_back(BO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">        Op->setOperand(1, NewRHS);</td>
    <td class="lineNumber">735</td>
    <td class="codeline">        Op->setOperand(1, NewRHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">736</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td class="lineNumber">737</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline"></td>
    <td class="lineNumber">738</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">      ExpressionChangedStart = Op;</td>
    <td class="lineNumber">739</td>
    <td class="codeline">      ExpressionChangedStart = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">      if (!ExpressionChangedEnd)</td>
    <td class="lineNumber">740</td>
    <td class="codeline">      if (!ExpressionChangedEnd)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">        ExpressionChangedEnd = Op;</td>
    <td class="lineNumber">741</td>
    <td class="codeline">        ExpressionChangedEnd = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">      MadeChange = true;</td>
    <td class="lineNumber">742</td>
    <td class="codeline">      MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">      ++NumChanged;</td>
    <td class="lineNumber">743</td>
    <td class="codeline">      ++NumChanged;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline"></td>
    <td class="lineNumber">744</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">745</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">746</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline"></td>
    <td class="lineNumber">747</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">    // Not the last operation.  The left-hand side will be a sub-expression</td>
    <td class="lineNumber">748</td>
    <td class="codeline">    // Not the last operation.  The left-hand side will be a sub-expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">    // while the right-hand side will be the current element of Ops.</td>
    <td class="lineNumber">749</td>
    <td class="codeline">    // while the right-hand side will be the current element of Ops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">    Value *NewRHS = Ops[i].Op;</td>
    <td class="lineNumber">750</td>
    <td class="codeline">    Value *NewRHS = Ops[i].Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">    if (NewRHS != Op->getOperand(1)) {</td>
    <td class="lineNumber">751</td>
    <td class="codeline">    if (NewRHS != Op->getOperand(1)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td class="lineNumber">752</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">      if (NewRHS == Op->getOperand(0)) {</td>
    <td class="lineNumber">753</td>
    <td class="codeline">      if (NewRHS == Op->getOperand(0)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">        // The new right-hand side was already present as the left operand.  If</td>
    <td class="lineNumber">754</td>
    <td class="codeline">        // The new right-hand side was already present as the left operand.  If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">        // we are lucky then swapping the operands will sort out both of them.</td>
    <td class="lineNumber">755</td>
    <td class="codeline">        // we are lucky then swapping the operands will sort out both of them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">        Op->swapOperands();</td>
    <td class="lineNumber">756</td>
    <td class="codeline">        Op->swapOperands();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">757</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">        // Overwrite with the new right-hand side.</td>
    <td class="lineNumber">758</td>
    <td class="codeline">        // Overwrite with the new right-hand side.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">        BinaryOperator *BO = isReassociableOp(Op->getOperand(1), Opcode);</td>
    <td class="lineNumber">759</td>
    <td class="codeline">        BinaryOperator *BO = isReassociableOp(Op->getOperand(1), Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">        if (BO && !NotRewritable.count(BO))</td>
    <td class="lineNumber">760</td>
    <td class="codeline">        if (BO && !NotRewritable.count(BO))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">          NodesToRewrite.push_back(BO);</td>
    <td class="lineNumber">761</td>
    <td class="codeline">          NodesToRewrite.push_back(BO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">        Op->setOperand(1, NewRHS);</td>
    <td class="lineNumber">762</td>
    <td class="codeline">        Op->setOperand(1, NewRHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">        ExpressionChangedStart = Op;</td>
    <td class="lineNumber">763</td>
    <td class="codeline">        ExpressionChangedStart = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">        if (!ExpressionChangedEnd)</td>
    <td class="lineNumber">764</td>
    <td class="codeline">        if (!ExpressionChangedEnd)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">          ExpressionChangedEnd = Op;</td>
    <td class="lineNumber">765</td>
    <td class="codeline">          ExpressionChangedEnd = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">766</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td class="lineNumber">767</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">      MadeChange = true;</td>
    <td class="lineNumber">768</td>
    <td class="codeline">      MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">      ++NumChanged;</td>
    <td class="lineNumber">769</td>
    <td class="codeline">      ++NumChanged;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">770</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">    // Now deal with the left-hand side.  If this is already an operation node</td>
    <td class="lineNumber">772</td>
    <td class="codeline">    // Now deal with the left-hand side.  If this is already an operation node</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">    // from the original expression then just rewrite the rest of the expression</td>
    <td class="lineNumber">773</td>
    <td class="codeline">    // from the original expression then just rewrite the rest of the expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">    // into it.</td>
    <td class="lineNumber">774</td>
    <td class="codeline">    // into it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">    BinaryOperator *BO = isReassociableOp(Op->getOperand(0), Opcode);</td>
    <td class="lineNumber">775</td>
    <td class="codeline">    BinaryOperator *BO = isReassociableOp(Op->getOperand(0), Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">    if (BO && !NotRewritable.count(BO)) {</td>
    <td class="lineNumber">776</td>
    <td class="codeline">    if (BO && !NotRewritable.count(BO)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">      Op = BO;</td>
    <td class="lineNumber">777</td>
    <td class="codeline">      Op = BO;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">778</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">779</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline"></td>
    <td class="lineNumber">780</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">    // Otherwise, grab a spare node from the original expression and use that as</td>
    <td class="lineNumber">781</td>
    <td class="codeline">    // Otherwise, grab a spare node from the original expression and use that as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">    // the left-hand side.  If there are no nodes left then the optimizers made</td>
    <td class="lineNumber">782</td>
    <td class="codeline">    // the left-hand side.  If there are no nodes left then the optimizers made</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">    // an expression with more nodes than the original!  This usually means that</td>
    <td class="lineNumber">783</td>
    <td class="codeline">    // an expression with more nodes than the original!  This usually means that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">    // they did something stupid but it might mean that the problem was just too</td>
    <td class="lineNumber">784</td>
    <td class="codeline">    // they did something stupid but it might mean that the problem was just too</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">    // hard (finding the mimimal number of multiplications needed to realize a</td>
    <td class="lineNumber">785</td>
    <td class="codeline">    // hard (finding the mimimal number of multiplications needed to realize a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">    // multiplication expression is NP-complete).  Whatever the reason, smart or</td>
    <td class="lineNumber">786</td>
    <td class="codeline">    // multiplication expression is NP-complete).  Whatever the reason, smart or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">    // stupid, create a new node if there are none left.</td>
    <td class="lineNumber">787</td>
    <td class="codeline">    // stupid, create a new node if there are none left.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">    BinaryOperator *NewOp;</td>
    <td class="lineNumber">788</td>
    <td class="codeline">    BinaryOperator *NewOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">    if (NodesToRewrite.empty()) {</td>
    <td class="lineNumber">789</td>
    <td class="codeline">    if (NodesToRewrite.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">      Constant *Undef = UndefValue::get(I->getType());</td>
    <td class="lineNumber">790</td>
    <td class="codeline">      Constant *Undef = UndefValue::get(I->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">      NewOp = BinaryOperator::Create(Instruction::BinaryOps(Opcode),</td>
    <td class="lineNumber">791</td>
    <td class="codeline">      NewOp = BinaryOperator::Create(Instruction::BinaryOps(Opcode),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">                                     Undef, Undef, "", I);</td>
    <td class="lineNumber">792</td>
    <td class="codeline">                                     Undef, Undef, "", I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">      if (isa<FPMathOperator>(NewOp))</td>
    <td class="lineNumber">793</td>
    <td class="codeline">      if (isa<FPMathOperator>(NewOp))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">        NewOp->setFastMathFlags(I->getFastMathFlags());</td>
    <td class="lineNumber">794</td>
    <td class="codeline">        NewOp->setFastMathFlags(I->getFastMathFlags());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">795</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">      NewOp = NodesToRewrite.pop_back_val();</td>
    <td class="lineNumber">796</td>
    <td class="codeline">      NewOp = NodesToRewrite.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">797</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline"></td>
    <td class="lineNumber">798</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td class="lineNumber">799</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">    Op->setOperand(0, NewOp);</td>
    <td class="lineNumber">800</td>
    <td class="codeline">    Op->setOperand(0, NewOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td class="lineNumber">801</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">    ExpressionChangedStart = Op;</td>
    <td class="lineNumber">802</td>
    <td class="codeline">    ExpressionChangedStart = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">    if (!ExpressionChangedEnd)</td>
    <td class="lineNumber">803</td>
    <td class="codeline">    if (!ExpressionChangedEnd)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">      ExpressionChangedEnd = Op;</td>
    <td class="lineNumber">804</td>
    <td class="codeline">      ExpressionChangedEnd = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">    MadeChange = true;</td>
    <td class="lineNumber">805</td>
    <td class="codeline">    MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">    ++NumChanged;</td>
    <td class="lineNumber">806</td>
    <td class="codeline">    ++NumChanged;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">    Op = NewOp;</td>
    <td class="lineNumber">807</td>
    <td class="codeline">    Op = NewOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline"></td>
    <td class="lineNumber">809</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">  // If the expression changed non-trivially then clear out all subclass data</td>
    <td class="lineNumber">810</td>
    <td class="codeline">  // If the expression changed non-trivially then clear out all subclass data</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  // starting from the operator specified in ExpressionChanged, and compactify</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  // starting from the operator specified in ExpressionChanged, and compactify</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">  // the operators to just before the expression root to guarantee that the</td>
    <td class="lineNumber">812</td>
    <td class="codeline">  // the operators to just before the expression root to guarantee that the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  // expression tree is dominated by all of Ops.</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  // expression tree is dominated by all of Ops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">  if (ExpressionChangedStart) {</td>
    <td class="lineNumber">814</td>
    <td class="codeline">  if (ExpressionChangedStart) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">    bool ClearFlags = true;</td>
    <td class="lineNumber">815</td>
    <td class="codeline">    bool ClearFlags = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">    do {</td>
    <td class="lineNumber">816</td>
    <td class="codeline">    do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">      // Preserve FastMathFlags.</td>
    <td class="lineNumber">817</td>
    <td class="codeline">      // Preserve FastMathFlags.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">      if (ClearFlags) {</td>
    <td class="lineNumber">818</td>
    <td class="codeline">      if (ClearFlags) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">        if (isa<FPMathOperator>(I)) {</td>
    <td class="lineNumber">819</td>
    <td class="codeline">        if (isa<FPMathOperator>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">          FastMathFlags Flags = I->getFastMathFlags();</td>
    <td class="lineNumber">820</td>
    <td class="codeline">          FastMathFlags Flags = I->getFastMathFlags();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">          ExpressionChangedStart->clearSubclassOptionalData();</td>
    <td class="lineNumber">821</td>
    <td class="codeline">          ExpressionChangedStart->clearSubclassOptionalData();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">          ExpressionChangedStart->setFastMathFlags(Flags);</td>
    <td class="lineNumber">822</td>
    <td class="codeline">          ExpressionChangedStart->setFastMathFlags(Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">        } else</td>
    <td class="lineNumber">823</td>
    <td class="codeline">        } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">          ExpressionChangedStart->clearSubclassOptionalData();</td>
    <td class="lineNumber">824</td>
    <td class="codeline">          ExpressionChangedStart->clearSubclassOptionalData();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">825</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline"></td>
    <td class="lineNumber">826</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">      if (ExpressionChangedStart == ExpressionChangedEnd)</td>
    <td class="lineNumber">827</td>
    <td class="codeline">      if (ExpressionChangedStart == ExpressionChangedEnd)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">        ClearFlags = false;</td>
    <td class="lineNumber">828</td>
    <td class="codeline">        ClearFlags = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">      if (ExpressionChangedStart == I)</td>
    <td class="lineNumber">829</td>
    <td class="codeline">      if (ExpressionChangedStart == I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">830</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline"></td>
    <td class="lineNumber">831</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">      // Discard any debug info related to the expressions that has changed (we</td>
    <td class="lineNumber">832</td>
    <td class="codeline">      // Discard any debug info related to the expressions that has changed (we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">      // can leave debug info related to the root and any operation that didn't</td>
    <td class="lineNumber">833</td>
    <td class="codeline">      // can leave debug info related to the root and any operation that didn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">      // change, since the result of the expression tree should be the same</td>
    <td class="lineNumber">834</td>
    <td class="codeline">      // change, since the result of the expression tree should be the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">      // even after reassociation).</td>
    <td class="lineNumber">835</td>
    <td class="codeline">      // even after reassociation).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">      if (ClearFlags)</td>
    <td class="lineNumber">836</td>
    <td class="codeline">      if (ClearFlags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">        replaceDbgUsesWithUndef(ExpressionChangedStart);</td>
    <td class="lineNumber">837</td>
    <td class="codeline">        replaceDbgUsesWithUndef(ExpressionChangedStart);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline"></td>
    <td class="lineNumber">838</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">      ExpressionChangedStart->moveBefore(I);</td>
    <td class="lineNumber">839</td>
    <td class="codeline">      ExpressionChangedStart->moveBefore(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">      ExpressionChangedStart =</td>
    <td class="lineNumber">840</td>
    <td class="codeline">      ExpressionChangedStart =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">          cast<BinaryOperator>(*ExpressionChangedStart->user_begin());</td>
    <td class="lineNumber">841</td>
    <td class="codeline">          cast<BinaryOperator>(*ExpressionChangedStart->user_begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">    } while (true);</td>
    <td class="lineNumber">842</td>
    <td class="codeline">    } while (true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">843</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline"></td>
    <td class="lineNumber">844</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">  // Throw away any left over nodes from the original expression.</td>
    <td class="lineNumber">845</td>
    <td class="codeline">  // Throw away any left over nodes from the original expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">  for (unsigned i = 0, e = NodesToRewrite.size(); i != e; ++i)</td>
    <td class="lineNumber">846</td>
    <td class="codeline">  for (unsigned i = 0, e = NodesToRewrite.size(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">    RedoInsts.insert(NodesToRewrite[i]);</td>
    <td class="lineNumber">847</td>
    <td class="codeline">    RedoInsts.insert(NodesToRewrite[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">}</td>
    <td class="lineNumber">848</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline"></td>
    <td class="lineNumber">849</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">/// Insert instructions before the instruction pointed to by BI,</td>
    <td class="lineNumber">850</td>
    <td class="codeline">/// Insert instructions before the instruction pointed to by BI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">/// that computes the negative version of the value specified.  The negative</td>
    <td class="lineNumber">851</td>
    <td class="codeline">/// that computes the negative version of the value specified.  The negative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">/// version of the value is returned, and BI is left pointing at the instruction</td>
    <td class="lineNumber">852</td>
    <td class="codeline">/// version of the value is returned, and BI is left pointing at the instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">/// that should be processed next by the reassociation pass.</td>
    <td class="lineNumber">853</td>
    <td class="codeline">/// that should be processed next by the reassociation pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">/// Also add intermediate instructions to the redo list that are modified while</td>
    <td class="lineNumber">854</td>
    <td class="codeline">/// Also add intermediate instructions to the redo list that are modified while</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">/// pushing the negates through adds.  These will be revisited to see if</td>
    <td class="lineNumber">855</td>
    <td class="codeline">/// pushing the negates through adds.  These will be revisited to see if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">/// additional opportunities have been exposed.</td>
    <td class="lineNumber">856</td>
    <td class="codeline">/// additional opportunities have been exposed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">static Value *NegateValue(Value *V, Instruction *BI,</td>
    <td class="lineNumber">857</td>
    <td class="codeline">static Value *NegateValue(Value *V, Instruction *BI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">                          ReassociatePass::OrderedSet &ToRedo) {</td>
    <td class="lineNumber">858</td>
    <td class="codeline">                          ReassociatePass::OrderedSet &ToRedo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">  if (auto *C = dyn_cast<Constant>(V)) {</td>
    <td class="lineNumber">859</td>
    <td class="codeline">  if (auto *C = dyn_cast<Constant>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">    const DataLayout &DL = BI->getModule()->getDataLayout();</td>
    <td class="lineNumber">860</td>
    <td class="codeline">    const DataLayout &DL = BI->getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">    Constant *Res = C->getType()->isFPOrFPVectorTy()</td>
    <td class="lineNumber">861</td>
    <td class="codeline">    Constant *Res = C->getType()->isFPOrFPVectorTy()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">                        ? ConstantFoldUnaryOpOperand(Instruction::FNeg, C, DL)</td>
    <td class="lineNumber">862</td>
    <td class="codeline">                        ? ConstantFoldUnaryOpOperand(Instruction::FNeg, C, DL)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">                        : ConstantExpr::getNeg(C);</td>
    <td class="lineNumber">863</td>
    <td class="codeline">                        : ConstantExpr::getNeg(C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">    if (Res)</td>
    <td class="lineNumber">864</td>
    <td class="codeline">    if (Res)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">      return Res;</td>
    <td class="lineNumber">865</td>
    <td class="codeline">      return Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">866</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline"></td>
    <td class="lineNumber">867</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">  // We are trying to expose opportunity for reassociation.  One of the things</td>
    <td class="lineNumber">868</td>
    <td class="codeline">  // We are trying to expose opportunity for reassociation.  One of the things</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">  // that we want to do to achieve this is to push a negation as deep into an</td>
    <td class="lineNumber">869</td>
    <td class="codeline">  // that we want to do to achieve this is to push a negation as deep into an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  // expression chain as possible, to expose the add instructions.  In practice,</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  // expression chain as possible, to expose the add instructions.  In practice,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">  // this means that we turn this:</td>
    <td class="lineNumber">871</td>
    <td class="codeline">  // this means that we turn this:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">  //   X = -(A+12+C+D)   into    X = -A + -12 + -C + -D = -12 + -A + -C + -D</td>
    <td class="lineNumber">872</td>
    <td class="codeline">  //   X = -(A+12+C+D)   into    X = -A + -12 + -C + -D = -12 + -A + -C + -D</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">  // so that later, a: Y = 12+X could get reassociated with the -12 to eliminate</td>
    <td class="lineNumber">873</td>
    <td class="codeline">  // so that later, a: Y = 12+X could get reassociated with the -12 to eliminate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">  // the constants.  We assume that instcombine will clean up the mess later if</td>
    <td class="lineNumber">874</td>
    <td class="codeline">  // the constants.  We assume that instcombine will clean up the mess later if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  // we introduce tons of unnecessary negation instructions.</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  // we introduce tons of unnecessary negation instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">  if (BinaryOperator *I =</td>
    <td class="lineNumber">877</td>
    <td class="codeline">  if (BinaryOperator *I =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">          isReassociableOp(V, Instruction::Add, Instruction::FAdd)) {</td>
    <td class="lineNumber">878</td>
    <td class="codeline">          isReassociableOp(V, Instruction::Add, Instruction::FAdd)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">    // Push the negates through the add.</td>
    <td class="lineNumber">879</td>
    <td class="codeline">    // Push the negates through the add.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">    I->setOperand(0, NegateValue(I->getOperand(0), BI, ToRedo));</td>
    <td class="lineNumber">880</td>
    <td class="codeline">    I->setOperand(0, NegateValue(I->getOperand(0), BI, ToRedo));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">    I->setOperand(1, NegateValue(I->getOperand(1), BI, ToRedo));</td>
    <td class="lineNumber">881</td>
    <td class="codeline">    I->setOperand(1, NegateValue(I->getOperand(1), BI, ToRedo));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">    if (I->getOpcode() == Instruction::Add) {</td>
    <td class="lineNumber">882</td>
    <td class="codeline">    if (I->getOpcode() == Instruction::Add) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">      I->setHasNoUnsignedWrap(false);</td>
    <td class="lineNumber">883</td>
    <td class="codeline">      I->setHasNoUnsignedWrap(false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">      I->setHasNoSignedWrap(false);</td>
    <td class="lineNumber">884</td>
    <td class="codeline">      I->setHasNoSignedWrap(false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">885</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline"></td>
    <td class="lineNumber">886</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">    // We must move the add instruction here, because the neg instructions do</td>
    <td class="lineNumber">887</td>
    <td class="codeline">    // We must move the add instruction here, because the neg instructions do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">    // not dominate the old add instruction in general.  By moving it, we are</td>
    <td class="lineNumber">888</td>
    <td class="codeline">    // not dominate the old add instruction in general.  By moving it, we are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">    // assured that the neg instructions we just inserted dominate the</td>
    <td class="lineNumber">889</td>
    <td class="codeline">    // assured that the neg instructions we just inserted dominate the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">    // instruction we are about to insert after them.</td>
    <td class="lineNumber">890</td>
    <td class="codeline">    // instruction we are about to insert after them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">891</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">    I->moveBefore(BI);</td>
    <td class="lineNumber">892</td>
    <td class="codeline">    I->moveBefore(BI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">    I->setName(I->getName()+".neg");</td>
    <td class="lineNumber">893</td>
    <td class="codeline">    I->setName(I->getName()+".neg");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline"></td>
    <td class="lineNumber">894</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">    // Add the intermediate negates to the redo list as processing them later</td>
    <td class="lineNumber">895</td>
    <td class="codeline">    // Add the intermediate negates to the redo list as processing them later</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">    // could expose more reassociating opportunities.</td>
    <td class="lineNumber">896</td>
    <td class="codeline">    // could expose more reassociating opportunities.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">    ToRedo.insert(I);</td>
    <td class="lineNumber">897</td>
    <td class="codeline">    ToRedo.insert(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">    return I;</td>
    <td class="lineNumber">898</td>
    <td class="codeline">    return I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">899</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline"></td>
    <td class="lineNumber">900</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">  // Okay, we need to materialize a negated version of V with an instruction.</td>
    <td class="lineNumber">901</td>
    <td class="codeline">  // Okay, we need to materialize a negated version of V with an instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">  // Scan the use lists of V to see if we have one already.</td>
    <td class="lineNumber">902</td>
    <td class="codeline">  // Scan the use lists of V to see if we have one already.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">  for (User *U : V->users()) {</td>
    <td class="lineNumber">903</td>
    <td class="codeline">  for (User *U : V->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">    if (!match(U, m_Neg(m_Value())) && !match(U, m_FNeg(m_Value())))</td>
    <td class="lineNumber">904</td>
    <td class="codeline">    if (!match(U, m_Neg(m_Value())) && !match(U, m_FNeg(m_Value())))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">905</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline"></td>
    <td class="lineNumber">906</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">    // We found one!  Now we have to make sure that the definition dominates</td>
    <td class="lineNumber">907</td>
    <td class="codeline">    // We found one!  Now we have to make sure that the definition dominates</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">    // this use.  We do this by moving it to the entry block (if it is a</td>
    <td class="lineNumber">908</td>
    <td class="codeline">    // this use.  We do this by moving it to the entry block (if it is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">    // non-instruction value) or right after the definition.  These negates will</td>
    <td class="lineNumber">909</td>
    <td class="codeline">    // non-instruction value) or right after the definition.  These negates will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">    // be zapped by reassociate later, so we don't need much finesse here.</td>
    <td class="lineNumber">910</td>
    <td class="codeline">    // be zapped by reassociate later, so we don't need much finesse here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">    Instruction *TheNeg = dyn_cast<Instruction>(U);</td>
    <td class="lineNumber">911</td>
    <td class="codeline">    Instruction *TheNeg = dyn_cast<Instruction>(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline"></td>
    <td class="lineNumber">912</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">    // We can't safely propagate a vector zero constant with poison/undef lanes.</td>
    <td class="lineNumber">913</td>
    <td class="codeline">    // We can't safely propagate a vector zero constant with poison/undef lanes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">    Constant *C;</td>
    <td class="lineNumber">914</td>
    <td class="codeline">    Constant *C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">    if (match(TheNeg, m_BinOp(m_Constant(C), m_Value())) &&</td>
    <td class="lineNumber">915</td>
    <td class="codeline">    if (match(TheNeg, m_BinOp(m_Constant(C), m_Value())) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">        C->containsUndefOrPoisonElement())</td>
    <td class="lineNumber">916</td>
    <td class="codeline">        C->containsUndefOrPoisonElement())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">917</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline"></td>
    <td class="lineNumber">918</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">    // Verify that the negate is in this function, V might be a constant expr.</td>
    <td class="lineNumber">919</td>
    <td class="codeline">    // Verify that the negate is in this function, V might be a constant expr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">    if (!TheNeg ||</td>
    <td class="lineNumber">920</td>
    <td class="codeline">    if (!TheNeg ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">        TheNeg->getParent()->getParent() != BI->getParent()->getParent())</td>
    <td class="lineNumber">921</td>
    <td class="codeline">        TheNeg->getParent()->getParent() != BI->getParent()->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">922</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline"></td>
    <td class="lineNumber">923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">    Instruction *InsertPt;</td>
    <td class="lineNumber">924</td>
    <td class="codeline">    Instruction *InsertPt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">    if (Instruction *InstInput = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">925</td>
    <td class="codeline">    if (Instruction *InstInput = dyn_cast<Instruction>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">      InsertPt = InstInput->getInsertionPointAfterDef();</td>
    <td class="lineNumber">926</td>
    <td class="codeline">      InsertPt = InstInput->getInsertionPointAfterDef();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">      if (!InsertPt)</td>
    <td class="lineNumber">927</td>
    <td class="codeline">      if (!InsertPt)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">928</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">929</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">      InsertPt = &*TheNeg->getFunction()->getEntryBlock().begin();</td>
    <td class="lineNumber">930</td>
    <td class="codeline">      InsertPt = &*TheNeg->getFunction()->getEntryBlock().begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">931</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline"></td>
    <td class="lineNumber">932</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">    TheNeg->moveBefore(InsertPt);</td>
    <td class="lineNumber">933</td>
    <td class="codeline">    TheNeg->moveBefore(InsertPt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">    if (TheNeg->getOpcode() == Instruction::Sub) {</td>
    <td class="lineNumber">934</td>
    <td class="codeline">    if (TheNeg->getOpcode() == Instruction::Sub) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">      TheNeg->setHasNoUnsignedWrap(false);</td>
    <td class="lineNumber">935</td>
    <td class="codeline">      TheNeg->setHasNoUnsignedWrap(false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">      TheNeg->setHasNoSignedWrap(false);</td>
    <td class="lineNumber">936</td>
    <td class="codeline">      TheNeg->setHasNoSignedWrap(false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">937</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">      TheNeg->andIRFlags(BI);</td>
    <td class="lineNumber">938</td>
    <td class="codeline">      TheNeg->andIRFlags(BI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">939</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">    ToRedo.insert(TheNeg);</td>
    <td class="lineNumber">940</td>
    <td class="codeline">    ToRedo.insert(TheNeg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">    return TheNeg;</td>
    <td class="lineNumber">941</td>
    <td class="codeline">    return TheNeg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">942</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline"></td>
    <td class="lineNumber">943</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">  // Insert a 'neg' instruction that subtracts the value from zero to get the</td>
    <td class="lineNumber">944</td>
    <td class="codeline">  // Insert a 'neg' instruction that subtracts the value from zero to get the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">  // negation.</td>
    <td class="lineNumber">945</td>
    <td class="codeline">  // negation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">  Instruction *NewNeg = CreateNeg(V, V->getName() + ".neg", BI, BI);</td>
    <td class="lineNumber">946</td>
    <td class="codeline">  Instruction *NewNeg = CreateNeg(V, V->getName() + ".neg", BI, BI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">  ToRedo.insert(NewNeg);</td>
    <td class="lineNumber">947</td>
    <td class="codeline">  ToRedo.insert(NewNeg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">  return NewNeg;</td>
    <td class="lineNumber">948</td>
    <td class="codeline">  return NewNeg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">}</td>
    <td class="lineNumber">949</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline"></td>
    <td class="lineNumber">950</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">// See if this `or` looks like an load widening reduction, i.e. that it</td>
    <td class="lineNumber">951</td>
    <td class="codeline">// See if this `or` looks like an load widening reduction, i.e. that it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">// consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't</td>
    <td class="lineNumber">952</td>
    <td class="codeline">// consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">// ensure that the pattern is *really* a load widening reduction,</td>
    <td class="lineNumber">953</td>
    <td class="codeline">// ensure that the pattern is *really* a load widening reduction,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">// we do not ensure that it can really be replaced with a widened load,</td>
    <td class="lineNumber">954</td>
    <td class="codeline">// we do not ensure that it can really be replaced with a widened load,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">// only that it mostly looks like one.</td>
    <td class="lineNumber">955</td>
    <td class="codeline">// only that it mostly looks like one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">static bool isLoadCombineCandidate(Instruction *Or) {</td>
    <td class="lineNumber">956</td>
    <td class="codeline">static bool isLoadCombineCandidate(Instruction *Or) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">  SmallVector<Instruction *, 8> Worklist;</td>
    <td class="lineNumber">957</td>
    <td class="codeline">  SmallVector<Instruction *, 8> Worklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">  SmallSet<Instruction *, 8> Visited;</td>
    <td class="lineNumber">958</td>
    <td class="codeline">  SmallSet<Instruction *, 8> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline"></td>
    <td class="lineNumber">959</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">  auto Enqueue = [&](Value *V) {</td>
    <td class="lineNumber">960</td>
    <td class="codeline">  auto Enqueue = [&](Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">    auto *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">961</td>
    <td class="codeline">    auto *I = dyn_cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">    // Each node of an `or` reduction must be an instruction,</td>
    <td class="lineNumber">962</td>
    <td class="codeline">    // Each node of an `or` reduction must be an instruction,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">    if (!I)</td>
    <td class="lineNumber">963</td>
    <td class="codeline">    if (!I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">      return false; // Node is certainly not part of an `or` load reduction.</td>
    <td class="lineNumber">964</td>
    <td class="codeline">      return false; // Node is certainly not part of an `or` load reduction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">    // Only process instructions we have never processed before.</td>
    <td class="lineNumber">965</td>
    <td class="codeline">    // Only process instructions we have never processed before.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">    if (Visited.insert(I).second)</td>
    <td class="lineNumber">966</td>
    <td class="codeline">    if (Visited.insert(I).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">      Worklist.emplace_back(I);</td>
    <td class="lineNumber">967</td>
    <td class="codeline">      Worklist.emplace_back(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">    return true; // Will need to look at parent nodes.</td>
    <td class="lineNumber">968</td>
    <td class="codeline">    return true; // Will need to look at parent nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">969</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline"></td>
    <td class="lineNumber">970</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">  if (!Enqueue(Or))</td>
    <td class="lineNumber">971</td>
    <td class="codeline">  if (!Enqueue(Or))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">    return false; // Not an `or` reduction pattern.</td>
    <td class="lineNumber">972</td>
    <td class="codeline">    return false; // Not an `or` reduction pattern.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
    <td class="lineNumber">973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">974</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">    auto *I = Worklist.pop_back_val();</td>
    <td class="lineNumber">975</td>
    <td class="codeline">    auto *I = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline"></td>
    <td class="lineNumber">976</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">    // Okay, which instruction is this node?</td>
    <td class="lineNumber">977</td>
    <td class="codeline">    // Okay, which instruction is this node?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">    switch (I->getOpcode()) {</td>
    <td class="lineNumber">978</td>
    <td class="codeline">    switch (I->getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">    case Instruction::Or:</td>
    <td class="lineNumber">979</td>
    <td class="codeline">    case Instruction::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">      // Got an `or` node. That's fine, just recurse into it's operands.</td>
    <td class="lineNumber">980</td>
    <td class="codeline">      // Got an `or` node. That's fine, just recurse into it's operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">      for (Value *Op : I->operands())</td>
    <td class="lineNumber">981</td>
    <td class="codeline">      for (Value *Op : I->operands())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">        if (!Enqueue(Op))</td>
    <td class="lineNumber">982</td>
    <td class="codeline">        if (!Enqueue(Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">          return false; // Not an `or` reduction pattern.</td>
    <td class="lineNumber">983</td>
    <td class="codeline">          return false; // Not an `or` reduction pattern.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">984</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline"></td>
    <td class="lineNumber">985</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">    case Instruction::Shl:</td>
    <td class="lineNumber">986</td>
    <td class="codeline">    case Instruction::Shl:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">    case Instruction::ZExt:</td>
    <td class="lineNumber">987</td>
    <td class="codeline">    case Instruction::ZExt:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">      // `shl`/`zext` nodes are fine, just recurse into their base operand.</td>
    <td class="lineNumber">988</td>
    <td class="codeline">      // `shl`/`zext` nodes are fine, just recurse into their base operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">      if (!Enqueue(I->getOperand(0)))</td>
    <td class="lineNumber">989</td>
    <td class="codeline">      if (!Enqueue(I->getOperand(0)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">        return false; // Not an `or` reduction pattern.</td>
    <td class="lineNumber">990</td>
    <td class="codeline">        return false; // Not an `or` reduction pattern.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">991</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
    <td class="lineNumber">992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">    case Instruction::Load:</td>
    <td class="lineNumber">993</td>
    <td class="codeline">    case Instruction::Load:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">      // Perfect, `load` node means we've reached an edge of the graph.</td>
    <td class="lineNumber">994</td>
    <td class="codeline">      // Perfect, `load` node means we've reached an edge of the graph.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">995</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline"></td>
    <td class="lineNumber">996</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">    default:        // Unknown node.</td>
    <td class="lineNumber">997</td>
    <td class="codeline">    default:        // Unknown node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">      return false; // Not an `or` reduction pattern.</td>
    <td class="lineNumber">998</td>
    <td class="codeline">      return false; // Not an `or` reduction pattern.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">999</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline"></td>
    <td class="lineNumber">1001</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline"></td>
    <td class="lineNumber">1004</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">/// Return true if it may be profitable to convert this (X|Y) into (X+Y).</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">/// Return true if it may be profitable to convert this (X|Y) into (X+Y).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">static bool shouldConvertOrWithNoCommonBitsToAdd(Instruction *Or) {</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">static bool shouldConvertOrWithNoCommonBitsToAdd(Instruction *Or) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">  // Don't bother to convert this up unless either the LHS is an associable add</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">  // Don't bother to convert this up unless either the LHS is an associable add</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">  // or subtract or mul or if this is only used by one of the above.</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">  // or subtract or mul or if this is only used by one of the above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">  // This is only a compile-time improvement, it is not needed for correctness!</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">  // This is only a compile-time improvement, it is not needed for correctness!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">  auto isInteresting = [](Value *V) {</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">  auto isInteresting = [](Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">    for (auto Op : {Instruction::Add, Instruction::Sub, Instruction::Mul,</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">    for (auto Op : {Instruction::Add, Instruction::Sub, Instruction::Mul,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">                    Instruction::Shl})</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">                    Instruction::Shl})</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">      if (isReassociableOp(V, Op))</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">      if (isReassociableOp(V, Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline"></td>
    <td class="lineNumber">1017</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">  if (any_of(Or->operands(), isInteresting))</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">  if (any_of(Or->operands(), isInteresting))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline"></td>
    <td class="lineNumber">1020</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">  Value *VB = Or->user_back();</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">  Value *VB = Or->user_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">  if (Or->hasOneUse() && isInteresting(VB))</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">  if (Or->hasOneUse() && isInteresting(VB))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline"></td>
    <td class="lineNumber">1024</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline"></td>
    <td class="lineNumber">1027</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">/// If we have (X|Y), and iff X and Y have no common bits set,</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">/// If we have (X|Y), and iff X and Y have no common bits set,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">/// transform this into (X+Y) to allow arithmetics reassociation.</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">/// transform this into (X+Y) to allow arithmetics reassociation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">static BinaryOperator *convertOrWithNoCommonBitsToAdd(Instruction *Or) {</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">static BinaryOperator *convertOrWithNoCommonBitsToAdd(Instruction *Or) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">  // Convert an or into an add.</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">  // Convert an or into an add.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">  BinaryOperator *New =</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">  BinaryOperator *New =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">      CreateAdd(Or->getOperand(0), Or->getOperand(1), "", Or, Or);</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">      CreateAdd(Or->getOperand(0), Or->getOperand(1), "", Or, Or);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">  New->setHasNoSignedWrap();</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">  New->setHasNoSignedWrap();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">  New->setHasNoUnsignedWrap();</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">  New->setHasNoUnsignedWrap();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">  New->takeName(Or);</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">  New->takeName(Or);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline"></td>
    <td class="lineNumber">1037</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">  // Everyone now refers to the add instruction.</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">  // Everyone now refers to the add instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  Or->replaceAllUsesWith(New);</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  Or->replaceAllUsesWith(New);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">  New->setDebugLoc(Or->getDebugLoc());</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">  New->setDebugLoc(Or->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline"></td>
    <td class="lineNumber">1041</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Converted or into an add: " << *New << '\n');</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Converted or into an add: " << *New << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">  return New;</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">  return New;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline"></td>
    <td class="lineNumber">1045</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">/// Return true if we should break up this subtract of X-Y into (X + -Y).</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">/// Return true if we should break up this subtract of X-Y into (X + -Y).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">static bool ShouldBreakUpSubtract(Instruction *Sub) {</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">static bool ShouldBreakUpSubtract(Instruction *Sub) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">  // If this is a negation, we can't split it up!</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">  // If this is a negation, we can't split it up!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  if (match(Sub, m_Neg(m_Value())) || match(Sub, m_FNeg(m_Value()))) </td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  if (match(Sub, m_Neg(m_Value())) || match(Sub, m_FNeg(m_Value()))) </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline"></td>
    <td class="lineNumber">1051</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">  // Don't breakup X - undef.</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">  // Don't breakup X - undef.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">  if (isa<UndefValue>(Sub->getOperand(1)))</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">  if (isa<UndefValue>(Sub->getOperand(1)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline"></td>
    <td class="lineNumber">1055</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">  // Don't bother to break this up unless either the LHS is an associable add or</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">  // Don't bother to break this up unless either the LHS is an associable add or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">  // subtract or if this is only used by one.</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">  // subtract or if this is only used by one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">  Value *V0 = Sub->getOperand(0);</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">  Value *V0 = Sub->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  if (isReassociableOp(V0, Instruction::Add, Instruction::FAdd) ||</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  if (isReassociableOp(V0, Instruction::Add, Instruction::FAdd) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">      isReassociableOp(V0, Instruction::Sub, Instruction::FSub))</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">      isReassociableOp(V0, Instruction::Sub, Instruction::FSub))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">  Value *V1 = Sub->getOperand(1);</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">  Value *V1 = Sub->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">  if (isReassociableOp(V1, Instruction::Add, Instruction::FAdd) ||</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">  if (isReassociableOp(V1, Instruction::Add, Instruction::FAdd) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">      isReassociableOp(V1, Instruction::Sub, Instruction::FSub))</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">      isReassociableOp(V1, Instruction::Sub, Instruction::FSub))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">  Value *VB = Sub->user_back();</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">  Value *VB = Sub->user_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">  if (Sub->hasOneUse() &&</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">  if (Sub->hasOneUse() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">      (isReassociableOp(VB, Instruction::Add, Instruction::FAdd) ||</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">      (isReassociableOp(VB, Instruction::Add, Instruction::FAdd) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">       isReassociableOp(VB, Instruction::Sub, Instruction::FSub)))</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">       isReassociableOp(VB, Instruction::Sub, Instruction::FSub)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">  return false;</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">  return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline"></td>
    <td class="lineNumber">1074</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">/// If we have (X-Y), and if either X is an add, or if this is only used by an</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">/// If we have (X-Y), and if either X is an add, or if this is only used by an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">/// add, transform this into (X+(0-Y)) to promote better reassociation.</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">/// add, transform this into (X+(0-Y)) to promote better reassociation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">static BinaryOperator *BreakUpSubtract(Instruction *Sub,</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">static BinaryOperator *BreakUpSubtract(Instruction *Sub,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">                                       ReassociatePass::OrderedSet &ToRedo) {</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">                                       ReassociatePass::OrderedSet &ToRedo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">  // Convert a subtract into an add and a neg instruction. This allows sub</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">  // Convert a subtract into an add and a neg instruction. This allows sub</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">  // instructions to be commuted with other add instructions.</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">  // instructions to be commuted with other add instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">  // Calculate the negative value of Operand 1 of the sub instruction,</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">  // Calculate the negative value of Operand 1 of the sub instruction,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">  // and set it as the RHS of the add instruction we just made.</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">  // and set it as the RHS of the add instruction we just made.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">  Value *NegVal = NegateValue(Sub->getOperand(1), Sub, ToRedo);</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">  Value *NegVal = NegateValue(Sub->getOperand(1), Sub, ToRedo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">  BinaryOperator *New = CreateAdd(Sub->getOperand(0), NegVal, "", Sub, Sub);</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">  BinaryOperator *New = CreateAdd(Sub->getOperand(0), NegVal, "", Sub, Sub);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">  Sub->setOperand(0, Constant::getNullValue(Sub->getType())); // Drop use of op.</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">  Sub->setOperand(0, Constant::getNullValue(Sub->getType())); // Drop use of op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">  Sub->setOperand(1, Constant::getNullValue(Sub->getType())); // Drop use of op.</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">  Sub->setOperand(1, Constant::getNullValue(Sub->getType())); // Drop use of op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">  New->takeName(Sub);</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">  New->takeName(Sub);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline"></td>
    <td class="lineNumber">1089</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">  // Everyone now refers to the add instruction.</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">  // Everyone now refers to the add instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">  Sub->replaceAllUsesWith(New);</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">  Sub->replaceAllUsesWith(New);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">  New->setDebugLoc(Sub->getDebugLoc());</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">  New->setDebugLoc(Sub->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline"></td>
    <td class="lineNumber">1093</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Negated: " << *New << '\n');</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Negated: " << *New << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">  return New;</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">  return New;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline"></td>
    <td class="lineNumber">1097</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">/// If this is a shift of a reassociable multiply or is used by one, change</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">/// If this is a shift of a reassociable multiply or is used by one, change</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">/// this into a multiply by a constant to assist with further reassociation.</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">/// this into a multiply by a constant to assist with further reassociation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">static BinaryOperator *ConvertShiftToMul(Instruction *Shl) {</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">static BinaryOperator *ConvertShiftToMul(Instruction *Shl) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">  Constant *MulCst = ConstantInt::get(Shl->getType(), 1);</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">  Constant *MulCst = ConstantInt::get(Shl->getType(), 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">  auto *SA = cast<ConstantInt>(Shl->getOperand(1));</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">  auto *SA = cast<ConstantInt>(Shl->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">  MulCst = ConstantExpr::getShl(MulCst, SA);</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">  MulCst = ConstantExpr::getShl(MulCst, SA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline"></td>
    <td class="lineNumber">1104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">  BinaryOperator *Mul =</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">  BinaryOperator *Mul =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">    BinaryOperator::CreateMul(Shl->getOperand(0), MulCst, "", Shl);</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">    BinaryOperator::CreateMul(Shl->getOperand(0), MulCst, "", Shl);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">  Shl->setOperand(0, PoisonValue::get(Shl->getType())); // Drop use of op.</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">  Shl->setOperand(0, PoisonValue::get(Shl->getType())); // Drop use of op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">  Mul->takeName(Shl);</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">  Mul->takeName(Shl);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline"></td>
    <td class="lineNumber">1109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">  // Everyone now refers to the mul instruction.</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">  // Everyone now refers to the mul instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">  Shl->replaceAllUsesWith(Mul);</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">  Shl->replaceAllUsesWith(Mul);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">  Mul->setDebugLoc(Shl->getDebugLoc());</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">  Mul->setDebugLoc(Shl->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline"></td>
    <td class="lineNumber">1113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">  // We can safely preserve the nuw flag in all cases.  It's also safe to turn a</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">  // We can safely preserve the nuw flag in all cases.  It's also safe to turn a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">  // nuw nsw shl into a nuw nsw mul.  However, nsw in isolation requires special</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">  // nuw nsw shl into a nuw nsw mul.  However, nsw in isolation requires special</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">  // handling.  It can be preserved as long as we're not left shifting by</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">  // handling.  It can be preserved as long as we're not left shifting by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">  // bitwidth - 1.</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">  // bitwidth - 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">  bool NSW = cast<BinaryOperator>(Shl)->hasNoSignedWrap();</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">  bool NSW = cast<BinaryOperator>(Shl)->hasNoSignedWrap();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">  bool NUW = cast<BinaryOperator>(Shl)->hasNoUnsignedWrap();</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">  bool NUW = cast<BinaryOperator>(Shl)->hasNoUnsignedWrap();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">  unsigned BitWidth = Shl->getType()->getIntegerBitWidth();</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">  unsigned BitWidth = Shl->getType()->getIntegerBitWidth();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">  if (NSW && (NUW || SA->getValue().ult(BitWidth - 1)))</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">  if (NSW && (NUW || SA->getValue().ult(BitWidth - 1)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">    Mul->setHasNoSignedWrap(true);</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">    Mul->setHasNoSignedWrap(true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">  Mul->setHasNoUnsignedWrap(NUW);</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">  Mul->setHasNoUnsignedWrap(NUW);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">  return Mul;</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">  return Mul;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline"></td>
    <td class="lineNumber">1126</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">/// Scan backwards and forwards among values with the same rank as element i</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">/// Scan backwards and forwards among values with the same rank as element i</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">/// to see if X exists.  If X does not exist, return i.  This is useful when</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">/// to see if X exists.  If X does not exist, return i.  This is useful when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">/// scanning for 'x' when we see '-x' because they both get the same rank.</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">/// scanning for 'x' when we see '-x' because they both get the same rank.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">static unsigned FindInOperandList(const SmallVectorImpl<ValueEntry> &Ops,</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">static unsigned FindInOperandList(const SmallVectorImpl<ValueEntry> &Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">                                  unsigned i, Value *X) {</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">                                  unsigned i, Value *X) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">  unsigned XRank = Ops[i].Rank;</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">  unsigned XRank = Ops[i].Rank;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">  unsigned e = Ops.size();</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">  unsigned e = Ops.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">  for (unsigned j = i+1; j != e && Ops[j].Rank == XRank; ++j) {</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">  for (unsigned j = i+1; j != e && Ops[j].Rank == XRank; ++j) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">    if (Ops[j].Op == X)</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">    if (Ops[j].Op == X)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">      return j;</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">      return j;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">    if (Instruction *I1 = dyn_cast<Instruction>(Ops[j].Op))</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">    if (Instruction *I1 = dyn_cast<Instruction>(Ops[j].Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">      if (Instruction *I2 = dyn_cast<Instruction>(X))</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">      if (Instruction *I2 = dyn_cast<Instruction>(X))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">        if (I1->isIdenticalTo(I2))</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">        if (I1->isIdenticalTo(I2))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">          return j;</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">          return j;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">  // Scan backwards.</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">  // Scan backwards.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">  for (unsigned j = i-1; j != ~0U && Ops[j].Rank == XRank; --j) {</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">  for (unsigned j = i-1; j != ~0U && Ops[j].Rank == XRank; --j) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">    if (Ops[j].Op == X)</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">    if (Ops[j].Op == X)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">      return j;</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">      return j;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">    if (Instruction *I1 = dyn_cast<Instruction>(Ops[j].Op))</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">    if (Instruction *I1 = dyn_cast<Instruction>(Ops[j].Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">      if (Instruction *I2 = dyn_cast<Instruction>(X))</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">      if (Instruction *I2 = dyn_cast<Instruction>(X))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">        if (I1->isIdenticalTo(I2))</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">        if (I1->isIdenticalTo(I2))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">          return j;</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">          return j;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">  return i;</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">  return i;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline"></td>
    <td class="lineNumber">1153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">/// Emit a tree of add instructions, summing Ops together</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">/// Emit a tree of add instructions, summing Ops together</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">/// and returning the result.  Insert the tree before I.</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">/// and returning the result.  Insert the tree before I.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">static Value *EmitAddTreeOfValues(Instruction *I,</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">static Value *EmitAddTreeOfValues(Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">                                  SmallVectorImpl<WeakTrackingVH> &Ops) {</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">                                  SmallVectorImpl<WeakTrackingVH> &Ops) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">  if (Ops.size() == 1) return Ops.back();</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">  if (Ops.size() == 1) return Ops.back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">  Value *V1 = Ops.pop_back_val();</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">  Value *V1 = Ops.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">  Value *V2 = EmitAddTreeOfValues(I, Ops);</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">  Value *V2 = EmitAddTreeOfValues(I, Ops);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">  return CreateAdd(V2, V1, "reass.add", I, I);</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">  return CreateAdd(V2, V1, "reass.add", I, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline"></td>
    <td class="lineNumber">1164</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">/// If V is an expression tree that is a multiplication sequence,</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">/// If V is an expression tree that is a multiplication sequence,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">/// and if this sequence contains a multiply by Factor,</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">/// and if this sequence contains a multiply by Factor,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">/// remove Factor from the tree and return the new tree.</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">/// remove Factor from the tree and return the new tree.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">Value *ReassociatePass::RemoveFactorFromExpression(Value *V, Value *Factor) {</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">Value *ReassociatePass::RemoveFactorFromExpression(Value *V, Value *Factor) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">  BinaryOperator *BO = isReassociableOp(V, Instruction::Mul, Instruction::FMul);</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">  BinaryOperator *BO = isReassociableOp(V, Instruction::Mul, Instruction::FMul);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">  if (!BO)</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">  if (!BO)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline"></td>
    <td class="lineNumber">1172</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">  SmallVector<RepeatedValue, 8> Tree;</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">  SmallVector<RepeatedValue, 8> Tree;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">  MadeChange |= LinearizeExprTree(BO, Tree, RedoInsts);</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">  MadeChange |= LinearizeExprTree(BO, Tree, RedoInsts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">  SmallVector<ValueEntry, 8> Factors;</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">  SmallVector<ValueEntry, 8> Factors;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">  Factors.reserve(Tree.size());</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">  Factors.reserve(Tree.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">  for (unsigned i = 0, e = Tree.size(); i != e; ++i) {</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">  for (unsigned i = 0, e = Tree.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">    RepeatedValue E = Tree[i];</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">    RepeatedValue E = Tree[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">    Factors.append(E.second.getZExtValue(),</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">    Factors.append(E.second.getZExtValue(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">                   ValueEntry(getRank(E.first), E.first));</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">                   ValueEntry(getRank(E.first), E.first));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline"></td>
    <td class="lineNumber">1182</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">  bool FoundFactor = false;</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">  bool FoundFactor = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">  bool NeedsNegate = false;</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">  bool NeedsNegate = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">  for (unsigned i = 0, e = Factors.size(); i != e; ++i) {</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">  for (unsigned i = 0, e = Factors.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">    if (Factors[i].Op == Factor) {</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">    if (Factors[i].Op == Factor) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">      FoundFactor = true;</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">      FoundFactor = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">      Factors.erase(Factors.begin()+i);</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">      Factors.erase(Factors.begin()+i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline"></td>
    <td class="lineNumber">1191</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">    // If this is a negative version of this factor, remove it.</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">    // If this is a negative version of this factor, remove it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">    if (ConstantInt *FC1 = dyn_cast<ConstantInt>(Factor)) {</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">    if (ConstantInt *FC1 = dyn_cast<ConstantInt>(Factor)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">      if (ConstantInt *FC2 = dyn_cast<ConstantInt>(Factors[i].Op))</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">      if (ConstantInt *FC2 = dyn_cast<ConstantInt>(Factors[i].Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">        if (FC1->getValue() == -FC2->getValue()) {</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">        if (FC1->getValue() == -FC2->getValue()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">          FoundFactor = NeedsNegate = true;</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">          FoundFactor = NeedsNegate = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">          Factors.erase(Factors.begin()+i);</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">          Factors.erase(Factors.begin()+i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">    } else if (ConstantFP *FC1 = dyn_cast<ConstantFP>(Factor)) {</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">    } else if (ConstantFP *FC1 = dyn_cast<ConstantFP>(Factor)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">      if (ConstantFP *FC2 = dyn_cast<ConstantFP>(Factors[i].Op)) {</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">      if (ConstantFP *FC2 = dyn_cast<ConstantFP>(Factors[i].Op)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">        const APFloat &F1 = FC1->getValueAPF();</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">        const APFloat &F1 = FC1->getValueAPF();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">        APFloat F2(FC2->getValueAPF());</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">        APFloat F2(FC2->getValueAPF());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">        F2.changeSign();</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">        F2.changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">        if (F1 == F2) {</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">        if (F1 == F2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">          FoundFactor = NeedsNegate = true;</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">          FoundFactor = NeedsNegate = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">          Factors.erase(Factors.begin() + i);</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">          Factors.erase(Factors.begin() + i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline"></td>
    <td class="lineNumber">1213</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  if (!FoundFactor) {</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  if (!FoundFactor) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">    // Make sure to restore the operands to the expression tree.</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">    // Make sure to restore the operands to the expression tree.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">    RewriteExprTree(BO, Factors);</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">    RewriteExprTree(BO, Factors);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">  BasicBlock::iterator InsertPt = ++BO->getIterator();</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">  BasicBlock::iterator InsertPt = ++BO->getIterator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  // If this was just a single multiply, remove the multiply and return the only</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  // If this was just a single multiply, remove the multiply and return the only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">  // remaining operand.</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">  // remaining operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">  if (Factors.size() == 1) {</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">  if (Factors.size() == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">    RedoInsts.insert(BO);</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">    RedoInsts.insert(BO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">    V = Factors[0].Op;</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">    V = Factors[0].Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">    RewriteExprTree(BO, Factors);</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">    RewriteExprTree(BO, Factors);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">    V = BO;</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">    V = BO;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline"></td>
    <td class="lineNumber">1231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  if (NeedsNegate)</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  if (NeedsNegate)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">    V = CreateNeg(V, "neg", &*InsertPt, BO);</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">    V = CreateNeg(V, "neg", &*InsertPt, BO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline"></td>
    <td class="lineNumber">1234</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline"></td>
    <td class="lineNumber">1237</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">/// If V is a single-use multiply, recursively add its operands as factors,</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">/// If V is a single-use multiply, recursively add its operands as factors,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">/// otherwise add V to the list of factors.</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">/// otherwise add V to the list of factors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">/// Ops is the top-level list of add operands we're trying to factor.</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">/// Ops is the top-level list of add operands we're trying to factor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">static void FindSingleUseMultiplyFactors(Value *V,</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">static void FindSingleUseMultiplyFactors(Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">                                         SmallVectorImpl<Value*> &Factors) {</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">                                         SmallVectorImpl<Value*> &Factors) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">  BinaryOperator *BO = isReassociableOp(V, Instruction::Mul, Instruction::FMul);</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">  BinaryOperator *BO = isReassociableOp(V, Instruction::Mul, Instruction::FMul);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">  if (!BO) {</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">  if (!BO) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">    Factors.push_back(V);</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">    Factors.push_back(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline"></td>
    <td class="lineNumber">1249</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">  // Otherwise, add the LHS and RHS to the list of factors.</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">  // Otherwise, add the LHS and RHS to the list of factors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">  FindSingleUseMultiplyFactors(BO->getOperand(1), Factors);</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">  FindSingleUseMultiplyFactors(BO->getOperand(1), Factors);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">  FindSingleUseMultiplyFactors(BO->getOperand(0), Factors);</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">  FindSingleUseMultiplyFactors(BO->getOperand(0), Factors);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline"></td>
    <td class="lineNumber">1254</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">/// This optimizes based on identities.  If it can be reduced to a single Value,</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">/// This optimizes based on identities.  If it can be reduced to a single Value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">/// it is returned, otherwise the Ops list is mutated as necessary.</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">/// it is returned, otherwise the Ops list is mutated as necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">static Value *OptimizeAndOrXor(unsigned Opcode,</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">static Value *OptimizeAndOrXor(unsigned Opcode,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">                               SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">                               SmallVectorImpl<ValueEntry> &Ops) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">  // Scan the operand lists looking for X and ~X pairs, along with X,X pairs.</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">  // Scan the operand lists looking for X and ~X pairs, along with X,X pairs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">  // If we find any, we can simplify the expression. X&~X == 0, X|~X == -1.</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">  // If we find any, we can simplify the expression. X&~X == 0, X|~X == -1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">    // First, check for X and ~X in the operand list.</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">    // First, check for X and ~X in the operand list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">    assert(i < Ops.size());</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">    assert(i < Ops.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">    Value *X;</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">    Value *X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">    if (match(Ops[i].Op, m_Not(m_Value(X)))) {    // Cannot occur for ^.</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">    if (match(Ops[i].Op, m_Not(m_Value(X)))) {    // Cannot occur for ^.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">      unsigned FoundX = FindInOperandList(Ops, i, X);</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">      unsigned FoundX = FindInOperandList(Ops, i, X);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">      if (FoundX != i) {</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">      if (FoundX != i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">        if (Opcode == Instruction::And)   // ...&X&~X = 0</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">        if (Opcode == Instruction::And)   // ...&X&~X = 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">          return Constant::getNullValue(X->getType());</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">          return Constant::getNullValue(X->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline"></td>
    <td class="lineNumber">1271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">        if (Opcode == Instruction::Or)    // ...|X|~X = -1</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">        if (Opcode == Instruction::Or)    // ...|X|~X = -1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">          return Constant::getAllOnesValue(X->getType());</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">          return Constant::getAllOnesValue(X->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">    // Next, check for duplicate pairs of values, which we assume are next to</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">    // Next, check for duplicate pairs of values, which we assume are next to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">    // each other, due to our sorting criteria.</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">    // each other, due to our sorting criteria.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">    assert(i < Ops.size());</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">    assert(i < Ops.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">    if (i+1 != Ops.size() && Ops[i+1].Op == Ops[i].Op) {</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">    if (i+1 != Ops.size() && Ops[i+1].Op == Ops[i].Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">      if (Opcode == Instruction::And || Opcode == Instruction::Or) {</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">      if (Opcode == Instruction::And || Opcode == Instruction::Or) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">        // Drop duplicate values for And and Or.</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">        // Drop duplicate values for And and Or.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">        Ops.erase(Ops.begin()+i);</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">        Ops.erase(Ops.begin()+i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">        --i; --e;</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">        --i; --e;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">        ++NumAnnihil;</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">        ++NumAnnihil;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline"></td>
    <td class="lineNumber">1288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">      // Drop pairs of values for Xor.</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">      // Drop pairs of values for Xor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">      assert(Opcode == Instruction::Xor);</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">      assert(Opcode == Instruction::Xor);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">      if (e == 2)</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">      if (e == 2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">        return Constant::getNullValue(Ops[0].Op->getType());</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">        return Constant::getNullValue(Ops[0].Op->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline"></td>
    <td class="lineNumber">1293</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">      // Y ^ X^X -> Y</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">      // Y ^ X^X -> Y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">      Ops.erase(Ops.begin()+i, Ops.begin()+i+2);</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">      Ops.erase(Ops.begin()+i, Ops.begin()+i+2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">      i -= 1; e -= 2;</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">      i -= 1; e -= 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">      ++NumAnnihil;</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">      ++NumAnnihil;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline"></td>
    <td class="lineNumber">1302</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">/// Helper function of CombineXorOpnd(). It creates a bitwise-and</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">/// Helper function of CombineXorOpnd(). It creates a bitwise-and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">/// instruction with the given two operands, and return the resulting</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">/// instruction with the given two operands, and return the resulting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">/// instruction. There are two special cases: 1) if the constant operand is 0,</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">/// instruction. There are two special cases: 1) if the constant operand is 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">/// it will return NULL. 2) if the constant is ~0, the symbolic operand will</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">/// it will return NULL. 2) if the constant is ~0, the symbolic operand will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">/// be returned.</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">/// be returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">static Value *createAndInstr(Instruction *InsertBefore, Value *Opnd,</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">static Value *createAndInstr(Instruction *InsertBefore, Value *Opnd,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">                             const APInt &ConstOpnd) {</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">                             const APInt &ConstOpnd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">  if (ConstOpnd.isZero())</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">  if (ConstOpnd.isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline"></td>
    <td class="lineNumber">1312</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  if (ConstOpnd.isAllOnes())</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  if (ConstOpnd.isAllOnes())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">    return Opnd;</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">    return Opnd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
    <td class="lineNumber">1315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">  Instruction *I = BinaryOperator::CreateAnd(</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">  Instruction *I = BinaryOperator::CreateAnd(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">      Opnd, ConstantInt::get(Opnd->getType(), ConstOpnd), "and.ra",</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">      Opnd, ConstantInt::get(Opnd->getType(), ConstOpnd), "and.ra",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">      InsertBefore);</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">      InsertBefore);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline">  I->setDebugLoc(InsertBefore->getDebugLoc());</td>
    <td class="lineNumber">1319</td>
    <td class="codeline">  I->setDebugLoc(InsertBefore->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">  return I;</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">  return I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline"></td>
    <td class="lineNumber">1322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">// Helper function of OptimizeXor(). It tries to simplify "Opnd1 ^ ConstOpnd"</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">// Helper function of OptimizeXor(). It tries to simplify "Opnd1 ^ ConstOpnd"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">// into "R ^ C", where C would be 0, and R is a symbolic value.</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">// into "R ^ C", where C would be 0, and R is a symbolic value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">// If it was successful, true is returned, and the "R" and "C" is returned</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">// If it was successful, true is returned, and the "R" and "C" is returned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">// via "Res" and "ConstOpnd", respectively; otherwise, false is returned,</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">// via "Res" and "ConstOpnd", respectively; otherwise, false is returned,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">// and both "Res" and "ConstOpnd" remain unchanged.</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">// and both "Res" and "ConstOpnd" remain unchanged.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">bool ReassociatePass::CombineXorOpnd(Instruction *I, XorOpnd *Opnd1,</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">bool ReassociatePass::CombineXorOpnd(Instruction *I, XorOpnd *Opnd1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">                                     APInt &ConstOpnd, Value *&Res) {</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">                                     APInt &ConstOpnd, Value *&Res) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">  // Xor-Rule 1: (x | c1) ^ c2 = (x | c1) ^ (c1 ^ c1) ^ c2</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">  // Xor-Rule 1: (x | c1) ^ c2 = (x | c1) ^ (c1 ^ c1) ^ c2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">  //                       = ((x | c1) ^ c1) ^ (c1 ^ c2)</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">  //                       = ((x | c1) ^ c1) ^ (c1 ^ c2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">  //                       = (x & ~c1) ^ (c1 ^ c2)</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">  //                       = (x & ~c1) ^ (c1 ^ c2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">  // It is useful only when c1 == c2.</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">  // It is useful only when c1 == c2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">  if (!Opnd1->isOrExpr() || Opnd1->getConstPart().isZero())</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">  if (!Opnd1->isOrExpr() || Opnd1->getConstPart().isZero())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline"></td>
    <td class="lineNumber">1337</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">  if (!Opnd1->getValue()->hasOneUse())</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">  if (!Opnd1->getValue()->hasOneUse())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline"></td>
    <td class="lineNumber">1340</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">  const APInt &C1 = Opnd1->getConstPart();</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">  const APInt &C1 = Opnd1->getConstPart();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">  if (C1 != ConstOpnd)</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">  if (C1 != ConstOpnd)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline"></td>
    <td class="lineNumber">1344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">  Value *X = Opnd1->getSymbolicPart();</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">  Value *X = Opnd1->getSymbolicPart();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">  Res = createAndInstr(I, X, ~C1);</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">  Res = createAndInstr(I, X, ~C1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">  // ConstOpnd was C2, now C1 ^ C2.</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">  // ConstOpnd was C2, now C1 ^ C2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">  ConstOpnd ^= C1;</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">  ConstOpnd ^= C1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">  if (Instruction *T = dyn_cast<Instruction>(Opnd1->getValue()))</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">  if (Instruction *T = dyn_cast<Instruction>(Opnd1->getValue()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">    RedoInsts.insert(T);</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">    RedoInsts.insert(T);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline"></td>
    <td class="lineNumber">1354</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">// Helper function of OptimizeXor(). It tries to simplify</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">// Helper function of OptimizeXor(). It tries to simplify</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">// "Opnd1 ^ Opnd2 ^ ConstOpnd" into "R ^ C", where C would be 0, and R is a</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">// "Opnd1 ^ Opnd2 ^ ConstOpnd" into "R ^ C", where C would be 0, and R is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">// symbolic value.</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">// symbolic value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">//</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">// If it was successful, true is returned, and the "R" and "C" is returned</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">// If it was successful, true is returned, and the "R" and "C" is returned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">// via "Res" and "ConstOpnd", respectively (If the entire expression is</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">// via "Res" and "ConstOpnd", respectively (If the entire expression is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">// evaluated to a constant, the Res is set to NULL); otherwise, false is</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">// evaluated to a constant, the Res is set to NULL); otherwise, false is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">// returned, and both "Res" and "ConstOpnd" remain unchanged.</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">// returned, and both "Res" and "ConstOpnd" remain unchanged.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">bool ReassociatePass::CombineXorOpnd(Instruction *I, XorOpnd *Opnd1,</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">bool ReassociatePass::CombineXorOpnd(Instruction *I, XorOpnd *Opnd1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">                                     XorOpnd *Opnd2, APInt &ConstOpnd,</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">                                     XorOpnd *Opnd2, APInt &ConstOpnd,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">                                     Value *&Res) {</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">                                     Value *&Res) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">  Value *X = Opnd1->getSymbolicPart();</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">  Value *X = Opnd1->getSymbolicPart();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">  if (X != Opnd2->getSymbolicPart())</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">  if (X != Opnd2->getSymbolicPart())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline"></td>
    <td class="lineNumber">1369</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">  // This many instruction become dead.(At least "Opnd1 ^ Opnd2" will die.)</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">  // This many instruction become dead.(At least "Opnd1 ^ Opnd2" will die.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">  int DeadInstNum = 1;</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">  int DeadInstNum = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">  if (Opnd1->getValue()->hasOneUse())</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">  if (Opnd1->getValue()->hasOneUse())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">    DeadInstNum++;</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">    DeadInstNum++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">  if (Opnd2->getValue()->hasOneUse())</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">  if (Opnd2->getValue()->hasOneUse())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">    DeadInstNum++;</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">    DeadInstNum++;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline"></td>
    <td class="lineNumber">1376</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">  // Xor-Rule 2:</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">  // Xor-Rule 2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">  //  (x | c1) ^ (x & c2)</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">  //  (x | c1) ^ (x & c2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">  //   = (x|c1) ^ (x&c2) ^ (c1 ^ c1) = ((x|c1) ^ c1) ^ (x & c2) ^ c1</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">  //   = (x|c1) ^ (x&c2) ^ (c1 ^ c1) = ((x|c1) ^ c1) ^ (x & c2) ^ c1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">  //   = (x & ~c1) ^ (x & c2) ^ c1               // Xor-Rule 1</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">  //   = (x & ~c1) ^ (x & c2) ^ c1               // Xor-Rule 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">  //   = (x & c3) ^ c1, where c3 = ~c1 ^ c2      // Xor-rule 3</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">  //   = (x & c3) ^ c1, where c3 = ~c1 ^ c2      // Xor-rule 3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">  if (Opnd1->isOrExpr() != Opnd2->isOrExpr()) {</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">  if (Opnd1->isOrExpr() != Opnd2->isOrExpr()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">    if (Opnd2->isOrExpr())</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">    if (Opnd2->isOrExpr())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">      std::swap(Opnd1, Opnd2);</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">      std::swap(Opnd1, Opnd2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline"></td>
    <td class="lineNumber">1386</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">    const APInt &C1 = Opnd1->getConstPart();</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">    const APInt &C1 = Opnd1->getConstPart();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">    const APInt &C2 = Opnd2->getConstPart();</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">    const APInt &C2 = Opnd2->getConstPart();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">    APInt C3((~C1) ^ C2);</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">    APInt C3((~C1) ^ C2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline"></td>
    <td class="lineNumber">1390</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">    // Do not increase code size!</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">    // Do not increase code size!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">    if (!C3.isZero() && !C3.isAllOnes()) {</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">    if (!C3.isZero() && !C3.isAllOnes()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">      int NewInstNum = ConstOpnd.getBoolValue() ? 1 : 2;</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">      int NewInstNum = ConstOpnd.getBoolValue() ? 1 : 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">      if (NewInstNum > DeadInstNum)</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">      if (NewInstNum > DeadInstNum)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline"></td>
    <td class="lineNumber">1397</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">    Res = createAndInstr(I, X, C3);</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">    Res = createAndInstr(I, X, C3);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">    ConstOpnd ^= C1;</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">    ConstOpnd ^= C1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">  } else if (Opnd1->isOrExpr()) {</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">  } else if (Opnd1->isOrExpr()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">    // Xor-Rule 3: (x | c1) ^ (x | c2) = (x & c3) ^ c3 where c3 = c1 ^ c2</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">    // Xor-Rule 3: (x | c1) ^ (x | c2) = (x & c3) ^ c3 where c3 = c1 ^ c2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">    const APInt &C1 = Opnd1->getConstPart();</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">    const APInt &C1 = Opnd1->getConstPart();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">    const APInt &C2 = Opnd2->getConstPart();</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">    const APInt &C2 = Opnd2->getConstPart();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">    APInt C3 = C1 ^ C2;</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">    APInt C3 = C1 ^ C2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline"></td>
    <td class="lineNumber">1406</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">    // Do not increase code size</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">    // Do not increase code size</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">    if (!C3.isZero() && !C3.isAllOnes()) {</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">    if (!C3.isZero() && !C3.isAllOnes()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">      int NewInstNum = ConstOpnd.getBoolValue() ? 1 : 2;</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">      int NewInstNum = ConstOpnd.getBoolValue() ? 1 : 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">      if (NewInstNum > DeadInstNum)</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">      if (NewInstNum > DeadInstNum)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline"></td>
    <td class="lineNumber">1413</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">    Res = createAndInstr(I, X, C3);</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">    Res = createAndInstr(I, X, C3);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">    ConstOpnd ^= C3;</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">    ConstOpnd ^= C3;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">    // Xor-Rule 4: (x & c1) ^ (x & c2) = (x & (c1^c2))</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">    // Xor-Rule 4: (x & c1) ^ (x & c2) = (x & (c1^c2))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">    const APInt &C1 = Opnd1->getConstPart();</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">    const APInt &C1 = Opnd1->getConstPart();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">    const APInt &C2 = Opnd2->getConstPart();</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">    const APInt &C2 = Opnd2->getConstPart();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">    APInt C3 = C1 ^ C2;</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">    APInt C3 = C1 ^ C2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">    Res = createAndInstr(I, X, C3);</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">    Res = createAndInstr(I, X, C3);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline"></td>
    <td class="lineNumber">1424</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">  // Put the original operands in the Redo list; hope they will be deleted</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">  // Put the original operands in the Redo list; hope they will be deleted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">  // as dead code.</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">  // as dead code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">  if (Instruction *T = dyn_cast<Instruction>(Opnd1->getValue()))</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">  if (Instruction *T = dyn_cast<Instruction>(Opnd1->getValue()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">    RedoInsts.insert(T);</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">    RedoInsts.insert(T);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">  if (Instruction *T = dyn_cast<Instruction>(Opnd2->getValue()))</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">  if (Instruction *T = dyn_cast<Instruction>(Opnd2->getValue()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">    RedoInsts.insert(T);</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">    RedoInsts.insert(T);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline"></td>
    <td class="lineNumber">1431</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline"></td>
    <td class="lineNumber">1434</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">/// Optimize a series of operands to an 'xor' instruction. If it can be reduced</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">/// Optimize a series of operands to an 'xor' instruction. If it can be reduced</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">/// to a single Value, it is returned, otherwise the Ops list is mutated as</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">/// to a single Value, it is returned, otherwise the Ops list is mutated as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">/// necessary.</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">/// necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">Value *ReassociatePass::OptimizeXor(Instruction *I,</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">Value *ReassociatePass::OptimizeXor(Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">  if (Value *V = OptimizeAndOrXor(Instruction::Xor, Ops))</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">  if (Value *V = OptimizeAndOrXor(Instruction::Xor, Ops))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline"></td>
    <td class="lineNumber">1442</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">  if (Ops.size() == 1)</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">  if (Ops.size() == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline"></td>
    <td class="lineNumber">1445</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">  SmallVector<XorOpnd, 8> Opnds;</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">  SmallVector<XorOpnd, 8> Opnds;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">  SmallVector<XorOpnd*, 8> OpndPtrs;</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">  SmallVector<XorOpnd*, 8> OpndPtrs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">  Type *Ty = Ops[0].Op->getType();</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">  Type *Ty = Ops[0].Op->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">  APInt ConstOpnd(Ty->getScalarSizeInBits(), 0);</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">  APInt ConstOpnd(Ty->getScalarSizeInBits(), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline"></td>
    <td class="lineNumber">1450</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">  // Step 1: Convert ValueEntry to XorOpnd</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">  // Step 1: Convert ValueEntry to XorOpnd</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">    Value *V = Ops[i].Op;</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">    Value *V = Ops[i].Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">    const APInt *C;</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">    const APInt *C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">    // TODO: Support non-splat vectors.</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">    // TODO: Support non-splat vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">    if (match(V, m_APInt(C))) {</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">    if (match(V, m_APInt(C))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline">      ConstOpnd ^= *C;</td>
    <td class="lineNumber">1457</td>
    <td class="codeline">      ConstOpnd ^= *C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">      XorOpnd O(V);</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">      XorOpnd O(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">      O.setSymbolicRank(getRank(O.getSymbolicPart()));</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">      O.setSymbolicRank(getRank(O.getSymbolicPart()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">      Opnds.push_back(O);</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">      Opnds.push_back(O);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1462</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline"></td>
    <td class="lineNumber">1464</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">  // NOTE: From this point on, do *NOT* add/delete element to/from "Opnds".</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">  // NOTE: From this point on, do *NOT* add/delete element to/from "Opnds".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">  //  It would otherwise invalidate the "Opnds"'s iterator, and hence invalidate</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">  //  It would otherwise invalidate the "Opnds"'s iterator, and hence invalidate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">  //  the "OpndPtrs" as well. For the similar reason, do not fuse this loop</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">  //  the "OpndPtrs" as well. For the similar reason, do not fuse this loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">  //  with the previous loop --- the iterator of the "Opnds" may be invalidated</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">  //  with the previous loop --- the iterator of the "Opnds" may be invalidated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">  //  when new elements are added to the vector.</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">  //  when new elements are added to the vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">  for (unsigned i = 0, e = Opnds.size(); i != e; ++i)</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">  for (unsigned i = 0, e = Opnds.size(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">    OpndPtrs.push_back(&Opnds[i]);</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">    OpndPtrs.push_back(&Opnds[i]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline"></td>
    <td class="lineNumber">1472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">  // Step 2: Sort the Xor-Operands in a way such that the operands containing</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">  // Step 2: Sort the Xor-Operands in a way such that the operands containing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">  //  the same symbolic value cluster together. For instance, the input operand</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">  //  the same symbolic value cluster together. For instance, the input operand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">  //  sequence ("x | 123", "y & 456", "x & 789") will be sorted into:</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">  //  sequence ("x | 123", "y & 456", "x & 789") will be sorted into:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">  //  ("x | 123", "x & 789", "y & 456").</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">  //  ("x | 123", "x & 789", "y & 456").</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">  //  The purpose is twofold:</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">  //  The purpose is twofold:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">  //  1) Cluster together the operands sharing the same symbolic-value.</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">  //  1) Cluster together the operands sharing the same symbolic-value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">  //  2) Operand having smaller symbolic-value-rank is permuted earlier, which</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">  //  2) Operand having smaller symbolic-value-rank is permuted earlier, which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">  //     could potentially shorten crital path, and expose more loop-invariants.</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">  //     could potentially shorten crital path, and expose more loop-invariants.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">  //     Note that values' rank are basically defined in RPO order (FIXME).</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">  //     Note that values' rank are basically defined in RPO order (FIXME).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">  //     So, if Rank(X) < Rank(Y) < Rank(Z), it means X is defined earlier</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">  //     So, if Rank(X) < Rank(Y) < Rank(Z), it means X is defined earlier</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">  //     than Y which is defined earlier than Z. Permute "x | 1", "Y & 2",</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">  //     than Y which is defined earlier than Z. Permute "x | 1", "Y & 2",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">  //     "z" in the order of X-Y-Z is better than any other orders.</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">  //     "z" in the order of X-Y-Z is better than any other orders.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">  llvm::stable_sort(OpndPtrs, [](XorOpnd *LHS, XorOpnd *RHS) {</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">  llvm::stable_sort(OpndPtrs, [](XorOpnd *LHS, XorOpnd *RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">    return LHS->getSymbolicRank() < RHS->getSymbolicRank();</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">    return LHS->getSymbolicRank() < RHS->getSymbolicRank();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline"></td>
    <td class="lineNumber">1489</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">  // Step 3: Combine adjacent operands</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">  // Step 3: Combine adjacent operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">  XorOpnd *PrevOpnd = nullptr;</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">  XorOpnd *PrevOpnd = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">  for (unsigned i = 0, e = Opnds.size(); i < e; i++) {</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">  for (unsigned i = 0, e = Opnds.size(); i < e; i++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">    XorOpnd *CurrOpnd = OpndPtrs[i];</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">    XorOpnd *CurrOpnd = OpndPtrs[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">    // The combined value</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">    // The combined value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">    Value *CV;</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">    Value *CV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline"></td>
    <td class="lineNumber">1497</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">    // Step 3.1: Try simplifying "CurrOpnd ^ ConstOpnd"</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">    // Step 3.1: Try simplifying "CurrOpnd ^ ConstOpnd"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">    if (!ConstOpnd.isZero() && CombineXorOpnd(I, CurrOpnd, ConstOpnd, CV)) {</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">    if (!ConstOpnd.isZero() && CombineXorOpnd(I, CurrOpnd, ConstOpnd, CV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">      Changed = true;</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">      Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">      if (CV)</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">      if (CV)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">        *CurrOpnd = XorOpnd(CV);</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">        *CurrOpnd = XorOpnd(CV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">      else {</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">      else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">        CurrOpnd->Invalidate();</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">        CurrOpnd->Invalidate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline"></td>
    <td class="lineNumber">1508</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">    if (!PrevOpnd || CurrOpnd->getSymbolicPart() != PrevOpnd->getSymbolicPart()) {</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">    if (!PrevOpnd || CurrOpnd->getSymbolicPart() != PrevOpnd->getSymbolicPart()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">      PrevOpnd = CurrOpnd;</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">      PrevOpnd = CurrOpnd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline"></td>
    <td class="lineNumber">1513</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">    // step 3.2: When previous and current operands share the same symbolic</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">    // step 3.2: When previous and current operands share the same symbolic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">    //  value, try to simplify "PrevOpnd ^ CurrOpnd ^ ConstOpnd"</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">    //  value, try to simplify "PrevOpnd ^ CurrOpnd ^ ConstOpnd"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">    if (CombineXorOpnd(I, CurrOpnd, PrevOpnd, ConstOpnd, CV)) {</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">    if (CombineXorOpnd(I, CurrOpnd, PrevOpnd, ConstOpnd, CV)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">      // Remove previous operand</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">      // Remove previous operand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">      PrevOpnd->Invalidate();</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">      PrevOpnd->Invalidate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">      if (CV) {</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">      if (CV) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">        *CurrOpnd = XorOpnd(CV);</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">        *CurrOpnd = XorOpnd(CV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">        PrevOpnd = CurrOpnd;</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">        PrevOpnd = CurrOpnd;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">        CurrOpnd->Invalidate();</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">        CurrOpnd->Invalidate();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">        PrevOpnd = nullptr;</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">        PrevOpnd = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">      Changed = true;</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">      Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline"></td>
    <td class="lineNumber">1529</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">  // Step 4: Reassemble the Ops</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">  // Step 4: Reassemble the Ops</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">  if (Changed) {</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">  if (Changed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">    Ops.clear();</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">    Ops.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">    for (const XorOpnd &O : Opnds) {</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">    for (const XorOpnd &O : Opnds) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">      if (O.isInvalid())</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">      if (O.isInvalid())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">      ValueEntry VE(getRank(O.getValue()), O.getValue());</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">      ValueEntry VE(getRank(O.getValue()), O.getValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">      Ops.push_back(VE);</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">      Ops.push_back(VE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">    if (!ConstOpnd.isZero()) {</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">    if (!ConstOpnd.isZero()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">      Value *C = ConstantInt::get(Ty, ConstOpnd);</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">      Value *C = ConstantInt::get(Ty, ConstOpnd);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">      ValueEntry VE(getRank(C), C);</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">      ValueEntry VE(getRank(C), C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">      Ops.push_back(VE);</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">      Ops.push_back(VE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">    unsigned Sz = Ops.size();</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">    unsigned Sz = Ops.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">    if (Sz == 1)</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">    if (Sz == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">      return Ops.back().Op;</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">      return Ops.back().Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">    if (Sz == 0) {</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">    if (Sz == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">      assert(ConstOpnd.isZero());</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">      assert(ConstOpnd.isZero());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">      return ConstantInt::get(Ty, ConstOpnd);</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">      return ConstantInt::get(Ty, ConstOpnd);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline"></td>
    <td class="lineNumber">1555</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">/// Optimize a series of operands to an 'add' instruction.  This</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">/// Optimize a series of operands to an 'add' instruction.  This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">/// optimizes based on identities.  If it can be reduced to a single Value, it</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">/// optimizes based on identities.  If it can be reduced to a single Value, it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">/// is returned, otherwise the Ops list is mutated as necessary.</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">/// is returned, otherwise the Ops list is mutated as necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">Value *ReassociatePass::OptimizeAdd(Instruction *I,</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">Value *ReassociatePass::OptimizeAdd(Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">  // Scan the operand lists looking for X and -X pairs.  If we find any, we</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">  // Scan the operand lists looking for X and -X pairs.  If we find any, we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">  // can simplify expressions like X+-X == 0 and X+~X ==-1.  While we're at it,</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">  // can simplify expressions like X+-X == 0 and X+~X ==-1.  While we're at it,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">  // scan for any</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">  // scan for any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">  // duplicates.  We want to canonicalize Y+Y+Y+Z -> 3*Y+Z.</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">  // duplicates.  We want to canonicalize Y+Y+Y+Z -> 3*Y+Z.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline"></td>
    <td class="lineNumber">1565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">    Value *TheOp = Ops[i].Op;</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">    Value *TheOp = Ops[i].Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">    // Check to see if we've seen this operand before.  If so, we factor all</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">    // Check to see if we've seen this operand before.  If so, we factor all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">    // instances of the operand together.  Due to our sorting criteria, we know</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">    // instances of the operand together.  Due to our sorting criteria, we know</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">    // that these need to be next to each other in the vector.</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">    // that these need to be next to each other in the vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">    if (i+1 != Ops.size() && Ops[i+1].Op == TheOp) {</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">    if (i+1 != Ops.size() && Ops[i+1].Op == TheOp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">      // Rescan the list, remove all instances of this operand from the expr.</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">      // Rescan the list, remove all instances of this operand from the expr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">      unsigned NumFound = 0;</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">      unsigned NumFound = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">      do {</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">      do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">        Ops.erase(Ops.begin()+i);</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">        Ops.erase(Ops.begin()+i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">        ++NumFound;</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">        ++NumFound;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">      } while (i != Ops.size() && Ops[i].Op == TheOp);</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">      } while (i != Ops.size() && Ops[i].Op == TheOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline"></td>
    <td class="lineNumber">1578</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "\nFACTORING [" << NumFound << "]: " << *TheOp</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "\nFACTORING [" << NumFound << "]: " << *TheOp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">                        << '\n');</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">                        << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">      ++NumFactor;</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">      ++NumFactor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline"></td>
    <td class="lineNumber">1582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">      // Insert a new multiply.</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">      // Insert a new multiply.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">      Type *Ty = TheOp->getType();</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">      Type *Ty = TheOp->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">      Constant *C = Ty->isIntOrIntVectorTy() ?</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">      Constant *C = Ty->isIntOrIntVectorTy() ?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">        ConstantInt::get(Ty, NumFound) : ConstantFP::get(Ty, NumFound);</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">        ConstantInt::get(Ty, NumFound) : ConstantFP::get(Ty, NumFound);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">      Instruction *Mul = CreateMul(TheOp, C, "factor", I, I);</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">      Instruction *Mul = CreateMul(TheOp, C, "factor", I, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline"></td>
    <td class="lineNumber">1588</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">      // Now that we have inserted a multiply, optimize it. This allows us to</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">      // Now that we have inserted a multiply, optimize it. This allows us to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">      // handle cases that require multiple factoring steps, such as this:</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">      // handle cases that require multiple factoring steps, such as this:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">      // (X*2) + (X*2) + (X*2) -> (X*2)*3 -> X*6</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">      // (X*2) + (X*2) + (X*2) -> (X*2)*3 -> X*6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">      RedoInsts.insert(Mul);</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">      RedoInsts.insert(Mul);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline"></td>
    <td class="lineNumber">1593</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">      // If every add operand was a duplicate, return the multiply.</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">      // If every add operand was a duplicate, return the multiply.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">      if (Ops.empty())</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">      if (Ops.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">        return Mul;</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">        return Mul;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline"></td>
    <td class="lineNumber">1597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">      // Otherwise, we had some input that didn't have the dupe, such as</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">      // Otherwise, we had some input that didn't have the dupe, such as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">      // "A + A + B" -> "A*2 + B".  Add the new multiply to the list of</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">      // "A + A + B" -> "A*2 + B".  Add the new multiply to the list of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">      // things being added by this operation.</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">      // things being added by this operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">      Ops.insert(Ops.begin(), ValueEntry(getRank(Mul), Mul));</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">      Ops.insert(Ops.begin(), ValueEntry(getRank(Mul), Mul));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline"></td>
    <td class="lineNumber">1602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">      --i;</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">      --i;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">      e = Ops.size();</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">      e = Ops.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline"></td>
    <td class="lineNumber">1607</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">    // Check for X and -X or X and ~X in the operand list.</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">    // Check for X and -X or X and ~X in the operand list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">    Value *X;</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">    Value *X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">    if (!match(TheOp, m_Neg(m_Value(X))) && !match(TheOp, m_Not(m_Value(X))) &&</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">    if (!match(TheOp, m_Neg(m_Value(X))) && !match(TheOp, m_Not(m_Value(X))) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">        !match(TheOp, m_FNeg(m_Value(X))))</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">        !match(TheOp, m_FNeg(m_Value(X))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline"></td>
    <td class="lineNumber">1613</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">    unsigned FoundX = FindInOperandList(Ops, i, X);</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">    unsigned FoundX = FindInOperandList(Ops, i, X);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">    if (FoundX == i)</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">    if (FoundX == i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline"></td>
    <td class="lineNumber">1617</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">    // Remove X and -X from the operand list.</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">    // Remove X and -X from the operand list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">    if (Ops.size() == 2 &&</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">    if (Ops.size() == 2 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">        (match(TheOp, m_Neg(m_Value())) || match(TheOp, m_FNeg(m_Value()))))</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">        (match(TheOp, m_Neg(m_Value())) || match(TheOp, m_FNeg(m_Value()))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">      return Constant::getNullValue(X->getType());</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">      return Constant::getNullValue(X->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline"></td>
    <td class="lineNumber">1622</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">    // Remove X and ~X from the operand list.</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">    // Remove X and ~X from the operand list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">    if (Ops.size() == 2 && match(TheOp, m_Not(m_Value())))</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">    if (Ops.size() == 2 && match(TheOp, m_Not(m_Value())))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">      return Constant::getAllOnesValue(X->getType());</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">      return Constant::getAllOnesValue(X->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline"></td>
    <td class="lineNumber">1626</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">    Ops.erase(Ops.begin()+i);</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">    Ops.erase(Ops.begin()+i);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">    if (i < FoundX)</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">    if (i < FoundX)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">      --FoundX;</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">      --FoundX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">      --i;   // Need to back up an extra one.</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">      --i;   // Need to back up an extra one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">    Ops.erase(Ops.begin()+FoundX);</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">    Ops.erase(Ops.begin()+FoundX);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">    ++NumAnnihil;</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">    ++NumAnnihil;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">    --i;     // Revisit element.</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">    --i;     // Revisit element.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">    e -= 2;  // Removed two elements.</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">    e -= 2;  // Removed two elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline"></td>
    <td class="lineNumber">1636</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">    // if X and ~X we append -1 to the operand list.</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">    // if X and ~X we append -1 to the operand list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">    if (match(TheOp, m_Not(m_Value()))) {</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">    if (match(TheOp, m_Not(m_Value()))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">      Value *V = Constant::getAllOnesValue(X->getType());</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">      Value *V = Constant::getAllOnesValue(X->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">      Ops.insert(Ops.end(), ValueEntry(getRank(V), V));</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">      Ops.insert(Ops.end(), ValueEntry(getRank(V), V));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">      e += 1;</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">      e += 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline"></td>
    <td class="lineNumber">1644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">  // Scan the operand list, checking to see if there are any common factors</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">  // Scan the operand list, checking to see if there are any common factors</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">  // between operands.  Consider something like A*A+A*B*C+D.  We would like to</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">  // between operands.  Consider something like A*A+A*B*C+D.  We would like to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">  // reassociate this to A*(A+B*C)+D, which reduces the number of multiplies.</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">  // reassociate this to A*(A+B*C)+D, which reduces the number of multiplies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">  // To efficiently find this, we count the number of times a factor occurs</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">  // To efficiently find this, we count the number of times a factor occurs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">  // for any ADD operands that are MULs.</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">  // for any ADD operands that are MULs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">  DenseMap<Value*, unsigned> FactorOccurrences;</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">  DenseMap<Value*, unsigned> FactorOccurrences;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline"></td>
    <td class="lineNumber">1651</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">  // Keep track of each multiply we see, to avoid triggering on (X*4)+(X*4)</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">  // Keep track of each multiply we see, to avoid triggering on (X*4)+(X*4)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">  // where they are actually the same multiply.</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">  // where they are actually the same multiply.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">  unsigned MaxOcc = 0;</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">  unsigned MaxOcc = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">  Value *MaxOccVal = nullptr;</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">  Value *MaxOccVal = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">    BinaryOperator *BOp =</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">    BinaryOperator *BOp =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">        isReassociableOp(Ops[i].Op, Instruction::Mul, Instruction::FMul);</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">        isReassociableOp(Ops[i].Op, Instruction::Mul, Instruction::FMul);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">    if (!BOp)</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">    if (!BOp)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline"></td>
    <td class="lineNumber">1661</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">    // Compute all of the factors of this added value.</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">    // Compute all of the factors of this added value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">    SmallVector<Value*, 8> Factors;</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">    SmallVector<Value*, 8> Factors;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">    FindSingleUseMultiplyFactors(BOp, Factors);</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">    FindSingleUseMultiplyFactors(BOp, Factors);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">    assert(Factors.size() > 1 && "Bad linearize!");</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">    assert(Factors.size() > 1 && "Bad linearize!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline"></td>
    <td class="lineNumber">1666</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">    // Add one to FactorOccurrences for each unique factor in this op.</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">    // Add one to FactorOccurrences for each unique factor in this op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">    SmallPtrSet<Value*, 8> Duplicates;</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">    SmallPtrSet<Value*, 8> Duplicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">    for (Value *Factor : Factors) {</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">    for (Value *Factor : Factors) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">      if (!Duplicates.insert(Factor).second)</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">      if (!Duplicates.insert(Factor).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline"></td>
    <td class="lineNumber">1672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">      unsigned Occ = ++FactorOccurrences[Factor];</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">      unsigned Occ = ++FactorOccurrences[Factor];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">      if (Occ > MaxOcc) {</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">      if (Occ > MaxOcc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">        MaxOcc = Occ;</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">        MaxOcc = Occ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">        MaxOccVal = Factor;</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">        MaxOccVal = Factor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
    <td class="lineNumber">1678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">      // If Factor is a negative constant, add the negated value as a factor</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">      // If Factor is a negative constant, add the negated value as a factor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">      // because we can percolate the negate out.  Watch for minint, which</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">      // because we can percolate the negate out.  Watch for minint, which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">      // cannot be positivified.</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">      // cannot be positivified.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Factor)) {</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Factor)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">        if (CI->isNegative() && !CI->isMinValue(true)) {</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">        if (CI->isNegative() && !CI->isMinValue(true)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">          Factor = ConstantInt::get(CI->getContext(), -CI->getValue());</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">          Factor = ConstantInt::get(CI->getContext(), -CI->getValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">          if (!Duplicates.insert(Factor).second)</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">          if (!Duplicates.insert(Factor).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">          unsigned Occ = ++FactorOccurrences[Factor];</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">          unsigned Occ = ++FactorOccurrences[Factor];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">          if (Occ > MaxOcc) {</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">          if (Occ > MaxOcc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">            MaxOcc = Occ;</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">            MaxOcc = Occ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">            MaxOccVal = Factor;</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">            MaxOccVal = Factor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">      } else if (ConstantFP *CF = dyn_cast<ConstantFP>(Factor)) {</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">      } else if (ConstantFP *CF = dyn_cast<ConstantFP>(Factor)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">        if (CF->isNegative()) {</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">        if (CF->isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">          APFloat F(CF->getValueAPF());</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">          APFloat F(CF->getValueAPF());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline">          F.changeSign();</td>
    <td class="lineNumber">1696</td>
    <td class="codeline">          F.changeSign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">          Factor = ConstantFP::get(CF->getContext(), F);</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">          Factor = ConstantFP::get(CF->getContext(), F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">          if (!Duplicates.insert(Factor).second)</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">          if (!Duplicates.insert(Factor).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">          unsigned Occ = ++FactorOccurrences[Factor];</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">          unsigned Occ = ++FactorOccurrences[Factor];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">          if (Occ > MaxOcc) {</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">          if (Occ > MaxOcc) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">            MaxOcc = Occ;</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">            MaxOcc = Occ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">            MaxOccVal = Factor;</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">            MaxOccVal = Factor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline"></td>
    <td class="lineNumber">1709</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">  // If any factor occurred more than one time, we can pull it out.</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">  // If any factor occurred more than one time, we can pull it out.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">  if (MaxOcc > 1) {</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">  if (MaxOcc > 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "\nFACTORING [" << MaxOcc << "]: " << *MaxOccVal</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "\nFACTORING [" << MaxOcc << "]: " << *MaxOccVal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">                      << '\n');</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">                      << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">    ++NumFactor;</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">    ++NumFactor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline"></td>
    <td class="lineNumber">1715</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">    // Create a new instruction that uses the MaxOccVal twice.  If we don't do</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">    // Create a new instruction that uses the MaxOccVal twice.  If we don't do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">    // this, we could otherwise run into situations where removing a factor</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">    // this, we could otherwise run into situations where removing a factor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">    // from an expression will drop a use of maxocc, and this can cause</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">    // from an expression will drop a use of maxocc, and this can cause</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">    // RemoveFactorFromExpression on successive values to behave differently.</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">    // RemoveFactorFromExpression on successive values to behave differently.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">    Instruction *DummyInst =</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">    Instruction *DummyInst =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">        I->getType()->isIntOrIntVectorTy()</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">        I->getType()->isIntOrIntVectorTy()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">            ? BinaryOperator::CreateAdd(MaxOccVal, MaxOccVal)</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">            ? BinaryOperator::CreateAdd(MaxOccVal, MaxOccVal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">            : BinaryOperator::CreateFAdd(MaxOccVal, MaxOccVal);</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">            : BinaryOperator::CreateFAdd(MaxOccVal, MaxOccVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline"></td>
    <td class="lineNumber">1724</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">    SmallVector<WeakTrackingVH, 4> NewMulOps;</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">    SmallVector<WeakTrackingVH, 4> NewMulOps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">    for (unsigned i = 0; i != Ops.size(); ++i) {</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">    for (unsigned i = 0; i != Ops.size(); ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">      // Only try to remove factors from expressions we're allowed to.</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">      // Only try to remove factors from expressions we're allowed to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">      BinaryOperator *BOp =</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">      BinaryOperator *BOp =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">          isReassociableOp(Ops[i].Op, Instruction::Mul, Instruction::FMul);</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">          isReassociableOp(Ops[i].Op, Instruction::Mul, Instruction::FMul);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">      if (!BOp)</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">      if (!BOp)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline"></td>
    <td class="lineNumber">1732</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">      if (Value *V = RemoveFactorFromExpression(Ops[i].Op, MaxOccVal)) {</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">      if (Value *V = RemoveFactorFromExpression(Ops[i].Op, MaxOccVal)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">        // The factorized operand may occur several times.  Convert them all in</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">        // The factorized operand may occur several times.  Convert them all in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">        // one fell swoop.</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">        // one fell swoop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">        for (unsigned j = Ops.size(); j != i;) {</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">        for (unsigned j = Ops.size(); j != i;) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">          --j;</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">          --j;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">          if (Ops[j].Op == Ops[i].Op) {</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">          if (Ops[j].Op == Ops[i].Op) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">            NewMulOps.push_back(V);</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">            NewMulOps.push_back(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">            Ops.erase(Ops.begin()+j);</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">            Ops.erase(Ops.begin()+j);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">        --i;</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">        --i;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline"></td>
    <td class="lineNumber">1746</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">    // No need for extra uses anymore.</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">    // No need for extra uses anymore.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">    DummyInst->deleteValue();</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">    DummyInst->deleteValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline"></td>
    <td class="lineNumber">1749</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">    unsigned NumAddedValues = NewMulOps.size();</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">    unsigned NumAddedValues = NewMulOps.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">    Value *V = EmitAddTreeOfValues(I, NewMulOps);</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">    Value *V = EmitAddTreeOfValues(I, NewMulOps);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline"></td>
    <td class="lineNumber">1752</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">    // Now that we have inserted the add tree, optimize it. This allows us to</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">    // Now that we have inserted the add tree, optimize it. This allows us to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">    // handle cases that require multiple factoring steps, such as this:</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">    // handle cases that require multiple factoring steps, such as this:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">    // A*A*B + A*A*C   -->   A*(A*B+A*C)   -->   A*(A*(B+C))</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">    // A*A*B + A*A*C   -->   A*(A*B+A*C)   -->   A*(A*(B+C))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">    assert(NumAddedValues > 1 && "Each occurrence should contribute a value");</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">    assert(NumAddedValues > 1 && "Each occurrence should contribute a value");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">    (void)NumAddedValues;</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">    (void)NumAddedValues;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">    if (Instruction *VI = dyn_cast<Instruction>(V))</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">    if (Instruction *VI = dyn_cast<Instruction>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">      RedoInsts.insert(VI);</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">      RedoInsts.insert(VI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline"></td>
    <td class="lineNumber">1760</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">    // Create the multiply.</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">    // Create the multiply.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">    Instruction *V2 = CreateMul(V, MaxOccVal, "reass.mul", I, I);</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">    Instruction *V2 = CreateMul(V, MaxOccVal, "reass.mul", I, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline"></td>
    <td class="lineNumber">1763</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">    // Rerun associate on the multiply in case the inner expression turned into</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">    // Rerun associate on the multiply in case the inner expression turned into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">    // a multiply.  We want to make sure that we keep things in canonical form.</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">    // a multiply.  We want to make sure that we keep things in canonical form.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">    RedoInsts.insert(V2);</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">    RedoInsts.insert(V2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">    // If every add operand included the factor (e.g. "A*B + A*C"), then the</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">    // If every add operand included the factor (e.g. "A*B + A*C"), then the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">    // entire result expression is just the multiply "A*(B+C)".</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">    // entire result expression is just the multiply "A*(B+C)".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">    if (Ops.empty())</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">    if (Ops.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">      return V2;</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">      return V2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline"></td>
    <td class="lineNumber">1772</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">    // Otherwise, we had some input that didn't have the factor, such as</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">    // Otherwise, we had some input that didn't have the factor, such as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">    // "A*B + A*C + D" -> "A*(B+C) + D".  Add the new multiply to the list of</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">    // "A*B + A*C + D" -> "A*(B+C) + D".  Add the new multiply to the list of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">    // things being added by this operation.</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">    // things being added by this operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">    Ops.insert(Ops.begin(), ValueEntry(getRank(V2), V2));</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">    Ops.insert(Ops.begin(), ValueEntry(getRank(V2), V2));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline"></td>
    <td class="lineNumber">1778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline"></td>
    <td class="lineNumber">1781</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">/// Build up a vector of value/power pairs factoring a product.</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">/// Build up a vector of value/power pairs factoring a product.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">/// Given a series of multiplication operands, build a vector of factors and</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">/// Given a series of multiplication operands, build a vector of factors and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">/// the powers each is raised to when forming the final product. Sort them in</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">/// the powers each is raised to when forming the final product. Sort them in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">/// the order of descending power.</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">/// the order of descending power.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">///      (x*x)          -> [(x, 2)]</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">///      (x*x)          -> [(x, 2)]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">///     ((x*x)*x)       -> [(x, 3)]</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">///     ((x*x)*x)       -> [(x, 3)]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">///   ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">///   ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">/// \returns Whether any factors have a power greater than one.</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">/// \returns Whether any factors have a power greater than one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">static bool collectMultiplyFactors(SmallVectorImpl<ValueEntry> &Ops,</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">static bool collectMultiplyFactors(SmallVectorImpl<ValueEntry> &Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">                                   SmallVectorImpl<Factor> &Factors) {</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">                                   SmallVectorImpl<Factor> &Factors) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">  // FIXME: Have Ops be (ValueEntry, Multiplicity) pairs, simplifying this.</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">  // FIXME: Have Ops be (ValueEntry, Multiplicity) pairs, simplifying this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">  // Compute the sum of powers of simplifiable factors.</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">  // Compute the sum of powers of simplifiable factors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">  unsigned FactorPowerSum = 0;</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">  unsigned FactorPowerSum = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">  for (unsigned Idx = 1, Size = Ops.size(); Idx < Size; ++Idx) {</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">  for (unsigned Idx = 1, Size = Ops.size(); Idx < Size; ++Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">    Value *Op = Ops[Idx-1].Op;</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">    Value *Op = Ops[Idx-1].Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline"></td>
    <td class="lineNumber">1800</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">    // Count the number of occurrences of this value.</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">    // Count the number of occurrences of this value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">    unsigned Count = 1;</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">    unsigned Count = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">    for (; Idx < Size && Ops[Idx].Op == Op; ++Idx)</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">    for (; Idx < Size && Ops[Idx].Op == Op; ++Idx)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">      ++Count;</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">      ++Count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">    // Track for simplification all factors which occur 2 or more times.</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">    // Track for simplification all factors which occur 2 or more times.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">    if (Count > 1)</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">    if (Count > 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">      FactorPowerSum += Count;</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">      FactorPowerSum += Count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline"></td>
    <td class="lineNumber">1809</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">  // We can only simplify factors if the sum of the powers of our simplifiable</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">  // We can only simplify factors if the sum of the powers of our simplifiable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">  // factors is 4 or higher. When that is the case, we will *always* have</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">  // factors is 4 or higher. When that is the case, we will *always* have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">  // a simplification. This is an important invariant to prevent cyclicly</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">  // a simplification. This is an important invariant to prevent cyclicly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">  // trying to simplify already minimal formations.</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">  // trying to simplify already minimal formations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">  if (FactorPowerSum < 4)</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">  if (FactorPowerSum < 4)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline"></td>
    <td class="lineNumber">1816</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">  // Now gather the simplifiable factors, removing them from Ops.</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">  // Now gather the simplifiable factors, removing them from Ops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">  FactorPowerSum = 0;</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">  FactorPowerSum = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">  for (unsigned Idx = 1; Idx < Ops.size(); ++Idx) {</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">  for (unsigned Idx = 1; Idx < Ops.size(); ++Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">    Value *Op = Ops[Idx-1].Op;</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">    Value *Op = Ops[Idx-1].Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline"></td>
    <td class="lineNumber">1821</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">    // Count the number of occurrences of this value.</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">    // Count the number of occurrences of this value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">    unsigned Count = 1;</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">    unsigned Count = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">    for (; Idx < Ops.size() && Ops[Idx].Op == Op; ++Idx)</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">    for (; Idx < Ops.size() && Ops[Idx].Op == Op; ++Idx)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">      ++Count;</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">      ++Count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">    if (Count == 1)</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">    if (Count == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">    // Move an even number of occurrences to Factors.</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">    // Move an even number of occurrences to Factors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">    Count &= ~1U;</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">    Count &= ~1U;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">    Idx -= Count;</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">    Idx -= Count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">    FactorPowerSum += Count;</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">    FactorPowerSum += Count;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">    Factors.push_back(Factor(Op, Count));</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">    Factors.push_back(Factor(Op, Count));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">    Ops.erase(Ops.begin()+Idx, Ops.begin()+Idx+Count);</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">    Ops.erase(Ops.begin()+Idx, Ops.begin()+Idx+Count);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline"></td>
    <td class="lineNumber">1835</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">  // None of the adjustments above should have reduced the sum of factor powers</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">  // None of the adjustments above should have reduced the sum of factor powers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">  // below our mininum of '4'.</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">  // below our mininum of '4'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">  assert(FactorPowerSum >= 4);</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">  assert(FactorPowerSum >= 4);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline"></td>
    <td class="lineNumber">1839</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">  llvm::stable_sort(Factors, [](const Factor &LHS, const Factor &RHS) {</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">  llvm::stable_sort(Factors, [](const Factor &LHS, const Factor &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">    return LHS.Power > RHS.Power;</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">    return LHS.Power > RHS.Power;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline"></td>
    <td class="lineNumber">1845</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">/// Build a tree of multiplies, computing the product of Ops.</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">/// Build a tree of multiplies, computing the product of Ops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">static Value *buildMultiplyTree(IRBuilderBase &Builder,</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">static Value *buildMultiplyTree(IRBuilderBase &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">                                SmallVectorImpl<Value*> &Ops) {</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">                                SmallVectorImpl<Value*> &Ops) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">  if (Ops.size() == 1)</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">  if (Ops.size() == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">    return Ops.back();</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">    return Ops.back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline"></td>
    <td class="lineNumber">1851</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">  Value *LHS = Ops.pop_back_val();</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">  Value *LHS = Ops.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">  do {</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">  do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">    if (LHS->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">    if (LHS->getType()->isIntOrIntVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">      LHS = Builder.CreateMul(LHS, Ops.pop_back_val());</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">      LHS = Builder.CreateMul(LHS, Ops.pop_back_val());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">      LHS = Builder.CreateFMul(LHS, Ops.pop_back_val());</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">      LHS = Builder.CreateFMul(LHS, Ops.pop_back_val());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">  } while (!Ops.empty());</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">  } while (!Ops.empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline"></td>
    <td class="lineNumber">1859</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">  return LHS;</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">  return LHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline"></td>
    <td class="lineNumber">1862</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">/// Build a minimal multiplication DAG for (a^x)*(b^y)*(c^z)*...</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">/// Build a minimal multiplication DAG for (a^x)*(b^y)*(c^z)*...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">/// Given a vector of values raised to various powers, where no two values are</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">/// Given a vector of values raised to various powers, where no two values are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">/// equal and the powers are sorted in decreasing order, compute the minimal</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">/// equal and the powers are sorted in decreasing order, compute the minimal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">/// DAG of multiplies to compute the final product, and return that product</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">/// DAG of multiplies to compute the final product, and return that product</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">/// value.</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">/// value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">Value *</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">Value *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">ReassociatePass::buildMinimalMultiplyDAG(IRBuilderBase &Builder,</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">ReassociatePass::buildMinimalMultiplyDAG(IRBuilderBase &Builder,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">                                         SmallVectorImpl<Factor> &Factors) {</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">                                         SmallVectorImpl<Factor> &Factors) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">  assert(Factors[0].Power);</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">  assert(Factors[0].Power);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">  SmallVector<Value *, 4> OuterProduct;</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">  SmallVector<Value *, 4> OuterProduct;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">  for (unsigned LastIdx = 0, Idx = 1, Size = Factors.size();</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">  for (unsigned LastIdx = 0, Idx = 1, Size = Factors.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">       Idx < Size && Factors[Idx].Power > 0; ++Idx) {</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">       Idx < Size && Factors[Idx].Power > 0; ++Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">    if (Factors[Idx].Power != Factors[LastIdx].Power) {</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">    if (Factors[Idx].Power != Factors[LastIdx].Power) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">      LastIdx = Idx;</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">      LastIdx = Idx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline"></td>
    <td class="lineNumber">1880</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">    // We want to multiply across all the factors with the same power so that</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">    // We want to multiply across all the factors with the same power so that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">    // we can raise them to that power as a single entity. Build a mini tree</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">    // we can raise them to that power as a single entity. Build a mini tree</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">    // for that.</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">    // for that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">    SmallVector<Value *, 4> InnerProduct;</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">    SmallVector<Value *, 4> InnerProduct;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">    InnerProduct.push_back(Factors[LastIdx].Base);</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">    InnerProduct.push_back(Factors[LastIdx].Base);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">    do {</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">    do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">      InnerProduct.push_back(Factors[Idx].Base);</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">      InnerProduct.push_back(Factors[Idx].Base);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">      ++Idx;</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">      ++Idx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">    } while (Idx < Size && Factors[Idx].Power == Factors[LastIdx].Power);</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">    } while (Idx < Size && Factors[Idx].Power == Factors[LastIdx].Power);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline"></td>
    <td class="lineNumber">1890</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">    // Reset the base value of the first factor to the new expression tree.</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">    // Reset the base value of the first factor to the new expression tree.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">    // We'll remove all the factors with the same power in a second pass.</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">    // We'll remove all the factors with the same power in a second pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">    Value *M = Factors[LastIdx].Base = buildMultiplyTree(Builder, InnerProduct);</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">    Value *M = Factors[LastIdx].Base = buildMultiplyTree(Builder, InnerProduct);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">    if (Instruction *MI = dyn_cast<Instruction>(M))</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">    if (Instruction *MI = dyn_cast<Instruction>(M))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">      RedoInsts.insert(MI);</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">      RedoInsts.insert(MI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline"></td>
    <td class="lineNumber">1896</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">    LastIdx = Idx;</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">    LastIdx = Idx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">  // Unique factors with equal powers -- we've folded them into the first one's</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">  // Unique factors with equal powers -- we've folded them into the first one's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">  // base.</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">  // base.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">  Factors.erase(std::unique(Factors.begin(), Factors.end(),</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">  Factors.erase(std::unique(Factors.begin(), Factors.end(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">                            [](const Factor &LHS, const Factor &RHS) {</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">                            [](const Factor &LHS, const Factor &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">                              return LHS.Power == RHS.Power;</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">                              return LHS.Power == RHS.Power;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">                            }),</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">                            }),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">                Factors.end());</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">                Factors.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline"></td>
    <td class="lineNumber">1906</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">  // Iteratively collect the base of each factor with an add power into the</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">  // Iteratively collect the base of each factor with an add power into the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">  // outer product, and halve each power in preparation for squaring the</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">  // outer product, and halve each power in preparation for squaring the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">  // expression.</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">  // expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">  for (Factor &F : Factors) {</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">  for (Factor &F : Factors) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">    if (F.Power & 1)</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">    if (F.Power & 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">      OuterProduct.push_back(F.Base);</td>
    <td class="lineNumber">1912</td>
    <td class="codeline">      OuterProduct.push_back(F.Base);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">    F.Power >>= 1;</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">    F.Power >>= 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">  if (Factors[0].Power) {</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">  if (Factors[0].Power) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">    Value *SquareRoot = buildMinimalMultiplyDAG(Builder, Factors);</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">    Value *SquareRoot = buildMinimalMultiplyDAG(Builder, Factors);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">    OuterProduct.push_back(SquareRoot);</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">    OuterProduct.push_back(SquareRoot);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">    OuterProduct.push_back(SquareRoot);</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">    OuterProduct.push_back(SquareRoot);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">  if (OuterProduct.size() == 1)</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">  if (OuterProduct.size() == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">    return OuterProduct.front();</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">    return OuterProduct.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline"></td>
    <td class="lineNumber">1922</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">  Value *V = buildMultiplyTree(Builder, OuterProduct);</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">  Value *V = buildMultiplyTree(Builder, OuterProduct);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline"></td>
    <td class="lineNumber">1926</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">Value *ReassociatePass::OptimizeMul(BinaryOperator *I,</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">Value *ReassociatePass::OptimizeMul(BinaryOperator *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">  // We can only optimize the multiplies when there is a chain of more than</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">  // We can only optimize the multiplies when there is a chain of more than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">  // three, such that a balanced tree might require fewer total multiplies.</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">  // three, such that a balanced tree might require fewer total multiplies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">  if (Ops.size() < 4)</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">  if (Ops.size() < 4)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1932</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline"></td>
    <td class="lineNumber">1933</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">  // Try to turn linear trees of multiplies without other uses of the</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">  // Try to turn linear trees of multiplies without other uses of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">  // intermediate stages into minimal multiply DAGs with perfect sub-expression</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">  // intermediate stages into minimal multiply DAGs with perfect sub-expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">  // re-use.</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">  // re-use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">  SmallVector<Factor, 4> Factors;</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">  SmallVector<Factor, 4> Factors;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">  if (!collectMultiplyFactors(Ops, Factors))</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">  if (!collectMultiplyFactors(Ops, Factors))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">    return nullptr; // All distinct factors, so nothing left for us to do.</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">    return nullptr; // All distinct factors, so nothing left for us to do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline"></td>
    <td class="lineNumber">1940</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">  IRBuilder<> Builder(I);</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">  IRBuilder<> Builder(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">  // The reassociate transformation for FP operations is performed only</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">  // The reassociate transformation for FP operations is performed only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">  // if unsafe algebra is permitted by FastMathFlags. Propagate those flags</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">  // if unsafe algebra is permitted by FastMathFlags. Propagate those flags</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">  // to the newly generated operations.</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">  // to the newly generated operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">  if (auto FPI = dyn_cast<FPMathOperator>(I))</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">  if (auto FPI = dyn_cast<FPMathOperator>(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">    Builder.setFastMathFlags(FPI->getFastMathFlags());</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">    Builder.setFastMathFlags(FPI->getFastMathFlags());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline"></td>
    <td class="lineNumber">1947</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">  Value *V = buildMinimalMultiplyDAG(Builder, Factors);</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">  Value *V = buildMinimalMultiplyDAG(Builder, Factors);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">  if (Ops.empty())</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">  if (Ops.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline"></td>
    <td class="lineNumber">1951</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">  ValueEntry NewEntry = ValueEntry(getRank(V), V);</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">  ValueEntry NewEntry = ValueEntry(getRank(V), V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">  Ops.insert(llvm::lower_bound(Ops, NewEntry), NewEntry);</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">  Ops.insert(llvm::lower_bound(Ops, NewEntry), NewEntry);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline"></td>
    <td class="lineNumber">1956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">Value *ReassociatePass::OptimizeExpression(BinaryOperator *I,</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">Value *ReassociatePass::OptimizeExpression(BinaryOperator *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">                                           SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">                                           SmallVectorImpl<ValueEntry> &Ops) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">  // Now that we have the linearized expression tree, try to optimize it.</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">  // Now that we have the linearized expression tree, try to optimize it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">  // Start by folding any constants that we found.</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">  // Start by folding any constants that we found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">  const DataLayout &DL = I->getModule()->getDataLayout();</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">  const DataLayout &DL = I->getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">  Constant *Cst = nullptr;</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">  Constant *Cst = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">  unsigned Opcode = I->getOpcode();</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">  unsigned Opcode = I->getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">  while (!Ops.empty()) {</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">  while (!Ops.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">    if (auto *C = dyn_cast<Constant>(Ops.back().Op)) {</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">    if (auto *C = dyn_cast<Constant>(Ops.back().Op)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">      if (!Cst) {</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">      if (!Cst) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">        Ops.pop_back();</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">        Ops.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">        Cst = C;</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">        Cst = C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">      if (Constant *Res = ConstantFoldBinaryOpOperands(Opcode, C, Cst, DL)) {</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">      if (Constant *Res = ConstantFoldBinaryOpOperands(Opcode, C, Cst, DL)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">        Ops.pop_back();</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">        Ops.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">        Cst = Res;</td>
    <td class="lineNumber">1973</td>
    <td class="codeline">        Cst = Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">  // If there was nothing but constants then we are done.</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">  // If there was nothing but constants then we are done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">  if (Ops.empty())</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">  if (Ops.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">    return Cst;</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">    return Cst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline"></td>
    <td class="lineNumber">1982</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">  // Put the combined constant back at the end of the operand list, except if</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">  // Put the combined constant back at the end of the operand list, except if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">  // there is no point.  For example, an add of 0 gets dropped here, while a</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">  // there is no point.  For example, an add of 0 gets dropped here, while a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">  // multiplication by zero turns the whole expression into zero.</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">  // multiplication by zero turns the whole expression into zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">  if (Cst && Cst != ConstantExpr::getBinOpIdentity(Opcode, I->getType())) {</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">  if (Cst && Cst != ConstantExpr::getBinOpIdentity(Opcode, I->getType())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">    if (Cst == ConstantExpr::getBinOpAbsorber(Opcode, I->getType()))</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">    if (Cst == ConstantExpr::getBinOpAbsorber(Opcode, I->getType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">      return Cst;</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">      return Cst;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">    Ops.push_back(ValueEntry(0, Cst));</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">    Ops.push_back(ValueEntry(0, Cst));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline"></td>
    <td class="lineNumber">1991</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">  if (Ops.size() == 1) return Ops[0].Op;</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">  if (Ops.size() == 1) return Ops[0].Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline"></td>
    <td class="lineNumber">1993</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">  // Handle destructive annihilation due to identities between elements in the</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">  // Handle destructive annihilation due to identities between elements in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">  // argument list here.</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">  // argument list here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">  unsigned NumOps = Ops.size();</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">  unsigned NumOps = Ops.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">  switch (Opcode) {</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">  switch (Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">  default: break;</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">  default: break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">  case Instruction::And:</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">  case Instruction::And:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">  case Instruction::Or:</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">  case Instruction::Or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">    if (Value *Result = OptimizeAndOrXor(Opcode, Ops))</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">    if (Value *Result = OptimizeAndOrXor(Opcode, Ops))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">      return Result;</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">      return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline"></td>
    <td class="lineNumber">2004</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">  case Instruction::Xor:</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">  case Instruction::Xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">    if (Value *Result = OptimizeXor(I, Ops))</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">    if (Value *Result = OptimizeXor(I, Ops))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">      return Result;</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">      return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline"></td>
    <td class="lineNumber">2009</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">  case Instruction::Add:</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">  case Instruction::Add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">  case Instruction::FAdd:</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">  case Instruction::FAdd:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">    if (Value *Result = OptimizeAdd(I, Ops))</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">    if (Value *Result = OptimizeAdd(I, Ops))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">      return Result;</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">      return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline"></td>
    <td class="lineNumber">2015</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">  case Instruction::Mul:</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">  case Instruction::Mul:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">  case Instruction::FMul:</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">  case Instruction::FMul:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">    if (Value *Result = OptimizeMul(I, Ops))</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">    if (Value *Result = OptimizeMul(I, Ops))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">      return Result;</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">      return Result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">    break;</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">    break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline"></td>
    <td class="lineNumber">2022</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">  if (Ops.size() != NumOps)</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">  if (Ops.size() != NumOps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">    return OptimizeExpression(I, Ops);</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">    return OptimizeExpression(I, Ops);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline"></td>
    <td class="lineNumber">2027</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">// Remove dead instructions and if any operands are trivially dead add them to</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">// Remove dead instructions and if any operands are trivially dead add them to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">// Insts so they will be removed as well.</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">// Insts so they will be removed as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">void ReassociatePass::RecursivelyEraseDeadInsts(Instruction *I,</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">void ReassociatePass::RecursivelyEraseDeadInsts(Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">                                                OrderedSet &Insts) {</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">                                                OrderedSet &Insts) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">  assert(isInstructionTriviallyDead(I) && "Trivially dead instructions only!");</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">  assert(isInstructionTriviallyDead(I) && "Trivially dead instructions only!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">  SmallVector<Value *, 4> Ops(I->operands());</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">  SmallVector<Value *, 4> Ops(I->operands());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">  ValueRankMap.erase(I);</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">  ValueRankMap.erase(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">  Insts.remove(I);</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">  Insts.remove(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">  RedoInsts.remove(I);</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">  RedoInsts.remove(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">  llvm::salvageDebugInfo(*I);</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">  llvm::salvageDebugInfo(*I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">  I->eraseFromParent();</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">  I->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">  for (auto *Op : Ops)</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">  for (auto *Op : Ops)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">    if (Instruction *OpInst = dyn_cast<Instruction>(Op))</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">    if (Instruction *OpInst = dyn_cast<Instruction>(Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">      if (OpInst->use_empty())</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">      if (OpInst->use_empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">        Insts.insert(OpInst);</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">        Insts.insert(OpInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline"></td>
    <td class="lineNumber">2044</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">/// Zap the given instruction, adding interesting operands to the work list.</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">/// Zap the given instruction, adding interesting operands to the work list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">void ReassociatePass::EraseInst(Instruction *I) {</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">void ReassociatePass::EraseInst(Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">  assert(isInstructionTriviallyDead(I) && "Trivially dead instructions only!");</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">  assert(isInstructionTriviallyDead(I) && "Trivially dead instructions only!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Erasing dead inst: "; I->dump());</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Erasing dead inst: "; I->dump());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline"></td>
    <td class="lineNumber">2049</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">  SmallVector<Value *, 8> Ops(I->operands());</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">  SmallVector<Value *, 8> Ops(I->operands());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">  // Erase the dead instruction.</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">  // Erase the dead instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">  ValueRankMap.erase(I);</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">  ValueRankMap.erase(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">  RedoInsts.remove(I);</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">  RedoInsts.remove(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">  llvm::salvageDebugInfo(*I);</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">  llvm::salvageDebugInfo(*I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">  I->eraseFromParent();</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">  I->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">  // Optimize its operands.</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">  // Optimize its operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">  SmallPtrSet<Instruction *, 8> Visited; // Detect self-referential nodes.</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">  SmallPtrSet<Instruction *, 8> Visited; // Detect self-referential nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i)</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">  for (unsigned i = 0, e = Ops.size(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline">    if (Instruction *Op = dyn_cast<Instruction>(Ops[i])) {</td>
    <td class="lineNumber">2059</td>
    <td class="codeline">    if (Instruction *Op = dyn_cast<Instruction>(Ops[i])) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">      // If this is a node in an expression tree, climb to the expression root</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">      // If this is a node in an expression tree, climb to the expression root</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">      // and add that since that's where optimization actually happens.</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">      // and add that since that's where optimization actually happens.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">      unsigned Opcode = Op->getOpcode();</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">      unsigned Opcode = Op->getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">      while (Op->hasOneUse() && Op->user_back()->getOpcode() == Opcode &&</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">      while (Op->hasOneUse() && Op->user_back()->getOpcode() == Opcode &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">             Visited.insert(Op).second)</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">             Visited.insert(Op).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">        Op = Op->user_back();</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">        Op = Op->user_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline"></td>
    <td class="lineNumber">2066</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">      // The instruction we're going to push may be coming from a</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">      // The instruction we're going to push may be coming from a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">      // dead block, and Reassociate skips the processing of unreachable</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">      // dead block, and Reassociate skips the processing of unreachable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">      // blocks because it's a waste of time and also because it can</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">      // blocks because it's a waste of time and also because it can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">      // lead to infinite loop due to LLVM's non-standard definition</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">      // lead to infinite loop due to LLVM's non-standard definition</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">      // of dominance.</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">      // of dominance.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">      if (ValueRankMap.contains(Op))</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">      if (ValueRankMap.contains(Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">        RedoInsts.insert(Op);</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">        RedoInsts.insert(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline"></td>
    <td class="lineNumber">2075</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">  MadeChange = true;</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">  MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline"></td>
    <td class="lineNumber">2078</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">/// Recursively analyze an expression to build a list of instructions that have</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">/// Recursively analyze an expression to build a list of instructions that have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">/// negative floating-point constant operands. The caller can then transform</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">/// negative floating-point constant operands. The caller can then transform</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">/// the list to create positive constants for better reassociation and CSE.</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">/// the list to create positive constants for better reassociation and CSE.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">static void getNegatibleInsts(Value *V,</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">static void getNegatibleInsts(Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">                              SmallVectorImpl<Instruction *> &Candidates) {</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">                              SmallVectorImpl<Instruction *> &Candidates) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">  // Handle only one-use instructions. Combining negations does not justify</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">  // Handle only one-use instructions. Combining negations does not justify</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">  // replicating instructions.</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">  // replicating instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">  Instruction *I;</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">  Instruction *I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">  if (!match(V, m_OneUse(m_Instruction(I))))</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">  if (!match(V, m_OneUse(m_Instruction(I))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline"></td>
    <td class="lineNumber">2089</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">  // Handle expressions of multiplications and divisions.</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">  // Handle expressions of multiplications and divisions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">  // TODO: This could look through floating-point casts.</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">  // TODO: This could look through floating-point casts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">  const APFloat *C;</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">  const APFloat *C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">  switch (I->getOpcode()) {</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">  switch (I->getOpcode()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">    case Instruction::FMul:</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">    case Instruction::FMul:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">      // Not expecting non-canonical code here. Bail out and wait.</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">      // Not expecting non-canonical code here. Bail out and wait.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">      if (match(I->getOperand(0), m_Constant()))</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">      if (match(I->getOperand(0), m_Constant()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline"></td>
    <td class="lineNumber">2098</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">      if (match(I->getOperand(1), m_APFloat(C)) && C->isNegative()) {</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">      if (match(I->getOperand(1), m_APFloat(C)) && C->isNegative()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">        Candidates.push_back(I);</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">        Candidates.push_back(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "FMul with negative constant: " << *I << '\n');</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "FMul with negative constant: " << *I << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">      getNegatibleInsts(I->getOperand(0), Candidates);</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">      getNegatibleInsts(I->getOperand(0), Candidates);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">      getNegatibleInsts(I->getOperand(1), Candidates);</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">      getNegatibleInsts(I->getOperand(1), Candidates);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">    case Instruction::FDiv:</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">    case Instruction::FDiv:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">      // Not expecting non-canonical code here. Bail out and wait.</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">      // Not expecting non-canonical code here. Bail out and wait.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">      if (match(I->getOperand(0), m_Constant()) &&</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">      if (match(I->getOperand(0), m_Constant()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">          match(I->getOperand(1), m_Constant()))</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">          match(I->getOperand(1), m_Constant()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline"></td>
    <td class="lineNumber">2111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">      if ((match(I->getOperand(0), m_APFloat(C)) && C->isNegative()) ||</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">      if ((match(I->getOperand(0), m_APFloat(C)) && C->isNegative()) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">          (match(I->getOperand(1), m_APFloat(C)) && C->isNegative())) {</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">          (match(I->getOperand(1), m_APFloat(C)) && C->isNegative())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">        Candidates.push_back(I);</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">        Candidates.push_back(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "FDiv with negative constant: " << *I << '\n');</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "FDiv with negative constant: " << *I << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">      getNegatibleInsts(I->getOperand(0), Candidates);</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">      getNegatibleInsts(I->getOperand(0), Candidates);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">      getNegatibleInsts(I->getOperand(1), Candidates);</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">      getNegatibleInsts(I->getOperand(1), Candidates);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline"></td>
    <td class="lineNumber">2124</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">/// Given an fadd/fsub with an operand that is a one-use instruction</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">/// Given an fadd/fsub with an operand that is a one-use instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">/// (the fadd/fsub), try to change negative floating-point constants into</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">/// (the fadd/fsub), try to change negative floating-point constants into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">/// positive constants to increase potential for reassociation and CSE.</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">/// positive constants to increase potential for reassociation and CSE.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">Instruction *ReassociatePass::canonicalizeNegFPConstantsForOp(Instruction *I,</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">Instruction *ReassociatePass::canonicalizeNegFPConstantsForOp(Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">                                                              Instruction *Op,</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">                                                              Instruction *Op,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">                                                              Value *OtherOp) {</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">                                                              Value *OtherOp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">  assert((I->getOpcode() == Instruction::FAdd ||</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">  assert((I->getOpcode() == Instruction::FAdd ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">          I->getOpcode() == Instruction::FSub) && "Expected fadd/fsub");</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">          I->getOpcode() == Instruction::FSub) && "Expected fadd/fsub");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline"></td>
    <td class="lineNumber">2133</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">  // Collect instructions with negative FP constants from the subtree that ends</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">  // Collect instructions with negative FP constants from the subtree that ends</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">  // in Op.</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">  // in Op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">  SmallVector<Instruction *, 4> Candidates;</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">  SmallVector<Instruction *, 4> Candidates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">  getNegatibleInsts(Op, Candidates);</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">  getNegatibleInsts(Op, Candidates);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">  if (Candidates.empty())</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">  if (Candidates.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline"></td>
    <td class="lineNumber">2140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">  // Don't canonicalize x + (-Constant * y) -> x - (Constant * y), if the</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">  // Don't canonicalize x + (-Constant * y) -> x - (Constant * y), if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">  // resulting subtract will be broken up later.  This can get us into an</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">  // resulting subtract will be broken up later.  This can get us into an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">  // infinite loop during reassociation.</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">  // infinite loop during reassociation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">  bool IsFSub = I->getOpcode() == Instruction::FSub;</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">  bool IsFSub = I->getOpcode() == Instruction::FSub;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">  bool NeedsSubtract = !IsFSub && Candidates.size() % 2 == 1;</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">  bool NeedsSubtract = !IsFSub && Candidates.size() % 2 == 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">  if (NeedsSubtract && ShouldBreakUpSubtract(I))</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">  if (NeedsSubtract && ShouldBreakUpSubtract(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline"></td>
    <td class="lineNumber">2148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">  for (Instruction *Negatible : Candidates) {</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">  for (Instruction *Negatible : Candidates) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">    const APFloat *C;</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">    const APFloat *C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">    if (match(Negatible->getOperand(0), m_APFloat(C))) {</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">    if (match(Negatible->getOperand(0), m_APFloat(C))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">      assert(!match(Negatible->getOperand(1), m_Constant()) &&</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">      assert(!match(Negatible->getOperand(1), m_Constant()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">             "Expecting only 1 constant operand");</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">             "Expecting only 1 constant operand");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">      assert(C->isNegative() && "Expected negative FP constant");</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">      assert(C->isNegative() && "Expected negative FP constant");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">      Negatible->setOperand(0, ConstantFP::get(Negatible->getType(), abs(*C)));</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">      Negatible->setOperand(0, ConstantFP::get(Negatible->getType(), abs(*C)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">      MadeChange = true;</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">      MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">    if (match(Negatible->getOperand(1), m_APFloat(C))) {</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">    if (match(Negatible->getOperand(1), m_APFloat(C))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">      assert(!match(Negatible->getOperand(0), m_Constant()) &&</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">      assert(!match(Negatible->getOperand(0), m_Constant()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">             "Expecting only 1 constant operand");</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">             "Expecting only 1 constant operand");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">      assert(C->isNegative() && "Expected negative FP constant");</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">      assert(C->isNegative() && "Expected negative FP constant");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">      Negatible->setOperand(1, ConstantFP::get(Negatible->getType(), abs(*C)));</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">      Negatible->setOperand(1, ConstantFP::get(Negatible->getType(), abs(*C)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">      MadeChange = true;</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">      MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">  assert(MadeChange == true && "Negative constant candidate was not changed");</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">  assert(MadeChange == true && "Negative constant candidate was not changed");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline"></td>
    <td class="lineNumber">2167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">  // Negations cancelled out.</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">  // Negations cancelled out.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">  if (Candidates.size() % 2 == 0)</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">  if (Candidates.size() % 2 == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">    return I;</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">    return I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline"></td>
    <td class="lineNumber">2171</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">  // Negate the final operand in the expression by flipping the opcode of this</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">  // Negate the final operand in the expression by flipping the opcode of this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">  // fadd/fsub.</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">  // fadd/fsub.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">  assert(Candidates.size() % 2 == 1 && "Expected odd number");</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">  assert(Candidates.size() % 2 == 1 && "Expected odd number");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">  IRBuilder<> Builder(I);</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">  IRBuilder<> Builder(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">  Value *NewInst = IsFSub ? Builder.CreateFAddFMF(OtherOp, Op, I)</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">  Value *NewInst = IsFSub ? Builder.CreateFAddFMF(OtherOp, Op, I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">                          : Builder.CreateFSubFMF(OtherOp, Op, I);</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">                          : Builder.CreateFSubFMF(OtherOp, Op, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">  I->replaceAllUsesWith(NewInst);</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">  I->replaceAllUsesWith(NewInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">  RedoInsts.insert(I);</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">  RedoInsts.insert(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">  return dyn_cast<Instruction>(NewInst);</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">  return dyn_cast<Instruction>(NewInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline"></td>
    <td class="lineNumber">2182</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">/// Canonicalize expressions that contain a negative floating-point constant</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">/// Canonicalize expressions that contain a negative floating-point constant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">/// of the following form:</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">/// of the following form:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">///   OtherOp + (subtree) -> OtherOp {+/-} (canonical subtree)</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">///   OtherOp + (subtree) -> OtherOp {+/-} (canonical subtree)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">///   (subtree) + OtherOp -> OtherOp {+/-} (canonical subtree)</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">///   (subtree) + OtherOp -> OtherOp {+/-} (canonical subtree)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">///   OtherOp - (subtree) -> OtherOp {+/-} (canonical subtree)</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">///   OtherOp - (subtree) -> OtherOp {+/-} (canonical subtree)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">/// The fadd/fsub opcode may be switched to allow folding a negation into the</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">/// The fadd/fsub opcode may be switched to allow folding a negation into the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">/// input instruction.</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">/// input instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">Instruction *ReassociatePass::canonicalizeNegFPConstants(Instruction *I) {</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">Instruction *ReassociatePass::canonicalizeNegFPConstants(Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Combine negations for: " << *I << '\n');</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Combine negations for: " << *I << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">  Value *X;</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">  Value *X;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">  Instruction *Op;</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">  Instruction *Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">  if (match(I, m_FAdd(m_Value(X), m_OneUse(m_Instruction(Op)))))</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">  if (match(I, m_FAdd(m_Value(X), m_OneUse(m_Instruction(Op)))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">      I = R;</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">      I = R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">  if (match(I, m_FAdd(m_OneUse(m_Instruction(Op)), m_Value(X))))</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">  if (match(I, m_FAdd(m_OneUse(m_Instruction(Op)), m_Value(X))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">      I = R;</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">      I = R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">  if (match(I, m_FSub(m_Value(X), m_OneUse(m_Instruction(Op)))))</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">  if (match(I, m_FSub(m_Value(X), m_OneUse(m_Instruction(Op)))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">      I = R;</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">      I = R;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">  return I;</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">  return I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline"></td>
    <td class="lineNumber">2206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">/// Inspect and optimize the given instruction. Note that erasing</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">/// Inspect and optimize the given instruction. Note that erasing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">/// instructions is not allowed.</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">/// instructions is not allowed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">void ReassociatePass::OptimizeInst(Instruction *I) {</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">void ReassociatePass::OptimizeInst(Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">  // Only consider operations that we understand.</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">  // Only consider operations that we understand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">  if (!isa<UnaryOperator>(I) && !isa<BinaryOperator>(I))</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">  if (!isa<UnaryOperator>(I) && !isa<BinaryOperator>(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline"></td>
    <td class="lineNumber">2213</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">  if (I->getOpcode() == Instruction::Shl && isa<ConstantInt>(I->getOperand(1)))</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">  if (I->getOpcode() == Instruction::Shl && isa<ConstantInt>(I->getOperand(1)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">    // If an operand of this shift is a reassociable multiply, or if the shift</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">    // If an operand of this shift is a reassociable multiply, or if the shift</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">    // is used by a reassociable multiply or add, turn into a multiply.</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">    // is used by a reassociable multiply or add, turn into a multiply.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">    if (isReassociableOp(I->getOperand(0), Instruction::Mul) ||</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">    if (isReassociableOp(I->getOperand(0), Instruction::Mul) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">        (I->hasOneUse() &&</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">        (I->hasOneUse() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">         (isReassociableOp(I->user_back(), Instruction::Mul) ||</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">         (isReassociableOp(I->user_back(), Instruction::Mul) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">          isReassociableOp(I->user_back(), Instruction::Add)))) {</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">          isReassociableOp(I->user_back(), Instruction::Add)))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">      Instruction *NI = ConvertShiftToMul(I);</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">      Instruction *NI = ConvertShiftToMul(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">      RedoInsts.insert(I);</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">      RedoInsts.insert(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">      MadeChange = true;</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">      MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">      I = NI;</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">      I = NI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2225</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline"></td>
    <td class="lineNumber">2226</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">  // Commute binary operators, to canonicalize the order of their operands.</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">  // Commute binary operators, to canonicalize the order of their operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">  // This can potentially expose more CSE opportunities, and makes writing other</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">  // This can potentially expose more CSE opportunities, and makes writing other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">  // transformations simpler.</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">  // transformations simpler.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">  if (I->isCommutative())</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">  if (I->isCommutative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">    canonicalizeOperands(I);</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">    canonicalizeOperands(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline"></td>
    <td class="lineNumber">2232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">  // Canonicalize negative constants out of expressions.</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">  // Canonicalize negative constants out of expressions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">  if (Instruction *Res = canonicalizeNegFPConstants(I))</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">  if (Instruction *Res = canonicalizeNegFPConstants(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">    I = Res;</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">    I = Res;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline"></td>
    <td class="lineNumber">2236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">  // Don't optimize floating-point instructions unless they have the</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">  // Don't optimize floating-point instructions unless they have the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline">  // appropriate FastMathFlags for reassociation enabled.</td>
    <td class="lineNumber">2238</td>
    <td class="codeline">  // appropriate FastMathFlags for reassociation enabled.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">  if (isa<FPMathOperator>(I) && !hasFPAssociativeFlags(I))</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">  if (isa<FPMathOperator>(I) && !hasFPAssociativeFlags(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline"></td>
    <td class="lineNumber">2241</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">  // Do not reassociate boolean (i1) expressions.  We want to preserve the</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">  // Do not reassociate boolean (i1) expressions.  We want to preserve the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline">  // original order of evaluation for short-circuited comparisons that</td>
    <td class="lineNumber">2243</td>
    <td class="codeline">  // original order of evaluation for short-circuited comparisons that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">  // SimplifyCFG has folded to AND/OR expressions.  If the expression</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">  // SimplifyCFG has folded to AND/OR expressions.  If the expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">  // is not further optimized, it is likely to be transformed back to a</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">  // is not further optimized, it is likely to be transformed back to a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">  // short-circuited form for code gen, and the source order may have been</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">  // short-circuited form for code gen, and the source order may have been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">  // optimized for the most likely conditions.</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">  // optimized for the most likely conditions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">  if (I->getType()->isIntegerTy(1))</td>
    <td class="lineNumber">2248</td>
    <td class="codeline">  if (I->getType()->isIntegerTy(1))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline"></td>
    <td class="lineNumber">2250</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">  // If this is a bitwise or instruction of operands</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">  // If this is a bitwise or instruction of operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">  // with no common bits set, convert it to X+Y.</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">  // with no common bits set, convert it to X+Y.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">  if (I->getOpcode() == Instruction::Or &&</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">  if (I->getOpcode() == Instruction::Or &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">      shouldConvertOrWithNoCommonBitsToAdd(I) && !isLoadCombineCandidate(I) &&</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">      shouldConvertOrWithNoCommonBitsToAdd(I) && !isLoadCombineCandidate(I) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">      haveNoCommonBitsSet(I->getOperand(0), I->getOperand(1),</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">      haveNoCommonBitsSet(I->getOperand(0), I->getOperand(1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">                          I->getModule()->getDataLayout(), /*AC=*/nullptr, I,</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">                          I->getModule()->getDataLayout(), /*AC=*/nullptr, I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">                          /*DT=*/nullptr)) {</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">                          /*DT=*/nullptr)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">    Instruction *NI = convertOrWithNoCommonBitsToAdd(I);</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">    Instruction *NI = convertOrWithNoCommonBitsToAdd(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">    RedoInsts.insert(I);</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">    RedoInsts.insert(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">    MadeChange = true;</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">    MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">    I = NI;</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">    I = NI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline"></td>
    <td class="lineNumber">2263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">  // If this is a subtract instruction which is not already in negate form,</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">  // If this is a subtract instruction which is not already in negate form,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">  // see if we can convert it to X+-Y.</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">  // see if we can convert it to X+-Y.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">  if (I->getOpcode() == Instruction::Sub) {</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">  if (I->getOpcode() == Instruction::Sub) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">    if (ShouldBreakUpSubtract(I)) {</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">    if (ShouldBreakUpSubtract(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">      Instruction *NI = BreakUpSubtract(I, RedoInsts);</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">      Instruction *NI = BreakUpSubtract(I, RedoInsts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">      RedoInsts.insert(I);</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">      RedoInsts.insert(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">      MadeChange = true;</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">      MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">      I = NI;</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">      I = NI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">    } else if (match(I, m_Neg(m_Value()))) {</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">    } else if (match(I, m_Neg(m_Value()))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">      // Otherwise, this is a negation.  See if the operand is a multiply tree</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">      // Otherwise, this is a negation.  See if the operand is a multiply tree</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">      // and if this is not an inner node of a multiply tree.</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">      // and if this is not an inner node of a multiply tree.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">      if (isReassociableOp(I->getOperand(1), Instruction::Mul) &&</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">      if (isReassociableOp(I->getOperand(1), Instruction::Mul) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">          (!I->hasOneUse() ||</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">          (!I->hasOneUse() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">           !isReassociableOp(I->user_back(), Instruction::Mul))) {</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">           !isReassociableOp(I->user_back(), Instruction::Mul))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">        Instruction *NI = LowerNegateToMultiply(I);</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">        Instruction *NI = LowerNegateToMultiply(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">        // If the negate was simplified, revisit the users to see if we can</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">        // If the negate was simplified, revisit the users to see if we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">        // reassociate further.</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">        // reassociate further.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">        for (User *U : NI->users()) {</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">        for (User *U : NI->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">          if (BinaryOperator *Tmp = dyn_cast<BinaryOperator>(U))</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">          if (BinaryOperator *Tmp = dyn_cast<BinaryOperator>(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">            RedoInsts.insert(Tmp);</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">            RedoInsts.insert(Tmp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">        RedoInsts.insert(I);</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">        RedoInsts.insert(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">        MadeChange = true;</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">        MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">        I = NI;</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">        I = NI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">  } else if (I->getOpcode() == Instruction::FNeg ||</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">  } else if (I->getOpcode() == Instruction::FNeg ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">             I->getOpcode() == Instruction::FSub) {</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">             I->getOpcode() == Instruction::FSub) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">    if (ShouldBreakUpSubtract(I)) {</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">    if (ShouldBreakUpSubtract(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">      Instruction *NI = BreakUpSubtract(I, RedoInsts);</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">      Instruction *NI = BreakUpSubtract(I, RedoInsts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">      RedoInsts.insert(I);</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">      RedoInsts.insert(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">      MadeChange = true;</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">      MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">      I = NI;</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">      I = NI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">    } else if (match(I, m_FNeg(m_Value()))) {</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">    } else if (match(I, m_FNeg(m_Value()))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline">      // Otherwise, this is a negation.  See if the operand is a multiply tree</td>
    <td class="lineNumber">2298</td>
    <td class="codeline">      // Otherwise, this is a negation.  See if the operand is a multiply tree</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">      // and if this is not an inner node of a multiply tree.</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">      // and if this is not an inner node of a multiply tree.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">      Value *Op = isa<BinaryOperator>(I) ? I->getOperand(1) :</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">      Value *Op = isa<BinaryOperator>(I) ? I->getOperand(1) :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline">                                           I->getOperand(0);</td>
    <td class="lineNumber">2301</td>
    <td class="codeline">                                           I->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">      if (isReassociableOp(Op, Instruction::FMul) &&</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">      if (isReassociableOp(Op, Instruction::FMul) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">          (!I->hasOneUse() ||</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">          (!I->hasOneUse() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline">           !isReassociableOp(I->user_back(), Instruction::FMul))) {</td>
    <td class="lineNumber">2304</td>
    <td class="codeline">           !isReassociableOp(I->user_back(), Instruction::FMul))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">        // If the negate was simplified, revisit the users to see if we can</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">        // If the negate was simplified, revisit the users to see if we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">        // reassociate further.</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">        // reassociate further.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">        Instruction *NI = LowerNegateToMultiply(I);</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">        Instruction *NI = LowerNegateToMultiply(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">        for (User *U : NI->users()) {</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">        for (User *U : NI->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">          if (BinaryOperator *Tmp = dyn_cast<BinaryOperator>(U))</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">          if (BinaryOperator *Tmp = dyn_cast<BinaryOperator>(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline">            RedoInsts.insert(Tmp);</td>
    <td class="lineNumber">2310</td>
    <td class="codeline">            RedoInsts.insert(Tmp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">        RedoInsts.insert(I);</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">        RedoInsts.insert(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">        MadeChange = true;</td>
    <td class="lineNumber">2313</td>
    <td class="codeline">        MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">        I = NI;</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">        I = NI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline"></td>
    <td class="lineNumber">2318</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">  // If this instruction is an associative binary operator, process it.</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">  // If this instruction is an associative binary operator, process it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">  if (!I->isAssociative()) return;</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">  if (!I->isAssociative()) return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">  BinaryOperator *BO = cast<BinaryOperator>(I);</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">  BinaryOperator *BO = cast<BinaryOperator>(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline"></td>
    <td class="lineNumber">2322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">  // If this is an interior node of a reassociable tree, ignore it until we</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">  // If this is an interior node of a reassociable tree, ignore it until we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">  // get to the root of the tree, to avoid N^2 analysis.</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">  // get to the root of the tree, to avoid N^2 analysis.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">  unsigned Opcode = BO->getOpcode();</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">  unsigned Opcode = BO->getOpcode();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">  if (BO->hasOneUse() && BO->user_back()->getOpcode() == Opcode) {</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">  if (BO->hasOneUse() && BO->user_back()->getOpcode() == Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">    // During the initial run we will get to the root of the tree.</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">    // During the initial run we will get to the root of the tree.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">    // But if we get here while we are redoing instructions, there is no</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">    // But if we get here while we are redoing instructions, there is no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">    // guarantee that the root will be visited. So Redo later</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">    // guarantee that the root will be visited. So Redo later</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">    if (BO->user_back() != BO &&</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">    if (BO->user_back() != BO &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline">        BO->getParent() == BO->user_back()->getParent())</td>
    <td class="lineNumber">2331</td>
    <td class="codeline">        BO->getParent() == BO->user_back()->getParent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">      RedoInsts.insert(BO->user_back());</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">      RedoInsts.insert(BO->user_back());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline"></td>
    <td class="lineNumber">2335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">  // If this is an add tree that is used by a sub instruction, ignore it</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">  // If this is an add tree that is used by a sub instruction, ignore it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">  // until we process the subtract.</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">  // until we process the subtract.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">  if (BO->hasOneUse() && BO->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">  if (BO->hasOneUse() && BO->getOpcode() == Instruction::Add &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">      cast<Instruction>(BO->user_back())->getOpcode() == Instruction::Sub)</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">      cast<Instruction>(BO->user_back())->getOpcode() == Instruction::Sub)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">  if (BO->hasOneUse() && BO->getOpcode() == Instruction::FAdd &&</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">  if (BO->hasOneUse() && BO->getOpcode() == Instruction::FAdd &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline">      cast<Instruction>(BO->user_back())->getOpcode() == Instruction::FSub)</td>
    <td class="lineNumber">2342</td>
    <td class="codeline">      cast<Instruction>(BO->user_back())->getOpcode() == Instruction::FSub)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline"></td>
    <td class="lineNumber">2344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">  ReassociateExpression(BO);</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">  ReassociateExpression(BO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline"></td>
    <td class="lineNumber">2347</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">void ReassociatePass::ReassociateExpression(BinaryOperator *I) {</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">void ReassociatePass::ReassociateExpression(BinaryOperator *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">  // First, walk the expression tree, linearizing the tree, collecting the</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">  // First, walk the expression tree, linearizing the tree, collecting the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">  // operand information.</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">  // operand information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">  SmallVector<RepeatedValue, 8> Tree;</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">  SmallVector<RepeatedValue, 8> Tree;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline">  MadeChange |= LinearizeExprTree(I, Tree, RedoInsts);</td>
    <td class="lineNumber">2352</td>
    <td class="codeline">  MadeChange |= LinearizeExprTree(I, Tree, RedoInsts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">  SmallVector<ValueEntry, 8> Ops;</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">  SmallVector<ValueEntry, 8> Ops;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">  Ops.reserve(Tree.size());</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">  Ops.reserve(Tree.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">  for (const RepeatedValue &E : Tree)</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">  for (const RepeatedValue &E : Tree)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">    Ops.append(E.second.getZExtValue(), ValueEntry(getRank(E.first), E.first));</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">    Ops.append(E.second.getZExtValue(), ValueEntry(getRank(E.first), E.first));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline"></td>
    <td class="lineNumber">2357</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "RAIn:\t"; PrintOps(I, Ops); dbgs() << '\n');</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "RAIn:\t"; PrintOps(I, Ops); dbgs() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline"></td>
    <td class="lineNumber">2359</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">  // Now that we have linearized the tree to a list and have gathered all of</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">  // Now that we have linearized the tree to a list and have gathered all of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">  // the operands and their ranks, sort the operands by their rank.  Use a</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">  // the operands and their ranks, sort the operands by their rank.  Use a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline">  // stable_sort so that values with equal ranks will have their relative</td>
    <td class="lineNumber">2362</td>
    <td class="codeline">  // stable_sort so that values with equal ranks will have their relative</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">  // positions maintained (and so the compiler is deterministic).  Note that</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">  // positions maintained (and so the compiler is deterministic).  Note that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">  // this sorts so that the highest ranking values end up at the beginning of</td>
    <td class="lineNumber">2364</td>
    <td class="codeline">  // this sorts so that the highest ranking values end up at the beginning of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">  // the vector.</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">  // the vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">  llvm::stable_sort(Ops);</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">  llvm::stable_sort(Ops);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline"></td>
    <td class="lineNumber">2367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">  // Now that we have the expression tree in a convenient</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">  // Now that we have the expression tree in a convenient</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">  // sorted form, optimize it globally if possible.</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">  // sorted form, optimize it globally if possible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">  if (Value *V = OptimizeExpression(I, Ops)) {</td>
    <td class="lineNumber">2370</td>
    <td class="codeline">  if (Value *V = OptimizeExpression(I, Ops)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">    if (V == I)</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">    if (V == I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">      // Self-referential expression in unreachable code.</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">      // Self-referential expression in unreachable code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">    // This expression tree simplified to something that isn't a tree,</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">    // This expression tree simplified to something that isn't a tree,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">    // eliminate it.</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">    // eliminate it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Reassoc to scalar: " << *V << '\n');</td>
    <td class="lineNumber">2376</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Reassoc to scalar: " << *V << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">    I->replaceAllUsesWith(V);</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">    I->replaceAllUsesWith(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">    if (Instruction *VI = dyn_cast<Instruction>(V))</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">    if (Instruction *VI = dyn_cast<Instruction>(V))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline">      if (I->getDebugLoc())</td>
    <td class="lineNumber">2379</td>
    <td class="codeline">      if (I->getDebugLoc())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">        VI->setDebugLoc(I->getDebugLoc());</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">        VI->setDebugLoc(I->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">    RedoInsts.insert(I);</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">    RedoInsts.insert(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">    ++NumAnnihil;</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">    ++NumAnnihil;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline"></td>
    <td class="lineNumber">2385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">  // We want to sink immediates as deeply as possible except in the case where</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">  // We want to sink immediates as deeply as possible except in the case where</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline">  // this is a multiply tree used only by an add, and the immediate is a -1.</td>
    <td class="lineNumber">2387</td>
    <td class="codeline">  // this is a multiply tree used only by an add, and the immediate is a -1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">  // In this case we reassociate to put the negation on the outside so that we</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">  // In this case we reassociate to put the negation on the outside so that we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">  // can fold the negation into the add: (-X)*Y + Z -> Z-X*Y</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">  // can fold the negation into the add: (-X)*Y + Z -> Z-X*Y</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">  if (I->hasOneUse()) {</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">  if (I->hasOneUse()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">    if (I->getOpcode() == Instruction::Mul &&</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">    if (I->getOpcode() == Instruction::Mul &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">        cast<Instruction>(I->user_back())->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">2392</td>
    <td class="codeline">        cast<Instruction>(I->user_back())->getOpcode() == Instruction::Add &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">        isa<ConstantInt>(Ops.back().Op) &&</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">        isa<ConstantInt>(Ops.back().Op) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">        cast<ConstantInt>(Ops.back().Op)->isMinusOne()) {</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">        cast<ConstantInt>(Ops.back().Op)->isMinusOne()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline">      ValueEntry Tmp = Ops.pop_back_val();</td>
    <td class="lineNumber">2395</td>
    <td class="codeline">      ValueEntry Tmp = Ops.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">      Ops.insert(Ops.begin(), Tmp);</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">      Ops.insert(Ops.begin(), Tmp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline">    } else if (I->getOpcode() == Instruction::FMul &&</td>
    <td class="lineNumber">2397</td>
    <td class="codeline">    } else if (I->getOpcode() == Instruction::FMul &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">               cast<Instruction>(I->user_back())->getOpcode() ==</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">               cast<Instruction>(I->user_back())->getOpcode() ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">                   Instruction::FAdd &&</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">                   Instruction::FAdd &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">               isa<ConstantFP>(Ops.back().Op) &&</td>
    <td class="lineNumber">2400</td>
    <td class="codeline">               isa<ConstantFP>(Ops.back().Op) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">               cast<ConstantFP>(Ops.back().Op)->isExactlyValue(-1.0)) {</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">               cast<ConstantFP>(Ops.back().Op)->isExactlyValue(-1.0)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">      ValueEntry Tmp = Ops.pop_back_val();</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">      ValueEntry Tmp = Ops.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline">      Ops.insert(Ops.begin(), Tmp);</td>
    <td class="lineNumber">2403</td>
    <td class="codeline">      Ops.insert(Ops.begin(), Tmp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline"></td>
    <td class="lineNumber">2406</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "RAOut:\t"; PrintOps(I, Ops); dbgs() << '\n');</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "RAOut:\t"; PrintOps(I, Ops); dbgs() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline"></td>
    <td class="lineNumber">2408</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">  if (Ops.size() == 1) {</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">  if (Ops.size() == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">    if (Ops[0].Op == I)</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">    if (Ops[0].Op == I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">      // Self-referential expression in unreachable code.</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">      // Self-referential expression in unreachable code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">2412</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline"></td>
    <td class="lineNumber">2413</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">    // This expression tree simplified to something that isn't a tree,</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">    // This expression tree simplified to something that isn't a tree,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">    // eliminate it.</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">    // eliminate it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">    I->replaceAllUsesWith(Ops[0].Op);</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">    I->replaceAllUsesWith(Ops[0].Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">    if (Instruction *OI = dyn_cast<Instruction>(Ops[0].Op))</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">    if (Instruction *OI = dyn_cast<Instruction>(Ops[0].Op))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">      OI->setDebugLoc(I->getDebugLoc());</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">      OI->setDebugLoc(I->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">    RedoInsts.insert(I);</td>
    <td class="lineNumber">2419</td>
    <td class="codeline">    RedoInsts.insert(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline"></td>
    <td class="lineNumber">2422</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">  if (Ops.size() > 2 && Ops.size() <= GlobalReassociateLimit) {</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">  if (Ops.size() > 2 && Ops.size() <= GlobalReassociateLimit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">    // Find the pair with the highest count in the pairmap and move it to the</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">    // Find the pair with the highest count in the pairmap and move it to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">    // back of the list so that it can later be CSE'd.</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">    // back of the list so that it can later be CSE'd.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline">    // example:</td>
    <td class="lineNumber">2426</td>
    <td class="codeline">    // example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">    //   a*b*c*d*e</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">    //   a*b*c*d*e</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">    // if c*e is the most "popular" pair, we can express this as</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">    // if c*e is the most "popular" pair, we can express this as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">    //   (((c*e)*d)*b)*a</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">    //   (((c*e)*d)*b)*a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline">    unsigned Max = 1;</td>
    <td class="lineNumber">2430</td>
    <td class="codeline">    unsigned Max = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">    unsigned BestRank = 0;</td>
    <td class="lineNumber">2431</td>
    <td class="codeline">    unsigned BestRank = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">    std::pair<unsigned, unsigned> BestPair;</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">    std::pair<unsigned, unsigned> BestPair;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">    unsigned Idx = I->getOpcode() - Instruction::BinaryOpsBegin;</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">    unsigned Idx = I->getOpcode() - Instruction::BinaryOpsBegin;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">    unsigned LimitIdx = 0;</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">    unsigned LimitIdx = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">    // With the CSE-driven heuristic, we are about to slap two values at the</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">    // With the CSE-driven heuristic, we are about to slap two values at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline">    // beginning of the expression whereas they could live very late in the CFG.</td>
    <td class="lineNumber">2436</td>
    <td class="codeline">    // beginning of the expression whereas they could live very late in the CFG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">    // When using the CSE-local heuristic we avoid creating dependences from</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">    // When using the CSE-local heuristic we avoid creating dependences from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">    // completely unrelated part of the CFG by limiting the expression</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">    // completely unrelated part of the CFG by limiting the expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">    // reordering on the values that live in the first seen basic block.</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">    // reordering on the values that live in the first seen basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">    // The main idea is that we want to avoid forming expressions that would</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">    // The main idea is that we want to avoid forming expressions that would</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">    // become loop dependent.</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">    // become loop dependent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline">    if (UseCSELocalOpt) {</td>
    <td class="lineNumber">2442</td>
    <td class="codeline">    if (UseCSELocalOpt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">      const BasicBlock *FirstSeenBB = nullptr;</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">      const BasicBlock *FirstSeenBB = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">      int StartIdx = Ops.size() - 1;</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">      int StartIdx = Ops.size() - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline">      // Skip the first value of the expression since we need at least two</td>
    <td class="lineNumber">2445</td>
    <td class="codeline">      // Skip the first value of the expression since we need at least two</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">      // values to materialize an expression. I.e., even if this value is</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">      // values to materialize an expression. I.e., even if this value is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">      // anchored in a different basic block, the actual first sub expression</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">      // anchored in a different basic block, the actual first sub expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline">      // will be anchored on the second value.</td>
    <td class="lineNumber">2448</td>
    <td class="codeline">      // will be anchored on the second value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline">      for (int i = StartIdx - 1; i != -1; --i) {</td>
    <td class="lineNumber">2449</td>
    <td class="codeline">      for (int i = StartIdx - 1; i != -1; --i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">        const Value *Val = Ops[i].Op;</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">        const Value *Val = Ops[i].Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">        const auto *CurrLeafInstr = dyn_cast<Instruction>(Val);</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">        const auto *CurrLeafInstr = dyn_cast<Instruction>(Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">        const BasicBlock *SeenBB = nullptr;</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">        const BasicBlock *SeenBB = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline">        if (!CurrLeafInstr) {</td>
    <td class="lineNumber">2453</td>
    <td class="codeline">        if (!CurrLeafInstr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">          // The value is free of any CFG dependencies.</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">          // The value is free of any CFG dependencies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">          // Do as if it lives in the entry block.</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">          // Do as if it lives in the entry block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline">          //</td>
    <td class="lineNumber">2456</td>
    <td class="codeline">          //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">          // We do this to make sure all the values falling on this path are</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">          // We do this to make sure all the values falling on this path are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">          // seen through the same anchor point. The rationale is these values</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">          // seen through the same anchor point. The rationale is these values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">          // can be combined together to from a sub expression free of any CFG</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">          // can be combined together to from a sub expression free of any CFG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline">          // dependencies so we want them to stay together.</td>
    <td class="lineNumber">2460</td>
    <td class="codeline">          // dependencies so we want them to stay together.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline">          // We could be cleverer and postpone the anchor down to the first</td>
    <td class="lineNumber">2461</td>
    <td class="codeline">          // We could be cleverer and postpone the anchor down to the first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">          // anchored value, but that's likely complicated to get right.</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">          // anchored value, but that's likely complicated to get right.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline">          // E.g., we wouldn't want to do that if that means being stuck in a</td>
    <td class="lineNumber">2463</td>
    <td class="codeline">          // E.g., we wouldn't want to do that if that means being stuck in a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">          // loop.</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">          // loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">          //</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">          //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">          // For instance, we wouldn't want to change:</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">          // For instance, we wouldn't want to change:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">          // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">          // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">          // into</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">          // into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">          // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">          // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline">          // Because all the sub expressions with arg2..N would be stuck between</td>
    <td class="lineNumber">2470</td>
    <td class="codeline">          // Because all the sub expressions with arg2..N would be stuck between</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">          // two loop dependent values.</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">          // two loop dependent values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline">          SeenBB = &I->getParent()->getParent()->getEntryBlock();</td>
    <td class="lineNumber">2472</td>
    <td class="codeline">          SeenBB = &I->getParent()->getParent()->getEntryBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">          SeenBB = CurrLeafInstr->getParent();</td>
    <td class="lineNumber">2474</td>
    <td class="codeline">          SeenBB = CurrLeafInstr->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2475</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline"></td>
    <td class="lineNumber">2476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline">        if (!FirstSeenBB) {</td>
    <td class="lineNumber">2477</td>
    <td class="codeline">        if (!FirstSeenBB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline">          FirstSeenBB = SeenBB;</td>
    <td class="lineNumber">2478</td>
    <td class="codeline">          FirstSeenBB = SeenBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2480</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline">        if (FirstSeenBB != SeenBB) {</td>
    <td class="lineNumber">2481</td>
    <td class="codeline">        if (FirstSeenBB != SeenBB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline">          // ith value is in a different basic block.</td>
    <td class="lineNumber">2482</td>
    <td class="codeline">          // ith value is in a different basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">          // Rewind the index once to point to the last value on the same basic</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">          // Rewind the index once to point to the last value on the same basic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline">          // block.</td>
    <td class="lineNumber">2484</td>
    <td class="codeline">          // block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline">          LimitIdx = i + 1;</td>
    <td class="lineNumber">2485</td>
    <td class="codeline">          LimitIdx = i + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << "CSE reordering: Consider values between ["</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">          LLVM_DEBUG(dbgs() << "CSE reordering: Consider values between ["</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline">                            << LimitIdx << ", " << StartIdx << "]\n");</td>
    <td class="lineNumber">2487</td>
    <td class="codeline">                            << LimitIdx << ", " << StartIdx << "]\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">2488</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2489</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2490</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2491</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline">    for (unsigned i = Ops.size() - 1; i > LimitIdx; --i) {</td>
    <td class="lineNumber">2492</td>
    <td class="codeline">    for (unsigned i = Ops.size() - 1; i > LimitIdx; --i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline">      // We must use int type to go below zero when LimitIdx is 0.</td>
    <td class="lineNumber">2493</td>
    <td class="codeline">      // We must use int type to go below zero when LimitIdx is 0.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline">      for (int j = i - 1; j >= (int)LimitIdx; --j) {</td>
    <td class="lineNumber">2494</td>
    <td class="codeline">      for (int j = i - 1; j >= (int)LimitIdx; --j) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline">        unsigned Score = 0;</td>
    <td class="lineNumber">2495</td>
    <td class="codeline">        unsigned Score = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline">        Value *Op0 = Ops[i].Op;</td>
    <td class="lineNumber">2496</td>
    <td class="codeline">        Value *Op0 = Ops[i].Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline">        Value *Op1 = Ops[j].Op;</td>
    <td class="lineNumber">2497</td>
    <td class="codeline">        Value *Op1 = Ops[j].Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline">        if (std::less<Value *>()(Op1, Op0))</td>
    <td class="lineNumber">2498</td>
    <td class="codeline">        if (std::less<Value *>()(Op1, Op0))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline">          std::swap(Op0, Op1);</td>
    <td class="lineNumber">2499</td>
    <td class="codeline">          std::swap(Op0, Op1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline">        auto it = PairMap[Idx].find({Op0, Op1});</td>
    <td class="lineNumber">2500</td>
    <td class="codeline">        auto it = PairMap[Idx].find({Op0, Op1});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline">        if (it != PairMap[Idx].end()) {</td>
    <td class="lineNumber">2501</td>
    <td class="codeline">        if (it != PairMap[Idx].end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">          // Functions like BreakUpSubtract() can erase the Values we're using</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">          // Functions like BreakUpSubtract() can erase the Values we're using</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline">          // as keys and create new Values after we built the PairMap. There's a</td>
    <td class="lineNumber">2503</td>
    <td class="codeline">          // as keys and create new Values after we built the PairMap. There's a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">          // small chance that the new nodes can have the same address as</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">          // small chance that the new nodes can have the same address as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline">          // something already in the table. We shouldn't accumulate the stored</td>
    <td class="lineNumber">2505</td>
    <td class="codeline">          // something already in the table. We shouldn't accumulate the stored</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">          // score in that case as it refers to the wrong Value.</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">          // score in that case as it refers to the wrong Value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline">          if (it->second.isValid())</td>
    <td class="lineNumber">2507</td>
    <td class="codeline">          if (it->second.isValid())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeline">            Score += it->second.Score;</td>
    <td class="lineNumber">2508</td>
    <td class="codeline">            Score += it->second.Score;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2509</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeline"></td>
    <td class="lineNumber">2510</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeline">        unsigned MaxRank = std::max(Ops[i].Rank, Ops[j].Rank);</td>
    <td class="lineNumber">2511</td>
    <td class="codeline">        unsigned MaxRank = std::max(Ops[i].Rank, Ops[j].Rank);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeline"></td>
    <td class="lineNumber">2512</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeline">        // By construction, the operands are sorted in reverse order of their</td>
    <td class="lineNumber">2513</td>
    <td class="codeline">        // By construction, the operands are sorted in reverse order of their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeline">        // topological order.</td>
    <td class="lineNumber">2514</td>
    <td class="codeline">        // topological order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeline">        // So we tend to form (sub) expressions with values that are close to</td>
    <td class="lineNumber">2515</td>
    <td class="codeline">        // So we tend to form (sub) expressions with values that are close to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeline">        // each other.</td>
    <td class="lineNumber">2516</td>
    <td class="codeline">        // each other.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeline">        //</td>
    <td class="lineNumber">2517</td>
    <td class="codeline">        //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeline">        // Now to expose more CSE opportunities we want to expose the pair of</td>
    <td class="lineNumber">2518</td>
    <td class="codeline">        // Now to expose more CSE opportunities we want to expose the pair of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeline">        // operands that occur the most (as statically computed in</td>
    <td class="lineNumber">2519</td>
    <td class="codeline">        // operands that occur the most (as statically computed in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeline">        // BuildPairMap.) as the first sub-expression.</td>
    <td class="lineNumber">2520</td>
    <td class="codeline">        // BuildPairMap.) as the first sub-expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeline">        //</td>
    <td class="lineNumber">2521</td>
    <td class="codeline">        //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeline">        // If two pairs occur as many times, we pick the one with the</td>
    <td class="lineNumber">2522</td>
    <td class="codeline">        // If two pairs occur as many times, we pick the one with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeline">        // lowest rank, meaning the one with both operands appearing first in</td>
    <td class="lineNumber">2523</td>
    <td class="codeline">        // lowest rank, meaning the one with both operands appearing first in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeline">        // the topological order.</td>
    <td class="lineNumber">2524</td>
    <td class="codeline">        // the topological order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeline">        if (Score > Max || (Score == Max && MaxRank < BestRank)) {</td>
    <td class="lineNumber">2525</td>
    <td class="codeline">        if (Score > Max || (Score == Max && MaxRank < BestRank)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeline">          BestPair = {j, i};</td>
    <td class="lineNumber">2526</td>
    <td class="codeline">          BestPair = {j, i};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeline">          Max = Score;</td>
    <td class="lineNumber">2527</td>
    <td class="codeline">          Max = Score;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeline">          BestRank = MaxRank;</td>
    <td class="lineNumber">2528</td>
    <td class="codeline">          BestRank = MaxRank;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2529</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2530</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2531</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeline">    if (Max > 1) {</td>
    <td class="lineNumber">2532</td>
    <td class="codeline">    if (Max > 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeline">      auto Op0 = Ops[BestPair.first];</td>
    <td class="lineNumber">2533</td>
    <td class="codeline">      auto Op0 = Ops[BestPair.first];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeline">      auto Op1 = Ops[BestPair.second];</td>
    <td class="lineNumber">2534</td>
    <td class="codeline">      auto Op1 = Ops[BestPair.second];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeline">      Ops.erase(&Ops[BestPair.second]);</td>
    <td class="lineNumber">2535</td>
    <td class="codeline">      Ops.erase(&Ops[BestPair.second]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeline">      Ops.erase(&Ops[BestPair.first]);</td>
    <td class="lineNumber">2536</td>
    <td class="codeline">      Ops.erase(&Ops[BestPair.first]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeline">      Ops.push_back(Op0);</td>
    <td class="lineNumber">2537</td>
    <td class="codeline">      Ops.push_back(Op0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeline">      Ops.push_back(Op1);</td>
    <td class="lineNumber">2538</td>
    <td class="codeline">      Ops.push_back(Op1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2539</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2540</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "RAOut after CSE reorder:\t"; PrintOps(I, Ops);</td>
    <td class="lineNumber">2541</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "RAOut after CSE reorder:\t"; PrintOps(I, Ops);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeline">             dbgs() << '\n');</td>
    <td class="lineNumber">2542</td>
    <td class="codeline">             dbgs() << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeline">  // Now that we ordered and optimized the expressions, splat them back into</td>
    <td class="lineNumber">2543</td>
    <td class="codeline">  // Now that we ordered and optimized the expressions, splat them back into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeline">  // the expression tree, removing any unneeded nodes.</td>
    <td class="lineNumber">2544</td>
    <td class="codeline">  // the expression tree, removing any unneeded nodes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeline">  RewriteExprTree(I, Ops);</td>
    <td class="lineNumber">2545</td>
    <td class="codeline">  RewriteExprTree(I, Ops);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2546</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeline"></td>
    <td class="lineNumber">2547</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeline">void</td>
    <td class="lineNumber">2548</td>
    <td class="codeline">void</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeline">ReassociatePass::BuildPairMap(ReversePostOrderTraversal<Function *> &RPOT) {</td>
    <td class="lineNumber">2549</td>
    <td class="codeline">ReassociatePass::BuildPairMap(ReversePostOrderTraversal<Function *> &RPOT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeline">  // Make a "pairmap" of how often each operand pair occurs.</td>
    <td class="lineNumber">2550</td>
    <td class="codeline">  // Make a "pairmap" of how often each operand pair occurs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeline">  for (BasicBlock *BI : RPOT) {</td>
    <td class="lineNumber">2551</td>
    <td class="codeline">  for (BasicBlock *BI : RPOT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeline">    for (Instruction &I : *BI) {</td>
    <td class="lineNumber">2552</td>
    <td class="codeline">    for (Instruction &I : *BI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeline">      if (!I.isAssociative())</td>
    <td class="lineNumber">2553</td>
    <td class="codeline">      if (!I.isAssociative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2554</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeline"></td>
    <td class="lineNumber">2555</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeline">      // Ignore nodes that aren't at the root of trees.</td>
    <td class="lineNumber">2556</td>
    <td class="codeline">      // Ignore nodes that aren't at the root of trees.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeline">      if (I.hasOneUse() && I.user_back()->getOpcode() == I.getOpcode())</td>
    <td class="lineNumber">2557</td>
    <td class="codeline">      if (I.hasOneUse() && I.user_back()->getOpcode() == I.getOpcode())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2558</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeline"></td>
    <td class="lineNumber">2559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeline">      // Collect all operands in a single reassociable expression.</td>
    <td class="lineNumber">2560</td>
    <td class="codeline">      // Collect all operands in a single reassociable expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeline">      // Since Reassociate has already been run once, we can assume things</td>
    <td class="lineNumber">2561</td>
    <td class="codeline">      // Since Reassociate has already been run once, we can assume things</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeline">      // are already canonical according to Reassociation's regime.</td>
    <td class="lineNumber">2562</td>
    <td class="codeline">      // are already canonical according to Reassociation's regime.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeline">      SmallVector<Value *, 8> Worklist = { I.getOperand(0), I.getOperand(1) };</td>
    <td class="lineNumber">2563</td>
    <td class="codeline">      SmallVector<Value *, 8> Worklist = { I.getOperand(0), I.getOperand(1) };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeline">      SmallVector<Value *, 8> Ops;</td>
    <td class="lineNumber">2564</td>
    <td class="codeline">      SmallVector<Value *, 8> Ops;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeline">      while (!Worklist.empty() && Ops.size() <= GlobalReassociateLimit) {</td>
    <td class="lineNumber">2565</td>
    <td class="codeline">      while (!Worklist.empty() && Ops.size() <= GlobalReassociateLimit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeline">        Value *Op = Worklist.pop_back_val();</td>
    <td class="lineNumber">2566</td>
    <td class="codeline">        Value *Op = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeline">        Instruction *OpI = dyn_cast<Instruction>(Op);</td>
    <td class="lineNumber">2567</td>
    <td class="codeline">        Instruction *OpI = dyn_cast<Instruction>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeline">        if (!OpI || OpI->getOpcode() != I.getOpcode() || !OpI->hasOneUse()) {</td>
    <td class="lineNumber">2568</td>
    <td class="codeline">        if (!OpI || OpI->getOpcode() != I.getOpcode() || !OpI->hasOneUse()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeline">          Ops.push_back(Op);</td>
    <td class="lineNumber">2569</td>
    <td class="codeline">          Ops.push_back(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">2570</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2571</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeline">        // Be paranoid about self-referencing expressions in unreachable code.</td>
    <td class="lineNumber">2572</td>
    <td class="codeline">        // Be paranoid about self-referencing expressions in unreachable code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeline">        if (OpI->getOperand(0) != OpI)</td>
    <td class="lineNumber">2573</td>
    <td class="codeline">        if (OpI->getOperand(0) != OpI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeline">          Worklist.push_back(OpI->getOperand(0));</td>
    <td class="lineNumber">2574</td>
    <td class="codeline">          Worklist.push_back(OpI->getOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeline">        if (OpI->getOperand(1) != OpI)</td>
    <td class="lineNumber">2575</td>
    <td class="codeline">        if (OpI->getOperand(1) != OpI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeline">          Worklist.push_back(OpI->getOperand(1));</td>
    <td class="lineNumber">2576</td>
    <td class="codeline">          Worklist.push_back(OpI->getOperand(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2577</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeline">      // Skip extremely long expressions.</td>
    <td class="lineNumber">2578</td>
    <td class="codeline">      // Skip extremely long expressions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeline">      if (Ops.size() > GlobalReassociateLimit)</td>
    <td class="lineNumber">2579</td>
    <td class="codeline">      if (Ops.size() > GlobalReassociateLimit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">2580</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeline"></td>
    <td class="lineNumber">2581</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeline">      // Add all pairwise combinations of operands to the pair map.</td>
    <td class="lineNumber">2582</td>
    <td class="codeline">      // Add all pairwise combinations of operands to the pair map.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeline">      unsigned BinaryIdx = I.getOpcode() - Instruction::BinaryOpsBegin;</td>
    <td class="lineNumber">2583</td>
    <td class="codeline">      unsigned BinaryIdx = I.getOpcode() - Instruction::BinaryOpsBegin;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeline">      SmallSet<std::pair<Value *, Value*>, 32> Visited;</td>
    <td class="lineNumber">2584</td>
    <td class="codeline">      SmallSet<std::pair<Value *, Value*>, 32> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeline">      for (unsigned i = 0; i < Ops.size() - 1; ++i) {</td>
    <td class="lineNumber">2585</td>
    <td class="codeline">      for (unsigned i = 0; i < Ops.size() - 1; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeline">        for (unsigned j = i + 1; j < Ops.size(); ++j) {</td>
    <td class="lineNumber">2586</td>
    <td class="codeline">        for (unsigned j = i + 1; j < Ops.size(); ++j) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeline">          // Canonicalize operand orderings.</td>
    <td class="lineNumber">2587</td>
    <td class="codeline">          // Canonicalize operand orderings.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeline">          Value *Op0 = Ops[i];</td>
    <td class="lineNumber">2588</td>
    <td class="codeline">          Value *Op0 = Ops[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeline">          Value *Op1 = Ops[j];</td>
    <td class="lineNumber">2589</td>
    <td class="codeline">          Value *Op1 = Ops[j];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeline">          if (std::less<Value *>()(Op1, Op0))</td>
    <td class="lineNumber">2590</td>
    <td class="codeline">          if (std::less<Value *>()(Op1, Op0))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeline">            std::swap(Op0, Op1);</td>
    <td class="lineNumber">2591</td>
    <td class="codeline">            std::swap(Op0, Op1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeline">          if (!Visited.insert({Op0, Op1}).second)</td>
    <td class="lineNumber">2592</td>
    <td class="codeline">          if (!Visited.insert({Op0, Op1}).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">2593</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeline">          auto res = PairMap[BinaryIdx].insert({{Op0, Op1}, {Op0, Op1, 1}});</td>
    <td class="lineNumber">2594</td>
    <td class="codeline">          auto res = PairMap[BinaryIdx].insert({{Op0, Op1}, {Op0, Op1, 1}});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeline">          if (!res.second) {</td>
    <td class="lineNumber">2595</td>
    <td class="codeline">          if (!res.second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeline">            // If either key value has been erased then we've got the same</td>
    <td class="lineNumber">2596</td>
    <td class="codeline">            // If either key value has been erased then we've got the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeline">            // address by coincidence. That can't happen here because nothing is</td>
    <td class="lineNumber">2597</td>
    <td class="codeline">            // address by coincidence. That can't happen here because nothing is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeline">            // erasing values but it can happen by the time we're querying the</td>
    <td class="lineNumber">2598</td>
    <td class="codeline">            // erasing values but it can happen by the time we're querying the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeline">            // map.</td>
    <td class="lineNumber">2599</td>
    <td class="codeline">            // map.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeline">            assert(res.first->second.isValid() && "WeakVH invalidated");</td>
    <td class="lineNumber">2600</td>
    <td class="codeline">            assert(res.first->second.isValid() && "WeakVH invalidated");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeline">            ++res.first->second.Score;</td>
    <td class="lineNumber">2601</td>
    <td class="codeline">            ++res.first->second.Score;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">2602</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2603</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2604</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2605</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2606</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2607</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeline"></td>
    <td class="lineNumber">2608</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeline">PreservedAnalyses ReassociatePass::run(Function &F, FunctionAnalysisManager &) {</td>
    <td class="lineNumber">2609</td>
    <td class="codeline">PreservedAnalyses ReassociatePass::run(Function &F, FunctionAnalysisManager &) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeline">  // Get the functions basic blocks in Reverse Post Order. This order is used by</td>
    <td class="lineNumber">2610</td>
    <td class="codeline">  // Get the functions basic blocks in Reverse Post Order. This order is used by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeline">  // BuildRankMap to pre calculate ranks correctly. It also excludes dead basic</td>
    <td class="lineNumber">2611</td>
    <td class="codeline">  // BuildRankMap to pre calculate ranks correctly. It also excludes dead basic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeline">  // blocks (it has been seen that the analysis in this pass could hang when</td>
    <td class="lineNumber">2612</td>
    <td class="codeline">  // blocks (it has been seen that the analysis in this pass could hang when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeline">  // analysing dead basic blocks).</td>
    <td class="lineNumber">2613</td>
    <td class="codeline">  // analysing dead basic blocks).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeline">  ReversePostOrderTraversal<Function *> RPOT(&F);</td>
    <td class="lineNumber">2614</td>
    <td class="codeline">  ReversePostOrderTraversal<Function *> RPOT(&F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeline"></td>
    <td class="lineNumber">2615</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeline">  // Calculate the rank map for F.</td>
    <td class="lineNumber">2616</td>
    <td class="codeline">  // Calculate the rank map for F.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeline">  BuildRankMap(F, RPOT);</td>
    <td class="lineNumber">2617</td>
    <td class="codeline">  BuildRankMap(F, RPOT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeline"></td>
    <td class="lineNumber">2618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeline">  // Build the pair map before running reassociate.</td>
    <td class="lineNumber">2619</td>
    <td class="codeline">  // Build the pair map before running reassociate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeline">  // Technically this would be more accurate if we did it after one round</td>
    <td class="lineNumber">2620</td>
    <td class="codeline">  // Technically this would be more accurate if we did it after one round</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeline">  // of reassociation, but in practice it doesn't seem to help much on</td>
    <td class="lineNumber">2621</td>
    <td class="codeline">  // of reassociation, but in practice it doesn't seem to help much on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeline">  // real-world code, so don't waste the compile time running reassociate</td>
    <td class="lineNumber">2622</td>
    <td class="codeline">  // real-world code, so don't waste the compile time running reassociate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeline">  // twice.</td>
    <td class="lineNumber">2623</td>
    <td class="codeline">  // twice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeline">  // If a user wants, they could expicitly run reassociate twice in their</td>
    <td class="lineNumber">2624</td>
    <td class="codeline">  // If a user wants, they could expicitly run reassociate twice in their</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeline">  // pass pipeline for further potential gains.</td>
    <td class="lineNumber">2625</td>
    <td class="codeline">  // pass pipeline for further potential gains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeline">  // It might also be possible to update the pair map during runtime, but the</td>
    <td class="lineNumber">2626</td>
    <td class="codeline">  // It might also be possible to update the pair map during runtime, but the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeline">  // overhead of that may be large if there's many reassociable chains.</td>
    <td class="lineNumber">2627</td>
    <td class="codeline">  // overhead of that may be large if there's many reassociable chains.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeline">  BuildPairMap(RPOT);</td>
    <td class="lineNumber">2628</td>
    <td class="codeline">  BuildPairMap(RPOT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeline"></td>
    <td class="lineNumber">2629</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeline">  MadeChange = false;</td>
    <td class="lineNumber">2630</td>
    <td class="codeline">  MadeChange = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeline"></td>
    <td class="lineNumber">2631</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeline">  // Traverse the same blocks that were analysed by BuildRankMap.</td>
    <td class="lineNumber">2632</td>
    <td class="codeline">  // Traverse the same blocks that were analysed by BuildRankMap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeline">  for (BasicBlock *BI : RPOT) {</td>
    <td class="lineNumber">2633</td>
    <td class="codeline">  for (BasicBlock *BI : RPOT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeline">    assert(RankMap.count(&*BI) && "BB should be ranked.");</td>
    <td class="lineNumber">2634</td>
    <td class="codeline">    assert(RankMap.count(&*BI) && "BB should be ranked.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeline">    // Optimize every instruction in the basic block.</td>
    <td class="lineNumber">2635</td>
    <td class="codeline">    // Optimize every instruction in the basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeline">    for (BasicBlock::iterator II = BI->begin(), IE = BI->end(); II != IE;)</td>
    <td class="lineNumber">2636</td>
    <td class="codeline">    for (BasicBlock::iterator II = BI->begin(), IE = BI->end(); II != IE;)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeline">      if (isInstructionTriviallyDead(&*II)) {</td>
    <td class="lineNumber">2637</td>
    <td class="codeline">      if (isInstructionTriviallyDead(&*II)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeline">        EraseInst(&*II++);</td>
    <td class="lineNumber">2638</td>
    <td class="codeline">        EraseInst(&*II++);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">2639</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeline">        OptimizeInst(&*II);</td>
    <td class="lineNumber">2640</td>
    <td class="codeline">        OptimizeInst(&*II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeline">        assert(II->getParent() == &*BI && "Moved to a different block!");</td>
    <td class="lineNumber">2641</td>
    <td class="codeline">        assert(II->getParent() == &*BI && "Moved to a different block!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeline">        ++II;</td>
    <td class="lineNumber">2642</td>
    <td class="codeline">        ++II;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2643</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeline"></td>
    <td class="lineNumber">2644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeline">    // Make a copy of all the instructions to be redone so we can remove dead</td>
    <td class="lineNumber">2645</td>
    <td class="codeline">    // Make a copy of all the instructions to be redone so we can remove dead</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeline">    // instructions.</td>
    <td class="lineNumber">2646</td>
    <td class="codeline">    // instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeline">    OrderedSet ToRedo(RedoInsts);</td>
    <td class="lineNumber">2647</td>
    <td class="codeline">    OrderedSet ToRedo(RedoInsts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeline">    // Iterate over all instructions to be reevaluated and remove trivially dead</td>
    <td class="lineNumber">2648</td>
    <td class="codeline">    // Iterate over all instructions to be reevaluated and remove trivially dead</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeline">    // instructions. If any operand of the trivially dead instruction becomes</td>
    <td class="lineNumber">2649</td>
    <td class="codeline">    // instructions. If any operand of the trivially dead instruction becomes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeline">    // dead mark it for deletion as well. Continue this process until all</td>
    <td class="lineNumber">2650</td>
    <td class="codeline">    // dead mark it for deletion as well. Continue this process until all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeline">    // trivially dead instructions have been removed.</td>
    <td class="lineNumber">2651</td>
    <td class="codeline">    // trivially dead instructions have been removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeline">    while (!ToRedo.empty()) {</td>
    <td class="lineNumber">2652</td>
    <td class="codeline">    while (!ToRedo.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeline">      Instruction *I = ToRedo.pop_back_val();</td>
    <td class="lineNumber">2653</td>
    <td class="codeline">      Instruction *I = ToRedo.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeline">      if (isInstructionTriviallyDead(I)) {</td>
    <td class="lineNumber">2654</td>
    <td class="codeline">      if (isInstructionTriviallyDead(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeline">        RecursivelyEraseDeadInsts(I, ToRedo);</td>
    <td class="lineNumber">2655</td>
    <td class="codeline">        RecursivelyEraseDeadInsts(I, ToRedo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeline">        MadeChange = true;</td>
    <td class="lineNumber">2656</td>
    <td class="codeline">        MadeChange = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2657</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2658</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeline"></td>
    <td class="lineNumber">2659</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeline">    // Now that we have removed dead instructions, we can reoptimize the</td>
    <td class="lineNumber">2660</td>
    <td class="codeline">    // Now that we have removed dead instructions, we can reoptimize the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeline">    // remaining instructions.</td>
    <td class="lineNumber">2661</td>
    <td class="codeline">    // remaining instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeline">    while (!RedoInsts.empty()) {</td>
    <td class="lineNumber">2662</td>
    <td class="codeline">    while (!RedoInsts.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeline">      Instruction *I = RedoInsts.front();</td>
    <td class="lineNumber">2663</td>
    <td class="codeline">      Instruction *I = RedoInsts.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeline">      RedoInsts.erase(RedoInsts.begin());</td>
    <td class="lineNumber">2664</td>
    <td class="codeline">      RedoInsts.erase(RedoInsts.begin());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeline">      if (isInstructionTriviallyDead(I))</td>
    <td class="lineNumber">2665</td>
    <td class="codeline">      if (isInstructionTriviallyDead(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeline">        EraseInst(I);</td>
    <td class="lineNumber">2666</td>
    <td class="codeline">        EraseInst(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">2667</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeline">        OptimizeInst(I);</td>
    <td class="lineNumber">2668</td>
    <td class="codeline">        OptimizeInst(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2669</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2670</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeline"></td>
    <td class="lineNumber">2671</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeline">  // We are done with the rank map and pair map.</td>
    <td class="lineNumber">2672</td>
    <td class="codeline">  // We are done with the rank map and pair map.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeline">  RankMap.clear();</td>
    <td class="lineNumber">2673</td>
    <td class="codeline">  RankMap.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeline">  ValueRankMap.clear();</td>
    <td class="lineNumber">2674</td>
    <td class="codeline">  ValueRankMap.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeline">  for (auto &Entry : PairMap)</td>
    <td class="lineNumber">2675</td>
    <td class="codeline">  for (auto &Entry : PairMap)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeline">    Entry.clear();</td>
    <td class="lineNumber">2676</td>
    <td class="codeline">    Entry.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeline"></td>
    <td class="lineNumber">2677</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeline">  if (MadeChange) {</td>
    <td class="lineNumber">2678</td>
    <td class="codeline">  if (MadeChange) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeline">    PreservedAnalyses PA;</td>
    <td class="lineNumber">2679</td>
    <td class="codeline">    PreservedAnalyses PA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeline">    PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">2680</td>
    <td class="codeline">    PA.preserveSet<CFGAnalyses>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeline">    return PA;</td>
    <td class="lineNumber">2681</td>
    <td class="codeline">    return PA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2682</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeline"></td>
    <td class="lineNumber">2683</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeline">  return PreservedAnalyses::all();</td>
    <td class="lineNumber">2684</td>
    <td class="codeline">  return PreservedAnalyses::all();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2685</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeline"></td>
    <td class="lineNumber">2686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">2687</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeline"></td>
    <td class="lineNumber">2688</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeline">  class ReassociateLegacyPass : public FunctionPass {</td>
    <td class="lineNumber">2689</td>
    <td class="codeline">  class ReassociateLegacyPass : public FunctionPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeline">    ReassociatePass Impl;</td>
    <td class="lineNumber">2690</td>
    <td class="codeline">    ReassociatePass Impl;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeline"></td>
    <td class="lineNumber">2691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">2692</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeline">    static char ID; // Pass identification, replacement for typeid</td>
    <td class="lineNumber">2693</td>
    <td class="codeline">    static char ID; // Pass identification, replacement for typeid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeline"></td>
    <td class="lineNumber">2694</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeline">    ReassociateLegacyPass() : FunctionPass(ID) {</td>
    <td class="lineNumber">2695</td>
    <td class="codeline">    ReassociateLegacyPass() : FunctionPass(ID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeline">      initializeReassociateLegacyPassPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">2696</td>
    <td class="codeline">      initializeReassociateLegacyPassPass(*PassRegistry::getPassRegistry());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2697</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeline"></td>
    <td class="lineNumber">2698</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeline">    bool runOnFunction(Function &F) override {</td>
    <td class="lineNumber">2699</td>
    <td class="codeline">    bool runOnFunction(Function &F) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeline">      if (skipFunction(F))</td>
    <td class="lineNumber">2700</td>
    <td class="codeline">      if (skipFunction(F))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">2701</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeline"></td>
    <td class="lineNumber">2702</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeline">      FunctionAnalysisManager DummyFAM;</td>
    <td class="lineNumber">2703</td>
    <td class="codeline">      FunctionAnalysisManager DummyFAM;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeline">      auto PA = Impl.run(F, DummyFAM);</td>
    <td class="lineNumber">2704</td>
    <td class="codeline">      auto PA = Impl.run(F, DummyFAM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeline">      return !PA.areAllPreserved();</td>
    <td class="lineNumber">2705</td>
    <td class="codeline">      return !PA.areAllPreserved();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2706</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeline"></td>
    <td class="lineNumber">2707</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeline">    void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">2708</td>
    <td class="codeline">    void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeline">      AU.setPreservesCFG();</td>
    <td class="lineNumber">2709</td>
    <td class="codeline">      AU.setPreservesCFG();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeline">      AU.addPreserved<AAResultsWrapperPass>();</td>
    <td class="lineNumber">2710</td>
    <td class="codeline">      AU.addPreserved<AAResultsWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeline">      AU.addPreserved<BasicAAWrapperPass>();</td>
    <td class="lineNumber">2711</td>
    <td class="codeline">      AU.addPreserved<BasicAAWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeline">      AU.addPreserved<GlobalsAAWrapperPass>();</td>
    <td class="lineNumber">2712</td>
    <td class="codeline">      AU.addPreserved<GlobalsAAWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2713</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2714</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeline"></td>
    <td class="lineNumber">2715</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">2716</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeline"></td>
    <td class="lineNumber">2717</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeline">char ReassociateLegacyPass::ID = 0;</td>
    <td class="lineNumber">2718</td>
    <td class="codeline">char ReassociateLegacyPass::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeline"></td>
    <td class="lineNumber">2719</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeline">INITIALIZE_PASS(ReassociateLegacyPass, "reassociate",</td>
    <td class="lineNumber">2720</td>
    <td class="codeline">INITIALIZE_PASS(ReassociateLegacyPass, "reassociate",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeline">                "Reassociate expressions", false, false)</td>
    <td class="lineNumber">2721</td>
    <td class="codeline">                "Reassociate expressions", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeline"></td>
    <td class="lineNumber">2722</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeline">// Public interface to the Reassociate pass</td>
    <td class="lineNumber">2723</td>
    <td class="codeline">// Public interface to the Reassociate pass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeline">FunctionPass *llvm::createReassociatePass() {</td>
    <td class="lineNumber">2724</td>
    <td class="codeline">FunctionPass *llvm::createReassociatePass() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeline">  return new ReassociateLegacyPass();</td>
    <td class="lineNumber">2725</td>
    <td class="codeline">  return new ReassociateLegacyPass();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2726</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeline"></td>
    <td class="lineNumber">2727</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- Reassociate.cpp - Reassociate binary expressions -------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- Reassociate.cpp - Reassociate binary expressions -------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This pass reassociates commutative expressions in an order that is designed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This pass reassociates commutative expressions in an order that is designed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// to promote better constant propagation, GCSE, LICM, PRE, etc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// to promote better constant propagation, GCSE, LICM, PRE, etc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">// For example: 4 + (x + 5) -> x + (4 + 5)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">// For example: 4 + (x + 5) -> x + (4 + 5)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">// In the implementation of this algorithm, constants are assigned rank = 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">// In the implementation of this algorithm, constants are assigned rank = 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">// function arguments are rank = 1, and other values are assigned ranks</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">// function arguments are rank = 1, and other values are assigned ranks</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">// corresponding to the reverse post order traversal of current function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">// corresponding to the reverse post order traversal of current function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">// (starting at 2), which effectively gives values in deep loops higher rank</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">// (starting at 2), which effectively gives values in deep loops higher rank</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">// than values not in loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">// than values not in loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar/Reassociate.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar/Reassociate.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/ADT/APFloat.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/ADT/APFloat.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/PostOrderIterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/PostOrderIterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/ADT/SmallSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/Analysis/BasicAliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/Analysis/BasicAliasAnalysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/Analysis/ConstantFolding.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/Analysis/ConstantFolding.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/Analysis/GlobalsModRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/Analysis/GlobalsModRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/Argument.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/Argument.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/CFG.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/CFG.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/IR/PatternMatch.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/IR/User.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/IR/User.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/IR/ValueHandle.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/IR/ValueHandle.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">using namespace reassociate;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">using namespace reassociate;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">using namespace PatternMatch;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">#define DEBUG_TYPE "reassociate"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">#define DEBUG_TYPE "reassociate"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">STATISTIC(NumChanged, "Number of insts reassociated");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">STATISTIC(NumChanged, "Number of insts reassociated");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">STATISTIC(NumAnnihil, "Number of expr tree annihilated");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">STATISTIC(NumAnnihil, "Number of expr tree annihilated");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">STATISTIC(NumFactor , "Number of multiplies factored");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">STATISTIC(NumFactor , "Number of multiplies factored");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">static cl::opt<bool></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">    UseCSELocalOpt(DEBUG_TYPE "-use-cse-local",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">    UseCSELocalOpt(DEBUG_TYPE "-use-cse-local",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">                   cl::desc("Only reorder expressions within a basic block "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">                   cl::desc("Only reorder expressions within a basic block "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">                            "when exposing CSE opportunities"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">                            "when exposing CSE opportunities"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">                   cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">                   cl::init(true), cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">/// Print out the expression identified in the Ops list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">/// Print out the expression identified in the Ops list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">static void PrintOps(Instruction *I, const SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">static void PrintOps(Instruction *I, const SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">  Module *M = I->getModule();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">  Module *M = I->getModule();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">  dbgs() << Instruction::getOpcodeName(I->getOpcode()) << " "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">  dbgs() << Instruction::getOpcodeName(I->getOpcode()) << " "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">       << *Ops[0].Op->getType() << '\t';</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">       << *Ops[0].Op->getType() << '\t';</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">    dbgs() << "[ ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">    dbgs() << "[ ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">    Ops[i].Op->printAsOperand(dbgs(), false, M);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">    Ops[i].Op->printAsOperand(dbgs(), false, M);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">    dbgs() << ", #" << Ops[i].Rank << "] ";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">    dbgs() << ", #" << Ops[i].Rank << "] ";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">/// Utility class representing a non-constant Xor-operand. We classify</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">/// Utility class representing a non-constant Xor-operand. We classify</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">/// non-constant Xor-Operands into two categories:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">/// non-constant Xor-Operands into two categories:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">///  C1) The operand is in the form "X & C", where C is a constant and C != ~0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">///  C1) The operand is in the form "X & C", where C is a constant and C != ~0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">///  C2)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">///  C2)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">///    C2.1) The operand is in the form of "X | C", where C is a non-zero</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">///    C2.1) The operand is in the form of "X | C", where C is a non-zero</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">///          constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">///          constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">///    C2.2) Any operand E which doesn't fall into C1 and C2.1, we view this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">///    C2.2) Any operand E which doesn't fall into C1 and C2.1, we view this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">///          operand as "E | 0"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">///          operand as "E | 0"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">class llvm::reassociate::XorOpnd {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">class llvm::reassociate::XorOpnd {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">  XorOpnd(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">  XorOpnd(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">  bool isInvalid() const { return SymbolicPart == nullptr; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">  bool isInvalid() const { return SymbolicPart == nullptr; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">  bool isOrExpr() const { return isOr; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">  bool isOrExpr() const { return isOr; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">  Value *getValue() const { return OrigVal; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">  Value *getValue() const { return OrigVal; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">  Value *getSymbolicPart() const { return SymbolicPart; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">  Value *getSymbolicPart() const { return SymbolicPart; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  unsigned getSymbolicRank() const { return SymbolicRank; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  unsigned getSymbolicRank() const { return SymbolicRank; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">  const APInt &getConstPart() const { return ConstPart; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">  const APInt &getConstPart() const { return ConstPart; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">  void Invalidate() { SymbolicPart = OrigVal = nullptr; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">  void Invalidate() { SymbolicPart = OrigVal = nullptr; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">  void setSymbolicRank(unsigned R) { SymbolicRank = R; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">  void setSymbolicRank(unsigned R) { SymbolicRank = R; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  Value *OrigVal;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  Value *OrigVal;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">  Value *SymbolicPart;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">  Value *SymbolicPart;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">  APInt ConstPart;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">  APInt ConstPart;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">  unsigned SymbolicRank;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">  unsigned SymbolicRank;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  bool isOr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  bool isOr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">XorOpnd::XorOpnd(Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">XorOpnd::XorOpnd(Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">  assert(!isa<ConstantInt>(V) && "No ConstantInt");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">  assert(!isa<ConstantInt>(V) && "No ConstantInt");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">  OrigVal = V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">  OrigVal = V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  Instruction *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  Instruction *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  SymbolicRank = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  SymbolicRank = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">  if (I && (I->getOpcode() == Instruction::Or ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">  if (I && (I->getOpcode() == Instruction::Or ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">            I->getOpcode() == Instruction::And)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">            I->getOpcode() == Instruction::And)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">    Value *V0 = I->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">    Value *V0 = I->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">    Value *V1 = I->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">    Value *V1 = I->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">    const APInt *C;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">    const APInt *C;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">    if (match(V0, m_APInt(C)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">    if (match(V0, m_APInt(C)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">      std::swap(V0, V1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">      std::swap(V0, V1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">    if (match(V1, m_APInt(C))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">    if (match(V1, m_APInt(C))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">      ConstPart = *C;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">      ConstPart = *C;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">      SymbolicPart = V0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">      SymbolicPart = V0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">      isOr = (I->getOpcode() == Instruction::Or);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">      isOr = (I->getOpcode() == Instruction::Or);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">  // view the operand as "V | 0"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">  // view the operand as "V | 0"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  SymbolicPart = V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  SymbolicPart = V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">  ConstPart = APInt::getZero(V->getType()->getScalarSizeInBits());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">  ConstPart = APInt::getZero(V->getType()->getScalarSizeInBits());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">  isOr = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">  isOr = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">/// Return true if I is an instruction with the FastMathFlags that are needed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">/// Return true if I is an instruction with the FastMathFlags that are needed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">/// for general reassociation set.  This is not the same as testing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">/// for general reassociation set.  This is not the same as testing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">/// Instruction::isAssociative() because it includes operations like fsub.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">/// Instruction::isAssociative() because it includes operations like fsub.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">/// (This routine is only intended to be called for floating-point operations.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">/// (This routine is only intended to be called for floating-point operations.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">static bool hasFPAssociativeFlags(Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">static bool hasFPAssociativeFlags(Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  assert(I && isa<FPMathOperator>(I) && "Should only check FP ops");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  assert(I && isa<FPMathOperator>(I) && "Should only check FP ops");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">  return I->hasAllowReassoc() && I->hasNoSignedZeros();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">  return I->hasAllowReassoc() && I->hasNoSignedZeros();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">/// Return true if V is an instruction of the specified opcode and if it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">/// Return true if V is an instruction of the specified opcode and if it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">/// only has one use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">/// only has one use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">static BinaryOperator *isReassociableOp(Value *V, unsigned Opcode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">static BinaryOperator *isReassociableOp(Value *V, unsigned Opcode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  auto *BO = dyn_cast<BinaryOperator>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  auto *BO = dyn_cast<BinaryOperator>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">  if (BO && BO->hasOneUse() && BO->getOpcode() == Opcode)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">  if (BO && BO->hasOneUse() && BO->getOpcode() == Opcode)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">    if (!isa<FPMathOperator>(BO) || hasFPAssociativeFlags(BO))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">    if (!isa<FPMathOperator>(BO) || hasFPAssociativeFlags(BO))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">      return BO;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">      return BO;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">static BinaryOperator *isReassociableOp(Value *V, unsigned Opcode1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">static BinaryOperator *isReassociableOp(Value *V, unsigned Opcode1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">                                        unsigned Opcode2) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">                                        unsigned Opcode2) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">  auto *BO = dyn_cast<BinaryOperator>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">  auto *BO = dyn_cast<BinaryOperator>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  if (BO && BO->hasOneUse() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  if (BO && BO->hasOneUse() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">      (BO->getOpcode() == Opcode1 || BO->getOpcode() == Opcode2))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">      (BO->getOpcode() == Opcode1 || BO->getOpcode() == Opcode2))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">    if (!isa<FPMathOperator>(BO) || hasFPAssociativeFlags(BO))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">    if (!isa<FPMathOperator>(BO) || hasFPAssociativeFlags(BO))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">      return BO;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">      return BO;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">void ReassociatePass::BuildRankMap(Function &F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">void ReassociatePass::BuildRankMap(Function &F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">                                   ReversePostOrderTraversal<Function*> &RPOT) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">                                   ReversePostOrderTraversal<Function*> &RPOT) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  unsigned Rank = 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  unsigned Rank = 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  // Assign distinct ranks to function arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  // Assign distinct ranks to function arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">  for (auto &Arg : F.args()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">  for (auto &Arg : F.args()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">    ValueRankMap[&Arg] = ++Rank;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">    ValueRankMap[&Arg] = ++Rank;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Calculated Rank[" << Arg.getName() << "] = " << Rank</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Calculated Rank[" << Arg.getName() << "] = " << Rank</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">  // Traverse basic blocks in ReversePostOrder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">  // Traverse basic blocks in ReversePostOrder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  for (BasicBlock *BB : RPOT) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  for (BasicBlock *BB : RPOT) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">    unsigned BBRank = RankMap[BB] = ++Rank << 16;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">    unsigned BBRank = RankMap[BB] = ++Rank << 16;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">    // Walk the basic block, adding precomputed ranks for any instructions that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">    // Walk the basic block, adding precomputed ranks for any instructions that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">    // we cannot move.  This ensures that the ranks for these instructions are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">    // we cannot move.  This ensures that the ranks for these instructions are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">    // all different in the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">    // all different in the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">    for (Instruction &I : *BB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">    for (Instruction &I : *BB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">      if (mayHaveNonDefUseDependency(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">      if (mayHaveNonDefUseDependency(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">        ValueRankMap[&I] = ++BBRank;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">        ValueRankMap[&I] = ++BBRank;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">unsigned ReassociatePass::getRank(Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">unsigned ReassociatePass::getRank(Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  Instruction *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  Instruction *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">  if (!I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">  if (!I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">    if (isa<Argument>(V)) return ValueRankMap[V];   // Function argument.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">    if (isa<Argument>(V)) return ValueRankMap[V];   // Function argument.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">    return 0;  // Otherwise it's a global or constant, rank 0.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">    return 0;  // Otherwise it's a global or constant, rank 0.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  if (unsigned Rank = ValueRankMap[I])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  if (unsigned Rank = ValueRankMap[I])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">    return Rank;    // Rank already known?</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">    return Rank;    // Rank already known?</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">  // If this is an expression, return the 1+MAX(rank(LHS), rank(RHS)) so that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">  // If this is an expression, return the 1+MAX(rank(LHS), rank(RHS)) so that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">  // we can reassociate expressions for code motion!  Since we do not recurse</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">  // we can reassociate expressions for code motion!  Since we do not recurse</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">  // for PHI nodes, we cannot have infinite recursion here, because there</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">  // for PHI nodes, we cannot have infinite recursion here, because there</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">  // cannot be loops in the value graph that do not go through PHI nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">  // cannot be loops in the value graph that do not go through PHI nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  unsigned Rank = 0, MaxRank = RankMap[I->getParent()];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  unsigned Rank = 0, MaxRank = RankMap[I->getParent()];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">  for (unsigned i = 0, e = I->getNumOperands(); i != e && Rank != MaxRank; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">  for (unsigned i = 0, e = I->getNumOperands(); i != e && Rank != MaxRank; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">    Rank = std::max(Rank, getRank(I->getOperand(i)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">    Rank = std::max(Rank, getRank(I->getOperand(i)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  // If this is a 'not' or 'neg' instruction, do not count it for rank. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  // If this is a 'not' or 'neg' instruction, do not count it for rank. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">  // assures us that X and ~X will have the same rank.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">  // assures us that X and ~X will have the same rank.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">  if (!match(I, m_Not(m_Value())) && !match(I, m_Neg(m_Value())) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">  if (!match(I, m_Not(m_Value())) && !match(I, m_Neg(m_Value())) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">      !match(I, m_FNeg(m_Value())))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">      !match(I, m_FNeg(m_Value())))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">    ++Rank;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">    ++Rank;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Calculated Rank[" << V->getName() << "] = " << Rank</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Calculated Rank[" << V->getName() << "] = " << Rank</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">  return ValueRankMap[I] = Rank;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">  return ValueRankMap[I] = Rank;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">// Canonicalize constants to RHS.  Otherwise, sort the operands by rank.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">// Canonicalize constants to RHS.  Otherwise, sort the operands by rank.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">void ReassociatePass::canonicalizeOperands(Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">void ReassociatePass::canonicalizeOperands(Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">  assert(isa<BinaryOperator>(I) && "Expected binary operator.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">  assert(isa<BinaryOperator>(I) && "Expected binary operator.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  assert(I->isCommutative() && "Expected commutative operator.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  assert(I->isCommutative() && "Expected commutative operator.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  Value *LHS = I->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  Value *LHS = I->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  Value *RHS = I->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  Value *RHS = I->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  if (LHS == RHS || isa<Constant>(RHS))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  if (LHS == RHS || isa<Constant>(RHS))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  if (isa<Constant>(LHS) || getRank(RHS) < getRank(LHS))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  if (isa<Constant>(LHS) || getRank(RHS) < getRank(LHS))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">    cast<BinaryOperator>(I)->swapOperands();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">    cast<BinaryOperator>(I)->swapOperands();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">static BinaryOperator *CreateAdd(Value *S1, Value *S2, const Twine &Name,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">static BinaryOperator *CreateAdd(Value *S1, Value *S2, const Twine &Name,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">                                 Instruction *InsertBefore, Value *FlagsOp) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">                                 Instruction *InsertBefore, Value *FlagsOp) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  if (S1->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  if (S1->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">    return BinaryOperator::CreateAdd(S1, S2, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">    return BinaryOperator::CreateAdd(S1, S2, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">    BinaryOperator *Res =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">    BinaryOperator *Res =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">        BinaryOperator::CreateFAdd(S1, S2, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">        BinaryOperator::CreateFAdd(S1, S2, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">    Res->setFastMathFlags(cast<FPMathOperator>(FlagsOp)->getFastMathFlags());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">    Res->setFastMathFlags(cast<FPMathOperator>(FlagsOp)->getFastMathFlags());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">static BinaryOperator *CreateMul(Value *S1, Value *S2, const Twine &Name,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">static BinaryOperator *CreateMul(Value *S1, Value *S2, const Twine &Name,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">                                 Instruction *InsertBefore, Value *FlagsOp) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">                                 Instruction *InsertBefore, Value *FlagsOp) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  if (S1->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  if (S1->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">    return BinaryOperator::CreateMul(S1, S2, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">    return BinaryOperator::CreateMul(S1, S2, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">    BinaryOperator *Res =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">    BinaryOperator *Res =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">      BinaryOperator::CreateFMul(S1, S2, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">      BinaryOperator::CreateFMul(S1, S2, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">    Res->setFastMathFlags(cast<FPMathOperator>(FlagsOp)->getFastMathFlags());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">    Res->setFastMathFlags(cast<FPMathOperator>(FlagsOp)->getFastMathFlags());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">    return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">static Instruction *CreateNeg(Value *S1, const Twine &Name,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">static Instruction *CreateNeg(Value *S1, const Twine &Name,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">                              Instruction *InsertBefore, Value *FlagsOp) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">                              Instruction *InsertBefore, Value *FlagsOp) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  if (S1->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  if (S1->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">    return BinaryOperator::CreateNeg(S1, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">    return BinaryOperator::CreateNeg(S1, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">  if (auto *FMFSource = dyn_cast<Instruction>(FlagsOp))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">  if (auto *FMFSource = dyn_cast<Instruction>(FlagsOp))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">    return UnaryOperator::CreateFNegFMF(S1, FMFSource, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">    return UnaryOperator::CreateFNegFMF(S1, FMFSource, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  return UnaryOperator::CreateFNeg(S1, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  return UnaryOperator::CreateFNeg(S1, Name, InsertBefore);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">/// Replace 0-X with X*-1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">/// Replace 0-X with X*-1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">static BinaryOperator *LowerNegateToMultiply(Instruction *Neg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">static BinaryOperator *LowerNegateToMultiply(Instruction *Neg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  assert((isa<UnaryOperator>(Neg) || isa<BinaryOperator>(Neg)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  assert((isa<UnaryOperator>(Neg) || isa<BinaryOperator>(Neg)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">         "Expected a Negate!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">         "Expected a Negate!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  // FIXME: It's not safe to lower a unary FNeg into a FMul by -1.0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  // FIXME: It's not safe to lower a unary FNeg into a FMul by -1.0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  unsigned OpNo = isa<BinaryOperator>(Neg) ? 1 : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  unsigned OpNo = isa<BinaryOperator>(Neg) ? 1 : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">  Type *Ty = Neg->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">  Type *Ty = Neg->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">  Constant *NegOne = Ty->isIntOrIntVectorTy() ?</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">  Constant *NegOne = Ty->isIntOrIntVectorTy() ?</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">    ConstantInt::getAllOnesValue(Ty) : ConstantFP::get(Ty, -1.0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">    ConstantInt::getAllOnesValue(Ty) : ConstantFP::get(Ty, -1.0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  BinaryOperator *Res = CreateMul(Neg->getOperand(OpNo), NegOne, "", Neg, Neg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  BinaryOperator *Res = CreateMul(Neg->getOperand(OpNo), NegOne, "", Neg, Neg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  Neg->setOperand(OpNo, Constant::getNullValue(Ty)); // Drop use of op.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  Neg->setOperand(OpNo, Constant::getNullValue(Ty)); // Drop use of op.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  Res->takeName(Neg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  Res->takeName(Neg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">  Neg->replaceAllUsesWith(Res);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">  Neg->replaceAllUsesWith(Res);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">  Res->setDebugLoc(Neg->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">  Res->setDebugLoc(Neg->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">/// Returns k such that lambda(2^Bitwidth) = 2^k, where lambda is the Carmichael</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">/// Returns k such that lambda(2^Bitwidth) = 2^k, where lambda is the Carmichael</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">/// function. This means that x^(2^k) === 1 mod 2^Bitwidth for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">/// function. This means that x^(2^k) === 1 mod 2^Bitwidth for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">/// every odd x, i.e. x^(2^k) = 1 for every odd x in Bitwidth-bit arithmetic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">/// every odd x, i.e. x^(2^k) = 1 for every odd x in Bitwidth-bit arithmetic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">/// Note that 0 <= k < Bitwidth, and if Bitwidth > 3 then x^(2^k) = 0 for every</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">/// Note that 0 <= k < Bitwidth, and if Bitwidth > 3 then x^(2^k) = 0 for every</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">/// even x in Bitwidth-bit arithmetic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">/// even x in Bitwidth-bit arithmetic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">static unsigned CarmichaelShift(unsigned Bitwidth) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">static unsigned CarmichaelShift(unsigned Bitwidth) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  if (Bitwidth < 3)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  if (Bitwidth < 3)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">    return Bitwidth - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">    return Bitwidth - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  return Bitwidth - 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  return Bitwidth - 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">/// Add the extra weight 'RHS' to the existing weight 'LHS',</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">/// Add the extra weight 'RHS' to the existing weight 'LHS',</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">/// reducing the combined weight using any special properties of the operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">/// reducing the combined weight using any special properties of the operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">/// The existing weight LHS represents the computation X op X op ... op X where</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">/// The existing weight LHS represents the computation X op X op ... op X where</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">/// X occurs LHS times.  The combined weight represents  X op X op ... op X with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">/// X occurs LHS times.  The combined weight represents  X op X op ... op X with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">/// X occurring LHS + RHS times.  If op is "Xor" for example then the combined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">/// X occurring LHS + RHS times.  If op is "Xor" for example then the combined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">/// operation is equivalent to X if LHS + RHS is odd, or 0 if LHS + RHS is even;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">/// operation is equivalent to X if LHS + RHS is odd, or 0 if LHS + RHS is even;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">/// the routine returns 1 in LHS in the first case, and 0 in LHS in the second.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">/// the routine returns 1 in LHS in the first case, and 0 in LHS in the second.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">static void IncorporateWeight(APInt &LHS, const APInt &RHS, unsigned Opcode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">static void IncorporateWeight(APInt &LHS, const APInt &RHS, unsigned Opcode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">  // If we were working with infinite precision arithmetic then the combined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">  // If we were working with infinite precision arithmetic then the combined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">  // weight would be LHS + RHS.  But we are using finite precision arithmetic,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">  // weight would be LHS + RHS.  But we are using finite precision arithmetic,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">  // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">  // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">  // for nilpotent operations and addition, but not for idempotent operations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">  // for nilpotent operations and addition, but not for idempotent operations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">  // and multiplication), so it is important to correctly reduce the combined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">  // and multiplication), so it is important to correctly reduce the combined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">  // weight back into range if wrapping would be wrong.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">  // weight back into range if wrapping would be wrong.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">  // If RHS is zero then the weight didn't change.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">  // If RHS is zero then the weight didn't change.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">  if (RHS.isMinValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">  if (RHS.isMinValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  // If LHS is zero then the combined weight is RHS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  // If LHS is zero then the combined weight is RHS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">  if (LHS.isMinValue()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">  if (LHS.isMinValue()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">    LHS = RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">    LHS = RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">  // From this point on we know that neither LHS nor RHS is zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">  // From this point on we know that neither LHS nor RHS is zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">  if (Instruction::isIdempotent(Opcode)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">  if (Instruction::isIdempotent(Opcode)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">    // Idempotent means X op X === X, so any non-zero weight is equivalent to a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">    // Idempotent means X op X === X, so any non-zero weight is equivalent to a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">    // weight of 1.  Keeping weights at zero or one also means that wrapping is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">    // weight of 1.  Keeping weights at zero or one also means that wrapping is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">    // not a problem.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">    // not a problem.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">    assert(LHS == 1 && RHS == 1 && "Weights not reduced!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">    assert(LHS == 1 && RHS == 1 && "Weights not reduced!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">    return; // Return a weight of 1.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">    return; // Return a weight of 1.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">  if (Instruction::isNilpotent(Opcode)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">  if (Instruction::isNilpotent(Opcode)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">    // Nilpotent means X op X === 0, so reduce weights modulo 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">    // Nilpotent means X op X === 0, so reduce weights modulo 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">    assert(LHS == 1 && RHS == 1 && "Weights not reduced!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">    assert(LHS == 1 && RHS == 1 && "Weights not reduced!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">    LHS = 0; // 1 + 1 === 0 modulo 2.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">    LHS = 0; // 1 + 1 === 0 modulo 2.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">  if (Opcode == Instruction::Add || Opcode == Instruction::FAdd) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">  if (Opcode == Instruction::Add || Opcode == Instruction::FAdd) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">    // TODO: Reduce the weight by exploiting nsw/nuw?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">    // TODO: Reduce the weight by exploiting nsw/nuw?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">    LHS += RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">    LHS += RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">  assert((Opcode == Instruction::Mul || Opcode == Instruction::FMul) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">  assert((Opcode == Instruction::Mul || Opcode == Instruction::FMul) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">         "Unknown associative operation!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">         "Unknown associative operation!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">  unsigned Bitwidth = LHS.getBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">  unsigned Bitwidth = LHS.getBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">  // If CM is the Carmichael number then a weight W satisfying W >= CM+Bitwidth</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">  // If CM is the Carmichael number then a weight W satisfying W >= CM+Bitwidth</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">  // can be replaced with W-CM.  That's because x^W=x^(W-CM) for every Bitwidth</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">  // can be replaced with W-CM.  That's because x^W=x^(W-CM) for every Bitwidth</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">  // bit number x, since either x is odd in which case x^CM = 1, or x is even in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">  // bit number x, since either x is odd in which case x^CM = 1, or x is even in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">  // which case both x^W and x^(W - CM) are zero.  By subtracting off multiples</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">  // which case both x^W and x^(W - CM) are zero.  By subtracting off multiples</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">  // of CM like this weights can always be reduced to the range [0, CM+Bitwidth)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">  // of CM like this weights can always be reduced to the range [0, CM+Bitwidth)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">  // which by a happy accident means that they can always be represented using</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">  // which by a happy accident means that they can always be represented using</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">  // Bitwidth bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">  // Bitwidth bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">  // TODO: Reduce the weight by exploiting nsw/nuw?  (Could do much better than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">  // TODO: Reduce the weight by exploiting nsw/nuw?  (Could do much better than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">  // the Carmichael number).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">  // the Carmichael number).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">  if (Bitwidth > 3) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">  if (Bitwidth > 3) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">    /// CM - The value of Carmichael's lambda function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">    /// CM - The value of Carmichael's lambda function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">    APInt CM = APInt::getOneBitSet(Bitwidth, CarmichaelShift(Bitwidth));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">    APInt CM = APInt::getOneBitSet(Bitwidth, CarmichaelShift(Bitwidth));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">    // Any weight W >= Threshold can be replaced with W - CM.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">    // Any weight W >= Threshold can be replaced with W - CM.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">    APInt Threshold = CM + Bitwidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">    APInt Threshold = CM + Bitwidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">    assert(LHS.ult(Threshold) && RHS.ult(Threshold) && "Weights not reduced!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">    assert(LHS.ult(Threshold) && RHS.ult(Threshold) && "Weights not reduced!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">    // For Bitwidth 4 or more the following sum does not overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">    // For Bitwidth 4 or more the following sum does not overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">    LHS += RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">    LHS += RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">    while (LHS.uge(Threshold))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">    while (LHS.uge(Threshold))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">      LHS -= CM;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">      LHS -= CM;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">    // To avoid problems with overflow do everything the same as above but using</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">    // To avoid problems with overflow do everything the same as above but using</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">    // a larger type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">    // a larger type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">    unsigned CM = 1U << CarmichaelShift(Bitwidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">    unsigned CM = 1U << CarmichaelShift(Bitwidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">    unsigned Threshold = CM + Bitwidth;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">    unsigned Threshold = CM + Bitwidth;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">    assert(LHS.getZExtValue() < Threshold && RHS.getZExtValue() < Threshold &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">    assert(LHS.getZExtValue() < Threshold && RHS.getZExtValue() < Threshold &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">           "Weights not reduced!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">           "Weights not reduced!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">    unsigned Total = LHS.getZExtValue() + RHS.getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">    unsigned Total = LHS.getZExtValue() + RHS.getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">    while (Total >= Threshold)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">    while (Total >= Threshold)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">      Total -= CM;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">      Total -= CM;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">    LHS = Total;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">    LHS = Total;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">using RepeatedValue = std::pair<Value*, APInt>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">using RepeatedValue = std::pair<Value*, APInt>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">/// Given an associative binary expression, return the leaf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">/// Given an associative binary expression, return the leaf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">/// nodes in Ops along with their weights (how many times the leaf occurs).  The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">/// nodes in Ops along with their weights (how many times the leaf occurs).  The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">/// original expression is the same as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">/// original expression is the same as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">///   (Ops[0].first op Ops[0].first op ... Ops[0].first)  <- Ops[0].second times</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">///   (Ops[0].first op Ops[0].first op ... Ops[0].first)  <- Ops[0].second times</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">/// op</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">/// op</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">///   (Ops[1].first op Ops[1].first op ... Ops[1].first)  <- Ops[1].second times</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">///   (Ops[1].first op Ops[1].first op ... Ops[1].first)  <- Ops[1].second times</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">/// op</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">/// op</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">///   ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">///   ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">/// op</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">/// op</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">///   (Ops[N].first op Ops[N].first op ... Ops[N].first)  <- Ops[N].second times</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">///   (Ops[N].first op Ops[N].first op ... Ops[N].first)  <- Ops[N].second times</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">/// Note that the values Ops[0].first, ..., Ops[N].first are all distinct.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">/// Note that the values Ops[0].first, ..., Ops[N].first are all distinct.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">/// This routine may modify the function, in which case it returns 'true'.  The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">/// This routine may modify the function, in which case it returns 'true'.  The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">/// changes it makes may well be destructive, changing the value computed by 'I'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">/// changes it makes may well be destructive, changing the value computed by 'I'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">/// to something completely different.  Thus if the routine returns 'true' then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">/// to something completely different.  Thus if the routine returns 'true' then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">/// you MUST either replace I with a new expression computed from the Ops array,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">/// you MUST either replace I with a new expression computed from the Ops array,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">/// or use RewriteExprTree to put the values back in.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">/// or use RewriteExprTree to put the values back in.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">/// A leaf node is either not a binary operation of the same kind as the root</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">/// A leaf node is either not a binary operation of the same kind as the root</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">/// node 'I' (i.e. is not a binary operator at all, or is, but with a different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">/// node 'I' (i.e. is not a binary operator at all, or is, but with a different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">/// opcode), or is the same kind of binary operator but has a use which either</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">/// opcode), or is the same kind of binary operator but has a use which either</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">/// does not belong to the expression, or does belong to the expression but is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">/// does not belong to the expression, or does belong to the expression but is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">/// a leaf node.  Every leaf node has at least one use that is a non-leaf node</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">/// a leaf node.  Every leaf node has at least one use that is a non-leaf node</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">/// of the expression, while for non-leaf nodes (except for the root 'I') every</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">/// of the expression, while for non-leaf nodes (except for the root 'I') every</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">/// use is a non-leaf node of the expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">/// use is a non-leaf node of the expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">/// For example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">/// For example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">///           expression graph        node names</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">///           expression graph        node names</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">///                     +        |        I</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">///                     +        |        I</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">///                    / \       |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">///                    / \       |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">///                   +   +      |      A,  B</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">///                   +   +      |      A,  B</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">///                  / \ / \     |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">///                  / \ / \     |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">///                 *   +   *    |    C,  D,  E</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">///                 *   +   *    |    C,  D,  E</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">///                / \ / \ / \   |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">///                / \ / \ / \   |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">///                   +   *      |      F,  G</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">///                   +   *      |      F,  G</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">/// The leaf nodes are C, E, F and G.  The Ops array will contain (maybe not in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">/// The leaf nodes are C, E, F and G.  The Ops array will contain (maybe not in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">/// that order) (C, 1), (E, 1), (F, 2), (G, 2).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">/// that order) (C, 1), (E, 1), (F, 2), (G, 2).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">/// The expression is maximal: if some instruction is a binary operator of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">/// The expression is maximal: if some instruction is a binary operator of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">/// same kind as 'I', and all of its uses are non-leaf nodes of the expression,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">/// same kind as 'I', and all of its uses are non-leaf nodes of the expression,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">/// then the instruction also belongs to the expression, is not a leaf node of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">/// then the instruction also belongs to the expression, is not a leaf node of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">/// it, and its operands also belong to the expression (but may be leaf nodes).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">/// it, and its operands also belong to the expression (but may be leaf nodes).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">/// NOTE: This routine will set operands of non-leaf non-root nodes to undef in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">/// NOTE: This routine will set operands of non-leaf non-root nodes to undef in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">/// order to ensure that every non-root node in the expression has *exactly one*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">/// order to ensure that every non-root node in the expression has *exactly one*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">/// use by a non-leaf node of the expression.  This destruction means that the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">/// use by a non-leaf node of the expression.  This destruction means that the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">/// caller MUST either replace 'I' with a new expression or use something like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">/// caller MUST either replace 'I' with a new expression or use something like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">/// RewriteExprTree to put the values back in if the routine indicates that it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">/// RewriteExprTree to put the values back in if the routine indicates that it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">/// made a change by returning 'true'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">/// made a change by returning 'true'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">/// In the above example either the right operand of A or the left operand of B</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">/// In the above example either the right operand of A or the left operand of B</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">/// will be replaced by undef.  If it is B's operand then this gives:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">/// will be replaced by undef.  If it is B's operand then this gives:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">///                     +        |        I</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">///                     +        |        I</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">///                    / \       |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">///                    / \       |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">///                   +   +      |      A,  B - operand of B replaced with undef</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">///                   +   +      |      A,  B - operand of B replaced with undef</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">///                  / \   \     |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">///                  / \   \     |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">///                 *   +   *    |    C,  D,  E</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">///                 *   +   *    |    C,  D,  E</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">///                / \ / \ / \   |</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">///                / \ / \ / \   |</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">///                   +   *      |      F,  G</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">///                   +   *      |      F,  G</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">/// Note that such undef operands can only be reached by passing through 'I'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">/// Note that such undef operands can only be reached by passing through 'I'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">/// For example, if you visit operands recursively starting from a leaf node</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">/// For example, if you visit operands recursively starting from a leaf node</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">/// then you will never see such an undef operand unless you get back to 'I',</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">/// then you will never see such an undef operand unless you get back to 'I',</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">/// which requires passing through a phi node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">/// which requires passing through a phi node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">/// Note that this routine may also mutate binary operators of the wrong type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">/// Note that this routine may also mutate binary operators of the wrong type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">/// that have all uses inside the expression (i.e. only used by non-leaf nodes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">/// that have all uses inside the expression (i.e. only used by non-leaf nodes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">/// of the expression) if it can turn them into binary operators of the right</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">/// of the expression) if it can turn them into binary operators of the right</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">/// type and thus make the expression bigger.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">/// type and thus make the expression bigger.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">static bool LinearizeExprTree(Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">static bool LinearizeExprTree(Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">                              SmallVectorImpl<RepeatedValue> &Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">                              SmallVectorImpl<RepeatedValue> &Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">                              ReassociatePass::OrderedSet &ToRedo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">                              ReassociatePass::OrderedSet &ToRedo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">  assert((isa<UnaryOperator>(I) || isa<BinaryOperator>(I)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">  assert((isa<UnaryOperator>(I) || isa<BinaryOperator>(I)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">         "Expected a UnaryOperator or BinaryOperator!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">         "Expected a UnaryOperator or BinaryOperator!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LINEARIZE: " << *I << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "LINEARIZE: " << *I << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  unsigned Bitwidth = I->getType()->getScalarType()->getPrimitiveSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  unsigned Bitwidth = I->getType()->getScalarType()->getPrimitiveSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  unsigned Opcode = I->getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  unsigned Opcode = I->getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  assert(I->isAssociative() && I->isCommutative() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  assert(I->isAssociative() && I->isCommutative() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">         "Expected an associative and commutative operation!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">         "Expected an associative and commutative operation!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  // Visit all operands of the expression, keeping track of their weight (the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  // Visit all operands of the expression, keeping track of their weight (the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  // number of paths from the expression root to the operand, or if you like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  // number of paths from the expression root to the operand, or if you like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">  // the number of times that operand occurs in the linearized expression).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">  // the number of times that operand occurs in the linearized expression).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">  // For example, if I = X + A, where X = A + B, then I, X and B have weight 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">  // For example, if I = X + A, where X = A + B, then I, X and B have weight 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">  // while A has weight two.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">  // while A has weight two.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">  // Worklist of non-leaf nodes (their operands are in the expression too) along</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">  // Worklist of non-leaf nodes (their operands are in the expression too) along</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">  // with their weights, representing a certain number of paths to the operator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">  // with their weights, representing a certain number of paths to the operator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  // If an operator occurs in the worklist multiple times then we found multiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  // If an operator occurs in the worklist multiple times then we found multiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  // ways to get to it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  // ways to get to it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">  SmallVector<std::pair<Instruction*, APInt>, 8> Worklist; // (Op, Weight)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">  SmallVector<std::pair<Instruction*, APInt>, 8> Worklist; // (Op, Weight)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">  Worklist.push_back(std::make_pair(I, APInt(Bitwidth, 1)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">  Worklist.push_back(std::make_pair(I, APInt(Bitwidth, 1)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">  // Leaves of the expression are values that either aren't the right kind of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">  // Leaves of the expression are values that either aren't the right kind of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  // operation (eg: a constant, or a multiply in an add tree), or are, but have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  // operation (eg: a constant, or a multiply in an add tree), or are, but have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  // some uses that are not inside the expression.  For example, in I = X + X,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  // some uses that are not inside the expression.  For example, in I = X + X,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">  // X = A + B, the value X has two uses (by I) that are in the expression.  If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">  // X = A + B, the value X has two uses (by I) that are in the expression.  If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  // X has any other uses, for example in a return instruction, then we consider</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  // X has any other uses, for example in a return instruction, then we consider</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">  // X to be a leaf, and won't analyze it further.  When we first visit a value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">  // X to be a leaf, and won't analyze it further.  When we first visit a value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">  // if it has more than one use then at first we conservatively consider it to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">  // if it has more than one use then at first we conservatively consider it to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">  // be a leaf.  Later, as the expression is explored, we may discover some more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">  // be a leaf.  Later, as the expression is explored, we may discover some more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">  // uses of the value from inside the expression.  If all uses turn out to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">  // uses of the value from inside the expression.  If all uses turn out to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">  // from within the expression (and the value is a binary operator of the right</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">  // from within the expression (and the value is a binary operator of the right</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">  // kind) then the value is no longer considered to be a leaf, and its operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">  // kind) then the value is no longer considered to be a leaf, and its operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">  // are explored.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">  // are explored.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">  // Leaves - Keeps track of the set of putative leaves as well as the number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">  // Leaves - Keeps track of the set of putative leaves as well as the number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">  // paths to each leaf seen so far.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">  // paths to each leaf seen so far.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">  using LeafMap = DenseMap<Value *, APInt>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">  using LeafMap = DenseMap<Value *, APInt>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">  LeafMap Leaves; // Leaf -> Total weight so far.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">  LeafMap Leaves; // Leaf -> Total weight so far.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  SmallVector<Value *, 8> LeafOrder; // Ensure deterministic leaf output order.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  SmallVector<Value *, 8> LeafOrder; // Ensure deterministic leaf output order.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  SmallPtrSet<Value *, 8> Visited; // For checking the iteration scheme.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  SmallPtrSet<Value *, 8> Visited; // For checking the iteration scheme.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">    std::pair<Instruction*, APInt> P = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">    std::pair<Instruction*, APInt> P = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">    I = P.first; // We examine the operands of this binary operator.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">    I = P.first; // We examine the operands of this binary operator.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">    for (unsigned OpIdx = 0; OpIdx < I->getNumOperands(); ++OpIdx) { // Visit operands.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">    for (unsigned OpIdx = 0; OpIdx < I->getNumOperands(); ++OpIdx) { // Visit operands.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">      Value *Op = I->getOperand(OpIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">      Value *Op = I->getOperand(OpIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">      APInt Weight = P.second; // Number of paths to this operand.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">      APInt Weight = P.second; // Number of paths to this operand.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "OPERAND: " << *Op << " (" << Weight << ")\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "OPERAND: " << *Op << " (" << Weight << ")\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">      assert(!Op->use_empty() && "No uses, so how did we get to it?!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">      assert(!Op->use_empty() && "No uses, so how did we get to it?!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">      // If this is a binary operation of the right kind with only one use then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">      // If this is a binary operation of the right kind with only one use then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">      // add its operands to the expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">      // add its operands to the expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">      if (BinaryOperator *BO = isReassociableOp(Op, Opcode)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">      if (BinaryOperator *BO = isReassociableOp(Op, Opcode)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">        assert(Visited.insert(Op).second && "Not first visit!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">        assert(Visited.insert(Op).second && "Not first visit!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "DIRECT ADD: " << *Op << " (" << Weight << ")\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "DIRECT ADD: " << *Op << " (" << Weight << ")\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">        Worklist.push_back(std::make_pair(BO, Weight));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">        Worklist.push_back(std::make_pair(BO, Weight));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">      // Appears to be a leaf.  Is the operand already in the set of leaves?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">      // Appears to be a leaf.  Is the operand already in the set of leaves?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">      LeafMap::iterator It = Leaves.find(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">      LeafMap::iterator It = Leaves.find(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">      if (It == Leaves.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">      if (It == Leaves.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">        // Not in the leaf map.  Must be the first time we saw this operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">        // Not in the leaf map.  Must be the first time we saw this operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">        assert(Visited.insert(Op).second && "Not first visit!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">        assert(Visited.insert(Op).second && "Not first visit!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">        if (!Op->hasOneUse()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">        if (!Op->hasOneUse()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">          // This value has uses not accounted for by the expression, so it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">          // This value has uses not accounted for by the expression, so it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">          // not safe to modify.  Mark it as being a leaf.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">          // not safe to modify.  Mark it as being a leaf.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">                     << "ADD USES LEAF: " << *Op << " (" << Weight << ")\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">                     << "ADD USES LEAF: " << *Op << " (" << Weight << ")\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">          LeafOrder.push_back(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">          LeafOrder.push_back(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">          Leaves[Op] = Weight;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">          Leaves[Op] = Weight;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">        // No uses outside the expression, try morphing it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">        // No uses outside the expression, try morphing it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">        // Already in the leaf map.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">        // Already in the leaf map.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">        assert(It != Leaves.end() && Visited.count(Op) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">        assert(It != Leaves.end() && Visited.count(Op) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">               "In leaf map but not visited!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">               "In leaf map but not visited!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">        // Update the number of paths to the leaf.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">        // Update the number of paths to the leaf.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">        IncorporateWeight(It->second, Weight, Opcode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">        IncorporateWeight(It->second, Weight, Opcode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">#if 0   // TODO: Re-enable once PR13021 is fixed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">#if 0   // TODO: Re-enable once PR13021 is fixed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">        // The leaf already has one use from inside the expression.  As we want</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">        // The leaf already has one use from inside the expression.  As we want</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">        // exactly one such use, drop this new use of the leaf.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">        // exactly one such use, drop this new use of the leaf.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">        assert(!Op->hasOneUse() && "Only one use, but we got here twice!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">        assert(!Op->hasOneUse() && "Only one use, but we got here twice!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">        I->setOperand(OpIdx, UndefValue::get(I->getType()));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">        I->setOperand(OpIdx, UndefValue::get(I->getType()));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">        Changed = true;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">        Changed = true;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">        // If the leaf is a binary operation of the right kind and we now see</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">        // If the leaf is a binary operation of the right kind and we now see</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">        // that its multiple original uses were in fact all by nodes belonging</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">        // that its multiple original uses were in fact all by nodes belonging</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">        // to the expression, then no longer consider it to be a leaf and add</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">        // to the expression, then no longer consider it to be a leaf and add</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">        // its operands to the expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">        // its operands to the expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">        if (BinaryOperator *BO = isReassociableOp(Op, Opcode)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">        if (BinaryOperator *BO = isReassociableOp(Op, Opcode)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << "UNLEAF: " << *Op << " (" << It->second << ")\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << "UNLEAF: " << *Op << " (" << It->second << ")\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">          Worklist.push_back(std::make_pair(BO, It->second));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">          Worklist.push_back(std::make_pair(BO, It->second));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">          Leaves.erase(It);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">          Leaves.erase(It);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">        // If we still have uses that are not accounted for by the expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">        // If we still have uses that are not accounted for by the expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">        // then it is not safe to modify the value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">        // then it is not safe to modify the value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">        if (!Op->hasOneUse())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">        if (!Op->hasOneUse())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">        // No uses outside the expression, try morphing it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">        // No uses outside the expression, try morphing it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">        Weight = It->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">        Weight = It->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">        Leaves.erase(It); // Since the value may be morphed below.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">        Leaves.erase(It); // Since the value may be morphed below.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">      // At this point we have a value which, first of all, is not a binary</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">      // At this point we have a value which, first of all, is not a binary</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">      // expression of the right kind, and secondly, is only used inside the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">      // expression of the right kind, and secondly, is only used inside the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">      // expression.  This means that it can safely be modified.  See if we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">      // expression.  This means that it can safely be modified.  See if we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">      // can usefully morph it into an expression of the right kind.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">      // can usefully morph it into an expression of the right kind.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">      assert((!isa<Instruction>(Op) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">      assert((!isa<Instruction>(Op) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">              cast<Instruction>(Op)->getOpcode() != Opcode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">              cast<Instruction>(Op)->getOpcode() != Opcode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">              || (isa<FPMathOperator>(Op) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">              || (isa<FPMathOperator>(Op) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">                  !hasFPAssociativeFlags(cast<Instruction>(Op)))) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">                  !hasFPAssociativeFlags(cast<Instruction>(Op)))) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">             "Should have been handled above!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">             "Should have been handled above!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">      assert(Op->hasOneUse() && "Has uses outside the expression tree!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">      assert(Op->hasOneUse() && "Has uses outside the expression tree!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">      // If this is a multiply expression, turn any internal negations into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">      // If this is a multiply expression, turn any internal negations into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">      // multiplies by -1 so they can be reassociated.  Add any users of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">      // multiplies by -1 so they can be reassociated.  Add any users of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">      // newly created multiplication by -1 to the redo list, so any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">      // newly created multiplication by -1 to the redo list, so any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">      // reassociation opportunities that are exposed will be reassociated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">      // reassociation opportunities that are exposed will be reassociated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">      // further.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">      // further.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">      Instruction *Neg;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">      Instruction *Neg;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">      if (((Opcode == Instruction::Mul && match(Op, m_Neg(m_Value()))) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">      if (((Opcode == Instruction::Mul && match(Op, m_Neg(m_Value()))) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">           (Opcode == Instruction::FMul && match(Op, m_FNeg(m_Value())))) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">           (Opcode == Instruction::FMul && match(Op, m_FNeg(m_Value())))) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">           match(Op, m_Instruction(Neg))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">           match(Op, m_Instruction(Neg))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">                   << "MORPH LEAF: " << *Op << " (" << Weight << ") TO ");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">                   << "MORPH LEAF: " << *Op << " (" << Weight << ") TO ");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">        Instruction *Mul = LowerNegateToMultiply(Neg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">        Instruction *Mul = LowerNegateToMultiply(Neg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << *Mul << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << *Mul << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">        Worklist.push_back(std::make_pair(Mul, Weight));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">        Worklist.push_back(std::make_pair(Mul, Weight));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">        for (User *U : Mul->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">        for (User *U : Mul->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">          if (BinaryOperator *UserBO = dyn_cast<BinaryOperator>(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">          if (BinaryOperator *UserBO = dyn_cast<BinaryOperator>(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">            ToRedo.insert(UserBO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">            ToRedo.insert(UserBO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">        ToRedo.insert(Neg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">        ToRedo.insert(Neg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">        Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">        Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">      // Failed to morph into an expression of the right type.  This really is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">      // Failed to morph into an expression of the right type.  This really is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">      // a leaf.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">      // a leaf.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "ADD LEAF: " << *Op << " (" << Weight << ")\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "ADD LEAF: " << *Op << " (" << Weight << ")\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">      assert(!isReassociableOp(Op, Opcode) && "Value was morphed?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">      assert(!isReassociableOp(Op, Opcode) && "Value was morphed?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">      LeafOrder.push_back(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">      LeafOrder.push_back(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">      Leaves[Op] = Weight;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">      Leaves[Op] = Weight;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">  // The leaves, repeated according to their weights, represent the linearized</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">  // The leaves, repeated according to their weights, represent the linearized</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">  // form of the expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">  // form of the expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">  for (Value *V : LeafOrder) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">  for (Value *V : LeafOrder) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">    LeafMap::iterator It = Leaves.find(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">    LeafMap::iterator It = Leaves.find(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">    if (It == Leaves.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">    if (It == Leaves.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">      // Node initially thought to be a leaf wasn't.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">      // Node initially thought to be a leaf wasn't.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">    assert(!isReassociableOp(V, Opcode) && "Shouldn't be a leaf!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">    assert(!isReassociableOp(V, Opcode) && "Shouldn't be a leaf!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">    APInt Weight = It->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">    APInt Weight = It->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">    if (Weight.isMinValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">    if (Weight.isMinValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">      // Leaf already output or weight reduction eliminated it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">      // Leaf already output or weight reduction eliminated it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">    // Ensure the leaf is only output once.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">    // Ensure the leaf is only output once.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">    It->second = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">    It->second = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">    Ops.push_back(std::make_pair(V, Weight));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">    Ops.push_back(std::make_pair(V, Weight));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  // For nilpotent operations or addition there may be no operands, for example</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  // For nilpotent operations or addition there may be no operands, for example</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">  // because the expression was "X xor X" or consisted of 2^Bitwidth additions:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">  // because the expression was "X xor X" or consisted of 2^Bitwidth additions:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  // in both cases the weight reduces to 0 causing the value to be skipped.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  // in both cases the weight reduces to 0 causing the value to be skipped.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">  if (Ops.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">  if (Ops.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">    Constant *Identity = ConstantExpr::getBinOpIdentity(Opcode, I->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">    Constant *Identity = ConstantExpr::getBinOpIdentity(Opcode, I->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">    assert(Identity && "Associative operation without identity!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">    assert(Identity && "Associative operation without identity!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">    Ops.emplace_back(Identity, APInt(Bitwidth, 1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">    Ops.emplace_back(Identity, APInt(Bitwidth, 1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">/// Now that the operands for this expression tree are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">/// Now that the operands for this expression tree are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">/// linearized and optimized, emit them in-order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">/// linearized and optimized, emit them in-order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">void ReassociatePass::RewriteExprTree(BinaryOperator *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">void ReassociatePass::RewriteExprTree(BinaryOperator *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">                                      SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">                                      SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">  assert(Ops.size() > 1 && "Single values should be used directly!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">  assert(Ops.size() > 1 && "Single values should be used directly!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">  // Since our optimizations should never increase the number of operations, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">  // Since our optimizations should never increase the number of operations, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">  // new expression can usually be written reusing the existing binary operators</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">  // new expression can usually be written reusing the existing binary operators</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">  // from the original expression tree, without creating any new instructions,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">  // from the original expression tree, without creating any new instructions,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  // though the rewritten expression may have a completely different topology.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  // though the rewritten expression may have a completely different topology.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  // We take care to not change anything if the new expression will be the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  // We take care to not change anything if the new expression will be the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">  // as the original.  If more than trivial changes (like commuting operands)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">  // as the original.  If more than trivial changes (like commuting operands)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">  // were made then we are obliged to clear out any optional subclass data like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">  // were made then we are obliged to clear out any optional subclass data like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">  // nsw flags.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">  // nsw flags.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">  /// NodesToRewrite - Nodes from the original expression available for writing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">  /// NodesToRewrite - Nodes from the original expression available for writing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  /// the new expression into.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  /// the new expression into.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  SmallVector<BinaryOperator*, 8> NodesToRewrite;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  SmallVector<BinaryOperator*, 8> NodesToRewrite;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">  unsigned Opcode = I->getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">  unsigned Opcode = I->getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">  BinaryOperator *Op = I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">  BinaryOperator *Op = I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">  /// NotRewritable - The operands being written will be the leaves of the new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">  /// NotRewritable - The operands being written will be the leaves of the new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  /// expression and must not be used as inner nodes (via NodesToRewrite) by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  /// expression and must not be used as inner nodes (via NodesToRewrite) by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">  /// mistake.  Inner nodes are always reassociable, and usually leaves are not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">  /// mistake.  Inner nodes are always reassociable, and usually leaves are not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">  /// (if they were they would have been incorporated into the expression and so</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">  /// (if they were they would have been incorporated into the expression and so</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">  /// would not be leaves), so most of the time there is no danger of this.  But</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">  /// would not be leaves), so most of the time there is no danger of this.  But</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">  /// in rare cases a leaf may become reassociable if an optimization kills uses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">  /// in rare cases a leaf may become reassociable if an optimization kills uses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  /// of it, or it may momentarily become reassociable during rewriting (below)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  /// of it, or it may momentarily become reassociable during rewriting (below)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">  /// due it being removed as an operand of one of its uses.  Ensure that misuse</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">  /// due it being removed as an operand of one of its uses.  Ensure that misuse</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  /// of leaf nodes as inner nodes cannot occur by remembering all of the future</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  /// of leaf nodes as inner nodes cannot occur by remembering all of the future</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">  /// leaves and refusing to reuse any of them as inner nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">  /// leaves and refusing to reuse any of them as inner nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">  SmallPtrSet<Value*, 8> NotRewritable;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">  SmallPtrSet<Value*, 8> NotRewritable;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">    NotRewritable.insert(Ops[i].Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">    NotRewritable.insert(Ops[i].Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  // ExpressionChangedStart - Non-null if the rewritten expression differs from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  // ExpressionChangedStart - Non-null if the rewritten expression differs from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  // the original in some non-trivial way, requiring the clearing of optional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  // the original in some non-trivial way, requiring the clearing of optional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  // flags. Flags are cleared from the operator in ExpressionChangedStart up to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  // flags. Flags are cleared from the operator in ExpressionChangedStart up to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">  // ExpressionChangedEnd inclusive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">  // ExpressionChangedEnd inclusive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">  BinaryOperator *ExpressionChangedStart = nullptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">  BinaryOperator *ExpressionChangedStart = nullptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">                 *ExpressionChangedEnd = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">                 *ExpressionChangedEnd = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  for (unsigned i = 0; ; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  for (unsigned i = 0; ; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">    // The last operation (which comes earliest in the IR) is special as both</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">    // The last operation (which comes earliest in the IR) is special as both</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">    // operands will come from Ops, rather than just one with the other being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">    // operands will come from Ops, rather than just one with the other being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">    // a subexpression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">    // a subexpression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">    if (i+2 == Ops.size()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">    if (i+2 == Ops.size()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">      Value *NewLHS = Ops[i].Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">      Value *NewLHS = Ops[i].Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">      Value *NewRHS = Ops[i+1].Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">      Value *NewRHS = Ops[i+1].Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">      Value *OldLHS = Op->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">      Value *OldLHS = Op->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">      Value *OldRHS = Op->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">      Value *OldRHS = Op->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">      if (NewLHS == OldLHS && NewRHS == OldRHS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">      if (NewLHS == OldLHS && NewRHS == OldRHS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">        // Nothing changed, leave it alone.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">        // Nothing changed, leave it alone.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">      if (NewLHS == OldRHS && NewRHS == OldLHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">      if (NewLHS == OldRHS && NewRHS == OldLHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">        // The order of the operands was reversed.  Swap them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">        // The order of the operands was reversed.  Swap them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">        Op->swapOperands();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">        Op->swapOperands();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">        MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">        MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">        ++NumChanged;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">        ++NumChanged;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">      // The new operation differs non-trivially from the original. Overwrite</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">      // The new operation differs non-trivially from the original. Overwrite</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">      // the old operands with the new ones.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">      // the old operands with the new ones.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">      if (NewLHS != OldLHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">      if (NewLHS != OldLHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">        BinaryOperator *BO = isReassociableOp(OldLHS, Opcode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">        BinaryOperator *BO = isReassociableOp(OldLHS, Opcode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">        if (BO && !NotRewritable.count(BO))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">        if (BO && !NotRewritable.count(BO))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">          NodesToRewrite.push_back(BO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">          NodesToRewrite.push_back(BO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">        Op->setOperand(0, NewLHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">        Op->setOperand(0, NewLHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">      if (NewRHS != OldRHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">      if (NewRHS != OldRHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">        BinaryOperator *BO = isReassociableOp(OldRHS, Opcode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">        BinaryOperator *BO = isReassociableOp(OldRHS, Opcode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">        if (BO && !NotRewritable.count(BO))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">        if (BO && !NotRewritable.count(BO))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">          NodesToRewrite.push_back(BO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">          NodesToRewrite.push_back(BO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">        Op->setOperand(1, NewRHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">        Op->setOperand(1, NewRHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">      ExpressionChangedStart = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">      ExpressionChangedStart = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">      if (!ExpressionChangedEnd)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">      if (!ExpressionChangedEnd)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">        ExpressionChangedEnd = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">        ExpressionChangedEnd = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">      ++NumChanged;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">      ++NumChanged;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">    // Not the last operation.  The left-hand side will be a sub-expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">    // Not the last operation.  The left-hand side will be a sub-expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">    // while the right-hand side will be the current element of Ops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">    // while the right-hand side will be the current element of Ops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">    Value *NewRHS = Ops[i].Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">    Value *NewRHS = Ops[i].Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">    if (NewRHS != Op->getOperand(1)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">    if (NewRHS != Op->getOperand(1)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">      if (NewRHS == Op->getOperand(0)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">      if (NewRHS == Op->getOperand(0)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">        // The new right-hand side was already present as the left operand.  If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">        // The new right-hand side was already present as the left operand.  If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">        // we are lucky then swapping the operands will sort out both of them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">        // we are lucky then swapping the operands will sort out both of them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">        Op->swapOperands();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">        Op->swapOperands();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">        // Overwrite with the new right-hand side.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">        // Overwrite with the new right-hand side.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">        BinaryOperator *BO = isReassociableOp(Op->getOperand(1), Opcode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">        BinaryOperator *BO = isReassociableOp(Op->getOperand(1), Opcode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">        if (BO && !NotRewritable.count(BO))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">        if (BO && !NotRewritable.count(BO))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">          NodesToRewrite.push_back(BO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">          NodesToRewrite.push_back(BO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">        Op->setOperand(1, NewRHS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">        Op->setOperand(1, NewRHS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">        ExpressionChangedStart = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">        ExpressionChangedStart = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">        if (!ExpressionChangedEnd)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">        if (!ExpressionChangedEnd)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">          ExpressionChangedEnd = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">          ExpressionChangedEnd = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">      ++NumChanged;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">      ++NumChanged;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">    // Now deal with the left-hand side.  If this is already an operation node</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">    // Now deal with the left-hand side.  If this is already an operation node</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">    // from the original expression then just rewrite the rest of the expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">    // from the original expression then just rewrite the rest of the expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">    // into it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">    // into it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">    BinaryOperator *BO = isReassociableOp(Op->getOperand(0), Opcode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">    BinaryOperator *BO = isReassociableOp(Op->getOperand(0), Opcode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">    if (BO && !NotRewritable.count(BO)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">    if (BO && !NotRewritable.count(BO)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">      Op = BO;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">      Op = BO;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">    // Otherwise, grab a spare node from the original expression and use that as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">    // Otherwise, grab a spare node from the original expression and use that as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">    // the left-hand side.  If there are no nodes left then the optimizers made</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">    // the left-hand side.  If there are no nodes left then the optimizers made</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">    // an expression with more nodes than the original!  This usually means that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">    // an expression with more nodes than the original!  This usually means that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">    // they did something stupid but it might mean that the problem was just too</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">    // they did something stupid but it might mean that the problem was just too</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">    // hard (finding the mimimal number of multiplications needed to realize a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">    // hard (finding the mimimal number of multiplications needed to realize a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">    // multiplication expression is NP-complete).  Whatever the reason, smart or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">    // multiplication expression is NP-complete).  Whatever the reason, smart or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">    // stupid, create a new node if there are none left.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">    // stupid, create a new node if there are none left.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">    BinaryOperator *NewOp;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">    BinaryOperator *NewOp;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">    if (NodesToRewrite.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">    if (NodesToRewrite.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">      Constant *Undef = UndefValue::get(I->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">      Constant *Undef = UndefValue::get(I->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">      NewOp = BinaryOperator::Create(Instruction::BinaryOps(Opcode),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">      NewOp = BinaryOperator::Create(Instruction::BinaryOps(Opcode),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">                                     Undef, Undef, "", I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">                                     Undef, Undef, "", I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">      if (isa<FPMathOperator>(NewOp))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">      if (isa<FPMathOperator>(NewOp))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">        NewOp->setFastMathFlags(I->getFastMathFlags());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">        NewOp->setFastMathFlags(I->getFastMathFlags());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">      NewOp = NodesToRewrite.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">      NewOp = NodesToRewrite.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "RA: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">    Op->setOperand(0, NewOp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">    Op->setOperand(0, NewOp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "TO: " << *Op << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">    ExpressionChangedStart = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">    ExpressionChangedStart = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">    if (!ExpressionChangedEnd)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">    if (!ExpressionChangedEnd)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">      ExpressionChangedEnd = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">      ExpressionChangedEnd = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">    MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">    MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">    ++NumChanged;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">    ++NumChanged;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">    Op = NewOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">    Op = NewOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">  // If the expression changed non-trivially then clear out all subclass data</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">  // If the expression changed non-trivially then clear out all subclass data</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  // starting from the operator specified in ExpressionChanged, and compactify</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  // starting from the operator specified in ExpressionChanged, and compactify</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">  // the operators to just before the expression root to guarantee that the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">  // the operators to just before the expression root to guarantee that the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">  // expression tree is dominated by all of Ops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">  // expression tree is dominated by all of Ops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">  if (ExpressionChangedStart) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">  if (ExpressionChangedStart) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">    bool ClearFlags = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">    bool ClearFlags = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">      // Preserve FastMathFlags.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">      // Preserve FastMathFlags.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">      if (ClearFlags) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">      if (ClearFlags) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">        if (isa<FPMathOperator>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">        if (isa<FPMathOperator>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">          FastMathFlags Flags = I->getFastMathFlags();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">          FastMathFlags Flags = I->getFastMathFlags();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">          ExpressionChangedStart->clearSubclassOptionalData();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">          ExpressionChangedStart->clearSubclassOptionalData();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">          ExpressionChangedStart->setFastMathFlags(Flags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">          ExpressionChangedStart->setFastMathFlags(Flags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">        } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">        } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">          ExpressionChangedStart->clearSubclassOptionalData();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">          ExpressionChangedStart->clearSubclassOptionalData();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">      if (ExpressionChangedStart == ExpressionChangedEnd)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">      if (ExpressionChangedStart == ExpressionChangedEnd)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">        ClearFlags = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">        ClearFlags = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">      if (ExpressionChangedStart == I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">      if (ExpressionChangedStart == I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">      // Discard any debug info related to the expressions that has changed (we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">      // Discard any debug info related to the expressions that has changed (we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">      // can leave debug info related to the root and any operation that didn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">      // can leave debug info related to the root and any operation that didn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">      // change, since the result of the expression tree should be the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">      // change, since the result of the expression tree should be the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">      // even after reassociation).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">      // even after reassociation).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">      if (ClearFlags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">      if (ClearFlags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">        replaceDbgUsesWithUndef(ExpressionChangedStart);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">        replaceDbgUsesWithUndef(ExpressionChangedStart);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">      ExpressionChangedStart->moveBefore(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">      ExpressionChangedStart->moveBefore(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">      ExpressionChangedStart =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">      ExpressionChangedStart =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">          cast<BinaryOperator>(*ExpressionChangedStart->user_begin());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">          cast<BinaryOperator>(*ExpressionChangedStart->user_begin());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">    } while (true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">    } while (true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">  // Throw away any left over nodes from the original expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">  // Throw away any left over nodes from the original expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">  for (unsigned i = 0, e = NodesToRewrite.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">  for (unsigned i = 0, e = NodesToRewrite.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">    RedoInsts.insert(NodesToRewrite[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">    RedoInsts.insert(NodesToRewrite[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">/// Insert instructions before the instruction pointed to by BI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">/// Insert instructions before the instruction pointed to by BI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">/// that computes the negative version of the value specified.  The negative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">/// that computes the negative version of the value specified.  The negative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">/// version of the value is returned, and BI is left pointing at the instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">/// version of the value is returned, and BI is left pointing at the instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">/// that should be processed next by the reassociation pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">/// that should be processed next by the reassociation pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">/// Also add intermediate instructions to the redo list that are modified while</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">/// Also add intermediate instructions to the redo list that are modified while</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">/// pushing the negates through adds.  These will be revisited to see if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">/// pushing the negates through adds.  These will be revisited to see if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">/// additional opportunities have been exposed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">/// additional opportunities have been exposed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">static Value *NegateValue(Value *V, Instruction *BI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">static Value *NegateValue(Value *V, Instruction *BI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">                          ReassociatePass::OrderedSet &ToRedo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">                          ReassociatePass::OrderedSet &ToRedo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">  if (auto *C = dyn_cast<Constant>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">  if (auto *C = dyn_cast<Constant>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">    const DataLayout &DL = BI->getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">    const DataLayout &DL = BI->getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">    Constant *Res = C->getType()->isFPOrFPVectorTy()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">    Constant *Res = C->getType()->isFPOrFPVectorTy()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">                        ? ConstantFoldUnaryOpOperand(Instruction::FNeg, C, DL)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">                        ? ConstantFoldUnaryOpOperand(Instruction::FNeg, C, DL)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">                        : ConstantExpr::getNeg(C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">                        : ConstantExpr::getNeg(C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">    if (Res)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">    if (Res)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">      return Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">      return Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">  // We are trying to expose opportunity for reassociation.  One of the things</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">  // We are trying to expose opportunity for reassociation.  One of the things</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">  // that we want to do to achieve this is to push a negation as deep into an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">  // that we want to do to achieve this is to push a negation as deep into an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  // expression chain as possible, to expose the add instructions.  In practice,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  // expression chain as possible, to expose the add instructions.  In practice,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">  // this means that we turn this:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">  // this means that we turn this:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">  //   X = -(A+12+C+D)   into    X = -A + -12 + -C + -D = -12 + -A + -C + -D</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">  //   X = -(A+12+C+D)   into    X = -A + -12 + -C + -D = -12 + -A + -C + -D</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">  // so that later, a: Y = 12+X could get reassociated with the -12 to eliminate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">  // so that later, a: Y = 12+X could get reassociated with the -12 to eliminate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">  // the constants.  We assume that instcombine will clean up the mess later if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">  // the constants.  We assume that instcombine will clean up the mess later if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  // we introduce tons of unnecessary negation instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  // we introduce tons of unnecessary negation instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">  if (BinaryOperator *I =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">  if (BinaryOperator *I =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">          isReassociableOp(V, Instruction::Add, Instruction::FAdd)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">          isReassociableOp(V, Instruction::Add, Instruction::FAdd)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">    // Push the negates through the add.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">    // Push the negates through the add.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">    I->setOperand(0, NegateValue(I->getOperand(0), BI, ToRedo));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">    I->setOperand(0, NegateValue(I->getOperand(0), BI, ToRedo));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">    I->setOperand(1, NegateValue(I->getOperand(1), BI, ToRedo));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">    I->setOperand(1, NegateValue(I->getOperand(1), BI, ToRedo));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">    if (I->getOpcode() == Instruction::Add) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">    if (I->getOpcode() == Instruction::Add) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">      I->setHasNoUnsignedWrap(false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">      I->setHasNoUnsignedWrap(false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">      I->setHasNoSignedWrap(false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">      I->setHasNoSignedWrap(false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">    // We must move the add instruction here, because the neg instructions do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">    // We must move the add instruction here, because the neg instructions do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">    // not dominate the old add instruction in general.  By moving it, we are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">    // not dominate the old add instruction in general.  By moving it, we are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">    // assured that the neg instructions we just inserted dominate the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">    // assured that the neg instructions we just inserted dominate the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">    // instruction we are about to insert after them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">    // instruction we are about to insert after them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">    I->moveBefore(BI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">    I->moveBefore(BI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">    I->setName(I->getName()+".neg");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">    I->setName(I->getName()+".neg");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">    // Add the intermediate negates to the redo list as processing them later</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">    // Add the intermediate negates to the redo list as processing them later</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">    // could expose more reassociating opportunities.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">    // could expose more reassociating opportunities.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">    ToRedo.insert(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">    ToRedo.insert(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">    return I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">    return I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">  // Okay, we need to materialize a negated version of V with an instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">  // Okay, we need to materialize a negated version of V with an instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">  // Scan the use lists of V to see if we have one already.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">  // Scan the use lists of V to see if we have one already.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">  for (User *U : V->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">  for (User *U : V->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">    if (!match(U, m_Neg(m_Value())) && !match(U, m_FNeg(m_Value())))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">    if (!match(U, m_Neg(m_Value())) && !match(U, m_FNeg(m_Value())))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">    // We found one!  Now we have to make sure that the definition dominates</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">    // We found one!  Now we have to make sure that the definition dominates</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">    // this use.  We do this by moving it to the entry block (if it is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">    // this use.  We do this by moving it to the entry block (if it is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">    // non-instruction value) or right after the definition.  These negates will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">    // non-instruction value) or right after the definition.  These negates will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">    // be zapped by reassociate later, so we don't need much finesse here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">    // be zapped by reassociate later, so we don't need much finesse here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">    Instruction *TheNeg = dyn_cast<Instruction>(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">    Instruction *TheNeg = dyn_cast<Instruction>(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">    // We can't safely propagate a vector zero constant with poison/undef lanes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">    // We can't safely propagate a vector zero constant with poison/undef lanes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">    Constant *C;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">    Constant *C;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">    if (match(TheNeg, m_BinOp(m_Constant(C), m_Value())) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">    if (match(TheNeg, m_BinOp(m_Constant(C), m_Value())) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">        C->containsUndefOrPoisonElement())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">        C->containsUndefOrPoisonElement())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">    // Verify that the negate is in this function, V might be a constant expr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">    // Verify that the negate is in this function, V might be a constant expr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">    if (!TheNeg ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">    if (!TheNeg ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">        TheNeg->getParent()->getParent() != BI->getParent()->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">        TheNeg->getParent()->getParent() != BI->getParent()->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">    Instruction *InsertPt;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">    Instruction *InsertPt;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">    if (Instruction *InstInput = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">    if (Instruction *InstInput = dyn_cast<Instruction>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">      InsertPt = InstInput->getInsertionPointAfterDef();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">      InsertPt = InstInput->getInsertionPointAfterDef();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">      if (!InsertPt)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">      if (!InsertPt)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">      InsertPt = &*TheNeg->getFunction()->getEntryBlock().begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">      InsertPt = &*TheNeg->getFunction()->getEntryBlock().begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">    TheNeg->moveBefore(InsertPt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">    TheNeg->moveBefore(InsertPt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">    if (TheNeg->getOpcode() == Instruction::Sub) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">    if (TheNeg->getOpcode() == Instruction::Sub) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">      TheNeg->setHasNoUnsignedWrap(false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">      TheNeg->setHasNoUnsignedWrap(false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">      TheNeg->setHasNoSignedWrap(false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">      TheNeg->setHasNoSignedWrap(false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">      TheNeg->andIRFlags(BI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">      TheNeg->andIRFlags(BI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">    ToRedo.insert(TheNeg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">    ToRedo.insert(TheNeg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">    return TheNeg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">    return TheNeg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">  // Insert a 'neg' instruction that subtracts the value from zero to get the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">  // Insert a 'neg' instruction that subtracts the value from zero to get the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">  // negation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">  // negation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">  Instruction *NewNeg = CreateNeg(V, V->getName() + ".neg", BI, BI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">  Instruction *NewNeg = CreateNeg(V, V->getName() + ".neg", BI, BI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">  ToRedo.insert(NewNeg);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">  ToRedo.insert(NewNeg);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">  return NewNeg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">  return NewNeg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">// See if this `or` looks like an load widening reduction, i.e. that it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">// See if this `or` looks like an load widening reduction, i.e. that it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">// consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">// consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">// ensure that the pattern is *really* a load widening reduction,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">// ensure that the pattern is *really* a load widening reduction,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">// we do not ensure that it can really be replaced with a widened load,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">// we do not ensure that it can really be replaced with a widened load,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">// only that it mostly looks like one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">// only that it mostly looks like one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">static bool isLoadCombineCandidate(Instruction *Or) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">static bool isLoadCombineCandidate(Instruction *Or) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">  SmallVector<Instruction *, 8> Worklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">  SmallVector<Instruction *, 8> Worklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">  SmallSet<Instruction *, 8> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">  SmallSet<Instruction *, 8> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">  auto Enqueue = [&](Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">  auto Enqueue = [&](Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">    auto *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">    auto *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">    // Each node of an `or` reduction must be an instruction,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">    // Each node of an `or` reduction must be an instruction,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">    if (!I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">    if (!I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">      return false; // Node is certainly not part of an `or` load reduction.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">      return false; // Node is certainly not part of an `or` load reduction.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">    // Only process instructions we have never processed before.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">    // Only process instructions we have never processed before.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">    if (Visited.insert(I).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">    if (Visited.insert(I).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">      Worklist.emplace_back(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">      Worklist.emplace_back(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">    return true; // Will need to look at parent nodes.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">    return true; // Will need to look at parent nodes.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">  if (!Enqueue(Or))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">  if (!Enqueue(Or))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">    return false; // Not an `or` reduction pattern.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">    return false; // Not an `or` reduction pattern.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">    auto *I = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">    auto *I = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">    // Okay, which instruction is this node?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">    // Okay, which instruction is this node?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">    switch (I->getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">    switch (I->getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">    case Instruction::Or:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">    case Instruction::Or:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">      // Got an `or` node. That's fine, just recurse into it's operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">      // Got an `or` node. That's fine, just recurse into it's operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">      for (Value *Op : I->operands())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">      for (Value *Op : I->operands())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">        if (!Enqueue(Op))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">        if (!Enqueue(Op))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">          return false; // Not an `or` reduction pattern.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">          return false; // Not an `or` reduction pattern.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">    case Instruction::Shl:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">    case Instruction::Shl:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">    case Instruction::ZExt:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">    case Instruction::ZExt:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">      // `shl`/`zext` nodes are fine, just recurse into their base operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">      // `shl`/`zext` nodes are fine, just recurse into their base operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">      if (!Enqueue(I->getOperand(0)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">      if (!Enqueue(I->getOperand(0)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">        return false; // Not an `or` reduction pattern.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">        return false; // Not an `or` reduction pattern.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">    case Instruction::Load:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">    case Instruction::Load:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">      // Perfect, `load` node means we've reached an edge of the graph.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">      // Perfect, `load` node means we've reached an edge of the graph.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">    default:        // Unknown node.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">    default:        // Unknown node.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">      return false; // Not an `or` reduction pattern.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">      return false; // Not an `or` reduction pattern.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">/// Return true if it may be profitable to convert this (X|Y) into (X+Y).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">/// Return true if it may be profitable to convert this (X|Y) into (X+Y).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">static bool shouldConvertOrWithNoCommonBitsToAdd(Instruction *Or) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">static bool shouldConvertOrWithNoCommonBitsToAdd(Instruction *Or) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">  // Don't bother to convert this up unless either the LHS is an associable add</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">  // Don't bother to convert this up unless either the LHS is an associable add</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">  // or subtract or mul or if this is only used by one of the above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">  // or subtract or mul or if this is only used by one of the above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">  // This is only a compile-time improvement, it is not needed for correctness!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">  // This is only a compile-time improvement, it is not needed for correctness!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">  auto isInteresting = [](Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">  auto isInteresting = [](Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">    for (auto Op : {Instruction::Add, Instruction::Sub, Instruction::Mul,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">    for (auto Op : {Instruction::Add, Instruction::Sub, Instruction::Mul,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">                    Instruction::Shl})</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">                    Instruction::Shl})</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">      if (isReassociableOp(V, Op))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">      if (isReassociableOp(V, Op))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">  if (any_of(Or->operands(), isInteresting))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">  if (any_of(Or->operands(), isInteresting))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">  Value *VB = Or->user_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">  Value *VB = Or->user_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">  if (Or->hasOneUse() && isInteresting(VB))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">  if (Or->hasOneUse() && isInteresting(VB))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">/// If we have (X|Y), and iff X and Y have no common bits set,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">/// If we have (X|Y), and iff X and Y have no common bits set,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">/// transform this into (X+Y) to allow arithmetics reassociation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">/// transform this into (X+Y) to allow arithmetics reassociation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">static BinaryOperator *convertOrWithNoCommonBitsToAdd(Instruction *Or) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">static BinaryOperator *convertOrWithNoCommonBitsToAdd(Instruction *Or) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">  // Convert an or into an add.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">  // Convert an or into an add.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">  BinaryOperator *New =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">  BinaryOperator *New =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">      CreateAdd(Or->getOperand(0), Or->getOperand(1), "", Or, Or);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">      CreateAdd(Or->getOperand(0), Or->getOperand(1), "", Or, Or);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">  New->setHasNoSignedWrap();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">  New->setHasNoSignedWrap();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">  New->setHasNoUnsignedWrap();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">  New->setHasNoUnsignedWrap();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">  New->takeName(Or);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">  New->takeName(Or);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">  // Everyone now refers to the add instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">  // Everyone now refers to the add instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  Or->replaceAllUsesWith(New);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  Or->replaceAllUsesWith(New);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">  New->setDebugLoc(Or->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">  New->setDebugLoc(Or->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Converted or into an add: " << *New << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Converted or into an add: " << *New << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">  return New;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">  return New;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">/// Return true if we should break up this subtract of X-Y into (X + -Y).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">/// Return true if we should break up this subtract of X-Y into (X + -Y).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">static bool ShouldBreakUpSubtract(Instruction *Sub) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">static bool ShouldBreakUpSubtract(Instruction *Sub) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">  // If this is a negation, we can't split it up!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">  // If this is a negation, we can't split it up!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">  if (match(Sub, m_Neg(m_Value())) || match(Sub, m_FNeg(m_Value()))) </td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">  if (match(Sub, m_Neg(m_Value())) || match(Sub, m_FNeg(m_Value()))) </td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">  // Don't breakup X - undef.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">  // Don't breakup X - undef.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">  if (isa<UndefValue>(Sub->getOperand(1)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">  if (isa<UndefValue>(Sub->getOperand(1)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">  // Don't bother to break this up unless either the LHS is an associable add or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">  // Don't bother to break this up unless either the LHS is an associable add or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">  // subtract or if this is only used by one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">  // subtract or if this is only used by one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">  Value *V0 = Sub->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">  Value *V0 = Sub->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  if (isReassociableOp(V0, Instruction::Add, Instruction::FAdd) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  if (isReassociableOp(V0, Instruction::Add, Instruction::FAdd) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">      isReassociableOp(V0, Instruction::Sub, Instruction::FSub))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">      isReassociableOp(V0, Instruction::Sub, Instruction::FSub))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">  Value *V1 = Sub->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">  Value *V1 = Sub->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">  if (isReassociableOp(V1, Instruction::Add, Instruction::FAdd) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">  if (isReassociableOp(V1, Instruction::Add, Instruction::FAdd) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">      isReassociableOp(V1, Instruction::Sub, Instruction::FSub))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">      isReassociableOp(V1, Instruction::Sub, Instruction::FSub))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">  Value *VB = Sub->user_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">  Value *VB = Sub->user_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">  if (Sub->hasOneUse() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">  if (Sub->hasOneUse() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">      (isReassociableOp(VB, Instruction::Add, Instruction::FAdd) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">      (isReassociableOp(VB, Instruction::Add, Instruction::FAdd) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">       isReassociableOp(VB, Instruction::Sub, Instruction::FSub)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">       isReassociableOp(VB, Instruction::Sub, Instruction::FSub)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">  return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">/// If we have (X-Y), and if either X is an add, or if this is only used by an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">/// If we have (X-Y), and if either X is an add, or if this is only used by an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">/// add, transform this into (X+(0-Y)) to promote better reassociation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">/// add, transform this into (X+(0-Y)) to promote better reassociation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">static BinaryOperator *BreakUpSubtract(Instruction *Sub,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">static BinaryOperator *BreakUpSubtract(Instruction *Sub,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">                                       ReassociatePass::OrderedSet &ToRedo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">                                       ReassociatePass::OrderedSet &ToRedo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">  // Convert a subtract into an add and a neg instruction. This allows sub</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">  // Convert a subtract into an add and a neg instruction. This allows sub</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">  // instructions to be commuted with other add instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">  // instructions to be commuted with other add instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">  // Calculate the negative value of Operand 1 of the sub instruction,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">  // Calculate the negative value of Operand 1 of the sub instruction,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">  // and set it as the RHS of the add instruction we just made.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">  // and set it as the RHS of the add instruction we just made.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">  Value *NegVal = NegateValue(Sub->getOperand(1), Sub, ToRedo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">  Value *NegVal = NegateValue(Sub->getOperand(1), Sub, ToRedo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">  BinaryOperator *New = CreateAdd(Sub->getOperand(0), NegVal, "", Sub, Sub);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">  BinaryOperator *New = CreateAdd(Sub->getOperand(0), NegVal, "", Sub, Sub);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">  Sub->setOperand(0, Constant::getNullValue(Sub->getType())); // Drop use of op.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">  Sub->setOperand(0, Constant::getNullValue(Sub->getType())); // Drop use of op.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">  Sub->setOperand(1, Constant::getNullValue(Sub->getType())); // Drop use of op.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">  Sub->setOperand(1, Constant::getNullValue(Sub->getType())); // Drop use of op.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">  New->takeName(Sub);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">  New->takeName(Sub);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">  // Everyone now refers to the add instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">  // Everyone now refers to the add instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">  Sub->replaceAllUsesWith(New);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">  Sub->replaceAllUsesWith(New);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">  New->setDebugLoc(Sub->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">  New->setDebugLoc(Sub->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Negated: " << *New << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Negated: " << *New << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">  return New;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">  return New;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">/// If this is a shift of a reassociable multiply or is used by one, change</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">/// If this is a shift of a reassociable multiply or is used by one, change</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">/// this into a multiply by a constant to assist with further reassociation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">/// this into a multiply by a constant to assist with further reassociation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">static BinaryOperator *ConvertShiftToMul(Instruction *Shl) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">static BinaryOperator *ConvertShiftToMul(Instruction *Shl) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">  Constant *MulCst = ConstantInt::get(Shl->getType(), 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">  Constant *MulCst = ConstantInt::get(Shl->getType(), 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">  auto *SA = cast<ConstantInt>(Shl->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">  auto *SA = cast<ConstantInt>(Shl->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">  MulCst = ConstantExpr::getShl(MulCst, SA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">  MulCst = ConstantExpr::getShl(MulCst, SA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">  BinaryOperator *Mul =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">  BinaryOperator *Mul =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">    BinaryOperator::CreateMul(Shl->getOperand(0), MulCst, "", Shl);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">    BinaryOperator::CreateMul(Shl->getOperand(0), MulCst, "", Shl);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">  Shl->setOperand(0, PoisonValue::get(Shl->getType())); // Drop use of op.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">  Shl->setOperand(0, PoisonValue::get(Shl->getType())); // Drop use of op.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">  Mul->takeName(Shl);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">  Mul->takeName(Shl);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">  // Everyone now refers to the mul instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">  // Everyone now refers to the mul instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">  Shl->replaceAllUsesWith(Mul);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">  Shl->replaceAllUsesWith(Mul);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">  Mul->setDebugLoc(Shl->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">  Mul->setDebugLoc(Shl->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">  // We can safely preserve the nuw flag in all cases.  It's also safe to turn a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">  // We can safely preserve the nuw flag in all cases.  It's also safe to turn a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">  // nuw nsw shl into a nuw nsw mul.  However, nsw in isolation requires special</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">  // nuw nsw shl into a nuw nsw mul.  However, nsw in isolation requires special</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">  // handling.  It can be preserved as long as we're not left shifting by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">  // handling.  It can be preserved as long as we're not left shifting by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">  // bitwidth - 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">  // bitwidth - 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">  bool NSW = cast<BinaryOperator>(Shl)->hasNoSignedWrap();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">  bool NSW = cast<BinaryOperator>(Shl)->hasNoSignedWrap();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">  bool NUW = cast<BinaryOperator>(Shl)->hasNoUnsignedWrap();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">  bool NUW = cast<BinaryOperator>(Shl)->hasNoUnsignedWrap();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">  unsigned BitWidth = Shl->getType()->getIntegerBitWidth();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">  unsigned BitWidth = Shl->getType()->getIntegerBitWidth();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">  if (NSW && (NUW || SA->getValue().ult(BitWidth - 1)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">  if (NSW && (NUW || SA->getValue().ult(BitWidth - 1)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">    Mul->setHasNoSignedWrap(true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">    Mul->setHasNoSignedWrap(true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">  Mul->setHasNoUnsignedWrap(NUW);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">  Mul->setHasNoUnsignedWrap(NUW);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">  return Mul;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">  return Mul;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">/// Scan backwards and forwards among values with the same rank as element i</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">/// Scan backwards and forwards among values with the same rank as element i</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">/// to see if X exists.  If X does not exist, return i.  This is useful when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">/// to see if X exists.  If X does not exist, return i.  This is useful when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">/// scanning for 'x' when we see '-x' because they both get the same rank.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">/// scanning for 'x' when we see '-x' because they both get the same rank.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">static unsigned FindInOperandList(const SmallVectorImpl<ValueEntry> &Ops,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">static unsigned FindInOperandList(const SmallVectorImpl<ValueEntry> &Ops,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">                                  unsigned i, Value *X) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">                                  unsigned i, Value *X) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">  unsigned XRank = Ops[i].Rank;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">  unsigned XRank = Ops[i].Rank;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">  unsigned e = Ops.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">  unsigned e = Ops.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">  for (unsigned j = i+1; j != e && Ops[j].Rank == XRank; ++j) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">  for (unsigned j = i+1; j != e && Ops[j].Rank == XRank; ++j) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">    if (Ops[j].Op == X)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">    if (Ops[j].Op == X)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">      return j;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">      return j;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">    if (Instruction *I1 = dyn_cast<Instruction>(Ops[j].Op))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">    if (Instruction *I1 = dyn_cast<Instruction>(Ops[j].Op))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">      if (Instruction *I2 = dyn_cast<Instruction>(X))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">      if (Instruction *I2 = dyn_cast<Instruction>(X))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">        if (I1->isIdenticalTo(I2))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">        if (I1->isIdenticalTo(I2))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">          return j;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">          return j;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">  // Scan backwards.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">  // Scan backwards.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">  for (unsigned j = i-1; j != ~0U && Ops[j].Rank == XRank; --j) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">  for (unsigned j = i-1; j != ~0U && Ops[j].Rank == XRank; --j) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">    if (Ops[j].Op == X)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">    if (Ops[j].Op == X)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">      return j;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">      return j;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">    if (Instruction *I1 = dyn_cast<Instruction>(Ops[j].Op))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">    if (Instruction *I1 = dyn_cast<Instruction>(Ops[j].Op))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">      if (Instruction *I2 = dyn_cast<Instruction>(X))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">      if (Instruction *I2 = dyn_cast<Instruction>(X))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">        if (I1->isIdenticalTo(I2))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">        if (I1->isIdenticalTo(I2))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">          return j;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">          return j;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">  return i;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">  return i;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">/// Emit a tree of add instructions, summing Ops together</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">/// Emit a tree of add instructions, summing Ops together</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">/// and returning the result.  Insert the tree before I.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">/// and returning the result.  Insert the tree before I.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">static Value *EmitAddTreeOfValues(Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">static Value *EmitAddTreeOfValues(Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">                                  SmallVectorImpl<WeakTrackingVH> &Ops) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">                                  SmallVectorImpl<WeakTrackingVH> &Ops) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">  if (Ops.size() == 1) return Ops.back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">  if (Ops.size() == 1) return Ops.back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">  Value *V1 = Ops.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">  Value *V1 = Ops.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">  Value *V2 = EmitAddTreeOfValues(I, Ops);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">  Value *V2 = EmitAddTreeOfValues(I, Ops);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">  return CreateAdd(V2, V1, "reass.add", I, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">  return CreateAdd(V2, V1, "reass.add", I, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">/// If V is an expression tree that is a multiplication sequence,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">/// If V is an expression tree that is a multiplication sequence,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">/// and if this sequence contains a multiply by Factor,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">/// and if this sequence contains a multiply by Factor,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">/// remove Factor from the tree and return the new tree.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">/// remove Factor from the tree and return the new tree.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">Value *ReassociatePass::RemoveFactorFromExpression(Value *V, Value *Factor) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">Value *ReassociatePass::RemoveFactorFromExpression(Value *V, Value *Factor) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">  BinaryOperator *BO = isReassociableOp(V, Instruction::Mul, Instruction::FMul);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">  BinaryOperator *BO = isReassociableOp(V, Instruction::Mul, Instruction::FMul);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">  if (!BO)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">  if (!BO)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">  SmallVector<RepeatedValue, 8> Tree;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">  SmallVector<RepeatedValue, 8> Tree;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">  MadeChange |= LinearizeExprTree(BO, Tree, RedoInsts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">  MadeChange |= LinearizeExprTree(BO, Tree, RedoInsts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">  SmallVector<ValueEntry, 8> Factors;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">  SmallVector<ValueEntry, 8> Factors;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">  Factors.reserve(Tree.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">  Factors.reserve(Tree.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">  for (unsigned i = 0, e = Tree.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">  for (unsigned i = 0, e = Tree.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">    RepeatedValue E = Tree[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">    RepeatedValue E = Tree[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">    Factors.append(E.second.getZExtValue(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">    Factors.append(E.second.getZExtValue(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">                   ValueEntry(getRank(E.first), E.first));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">                   ValueEntry(getRank(E.first), E.first));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">  bool FoundFactor = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">  bool FoundFactor = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">  bool NeedsNegate = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">  bool NeedsNegate = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">  for (unsigned i = 0, e = Factors.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">  for (unsigned i = 0, e = Factors.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">    if (Factors[i].Op == Factor) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">    if (Factors[i].Op == Factor) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">      FoundFactor = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">      FoundFactor = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">      Factors.erase(Factors.begin()+i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">      Factors.erase(Factors.begin()+i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">    // If this is a negative version of this factor, remove it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">    // If this is a negative version of this factor, remove it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">    if (ConstantInt *FC1 = dyn_cast<ConstantInt>(Factor)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">    if (ConstantInt *FC1 = dyn_cast<ConstantInt>(Factor)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">      if (ConstantInt *FC2 = dyn_cast<ConstantInt>(Factors[i].Op))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">      if (ConstantInt *FC2 = dyn_cast<ConstantInt>(Factors[i].Op))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">        if (FC1->getValue() == -FC2->getValue()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">        if (FC1->getValue() == -FC2->getValue()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">          FoundFactor = NeedsNegate = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">          FoundFactor = NeedsNegate = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">          Factors.erase(Factors.begin()+i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">          Factors.erase(Factors.begin()+i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">    } else if (ConstantFP *FC1 = dyn_cast<ConstantFP>(Factor)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">    } else if (ConstantFP *FC1 = dyn_cast<ConstantFP>(Factor)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">      if (ConstantFP *FC2 = dyn_cast<ConstantFP>(Factors[i].Op)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">      if (ConstantFP *FC2 = dyn_cast<ConstantFP>(Factors[i].Op)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">        const APFloat &F1 = FC1->getValueAPF();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">        const APFloat &F1 = FC1->getValueAPF();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">        APFloat F2(FC2->getValueAPF());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">        APFloat F2(FC2->getValueAPF());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">        F2.changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">        F2.changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">        if (F1 == F2) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">        if (F1 == F2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">          FoundFactor = NeedsNegate = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">          FoundFactor = NeedsNegate = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">          Factors.erase(Factors.begin() + i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">          Factors.erase(Factors.begin() + i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  if (!FoundFactor) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  if (!FoundFactor) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">    // Make sure to restore the operands to the expression tree.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">    // Make sure to restore the operands to the expression tree.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">    RewriteExprTree(BO, Factors);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">    RewriteExprTree(BO, Factors);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">  BasicBlock::iterator InsertPt = ++BO->getIterator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">  BasicBlock::iterator InsertPt = ++BO->getIterator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">  // If this was just a single multiply, remove the multiply and return the only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">  // If this was just a single multiply, remove the multiply and return the only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">  // remaining operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">  // remaining operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">  if (Factors.size() == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">  if (Factors.size() == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">    RedoInsts.insert(BO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">    RedoInsts.insert(BO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">    V = Factors[0].Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">    V = Factors[0].Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">    RewriteExprTree(BO, Factors);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">    RewriteExprTree(BO, Factors);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">    V = BO;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">    V = BO;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  if (NeedsNegate)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  if (NeedsNegate)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">    V = CreateNeg(V, "neg", &*InsertPt, BO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">    V = CreateNeg(V, "neg", &*InsertPt, BO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">/// If V is a single-use multiply, recursively add its operands as factors,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">/// If V is a single-use multiply, recursively add its operands as factors,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">/// otherwise add V to the list of factors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">/// otherwise add V to the list of factors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">/// Ops is the top-level list of add operands we're trying to factor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">/// Ops is the top-level list of add operands we're trying to factor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">static void FindSingleUseMultiplyFactors(Value *V,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">static void FindSingleUseMultiplyFactors(Value *V,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">                                         SmallVectorImpl<Value*> &Factors) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">                                         SmallVectorImpl<Value*> &Factors) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">  BinaryOperator *BO = isReassociableOp(V, Instruction::Mul, Instruction::FMul);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">  BinaryOperator *BO = isReassociableOp(V, Instruction::Mul, Instruction::FMul);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">  if (!BO) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">  if (!BO) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">    Factors.push_back(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">    Factors.push_back(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">  // Otherwise, add the LHS and RHS to the list of factors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">  // Otherwise, add the LHS and RHS to the list of factors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">  FindSingleUseMultiplyFactors(BO->getOperand(1), Factors);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">  FindSingleUseMultiplyFactors(BO->getOperand(1), Factors);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">  FindSingleUseMultiplyFactors(BO->getOperand(0), Factors);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">  FindSingleUseMultiplyFactors(BO->getOperand(0), Factors);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">/// This optimizes based on identities.  If it can be reduced to a single Value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">/// This optimizes based on identities.  If it can be reduced to a single Value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">/// it is returned, otherwise the Ops list is mutated as necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">/// it is returned, otherwise the Ops list is mutated as necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">static Value *OptimizeAndOrXor(unsigned Opcode,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">static Value *OptimizeAndOrXor(unsigned Opcode,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">                               SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">                               SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">  // Scan the operand lists looking for X and ~X pairs, along with X,X pairs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">  // Scan the operand lists looking for X and ~X pairs, along with X,X pairs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">  // If we find any, we can simplify the expression. X&~X == 0, X|~X == -1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">  // If we find any, we can simplify the expression. X&~X == 0, X|~X == -1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">    // First, check for X and ~X in the operand list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">    // First, check for X and ~X in the operand list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">    assert(i < Ops.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">    assert(i < Ops.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">    Value *X;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">    Value *X;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">    if (match(Ops[i].Op, m_Not(m_Value(X)))) {    // Cannot occur for ^.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">    if (match(Ops[i].Op, m_Not(m_Value(X)))) {    // Cannot occur for ^.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">      unsigned FoundX = FindInOperandList(Ops, i, X);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">      unsigned FoundX = FindInOperandList(Ops, i, X);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">      if (FoundX != i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">      if (FoundX != i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">        if (Opcode == Instruction::And)   // ...&X&~X = 0</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">        if (Opcode == Instruction::And)   // ...&X&~X = 0</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">          return Constant::getNullValue(X->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">          return Constant::getNullValue(X->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">        if (Opcode == Instruction::Or)    // ...|X|~X = -1</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">        if (Opcode == Instruction::Or)    // ...|X|~X = -1</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">          return Constant::getAllOnesValue(X->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">          return Constant::getAllOnesValue(X->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">    // Next, check for duplicate pairs of values, which we assume are next to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">    // Next, check for duplicate pairs of values, which we assume are next to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">    // each other, due to our sorting criteria.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">    // each other, due to our sorting criteria.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">    assert(i < Ops.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">    assert(i < Ops.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">    if (i+1 != Ops.size() && Ops[i+1].Op == Ops[i].Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">    if (i+1 != Ops.size() && Ops[i+1].Op == Ops[i].Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">      if (Opcode == Instruction::And || Opcode == Instruction::Or) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">      if (Opcode == Instruction::And || Opcode == Instruction::Or) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">        // Drop duplicate values for And and Or.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">        // Drop duplicate values for And and Or.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">        Ops.erase(Ops.begin()+i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">        Ops.erase(Ops.begin()+i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">        --i; --e;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">        --i; --e;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">        ++NumAnnihil;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">        ++NumAnnihil;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">      // Drop pairs of values for Xor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">      // Drop pairs of values for Xor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">      assert(Opcode == Instruction::Xor);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">      assert(Opcode == Instruction::Xor);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">      if (e == 2)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">      if (e == 2)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">        return Constant::getNullValue(Ops[0].Op->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">        return Constant::getNullValue(Ops[0].Op->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">      // Y ^ X^X -> Y</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">      // Y ^ X^X -> Y</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">      Ops.erase(Ops.begin()+i, Ops.begin()+i+2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">      Ops.erase(Ops.begin()+i, Ops.begin()+i+2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">      i -= 1; e -= 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">      i -= 1; e -= 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">      ++NumAnnihil;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">      ++NumAnnihil;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">/// Helper function of CombineXorOpnd(). It creates a bitwise-and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">/// Helper function of CombineXorOpnd(). It creates a bitwise-and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">/// instruction with the given two operands, and return the resulting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">/// instruction with the given two operands, and return the resulting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">/// instruction. There are two special cases: 1) if the constant operand is 0,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">/// instruction. There are two special cases: 1) if the constant operand is 0,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">/// it will return NULL. 2) if the constant is ~0, the symbolic operand will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">/// it will return NULL. 2) if the constant is ~0, the symbolic operand will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">/// be returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">/// be returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">static Value *createAndInstr(Instruction *InsertBefore, Value *Opnd,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">static Value *createAndInstr(Instruction *InsertBefore, Value *Opnd,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">                             const APInt &ConstOpnd) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">                             const APInt &ConstOpnd) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">  if (ConstOpnd.isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">  if (ConstOpnd.isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  if (ConstOpnd.isAllOnes())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  if (ConstOpnd.isAllOnes())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">    return Opnd;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">    return Opnd;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">  Instruction *I = BinaryOperator::CreateAnd(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">  Instruction *I = BinaryOperator::CreateAnd(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">      Opnd, ConstantInt::get(Opnd->getType(), ConstOpnd), "and.ra",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">      Opnd, ConstantInt::get(Opnd->getType(), ConstOpnd), "and.ra",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">      InsertBefore);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">      InsertBefore);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine">  I->setDebugLoc(InsertBefore->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine">  I->setDebugLoc(InsertBefore->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">  return I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">  return I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">// Helper function of OptimizeXor(). It tries to simplify "Opnd1 ^ ConstOpnd"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">// Helper function of OptimizeXor(). It tries to simplify "Opnd1 ^ ConstOpnd"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">// into "R ^ C", where C would be 0, and R is a symbolic value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">// into "R ^ C", where C would be 0, and R is a symbolic value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">// If it was successful, true is returned, and the "R" and "C" is returned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">// If it was successful, true is returned, and the "R" and "C" is returned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">// via "Res" and "ConstOpnd", respectively; otherwise, false is returned,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">// via "Res" and "ConstOpnd", respectively; otherwise, false is returned,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">// and both "Res" and "ConstOpnd" remain unchanged.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">// and both "Res" and "ConstOpnd" remain unchanged.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">bool ReassociatePass::CombineXorOpnd(Instruction *I, XorOpnd *Opnd1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">bool ReassociatePass::CombineXorOpnd(Instruction *I, XorOpnd *Opnd1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">                                     APInt &ConstOpnd, Value *&Res) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">                                     APInt &ConstOpnd, Value *&Res) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">  // Xor-Rule 1: (x | c1) ^ c2 = (x | c1) ^ (c1 ^ c1) ^ c2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">  // Xor-Rule 1: (x | c1) ^ c2 = (x | c1) ^ (c1 ^ c1) ^ c2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">  //                       = ((x | c1) ^ c1) ^ (c1 ^ c2)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">  //                       = ((x | c1) ^ c1) ^ (c1 ^ c2)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">  //                       = (x & ~c1) ^ (c1 ^ c2)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">  //                       = (x & ~c1) ^ (c1 ^ c2)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">  // It is useful only when c1 == c2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">  // It is useful only when c1 == c2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">  if (!Opnd1->isOrExpr() || Opnd1->getConstPart().isZero())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">  if (!Opnd1->isOrExpr() || Opnd1->getConstPart().isZero())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">  if (!Opnd1->getValue()->hasOneUse())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">  if (!Opnd1->getValue()->hasOneUse())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">  const APInt &C1 = Opnd1->getConstPart();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">  const APInt &C1 = Opnd1->getConstPart();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">  if (C1 != ConstOpnd)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">  if (C1 != ConstOpnd)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">  Value *X = Opnd1->getSymbolicPart();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">  Value *X = Opnd1->getSymbolicPart();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">  Res = createAndInstr(I, X, ~C1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">  Res = createAndInstr(I, X, ~C1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">  // ConstOpnd was C2, now C1 ^ C2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">  // ConstOpnd was C2, now C1 ^ C2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">  ConstOpnd ^= C1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">  ConstOpnd ^= C1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">  if (Instruction *T = dyn_cast<Instruction>(Opnd1->getValue()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">  if (Instruction *T = dyn_cast<Instruction>(Opnd1->getValue()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">    RedoInsts.insert(T);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">    RedoInsts.insert(T);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">// Helper function of OptimizeXor(). It tries to simplify</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">// Helper function of OptimizeXor(). It tries to simplify</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">// "Opnd1 ^ Opnd2 ^ ConstOpnd" into "R ^ C", where C would be 0, and R is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">// "Opnd1 ^ Opnd2 ^ ConstOpnd" into "R ^ C", where C would be 0, and R is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">// symbolic value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">// symbolic value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">// If it was successful, true is returned, and the "R" and "C" is returned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">// If it was successful, true is returned, and the "R" and "C" is returned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">// via "Res" and "ConstOpnd", respectively (If the entire expression is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">// via "Res" and "ConstOpnd", respectively (If the entire expression is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">// evaluated to a constant, the Res is set to NULL); otherwise, false is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">// evaluated to a constant, the Res is set to NULL); otherwise, false is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">// returned, and both "Res" and "ConstOpnd" remain unchanged.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">// returned, and both "Res" and "ConstOpnd" remain unchanged.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">bool ReassociatePass::CombineXorOpnd(Instruction *I, XorOpnd *Opnd1,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">bool ReassociatePass::CombineXorOpnd(Instruction *I, XorOpnd *Opnd1,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">                                     XorOpnd *Opnd2, APInt &ConstOpnd,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">                                     XorOpnd *Opnd2, APInt &ConstOpnd,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">                                     Value *&Res) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">                                     Value *&Res) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">  Value *X = Opnd1->getSymbolicPart();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">  Value *X = Opnd1->getSymbolicPart();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">  if (X != Opnd2->getSymbolicPart())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">  if (X != Opnd2->getSymbolicPart())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">  // This many instruction become dead.(At least "Opnd1 ^ Opnd2" will die.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">  // This many instruction become dead.(At least "Opnd1 ^ Opnd2" will die.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">  int DeadInstNum = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">  int DeadInstNum = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">  if (Opnd1->getValue()->hasOneUse())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">  if (Opnd1->getValue()->hasOneUse())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">    DeadInstNum++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">    DeadInstNum++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">  if (Opnd2->getValue()->hasOneUse())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">  if (Opnd2->getValue()->hasOneUse())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">    DeadInstNum++;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">    DeadInstNum++;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">  // Xor-Rule 2:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">  // Xor-Rule 2:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">  //  (x | c1) ^ (x & c2)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">  //  (x | c1) ^ (x & c2)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">  //   = (x|c1) ^ (x&c2) ^ (c1 ^ c1) = ((x|c1) ^ c1) ^ (x & c2) ^ c1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">  //   = (x|c1) ^ (x&c2) ^ (c1 ^ c1) = ((x|c1) ^ c1) ^ (x & c2) ^ c1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">  //   = (x & ~c1) ^ (x & c2) ^ c1               // Xor-Rule 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">  //   = (x & ~c1) ^ (x & c2) ^ c1               // Xor-Rule 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">  //   = (x & c3) ^ c1, where c3 = ~c1 ^ c2      // Xor-rule 3</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">  //   = (x & c3) ^ c1, where c3 = ~c1 ^ c2      // Xor-rule 3</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">  if (Opnd1->isOrExpr() != Opnd2->isOrExpr()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">  if (Opnd1->isOrExpr() != Opnd2->isOrExpr()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">    if (Opnd2->isOrExpr())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">    if (Opnd2->isOrExpr())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">      std::swap(Opnd1, Opnd2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">      std::swap(Opnd1, Opnd2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">    const APInt &C1 = Opnd1->getConstPart();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">    const APInt &C1 = Opnd1->getConstPart();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">    const APInt &C2 = Opnd2->getConstPart();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">    const APInt &C2 = Opnd2->getConstPart();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">    APInt C3((~C1) ^ C2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">    APInt C3((~C1) ^ C2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">    // Do not increase code size!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">    // Do not increase code size!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">    if (!C3.isZero() && !C3.isAllOnes()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">    if (!C3.isZero() && !C3.isAllOnes()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">      int NewInstNum = ConstOpnd.getBoolValue() ? 1 : 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">      int NewInstNum = ConstOpnd.getBoolValue() ? 1 : 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">      if (NewInstNum > DeadInstNum)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">      if (NewInstNum > DeadInstNum)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">    Res = createAndInstr(I, X, C3);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">    Res = createAndInstr(I, X, C3);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">    ConstOpnd ^= C1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">    ConstOpnd ^= C1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">  } else if (Opnd1->isOrExpr()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">  } else if (Opnd1->isOrExpr()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">    // Xor-Rule 3: (x | c1) ^ (x | c2) = (x & c3) ^ c3 where c3 = c1 ^ c2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">    // Xor-Rule 3: (x | c1) ^ (x | c2) = (x & c3) ^ c3 where c3 = c1 ^ c2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">    const APInt &C1 = Opnd1->getConstPart();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">    const APInt &C1 = Opnd1->getConstPart();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">    const APInt &C2 = Opnd2->getConstPart();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">    const APInt &C2 = Opnd2->getConstPart();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">    APInt C3 = C1 ^ C2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">    APInt C3 = C1 ^ C2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">    // Do not increase code size</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">    // Do not increase code size</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">    if (!C3.isZero() && !C3.isAllOnes()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">    if (!C3.isZero() && !C3.isAllOnes()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">      int NewInstNum = ConstOpnd.getBoolValue() ? 1 : 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">      int NewInstNum = ConstOpnd.getBoolValue() ? 1 : 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">      if (NewInstNum > DeadInstNum)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">      if (NewInstNum > DeadInstNum)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">    Res = createAndInstr(I, X, C3);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">    Res = createAndInstr(I, X, C3);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">    ConstOpnd ^= C3;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">    ConstOpnd ^= C3;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">    // Xor-Rule 4: (x & c1) ^ (x & c2) = (x & (c1^c2))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">    // Xor-Rule 4: (x & c1) ^ (x & c2) = (x & (c1^c2))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">    const APInt &C1 = Opnd1->getConstPart();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">    const APInt &C1 = Opnd1->getConstPart();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">    const APInt &C2 = Opnd2->getConstPart();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">    const APInt &C2 = Opnd2->getConstPart();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">    APInt C3 = C1 ^ C2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">    APInt C3 = C1 ^ C2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">    Res = createAndInstr(I, X, C3);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">    Res = createAndInstr(I, X, C3);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">  // Put the original operands in the Redo list; hope they will be deleted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">  // Put the original operands in the Redo list; hope they will be deleted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">  // as dead code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">  // as dead code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">  if (Instruction *T = dyn_cast<Instruction>(Opnd1->getValue()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">  if (Instruction *T = dyn_cast<Instruction>(Opnd1->getValue()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">    RedoInsts.insert(T);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">    RedoInsts.insert(T);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">  if (Instruction *T = dyn_cast<Instruction>(Opnd2->getValue()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">  if (Instruction *T = dyn_cast<Instruction>(Opnd2->getValue()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">    RedoInsts.insert(T);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">    RedoInsts.insert(T);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">/// Optimize a series of operands to an 'xor' instruction. If it can be reduced</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">/// Optimize a series of operands to an 'xor' instruction. If it can be reduced</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">/// to a single Value, it is returned, otherwise the Ops list is mutated as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">/// to a single Value, it is returned, otherwise the Ops list is mutated as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">/// necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">/// necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">Value *ReassociatePass::OptimizeXor(Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">Value *ReassociatePass::OptimizeXor(Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">  if (Value *V = OptimizeAndOrXor(Instruction::Xor, Ops))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">  if (Value *V = OptimizeAndOrXor(Instruction::Xor, Ops))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">  if (Ops.size() == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">  if (Ops.size() == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">  SmallVector<XorOpnd, 8> Opnds;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">  SmallVector<XorOpnd, 8> Opnds;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">  SmallVector<XorOpnd*, 8> OpndPtrs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">  SmallVector<XorOpnd*, 8> OpndPtrs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">  Type *Ty = Ops[0].Op->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">  Type *Ty = Ops[0].Op->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">  APInt ConstOpnd(Ty->getScalarSizeInBits(), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">  APInt ConstOpnd(Ty->getScalarSizeInBits(), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">  // Step 1: Convert ValueEntry to XorOpnd</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">  // Step 1: Convert ValueEntry to XorOpnd</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">    Value *V = Ops[i].Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">    Value *V = Ops[i].Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">    const APInt *C;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">    const APInt *C;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">    // TODO: Support non-splat vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">    // TODO: Support non-splat vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">    if (match(V, m_APInt(C))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">    if (match(V, m_APInt(C))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine">      ConstOpnd ^= *C;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine">      ConstOpnd ^= *C;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">      XorOpnd O(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">      XorOpnd O(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">      O.setSymbolicRank(getRank(O.getSymbolicPart()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">      O.setSymbolicRank(getRank(O.getSymbolicPart()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">      Opnds.push_back(O);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">      Opnds.push_back(O);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">  // NOTE: From this point on, do *NOT* add/delete element to/from "Opnds".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">  // NOTE: From this point on, do *NOT* add/delete element to/from "Opnds".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">  //  It would otherwise invalidate the "Opnds"'s iterator, and hence invalidate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">  //  It would otherwise invalidate the "Opnds"'s iterator, and hence invalidate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">  //  the "OpndPtrs" as well. For the similar reason, do not fuse this loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">  //  the "OpndPtrs" as well. For the similar reason, do not fuse this loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">  //  with the previous loop --- the iterator of the "Opnds" may be invalidated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">  //  with the previous loop --- the iterator of the "Opnds" may be invalidated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">  //  when new elements are added to the vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">  //  when new elements are added to the vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">  for (unsigned i = 0, e = Opnds.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">  for (unsigned i = 0, e = Opnds.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">    OpndPtrs.push_back(&Opnds[i]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">    OpndPtrs.push_back(&Opnds[i]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">  // Step 2: Sort the Xor-Operands in a way such that the operands containing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">  // Step 2: Sort the Xor-Operands in a way such that the operands containing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">  //  the same symbolic value cluster together. For instance, the input operand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">  //  the same symbolic value cluster together. For instance, the input operand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">  //  sequence ("x | 123", "y & 456", "x & 789") will be sorted into:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">  //  sequence ("x | 123", "y & 456", "x & 789") will be sorted into:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">  //  ("x | 123", "x & 789", "y & 456").</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">  //  ("x | 123", "x & 789", "y & 456").</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">  //  The purpose is twofold:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">  //  The purpose is twofold:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">  //  1) Cluster together the operands sharing the same symbolic-value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">  //  1) Cluster together the operands sharing the same symbolic-value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">  //  2) Operand having smaller symbolic-value-rank is permuted earlier, which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">  //  2) Operand having smaller symbolic-value-rank is permuted earlier, which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">  //     could potentially shorten crital path, and expose more loop-invariants.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">  //     could potentially shorten crital path, and expose more loop-invariants.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">  //     Note that values' rank are basically defined in RPO order (FIXME).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">  //     Note that values' rank are basically defined in RPO order (FIXME).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">  //     So, if Rank(X) < Rank(Y) < Rank(Z), it means X is defined earlier</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">  //     So, if Rank(X) < Rank(Y) < Rank(Z), it means X is defined earlier</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">  //     than Y which is defined earlier than Z. Permute "x | 1", "Y & 2",</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">  //     than Y which is defined earlier than Z. Permute "x | 1", "Y & 2",</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">  //     "z" in the order of X-Y-Z is better than any other orders.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">  //     "z" in the order of X-Y-Z is better than any other orders.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">  llvm::stable_sort(OpndPtrs, [](XorOpnd *LHS, XorOpnd *RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">  llvm::stable_sort(OpndPtrs, [](XorOpnd *LHS, XorOpnd *RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">    return LHS->getSymbolicRank() < RHS->getSymbolicRank();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">    return LHS->getSymbolicRank() < RHS->getSymbolicRank();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">  // Step 3: Combine adjacent operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">  // Step 3: Combine adjacent operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">  XorOpnd *PrevOpnd = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">  XorOpnd *PrevOpnd = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">  for (unsigned i = 0, e = Opnds.size(); i < e; i++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">  for (unsigned i = 0, e = Opnds.size(); i < e; i++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">    XorOpnd *CurrOpnd = OpndPtrs[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">    XorOpnd *CurrOpnd = OpndPtrs[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">    // The combined value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">    // The combined value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">    Value *CV;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">    Value *CV;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">    // Step 3.1: Try simplifying "CurrOpnd ^ ConstOpnd"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">    // Step 3.1: Try simplifying "CurrOpnd ^ ConstOpnd"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">    if (!ConstOpnd.isZero() && CombineXorOpnd(I, CurrOpnd, ConstOpnd, CV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">    if (!ConstOpnd.isZero() && CombineXorOpnd(I, CurrOpnd, ConstOpnd, CV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">      if (CV)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">      if (CV)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">        *CurrOpnd = XorOpnd(CV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">        *CurrOpnd = XorOpnd(CV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">      else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">      else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">        CurrOpnd->Invalidate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">        CurrOpnd->Invalidate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">    if (!PrevOpnd || CurrOpnd->getSymbolicPart() != PrevOpnd->getSymbolicPart()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">    if (!PrevOpnd || CurrOpnd->getSymbolicPart() != PrevOpnd->getSymbolicPart()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">      PrevOpnd = CurrOpnd;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">      PrevOpnd = CurrOpnd;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">    // step 3.2: When previous and current operands share the same symbolic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">    // step 3.2: When previous and current operands share the same symbolic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">    //  value, try to simplify "PrevOpnd ^ CurrOpnd ^ ConstOpnd"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">    //  value, try to simplify "PrevOpnd ^ CurrOpnd ^ ConstOpnd"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">    if (CombineXorOpnd(I, CurrOpnd, PrevOpnd, ConstOpnd, CV)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">    if (CombineXorOpnd(I, CurrOpnd, PrevOpnd, ConstOpnd, CV)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">      // Remove previous operand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">      // Remove previous operand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">      PrevOpnd->Invalidate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">      PrevOpnd->Invalidate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">      if (CV) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">      if (CV) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">        *CurrOpnd = XorOpnd(CV);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">        *CurrOpnd = XorOpnd(CV);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">        PrevOpnd = CurrOpnd;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">        PrevOpnd = CurrOpnd;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">        CurrOpnd->Invalidate();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">        CurrOpnd->Invalidate();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">        PrevOpnd = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">        PrevOpnd = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">  // Step 4: Reassemble the Ops</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">  // Step 4: Reassemble the Ops</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">  if (Changed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">  if (Changed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">    Ops.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">    Ops.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">    for (const XorOpnd &O : Opnds) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">    for (const XorOpnd &O : Opnds) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">      if (O.isInvalid())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">      if (O.isInvalid())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">      ValueEntry VE(getRank(O.getValue()), O.getValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">      ValueEntry VE(getRank(O.getValue()), O.getValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">      Ops.push_back(VE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">      Ops.push_back(VE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">    if (!ConstOpnd.isZero()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">    if (!ConstOpnd.isZero()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">      Value *C = ConstantInt::get(Ty, ConstOpnd);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">      Value *C = ConstantInt::get(Ty, ConstOpnd);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">      ValueEntry VE(getRank(C), C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">      ValueEntry VE(getRank(C), C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">      Ops.push_back(VE);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">      Ops.push_back(VE);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">    unsigned Sz = Ops.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">    unsigned Sz = Ops.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">    if (Sz == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">    if (Sz == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">      return Ops.back().Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">      return Ops.back().Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">    if (Sz == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">    if (Sz == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">      assert(ConstOpnd.isZero());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">      assert(ConstOpnd.isZero());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">      return ConstantInt::get(Ty, ConstOpnd);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">      return ConstantInt::get(Ty, ConstOpnd);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">/// Optimize a series of operands to an 'add' instruction.  This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">/// Optimize a series of operands to an 'add' instruction.  This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">/// optimizes based on identities.  If it can be reduced to a single Value, it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">/// optimizes based on identities.  If it can be reduced to a single Value, it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">/// is returned, otherwise the Ops list is mutated as necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">/// is returned, otherwise the Ops list is mutated as necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">Value *ReassociatePass::OptimizeAdd(Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">Value *ReassociatePass::OptimizeAdd(Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">  // Scan the operand lists looking for X and -X pairs.  If we find any, we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">  // Scan the operand lists looking for X and -X pairs.  If we find any, we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">  // can simplify expressions like X+-X == 0 and X+~X ==-1.  While we're at it,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">  // can simplify expressions like X+-X == 0 and X+~X ==-1.  While we're at it,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">  // scan for any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">  // scan for any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">  // duplicates.  We want to canonicalize Y+Y+Y+Z -> 3*Y+Z.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">  // duplicates.  We want to canonicalize Y+Y+Y+Z -> 3*Y+Z.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">    Value *TheOp = Ops[i].Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">    Value *TheOp = Ops[i].Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">    // Check to see if we've seen this operand before.  If so, we factor all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">    // Check to see if we've seen this operand before.  If so, we factor all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">    // instances of the operand together.  Due to our sorting criteria, we know</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">    // instances of the operand together.  Due to our sorting criteria, we know</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">    // that these need to be next to each other in the vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">    // that these need to be next to each other in the vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">    if (i+1 != Ops.size() && Ops[i+1].Op == TheOp) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">    if (i+1 != Ops.size() && Ops[i+1].Op == TheOp) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">      // Rescan the list, remove all instances of this operand from the expr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">      // Rescan the list, remove all instances of this operand from the expr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">      unsigned NumFound = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">      unsigned NumFound = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">      do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">      do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">        Ops.erase(Ops.begin()+i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">        Ops.erase(Ops.begin()+i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">        ++NumFound;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">        ++NumFound;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">      } while (i != Ops.size() && Ops[i].Op == TheOp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">      } while (i != Ops.size() && Ops[i].Op == TheOp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "\nFACTORING [" << NumFound << "]: " << *TheOp</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "\nFACTORING [" << NumFound << "]: " << *TheOp</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">                        << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">                        << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">      ++NumFactor;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">      ++NumFactor;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">      // Insert a new multiply.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">      // Insert a new multiply.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">      Type *Ty = TheOp->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">      Type *Ty = TheOp->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">      Constant *C = Ty->isIntOrIntVectorTy() ?</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">      Constant *C = Ty->isIntOrIntVectorTy() ?</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">        ConstantInt::get(Ty, NumFound) : ConstantFP::get(Ty, NumFound);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">        ConstantInt::get(Ty, NumFound) : ConstantFP::get(Ty, NumFound);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">      Instruction *Mul = CreateMul(TheOp, C, "factor", I, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">      Instruction *Mul = CreateMul(TheOp, C, "factor", I, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">      // Now that we have inserted a multiply, optimize it. This allows us to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">      // Now that we have inserted a multiply, optimize it. This allows us to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">      // handle cases that require multiple factoring steps, such as this:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">      // handle cases that require multiple factoring steps, such as this:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">      // (X*2) + (X*2) + (X*2) -> (X*2)*3 -> X*6</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">      // (X*2) + (X*2) + (X*2) -> (X*2)*3 -> X*6</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">      RedoInsts.insert(Mul);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">      RedoInsts.insert(Mul);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">      // If every add operand was a duplicate, return the multiply.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">      // If every add operand was a duplicate, return the multiply.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">      if (Ops.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">      if (Ops.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">        return Mul;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">        return Mul;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">      // Otherwise, we had some input that didn't have the dupe, such as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">      // Otherwise, we had some input that didn't have the dupe, such as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">      // "A + A + B" -> "A*2 + B".  Add the new multiply to the list of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">      // "A + A + B" -> "A*2 + B".  Add the new multiply to the list of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">      // things being added by this operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">      // things being added by this operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">      Ops.insert(Ops.begin(), ValueEntry(getRank(Mul), Mul));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">      Ops.insert(Ops.begin(), ValueEntry(getRank(Mul), Mul));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">      --i;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">      --i;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">      e = Ops.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">      e = Ops.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">    // Check for X and -X or X and ~X in the operand list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">    // Check for X and -X or X and ~X in the operand list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">    Value *X;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">    Value *X;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">    if (!match(TheOp, m_Neg(m_Value(X))) && !match(TheOp, m_Not(m_Value(X))) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">    if (!match(TheOp, m_Neg(m_Value(X))) && !match(TheOp, m_Not(m_Value(X))) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">        !match(TheOp, m_FNeg(m_Value(X))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">        !match(TheOp, m_FNeg(m_Value(X))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">    unsigned FoundX = FindInOperandList(Ops, i, X);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">    unsigned FoundX = FindInOperandList(Ops, i, X);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">    if (FoundX == i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">    if (FoundX == i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">    // Remove X and -X from the operand list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">    // Remove X and -X from the operand list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">    if (Ops.size() == 2 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">    if (Ops.size() == 2 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">        (match(TheOp, m_Neg(m_Value())) || match(TheOp, m_FNeg(m_Value()))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">        (match(TheOp, m_Neg(m_Value())) || match(TheOp, m_FNeg(m_Value()))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">      return Constant::getNullValue(X->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">      return Constant::getNullValue(X->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">    // Remove X and ~X from the operand list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">    // Remove X and ~X from the operand list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">    if (Ops.size() == 2 && match(TheOp, m_Not(m_Value())))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">    if (Ops.size() == 2 && match(TheOp, m_Not(m_Value())))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">      return Constant::getAllOnesValue(X->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">      return Constant::getAllOnesValue(X->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">    Ops.erase(Ops.begin()+i);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">    Ops.erase(Ops.begin()+i);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">    if (i < FoundX)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">    if (i < FoundX)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">      --FoundX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">      --FoundX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">      --i;   // Need to back up an extra one.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">      --i;   // Need to back up an extra one.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">    Ops.erase(Ops.begin()+FoundX);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">    Ops.erase(Ops.begin()+FoundX);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">    ++NumAnnihil;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">    ++NumAnnihil;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">    --i;     // Revisit element.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">    --i;     // Revisit element.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">    e -= 2;  // Removed two elements.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">    e -= 2;  // Removed two elements.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">    // if X and ~X we append -1 to the operand list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">    // if X and ~X we append -1 to the operand list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">    if (match(TheOp, m_Not(m_Value()))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">    if (match(TheOp, m_Not(m_Value()))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">      Value *V = Constant::getAllOnesValue(X->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">      Value *V = Constant::getAllOnesValue(X->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">      Ops.insert(Ops.end(), ValueEntry(getRank(V), V));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">      Ops.insert(Ops.end(), ValueEntry(getRank(V), V));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">      e += 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">      e += 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">  // Scan the operand list, checking to see if there are any common factors</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">  // Scan the operand list, checking to see if there are any common factors</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">  // between operands.  Consider something like A*A+A*B*C+D.  We would like to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">  // between operands.  Consider something like A*A+A*B*C+D.  We would like to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">  // reassociate this to A*(A+B*C)+D, which reduces the number of multiplies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">  // reassociate this to A*(A+B*C)+D, which reduces the number of multiplies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">  // To efficiently find this, we count the number of times a factor occurs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">  // To efficiently find this, we count the number of times a factor occurs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">  // for any ADD operands that are MULs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">  // for any ADD operands that are MULs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">  DenseMap<Value*, unsigned> FactorOccurrences;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">  DenseMap<Value*, unsigned> FactorOccurrences;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">  // Keep track of each multiply we see, to avoid triggering on (X*4)+(X*4)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">  // Keep track of each multiply we see, to avoid triggering on (X*4)+(X*4)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">  // where they are actually the same multiply.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">  // where they are actually the same multiply.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">  unsigned MaxOcc = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">  unsigned MaxOcc = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">  Value *MaxOccVal = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">  Value *MaxOccVal = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">    BinaryOperator *BOp =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">    BinaryOperator *BOp =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">        isReassociableOp(Ops[i].Op, Instruction::Mul, Instruction::FMul);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">        isReassociableOp(Ops[i].Op, Instruction::Mul, Instruction::FMul);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">    if (!BOp)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">    if (!BOp)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">    // Compute all of the factors of this added value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">    // Compute all of the factors of this added value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">    SmallVector<Value*, 8> Factors;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">    SmallVector<Value*, 8> Factors;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">    FindSingleUseMultiplyFactors(BOp, Factors);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">    FindSingleUseMultiplyFactors(BOp, Factors);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">    assert(Factors.size() > 1 && "Bad linearize!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">    assert(Factors.size() > 1 && "Bad linearize!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">    // Add one to FactorOccurrences for each unique factor in this op.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">    // Add one to FactorOccurrences for each unique factor in this op.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">    SmallPtrSet<Value*, 8> Duplicates;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">    SmallPtrSet<Value*, 8> Duplicates;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">    for (Value *Factor : Factors) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">    for (Value *Factor : Factors) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">      if (!Duplicates.insert(Factor).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">      if (!Duplicates.insert(Factor).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">      unsigned Occ = ++FactorOccurrences[Factor];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">      unsigned Occ = ++FactorOccurrences[Factor];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">      if (Occ > MaxOcc) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">      if (Occ > MaxOcc) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">        MaxOcc = Occ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">        MaxOcc = Occ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">        MaxOccVal = Factor;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">        MaxOccVal = Factor;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">      // If Factor is a negative constant, add the negated value as a factor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">      // If Factor is a negative constant, add the negated value as a factor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">      // because we can percolate the negate out.  Watch for minint, which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">      // because we can percolate the negate out.  Watch for minint, which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">      // cannot be positivified.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">      // cannot be positivified.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Factor)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">      if (ConstantInt *CI = dyn_cast<ConstantInt>(Factor)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">        if (CI->isNegative() && !CI->isMinValue(true)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">        if (CI->isNegative() && !CI->isMinValue(true)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">          Factor = ConstantInt::get(CI->getContext(), -CI->getValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">          Factor = ConstantInt::get(CI->getContext(), -CI->getValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">          if (!Duplicates.insert(Factor).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">          if (!Duplicates.insert(Factor).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">          unsigned Occ = ++FactorOccurrences[Factor];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">          unsigned Occ = ++FactorOccurrences[Factor];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">          if (Occ > MaxOcc) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">          if (Occ > MaxOcc) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">            MaxOcc = Occ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">            MaxOcc = Occ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">            MaxOccVal = Factor;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">            MaxOccVal = Factor;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">      } else if (ConstantFP *CF = dyn_cast<ConstantFP>(Factor)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">      } else if (ConstantFP *CF = dyn_cast<ConstantFP>(Factor)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">        if (CF->isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">        if (CF->isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">          APFloat F(CF->getValueAPF());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">          APFloat F(CF->getValueAPF());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine">          F.changeSign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine">          F.changeSign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">          Factor = ConstantFP::get(CF->getContext(), F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">          Factor = ConstantFP::get(CF->getContext(), F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">          if (!Duplicates.insert(Factor).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">          if (!Duplicates.insert(Factor).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">          unsigned Occ = ++FactorOccurrences[Factor];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">          unsigned Occ = ++FactorOccurrences[Factor];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">          if (Occ > MaxOcc) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">          if (Occ > MaxOcc) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">            MaxOcc = Occ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">            MaxOcc = Occ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">            MaxOccVal = Factor;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">            MaxOccVal = Factor;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">  // If any factor occurred more than one time, we can pull it out.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">  // If any factor occurred more than one time, we can pull it out.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">  if (MaxOcc > 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">  if (MaxOcc > 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "\nFACTORING [" << MaxOcc << "]: " << *MaxOccVal</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "\nFACTORING [" << MaxOcc << "]: " << *MaxOccVal</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">                      << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">                      << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">    ++NumFactor;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">    ++NumFactor;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">    // Create a new instruction that uses the MaxOccVal twice.  If we don't do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">    // Create a new instruction that uses the MaxOccVal twice.  If we don't do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">    // this, we could otherwise run into situations where removing a factor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">    // this, we could otherwise run into situations where removing a factor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">    // from an expression will drop a use of maxocc, and this can cause</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">    // from an expression will drop a use of maxocc, and this can cause</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">    // RemoveFactorFromExpression on successive values to behave differently.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">    // RemoveFactorFromExpression on successive values to behave differently.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">    Instruction *DummyInst =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">    Instruction *DummyInst =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">        I->getType()->isIntOrIntVectorTy()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">        I->getType()->isIntOrIntVectorTy()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">            ? BinaryOperator::CreateAdd(MaxOccVal, MaxOccVal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">            ? BinaryOperator::CreateAdd(MaxOccVal, MaxOccVal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">            : BinaryOperator::CreateFAdd(MaxOccVal, MaxOccVal);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">            : BinaryOperator::CreateFAdd(MaxOccVal, MaxOccVal);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">    SmallVector<WeakTrackingVH, 4> NewMulOps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">    SmallVector<WeakTrackingVH, 4> NewMulOps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">    for (unsigned i = 0; i != Ops.size(); ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">    for (unsigned i = 0; i != Ops.size(); ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">      // Only try to remove factors from expressions we're allowed to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">      // Only try to remove factors from expressions we're allowed to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">      BinaryOperator *BOp =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">      BinaryOperator *BOp =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">          isReassociableOp(Ops[i].Op, Instruction::Mul, Instruction::FMul);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">          isReassociableOp(Ops[i].Op, Instruction::Mul, Instruction::FMul);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">      if (!BOp)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">      if (!BOp)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">      if (Value *V = RemoveFactorFromExpression(Ops[i].Op, MaxOccVal)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">      if (Value *V = RemoveFactorFromExpression(Ops[i].Op, MaxOccVal)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">        // The factorized operand may occur several times.  Convert them all in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">        // The factorized operand may occur several times.  Convert them all in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">        // one fell swoop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">        // one fell swoop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">        for (unsigned j = Ops.size(); j != i;) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">        for (unsigned j = Ops.size(); j != i;) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">          --j;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">          --j;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">          if (Ops[j].Op == Ops[i].Op) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">          if (Ops[j].Op == Ops[i].Op) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">            NewMulOps.push_back(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">            NewMulOps.push_back(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">            Ops.erase(Ops.begin()+j);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">            Ops.erase(Ops.begin()+j);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">        --i;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">        --i;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">    // No need for extra uses anymore.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">    // No need for extra uses anymore.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">    DummyInst->deleteValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">    DummyInst->deleteValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">    unsigned NumAddedValues = NewMulOps.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">    unsigned NumAddedValues = NewMulOps.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">    Value *V = EmitAddTreeOfValues(I, NewMulOps);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">    Value *V = EmitAddTreeOfValues(I, NewMulOps);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">    // Now that we have inserted the add tree, optimize it. This allows us to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">    // Now that we have inserted the add tree, optimize it. This allows us to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">    // handle cases that require multiple factoring steps, such as this:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">    // handle cases that require multiple factoring steps, such as this:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">    // A*A*B + A*A*C   -->   A*(A*B+A*C)   -->   A*(A*(B+C))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">    // A*A*B + A*A*C   -->   A*(A*B+A*C)   -->   A*(A*(B+C))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">    assert(NumAddedValues > 1 && "Each occurrence should contribute a value");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">    assert(NumAddedValues > 1 && "Each occurrence should contribute a value");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">    (void)NumAddedValues;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">    (void)NumAddedValues;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">    if (Instruction *VI = dyn_cast<Instruction>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">    if (Instruction *VI = dyn_cast<Instruction>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">      RedoInsts.insert(VI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">      RedoInsts.insert(VI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">    // Create the multiply.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">    // Create the multiply.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">    Instruction *V2 = CreateMul(V, MaxOccVal, "reass.mul", I, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">    Instruction *V2 = CreateMul(V, MaxOccVal, "reass.mul", I, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">    // Rerun associate on the multiply in case the inner expression turned into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">    // Rerun associate on the multiply in case the inner expression turned into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">    // a multiply.  We want to make sure that we keep things in canonical form.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">    // a multiply.  We want to make sure that we keep things in canonical form.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">    RedoInsts.insert(V2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">    RedoInsts.insert(V2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">    // If every add operand included the factor (e.g. "A*B + A*C"), then the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">    // If every add operand included the factor (e.g. "A*B + A*C"), then the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">    // entire result expression is just the multiply "A*(B+C)".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">    // entire result expression is just the multiply "A*(B+C)".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">    if (Ops.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">    if (Ops.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">      return V2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">      return V2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">    // Otherwise, we had some input that didn't have the factor, such as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">    // Otherwise, we had some input that didn't have the factor, such as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">    // "A*B + A*C + D" -> "A*(B+C) + D".  Add the new multiply to the list of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">    // "A*B + A*C + D" -> "A*(B+C) + D".  Add the new multiply to the list of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">    // things being added by this operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">    // things being added by this operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">    Ops.insert(Ops.begin(), ValueEntry(getRank(V2), V2));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">    Ops.insert(Ops.begin(), ValueEntry(getRank(V2), V2));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">/// Build up a vector of value/power pairs factoring a product.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">/// Build up a vector of value/power pairs factoring a product.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">/// Given a series of multiplication operands, build a vector of factors and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">/// Given a series of multiplication operands, build a vector of factors and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">/// the powers each is raised to when forming the final product. Sort them in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">/// the powers each is raised to when forming the final product. Sort them in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">/// the order of descending power.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">/// the order of descending power.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">///      (x*x)          -> [(x, 2)]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">///      (x*x)          -> [(x, 2)]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">///     ((x*x)*x)       -> [(x, 3)]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">///     ((x*x)*x)       -> [(x, 3)]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">///   ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">///   ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">/// \returns Whether any factors have a power greater than one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">/// \returns Whether any factors have a power greater than one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">static bool collectMultiplyFactors(SmallVectorImpl<ValueEntry> &Ops,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">static bool collectMultiplyFactors(SmallVectorImpl<ValueEntry> &Ops,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">                                   SmallVectorImpl<Factor> &Factors) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">                                   SmallVectorImpl<Factor> &Factors) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">  // FIXME: Have Ops be (ValueEntry, Multiplicity) pairs, simplifying this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">  // FIXME: Have Ops be (ValueEntry, Multiplicity) pairs, simplifying this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">  // Compute the sum of powers of simplifiable factors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">  // Compute the sum of powers of simplifiable factors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">  unsigned FactorPowerSum = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">  unsigned FactorPowerSum = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">  for (unsigned Idx = 1, Size = Ops.size(); Idx < Size; ++Idx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">  for (unsigned Idx = 1, Size = Ops.size(); Idx < Size; ++Idx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">    Value *Op = Ops[Idx-1].Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">    Value *Op = Ops[Idx-1].Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">    // Count the number of occurrences of this value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">    // Count the number of occurrences of this value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">    unsigned Count = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">    unsigned Count = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">    for (; Idx < Size && Ops[Idx].Op == Op; ++Idx)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">    for (; Idx < Size && Ops[Idx].Op == Op; ++Idx)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">      ++Count;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">      ++Count;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">    // Track for simplification all factors which occur 2 or more times.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">    // Track for simplification all factors which occur 2 or more times.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">    if (Count > 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">    if (Count > 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">      FactorPowerSum += Count;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">      FactorPowerSum += Count;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">  // We can only simplify factors if the sum of the powers of our simplifiable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">  // We can only simplify factors if the sum of the powers of our simplifiable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">  // factors is 4 or higher. When that is the case, we will *always* have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">  // factors is 4 or higher. When that is the case, we will *always* have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">  // a simplification. This is an important invariant to prevent cyclicly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">  // a simplification. This is an important invariant to prevent cyclicly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">  // trying to simplify already minimal formations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">  // trying to simplify already minimal formations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">  if (FactorPowerSum < 4)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">  if (FactorPowerSum < 4)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">  // Now gather the simplifiable factors, removing them from Ops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">  // Now gather the simplifiable factors, removing them from Ops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">  FactorPowerSum = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">  FactorPowerSum = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">  for (unsigned Idx = 1; Idx < Ops.size(); ++Idx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">  for (unsigned Idx = 1; Idx < Ops.size(); ++Idx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">    Value *Op = Ops[Idx-1].Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">    Value *Op = Ops[Idx-1].Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">    // Count the number of occurrences of this value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">    // Count the number of occurrences of this value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">    unsigned Count = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">    unsigned Count = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">    for (; Idx < Ops.size() && Ops[Idx].Op == Op; ++Idx)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">    for (; Idx < Ops.size() && Ops[Idx].Op == Op; ++Idx)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">      ++Count;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">      ++Count;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">    if (Count == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">    if (Count == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">    // Move an even number of occurrences to Factors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">    // Move an even number of occurrences to Factors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">    Count &= ~1U;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">    Count &= ~1U;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">    Idx -= Count;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">    Idx -= Count;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">    FactorPowerSum += Count;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">    FactorPowerSum += Count;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">    Factors.push_back(Factor(Op, Count));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">    Factors.push_back(Factor(Op, Count));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">    Ops.erase(Ops.begin()+Idx, Ops.begin()+Idx+Count);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">    Ops.erase(Ops.begin()+Idx, Ops.begin()+Idx+Count);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">  // None of the adjustments above should have reduced the sum of factor powers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">  // None of the adjustments above should have reduced the sum of factor powers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">  // below our mininum of '4'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">  // below our mininum of '4'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">  assert(FactorPowerSum >= 4);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">  assert(FactorPowerSum >= 4);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">  llvm::stable_sort(Factors, [](const Factor &LHS, const Factor &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">  llvm::stable_sort(Factors, [](const Factor &LHS, const Factor &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">    return LHS.Power > RHS.Power;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">    return LHS.Power > RHS.Power;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">/// Build a tree of multiplies, computing the product of Ops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">/// Build a tree of multiplies, computing the product of Ops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">static Value *buildMultiplyTree(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">static Value *buildMultiplyTree(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">                                SmallVectorImpl<Value*> &Ops) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">                                SmallVectorImpl<Value*> &Ops) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">  if (Ops.size() == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">  if (Ops.size() == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">    return Ops.back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">    return Ops.back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">  Value *LHS = Ops.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">  Value *LHS = Ops.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">    if (LHS->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">    if (LHS->getType()->isIntOrIntVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">      LHS = Builder.CreateMul(LHS, Ops.pop_back_val());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">      LHS = Builder.CreateMul(LHS, Ops.pop_back_val());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">      LHS = Builder.CreateFMul(LHS, Ops.pop_back_val());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">      LHS = Builder.CreateFMul(LHS, Ops.pop_back_val());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">  } while (!Ops.empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">  } while (!Ops.empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">  return LHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">  return LHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">/// Build a minimal multiplication DAG for (a^x)*(b^y)*(c^z)*...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">/// Build a minimal multiplication DAG for (a^x)*(b^y)*(c^z)*...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">/// Given a vector of values raised to various powers, where no two values are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">/// Given a vector of values raised to various powers, where no two values are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">/// equal and the powers are sorted in decreasing order, compute the minimal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">/// equal and the powers are sorted in decreasing order, compute the minimal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">/// DAG of multiplies to compute the final product, and return that product</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">/// DAG of multiplies to compute the final product, and return that product</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">/// value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">/// value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">Value *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">Value *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">ReassociatePass::buildMinimalMultiplyDAG(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">ReassociatePass::buildMinimalMultiplyDAG(IRBuilderBase &Builder,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">                                         SmallVectorImpl<Factor> &Factors) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">                                         SmallVectorImpl<Factor> &Factors) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">  assert(Factors[0].Power);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">  assert(Factors[0].Power);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">  SmallVector<Value *, 4> OuterProduct;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">  SmallVector<Value *, 4> OuterProduct;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">  for (unsigned LastIdx = 0, Idx = 1, Size = Factors.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">  for (unsigned LastIdx = 0, Idx = 1, Size = Factors.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">       Idx < Size && Factors[Idx].Power > 0; ++Idx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">       Idx < Size && Factors[Idx].Power > 0; ++Idx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">    if (Factors[Idx].Power != Factors[LastIdx].Power) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">    if (Factors[Idx].Power != Factors[LastIdx].Power) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">      LastIdx = Idx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">      LastIdx = Idx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">    // We want to multiply across all the factors with the same power so that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">    // We want to multiply across all the factors with the same power so that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">    // we can raise them to that power as a single entity. Build a mini tree</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">    // we can raise them to that power as a single entity. Build a mini tree</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">    // for that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">    // for that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">    SmallVector<Value *, 4> InnerProduct;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">    SmallVector<Value *, 4> InnerProduct;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">    InnerProduct.push_back(Factors[LastIdx].Base);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">    InnerProduct.push_back(Factors[LastIdx].Base);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">      InnerProduct.push_back(Factors[Idx].Base);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">      InnerProduct.push_back(Factors[Idx].Base);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">      ++Idx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">      ++Idx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">    } while (Idx < Size && Factors[Idx].Power == Factors[LastIdx].Power);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">    } while (Idx < Size && Factors[Idx].Power == Factors[LastIdx].Power);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">    // Reset the base value of the first factor to the new expression tree.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">    // Reset the base value of the first factor to the new expression tree.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">    // We'll remove all the factors with the same power in a second pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">    // We'll remove all the factors with the same power in a second pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">    Value *M = Factors[LastIdx].Base = buildMultiplyTree(Builder, InnerProduct);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">    Value *M = Factors[LastIdx].Base = buildMultiplyTree(Builder, InnerProduct);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">    if (Instruction *MI = dyn_cast<Instruction>(M))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">    if (Instruction *MI = dyn_cast<Instruction>(M))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">      RedoInsts.insert(MI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">      RedoInsts.insert(MI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">    LastIdx = Idx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">    LastIdx = Idx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">  // Unique factors with equal powers -- we've folded them into the first one's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">  // Unique factors with equal powers -- we've folded them into the first one's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">  // base.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">  // base.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">  Factors.erase(std::unique(Factors.begin(), Factors.end(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">  Factors.erase(std::unique(Factors.begin(), Factors.end(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">                            [](const Factor &LHS, const Factor &RHS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">                            [](const Factor &LHS, const Factor &RHS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">                              return LHS.Power == RHS.Power;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">                              return LHS.Power == RHS.Power;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">                            }),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">                            }),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">                Factors.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">                Factors.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">  // Iteratively collect the base of each factor with an add power into the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">  // Iteratively collect the base of each factor with an add power into the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">  // outer product, and halve each power in preparation for squaring the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">  // outer product, and halve each power in preparation for squaring the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">  // expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">  // expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">  for (Factor &F : Factors) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">  for (Factor &F : Factors) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">    if (F.Power & 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">    if (F.Power & 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">      OuterProduct.push_back(F.Base);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">      OuterProduct.push_back(F.Base);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">    F.Power >>= 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">    F.Power >>= 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">  if (Factors[0].Power) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">  if (Factors[0].Power) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">    Value *SquareRoot = buildMinimalMultiplyDAG(Builder, Factors);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">    Value *SquareRoot = buildMinimalMultiplyDAG(Builder, Factors);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">    OuterProduct.push_back(SquareRoot);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">    OuterProduct.push_back(SquareRoot);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">    OuterProduct.push_back(SquareRoot);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">    OuterProduct.push_back(SquareRoot);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">  if (OuterProduct.size() == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">  if (OuterProduct.size() == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">    return OuterProduct.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">    return OuterProduct.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">  Value *V = buildMultiplyTree(Builder, OuterProduct);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">  Value *V = buildMultiplyTree(Builder, OuterProduct);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">Value *ReassociatePass::OptimizeMul(BinaryOperator *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">Value *ReassociatePass::OptimizeMul(BinaryOperator *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">                                    SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">  // We can only optimize the multiplies when there is a chain of more than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">  // We can only optimize the multiplies when there is a chain of more than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">  // three, such that a balanced tree might require fewer total multiplies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">  // three, such that a balanced tree might require fewer total multiplies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">  if (Ops.size() < 4)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">  if (Ops.size() < 4)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">  // Try to turn linear trees of multiplies without other uses of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">  // Try to turn linear trees of multiplies without other uses of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">  // intermediate stages into minimal multiply DAGs with perfect sub-expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">  // intermediate stages into minimal multiply DAGs with perfect sub-expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">  // re-use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">  // re-use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">  SmallVector<Factor, 4> Factors;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">  SmallVector<Factor, 4> Factors;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">  if (!collectMultiplyFactors(Ops, Factors))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">  if (!collectMultiplyFactors(Ops, Factors))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">    return nullptr; // All distinct factors, so nothing left for us to do.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">    return nullptr; // All distinct factors, so nothing left for us to do.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">  IRBuilder<> Builder(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">  IRBuilder<> Builder(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">  // The reassociate transformation for FP operations is performed only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">  // The reassociate transformation for FP operations is performed only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">  // if unsafe algebra is permitted by FastMathFlags. Propagate those flags</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">  // if unsafe algebra is permitted by FastMathFlags. Propagate those flags</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">  // to the newly generated operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">  // to the newly generated operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">  if (auto FPI = dyn_cast<FPMathOperator>(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">  if (auto FPI = dyn_cast<FPMathOperator>(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">    Builder.setFastMathFlags(FPI->getFastMathFlags());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">    Builder.setFastMathFlags(FPI->getFastMathFlags());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">  Value *V = buildMinimalMultiplyDAG(Builder, Factors);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">  Value *V = buildMinimalMultiplyDAG(Builder, Factors);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">  if (Ops.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">  if (Ops.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">  ValueEntry NewEntry = ValueEntry(getRank(V), V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">  ValueEntry NewEntry = ValueEntry(getRank(V), V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">  Ops.insert(llvm::lower_bound(Ops, NewEntry), NewEntry);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">  Ops.insert(llvm::lower_bound(Ops, NewEntry), NewEntry);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">Value *ReassociatePass::OptimizeExpression(BinaryOperator *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">Value *ReassociatePass::OptimizeExpression(BinaryOperator *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">                                           SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">                                           SmallVectorImpl<ValueEntry> &Ops) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">  // Now that we have the linearized expression tree, try to optimize it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">  // Now that we have the linearized expression tree, try to optimize it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">  // Start by folding any constants that we found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">  // Start by folding any constants that we found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">  const DataLayout &DL = I->getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">  const DataLayout &DL = I->getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">  Constant *Cst = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">  Constant *Cst = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">  unsigned Opcode = I->getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">  unsigned Opcode = I->getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">  while (!Ops.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">  while (!Ops.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">    if (auto *C = dyn_cast<Constant>(Ops.back().Op)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">    if (auto *C = dyn_cast<Constant>(Ops.back().Op)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">      if (!Cst) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">      if (!Cst) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">        Ops.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">        Ops.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">        Cst = C;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">        Cst = C;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">      if (Constant *Res = ConstantFoldBinaryOpOperands(Opcode, C, Cst, DL)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">      if (Constant *Res = ConstantFoldBinaryOpOperands(Opcode, C, Cst, DL)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">        Ops.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">        Ops.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">        Cst = Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">        Cst = Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">  // If there was nothing but constants then we are done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">  // If there was nothing but constants then we are done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">  if (Ops.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">  if (Ops.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">    return Cst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">    return Cst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">  // Put the combined constant back at the end of the operand list, except if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">  // Put the combined constant back at the end of the operand list, except if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">  // there is no point.  For example, an add of 0 gets dropped here, while a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">  // there is no point.  For example, an add of 0 gets dropped here, while a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">  // multiplication by zero turns the whole expression into zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">  // multiplication by zero turns the whole expression into zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">  if (Cst && Cst != ConstantExpr::getBinOpIdentity(Opcode, I->getType())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">  if (Cst && Cst != ConstantExpr::getBinOpIdentity(Opcode, I->getType())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">    if (Cst == ConstantExpr::getBinOpAbsorber(Opcode, I->getType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">    if (Cst == ConstantExpr::getBinOpAbsorber(Opcode, I->getType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">      return Cst;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">      return Cst;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">    Ops.push_back(ValueEntry(0, Cst));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">    Ops.push_back(ValueEntry(0, Cst));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">  if (Ops.size() == 1) return Ops[0].Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">  if (Ops.size() == 1) return Ops[0].Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">  // Handle destructive annihilation due to identities between elements in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">  // Handle destructive annihilation due to identities between elements in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">  // argument list here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">  // argument list here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">  unsigned NumOps = Ops.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">  unsigned NumOps = Ops.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">  switch (Opcode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">  switch (Opcode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">  default: break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">  default: break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">  case Instruction::And:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">  case Instruction::And:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">  case Instruction::Or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">  case Instruction::Or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">    if (Value *Result = OptimizeAndOrXor(Opcode, Ops))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">    if (Value *Result = OptimizeAndOrXor(Opcode, Ops))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">      return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">      return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">  case Instruction::Xor:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">  case Instruction::Xor:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">    if (Value *Result = OptimizeXor(I, Ops))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">    if (Value *Result = OptimizeXor(I, Ops))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">      return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">      return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">  case Instruction::Add:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">  case Instruction::Add:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">  case Instruction::FAdd:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">  case Instruction::FAdd:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">    if (Value *Result = OptimizeAdd(I, Ops))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">    if (Value *Result = OptimizeAdd(I, Ops))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">      return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">      return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">  case Instruction::Mul:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">  case Instruction::Mul:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">  case Instruction::FMul:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">  case Instruction::FMul:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">    if (Value *Result = OptimizeMul(I, Ops))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">    if (Value *Result = OptimizeMul(I, Ops))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">      return Result;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">      return Result;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">    break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">  if (Ops.size() != NumOps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">  if (Ops.size() != NumOps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">    return OptimizeExpression(I, Ops);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">    return OptimizeExpression(I, Ops);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">// Remove dead instructions and if any operands are trivially dead add them to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">// Remove dead instructions and if any operands are trivially dead add them to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">// Insts so they will be removed as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">// Insts so they will be removed as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">void ReassociatePass::RecursivelyEraseDeadInsts(Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">void ReassociatePass::RecursivelyEraseDeadInsts(Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">                                                OrderedSet &Insts) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">                                                OrderedSet &Insts) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">  assert(isInstructionTriviallyDead(I) && "Trivially dead instructions only!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">  assert(isInstructionTriviallyDead(I) && "Trivially dead instructions only!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">  SmallVector<Value *, 4> Ops(I->operands());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">  SmallVector<Value *, 4> Ops(I->operands());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">  ValueRankMap.erase(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">  ValueRankMap.erase(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">  Insts.remove(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">  Insts.remove(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">  RedoInsts.remove(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">  RedoInsts.remove(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">  llvm::salvageDebugInfo(*I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">  llvm::salvageDebugInfo(*I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">  I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">  I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">  for (auto *Op : Ops)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">  for (auto *Op : Ops)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">    if (Instruction *OpInst = dyn_cast<Instruction>(Op))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">    if (Instruction *OpInst = dyn_cast<Instruction>(Op))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">      if (OpInst->use_empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">      if (OpInst->use_empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">        Insts.insert(OpInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">        Insts.insert(OpInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">/// Zap the given instruction, adding interesting operands to the work list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">/// Zap the given instruction, adding interesting operands to the work list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">void ReassociatePass::EraseInst(Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">void ReassociatePass::EraseInst(Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">  assert(isInstructionTriviallyDead(I) && "Trivially dead instructions only!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">  assert(isInstructionTriviallyDead(I) && "Trivially dead instructions only!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Erasing dead inst: "; I->dump());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Erasing dead inst: "; I->dump());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">  SmallVector<Value *, 8> Ops(I->operands());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">  SmallVector<Value *, 8> Ops(I->operands());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">  // Erase the dead instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">  // Erase the dead instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">  ValueRankMap.erase(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">  ValueRankMap.erase(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">  RedoInsts.remove(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">  RedoInsts.remove(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">  llvm::salvageDebugInfo(*I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">  llvm::salvageDebugInfo(*I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">  I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">  I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">  // Optimize its operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">  // Optimize its operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">  SmallPtrSet<Instruction *, 8> Visited; // Detect self-referential nodes.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">  SmallPtrSet<Instruction *, 8> Visited; // Detect self-referential nodes.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">  for (unsigned i = 0, e = Ops.size(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine">    if (Instruction *Op = dyn_cast<Instruction>(Ops[i])) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine">    if (Instruction *Op = dyn_cast<Instruction>(Ops[i])) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">      // If this is a node in an expression tree, climb to the expression root</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">      // If this is a node in an expression tree, climb to the expression root</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">      // and add that since that's where optimization actually happens.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">      // and add that since that's where optimization actually happens.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">      unsigned Opcode = Op->getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">      unsigned Opcode = Op->getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">      while (Op->hasOneUse() && Op->user_back()->getOpcode() == Opcode &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">      while (Op->hasOneUse() && Op->user_back()->getOpcode() == Opcode &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">             Visited.insert(Op).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">             Visited.insert(Op).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">        Op = Op->user_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">        Op = Op->user_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">      // The instruction we're going to push may be coming from a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">      // The instruction we're going to push may be coming from a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">      // dead block, and Reassociate skips the processing of unreachable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">      // dead block, and Reassociate skips the processing of unreachable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">      // blocks because it's a waste of time and also because it can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">      // blocks because it's a waste of time and also because it can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">      // lead to infinite loop due to LLVM's non-standard definition</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">      // lead to infinite loop due to LLVM's non-standard definition</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">      // of dominance.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">      // of dominance.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">      if (ValueRankMap.contains(Op))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">      if (ValueRankMap.contains(Op))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">        RedoInsts.insert(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">        RedoInsts.insert(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">  MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">  MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">/// Recursively analyze an expression to build a list of instructions that have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">/// Recursively analyze an expression to build a list of instructions that have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">/// negative floating-point constant operands. The caller can then transform</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">/// negative floating-point constant operands. The caller can then transform</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">/// the list to create positive constants for better reassociation and CSE.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">/// the list to create positive constants for better reassociation and CSE.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">static void getNegatibleInsts(Value *V,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">static void getNegatibleInsts(Value *V,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">                              SmallVectorImpl<Instruction *> &Candidates) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">                              SmallVectorImpl<Instruction *> &Candidates) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">  // Handle only one-use instructions. Combining negations does not justify</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">  // Handle only one-use instructions. Combining negations does not justify</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">  // replicating instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">  // replicating instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">  Instruction *I;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">  Instruction *I;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">  if (!match(V, m_OneUse(m_Instruction(I))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">  if (!match(V, m_OneUse(m_Instruction(I))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">  // Handle expressions of multiplications and divisions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">  // Handle expressions of multiplications and divisions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">  // TODO: This could look through floating-point casts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">  // TODO: This could look through floating-point casts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">  const APFloat *C;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">  const APFloat *C;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">  switch (I->getOpcode()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">  switch (I->getOpcode()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">    case Instruction::FMul:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">    case Instruction::FMul:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">      // Not expecting non-canonical code here. Bail out and wait.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">      // Not expecting non-canonical code here. Bail out and wait.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">      if (match(I->getOperand(0), m_Constant()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">      if (match(I->getOperand(0), m_Constant()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">      if (match(I->getOperand(1), m_APFloat(C)) && C->isNegative()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">      if (match(I->getOperand(1), m_APFloat(C)) && C->isNegative()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">        Candidates.push_back(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">        Candidates.push_back(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "FMul with negative constant: " << *I << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "FMul with negative constant: " << *I << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">      getNegatibleInsts(I->getOperand(0), Candidates);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">      getNegatibleInsts(I->getOperand(0), Candidates);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">      getNegatibleInsts(I->getOperand(1), Candidates);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">      getNegatibleInsts(I->getOperand(1), Candidates);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">    case Instruction::FDiv:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">    case Instruction::FDiv:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">      // Not expecting non-canonical code here. Bail out and wait.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">      // Not expecting non-canonical code here. Bail out and wait.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">      if (match(I->getOperand(0), m_Constant()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">      if (match(I->getOperand(0), m_Constant()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">          match(I->getOperand(1), m_Constant()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">          match(I->getOperand(1), m_Constant()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">      if ((match(I->getOperand(0), m_APFloat(C)) && C->isNegative()) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">      if ((match(I->getOperand(0), m_APFloat(C)) && C->isNegative()) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">          (match(I->getOperand(1), m_APFloat(C)) && C->isNegative())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">          (match(I->getOperand(1), m_APFloat(C)) && C->isNegative())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">        Candidates.push_back(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">        Candidates.push_back(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "FDiv with negative constant: " << *I << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "FDiv with negative constant: " << *I << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">      getNegatibleInsts(I->getOperand(0), Candidates);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">      getNegatibleInsts(I->getOperand(0), Candidates);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">      getNegatibleInsts(I->getOperand(1), Candidates);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">      getNegatibleInsts(I->getOperand(1), Candidates);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">/// Given an fadd/fsub with an operand that is a one-use instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">/// Given an fadd/fsub with an operand that is a one-use instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">/// (the fadd/fsub), try to change negative floating-point constants into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">/// (the fadd/fsub), try to change negative floating-point constants into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">/// positive constants to increase potential for reassociation and CSE.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">/// positive constants to increase potential for reassociation and CSE.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">Instruction *ReassociatePass::canonicalizeNegFPConstantsForOp(Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">Instruction *ReassociatePass::canonicalizeNegFPConstantsForOp(Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">                                                              Instruction *Op,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">                                                              Instruction *Op,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">                                                              Value *OtherOp) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">                                                              Value *OtherOp) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">  assert((I->getOpcode() == Instruction::FAdd ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">  assert((I->getOpcode() == Instruction::FAdd ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">          I->getOpcode() == Instruction::FSub) && "Expected fadd/fsub");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">          I->getOpcode() == Instruction::FSub) && "Expected fadd/fsub");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">  // Collect instructions with negative FP constants from the subtree that ends</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">  // Collect instructions with negative FP constants from the subtree that ends</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">  // in Op.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">  // in Op.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">  SmallVector<Instruction *, 4> Candidates;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">  SmallVector<Instruction *, 4> Candidates;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">  getNegatibleInsts(Op, Candidates);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">  getNegatibleInsts(Op, Candidates);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">  if (Candidates.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">  if (Candidates.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">  // Don't canonicalize x + (-Constant * y) -> x - (Constant * y), if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">  // Don't canonicalize x + (-Constant * y) -> x - (Constant * y), if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">  // resulting subtract will be broken up later.  This can get us into an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">  // resulting subtract will be broken up later.  This can get us into an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">  // infinite loop during reassociation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">  // infinite loop during reassociation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">  bool IsFSub = I->getOpcode() == Instruction::FSub;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">  bool IsFSub = I->getOpcode() == Instruction::FSub;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">  bool NeedsSubtract = !IsFSub && Candidates.size() % 2 == 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">  bool NeedsSubtract = !IsFSub && Candidates.size() % 2 == 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">  if (NeedsSubtract && ShouldBreakUpSubtract(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">  if (NeedsSubtract && ShouldBreakUpSubtract(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">  for (Instruction *Negatible : Candidates) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">  for (Instruction *Negatible : Candidates) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">    const APFloat *C;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">    const APFloat *C;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">    if (match(Negatible->getOperand(0), m_APFloat(C))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">    if (match(Negatible->getOperand(0), m_APFloat(C))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">      assert(!match(Negatible->getOperand(1), m_Constant()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">      assert(!match(Negatible->getOperand(1), m_Constant()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">             "Expecting only 1 constant operand");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">             "Expecting only 1 constant operand");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">      assert(C->isNegative() && "Expected negative FP constant");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">      assert(C->isNegative() && "Expected negative FP constant");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">      Negatible->setOperand(0, ConstantFP::get(Negatible->getType(), abs(*C)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">      Negatible->setOperand(0, ConstantFP::get(Negatible->getType(), abs(*C)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">    if (match(Negatible->getOperand(1), m_APFloat(C))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">    if (match(Negatible->getOperand(1), m_APFloat(C))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">      assert(!match(Negatible->getOperand(0), m_Constant()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">      assert(!match(Negatible->getOperand(0), m_Constant()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">             "Expecting only 1 constant operand");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">             "Expecting only 1 constant operand");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">      assert(C->isNegative() && "Expected negative FP constant");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">      assert(C->isNegative() && "Expected negative FP constant");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">      Negatible->setOperand(1, ConstantFP::get(Negatible->getType(), abs(*C)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">      Negatible->setOperand(1, ConstantFP::get(Negatible->getType(), abs(*C)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">  assert(MadeChange == true && "Negative constant candidate was not changed");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">  assert(MadeChange == true && "Negative constant candidate was not changed");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">  // Negations cancelled out.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">  // Negations cancelled out.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">  if (Candidates.size() % 2 == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">  if (Candidates.size() % 2 == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">    return I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">    return I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">  // Negate the final operand in the expression by flipping the opcode of this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">  // Negate the final operand in the expression by flipping the opcode of this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">  // fadd/fsub.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">  // fadd/fsub.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">  assert(Candidates.size() % 2 == 1 && "Expected odd number");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">  assert(Candidates.size() % 2 == 1 && "Expected odd number");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">  IRBuilder<> Builder(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">  IRBuilder<> Builder(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">  Value *NewInst = IsFSub ? Builder.CreateFAddFMF(OtherOp, Op, I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">  Value *NewInst = IsFSub ? Builder.CreateFAddFMF(OtherOp, Op, I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">                          : Builder.CreateFSubFMF(OtherOp, Op, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">                          : Builder.CreateFSubFMF(OtherOp, Op, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">  I->replaceAllUsesWith(NewInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">  I->replaceAllUsesWith(NewInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">  RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">  RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">  return dyn_cast<Instruction>(NewInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">  return dyn_cast<Instruction>(NewInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">/// Canonicalize expressions that contain a negative floating-point constant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">/// Canonicalize expressions that contain a negative floating-point constant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">/// of the following form:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">/// of the following form:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">///   OtherOp + (subtree) -> OtherOp {+/-} (canonical subtree)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">///   OtherOp + (subtree) -> OtherOp {+/-} (canonical subtree)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">///   (subtree) + OtherOp -> OtherOp {+/-} (canonical subtree)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">///   (subtree) + OtherOp -> OtherOp {+/-} (canonical subtree)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">///   OtherOp - (subtree) -> OtherOp {+/-} (canonical subtree)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">///   OtherOp - (subtree) -> OtherOp {+/-} (canonical subtree)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">/// The fadd/fsub opcode may be switched to allow folding a negation into the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">/// The fadd/fsub opcode may be switched to allow folding a negation into the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">/// input instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">/// input instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">Instruction *ReassociatePass::canonicalizeNegFPConstants(Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">Instruction *ReassociatePass::canonicalizeNegFPConstants(Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Combine negations for: " << *I << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Combine negations for: " << *I << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">  Value *X;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">  Value *X;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">  Instruction *Op;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">  Instruction *Op;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">  if (match(I, m_FAdd(m_Value(X), m_OneUse(m_Instruction(Op)))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">  if (match(I, m_FAdd(m_Value(X), m_OneUse(m_Instruction(Op)))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">      I = R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">      I = R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">  if (match(I, m_FAdd(m_OneUse(m_Instruction(Op)), m_Value(X))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">  if (match(I, m_FAdd(m_OneUse(m_Instruction(Op)), m_Value(X))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">      I = R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">      I = R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">  if (match(I, m_FSub(m_Value(X), m_OneUse(m_Instruction(Op)))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">  if (match(I, m_FSub(m_Value(X), m_OneUse(m_Instruction(Op)))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">    if (Instruction *R = canonicalizeNegFPConstantsForOp(I, Op, X))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">      I = R;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">      I = R;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">  return I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">  return I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">/// Inspect and optimize the given instruction. Note that erasing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">/// Inspect and optimize the given instruction. Note that erasing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">/// instructions is not allowed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">/// instructions is not allowed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">void ReassociatePass::OptimizeInst(Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">void ReassociatePass::OptimizeInst(Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">  // Only consider operations that we understand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">  // Only consider operations that we understand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">  if (!isa<UnaryOperator>(I) && !isa<BinaryOperator>(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">  if (!isa<UnaryOperator>(I) && !isa<BinaryOperator>(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">  if (I->getOpcode() == Instruction::Shl && isa<ConstantInt>(I->getOperand(1)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">  if (I->getOpcode() == Instruction::Shl && isa<ConstantInt>(I->getOperand(1)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">    // If an operand of this shift is a reassociable multiply, or if the shift</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">    // If an operand of this shift is a reassociable multiply, or if the shift</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine">    // is used by a reassociable multiply or add, turn into a multiply.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine">    // is used by a reassociable multiply or add, turn into a multiply.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">    if (isReassociableOp(I->getOperand(0), Instruction::Mul) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">    if (isReassociableOp(I->getOperand(0), Instruction::Mul) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">        (I->hasOneUse() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">        (I->hasOneUse() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">         (isReassociableOp(I->user_back(), Instruction::Mul) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">         (isReassociableOp(I->user_back(), Instruction::Mul) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">          isReassociableOp(I->user_back(), Instruction::Add)))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">          isReassociableOp(I->user_back(), Instruction::Add)))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">      Instruction *NI = ConvertShiftToMul(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">      Instruction *NI = ConvertShiftToMul(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">      RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">      RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">      I = NI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">      I = NI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">  // Commute binary operators, to canonicalize the order of their operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">  // Commute binary operators, to canonicalize the order of their operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">  // This can potentially expose more CSE opportunities, and makes writing other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">  // This can potentially expose more CSE opportunities, and makes writing other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">  // transformations simpler.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">  // transformations simpler.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">  if (I->isCommutative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">  if (I->isCommutative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">    canonicalizeOperands(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">    canonicalizeOperands(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">  // Canonicalize negative constants out of expressions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">  // Canonicalize negative constants out of expressions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">  if (Instruction *Res = canonicalizeNegFPConstants(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">  if (Instruction *Res = canonicalizeNegFPConstants(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">    I = Res;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">    I = Res;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">  // Don't optimize floating-point instructions unless they have the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">  // Don't optimize floating-point instructions unless they have the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine">  // appropriate FastMathFlags for reassociation enabled.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine">  // appropriate FastMathFlags for reassociation enabled.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">  if (isa<FPMathOperator>(I) && !hasFPAssociativeFlags(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">  if (isa<FPMathOperator>(I) && !hasFPAssociativeFlags(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">  // Do not reassociate boolean (i1) expressions.  We want to preserve the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">  // Do not reassociate boolean (i1) expressions.  We want to preserve the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine">  // original order of evaluation for short-circuited comparisons that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine">  // original order of evaluation for short-circuited comparisons that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">  // SimplifyCFG has folded to AND/OR expressions.  If the expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">  // SimplifyCFG has folded to AND/OR expressions.  If the expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">  // is not further optimized, it is likely to be transformed back to a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">  // is not further optimized, it is likely to be transformed back to a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">  // short-circuited form for code gen, and the source order may have been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">  // short-circuited form for code gen, and the source order may have been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">  // optimized for the most likely conditions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">  // optimized for the most likely conditions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">  if (I->getType()->isIntegerTy(1))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">  if (I->getType()->isIntegerTy(1))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">  // If this is a bitwise or instruction of operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">  // If this is a bitwise or instruction of operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">  // with no common bits set, convert it to X+Y.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">  // with no common bits set, convert it to X+Y.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">  if (I->getOpcode() == Instruction::Or &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">  if (I->getOpcode() == Instruction::Or &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">      shouldConvertOrWithNoCommonBitsToAdd(I) && !isLoadCombineCandidate(I) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">      shouldConvertOrWithNoCommonBitsToAdd(I) && !isLoadCombineCandidate(I) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">      haveNoCommonBitsSet(I->getOperand(0), I->getOperand(1),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">      haveNoCommonBitsSet(I->getOperand(0), I->getOperand(1),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">                          I->getModule()->getDataLayout(), /*AC=*/nullptr, I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">                          I->getModule()->getDataLayout(), /*AC=*/nullptr, I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">                          /*DT=*/nullptr)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">                          /*DT=*/nullptr)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">    Instruction *NI = convertOrWithNoCommonBitsToAdd(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">    Instruction *NI = convertOrWithNoCommonBitsToAdd(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">    RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">    RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">    MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">    MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">    I = NI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">    I = NI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">  // If this is a subtract instruction which is not already in negate form,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">  // If this is a subtract instruction which is not already in negate form,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">  // see if we can convert it to X+-Y.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">  // see if we can convert it to X+-Y.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">  if (I->getOpcode() == Instruction::Sub) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">  if (I->getOpcode() == Instruction::Sub) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">    if (ShouldBreakUpSubtract(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">    if (ShouldBreakUpSubtract(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">      Instruction *NI = BreakUpSubtract(I, RedoInsts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">      Instruction *NI = BreakUpSubtract(I, RedoInsts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">      RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">      RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">      I = NI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">      I = NI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">    } else if (match(I, m_Neg(m_Value()))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">    } else if (match(I, m_Neg(m_Value()))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine">      // Otherwise, this is a negation.  See if the operand is a multiply tree</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine">      // Otherwise, this is a negation.  See if the operand is a multiply tree</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">      // and if this is not an inner node of a multiply tree.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">      // and if this is not an inner node of a multiply tree.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">      if (isReassociableOp(I->getOperand(1), Instruction::Mul) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">      if (isReassociableOp(I->getOperand(1), Instruction::Mul) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">          (!I->hasOneUse() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">          (!I->hasOneUse() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">           !isReassociableOp(I->user_back(), Instruction::Mul))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">           !isReassociableOp(I->user_back(), Instruction::Mul))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">        Instruction *NI = LowerNegateToMultiply(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">        Instruction *NI = LowerNegateToMultiply(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine">        // If the negate was simplified, revisit the users to see if we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine">        // If the negate was simplified, revisit the users to see if we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">        // reassociate further.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">        // reassociate further.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">        for (User *U : NI->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">        for (User *U : NI->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">          if (BinaryOperator *Tmp = dyn_cast<BinaryOperator>(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">          if (BinaryOperator *Tmp = dyn_cast<BinaryOperator>(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">            RedoInsts.insert(Tmp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">            RedoInsts.insert(Tmp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">        RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">        RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">        MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">        MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">        I = NI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">        I = NI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">  } else if (I->getOpcode() == Instruction::FNeg ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">  } else if (I->getOpcode() == Instruction::FNeg ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">             I->getOpcode() == Instruction::FSub) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">             I->getOpcode() == Instruction::FSub) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">    if (ShouldBreakUpSubtract(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">    if (ShouldBreakUpSubtract(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">      Instruction *NI = BreakUpSubtract(I, RedoInsts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">      Instruction *NI = BreakUpSubtract(I, RedoInsts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">      RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">      RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">      MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">      I = NI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">      I = NI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">    } else if (match(I, m_FNeg(m_Value()))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">    } else if (match(I, m_FNeg(m_Value()))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine">      // Otherwise, this is a negation.  See if the operand is a multiply tree</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine">      // Otherwise, this is a negation.  See if the operand is a multiply tree</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">      // and if this is not an inner node of a multiply tree.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">      // and if this is not an inner node of a multiply tree.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">      Value *Op = isa<BinaryOperator>(I) ? I->getOperand(1) :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">      Value *Op = isa<BinaryOperator>(I) ? I->getOperand(1) :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine">                                           I->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine">                                           I->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">      if (isReassociableOp(Op, Instruction::FMul) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">      if (isReassociableOp(Op, Instruction::FMul) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">          (!I->hasOneUse() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">          (!I->hasOneUse() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine">           !isReassociableOp(I->user_back(), Instruction::FMul))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine">           !isReassociableOp(I->user_back(), Instruction::FMul))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">        // If the negate was simplified, revisit the users to see if we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">        // If the negate was simplified, revisit the users to see if we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">        // reassociate further.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">        // reassociate further.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">        Instruction *NI = LowerNegateToMultiply(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">        Instruction *NI = LowerNegateToMultiply(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">        for (User *U : NI->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">        for (User *U : NI->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">          if (BinaryOperator *Tmp = dyn_cast<BinaryOperator>(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">          if (BinaryOperator *Tmp = dyn_cast<BinaryOperator>(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine">            RedoInsts.insert(Tmp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine">            RedoInsts.insert(Tmp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">        RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">        RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine">        MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine">        MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">        I = NI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">        I = NI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine">  // If this instruction is an associative binary operator, process it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine">  // If this instruction is an associative binary operator, process it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">  if (!I->isAssociative()) return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">  if (!I->isAssociative()) return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">  BinaryOperator *BO = cast<BinaryOperator>(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">  BinaryOperator *BO = cast<BinaryOperator>(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">  // If this is an interior node of a reassociable tree, ignore it until we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">  // If this is an interior node of a reassociable tree, ignore it until we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">  // get to the root of the tree, to avoid N^2 analysis.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">  // get to the root of the tree, to avoid N^2 analysis.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">  unsigned Opcode = BO->getOpcode();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">  unsigned Opcode = BO->getOpcode();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">  if (BO->hasOneUse() && BO->user_back()->getOpcode() == Opcode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">  if (BO->hasOneUse() && BO->user_back()->getOpcode() == Opcode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">    // During the initial run we will get to the root of the tree.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">    // During the initial run we will get to the root of the tree.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">    // But if we get here while we are redoing instructions, there is no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">    // But if we get here while we are redoing instructions, there is no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">    // guarantee that the root will be visited. So Redo later</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">    // guarantee that the root will be visited. So Redo later</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">    if (BO->user_back() != BO &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">    if (BO->user_back() != BO &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine">        BO->getParent() == BO->user_back()->getParent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine">        BO->getParent() == BO->user_back()->getParent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">      RedoInsts.insert(BO->user_back());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">      RedoInsts.insert(BO->user_back());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">  // If this is an add tree that is used by a sub instruction, ignore it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">  // If this is an add tree that is used by a sub instruction, ignore it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">  // until we process the subtract.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">  // until we process the subtract.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">  if (BO->hasOneUse() && BO->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">  if (BO->hasOneUse() && BO->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">      cast<Instruction>(BO->user_back())->getOpcode() == Instruction::Sub)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">      cast<Instruction>(BO->user_back())->getOpcode() == Instruction::Sub)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">  if (BO->hasOneUse() && BO->getOpcode() == Instruction::FAdd &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">  if (BO->hasOneUse() && BO->getOpcode() == Instruction::FAdd &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine">      cast<Instruction>(BO->user_back())->getOpcode() == Instruction::FSub)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine">      cast<Instruction>(BO->user_back())->getOpcode() == Instruction::FSub)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">  ReassociateExpression(BO);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">  ReassociateExpression(BO);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine">void ReassociatePass::ReassociateExpression(BinaryOperator *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine">void ReassociatePass::ReassociateExpression(BinaryOperator *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">  // First, walk the expression tree, linearizing the tree, collecting the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">  // First, walk the expression tree, linearizing the tree, collecting the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">  // operand information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">  // operand information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">  SmallVector<RepeatedValue, 8> Tree;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">  SmallVector<RepeatedValue, 8> Tree;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine">  MadeChange |= LinearizeExprTree(I, Tree, RedoInsts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine">  MadeChange |= LinearizeExprTree(I, Tree, RedoInsts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">  SmallVector<ValueEntry, 8> Ops;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">  SmallVector<ValueEntry, 8> Ops;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">  Ops.reserve(Tree.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">  Ops.reserve(Tree.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">  for (const RepeatedValue &E : Tree)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">  for (const RepeatedValue &E : Tree)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">    Ops.append(E.second.getZExtValue(), ValueEntry(getRank(E.first), E.first));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">    Ops.append(E.second.getZExtValue(), ValueEntry(getRank(E.first), E.first));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "RAIn:\t"; PrintOps(I, Ops); dbgs() << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "RAIn:\t"; PrintOps(I, Ops); dbgs() << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">  // Now that we have linearized the tree to a list and have gathered all of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">  // Now that we have linearized the tree to a list and have gathered all of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">  // the operands and their ranks, sort the operands by their rank.  Use a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">  // the operands and their ranks, sort the operands by their rank.  Use a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine">  // stable_sort so that values with equal ranks will have their relative</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine">  // stable_sort so that values with equal ranks will have their relative</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">  // positions maintained (and so the compiler is deterministic).  Note that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">  // positions maintained (and so the compiler is deterministic).  Note that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">  // this sorts so that the highest ranking values end up at the beginning of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">  // this sorts so that the highest ranking values end up at the beginning of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">  // the vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">  // the vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine">  llvm::stable_sort(Ops);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine">  llvm::stable_sort(Ops);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">  // Now that we have the expression tree in a convenient</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">  // Now that we have the expression tree in a convenient</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">  // sorted form, optimize it globally if possible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">  // sorted form, optimize it globally if possible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">  if (Value *V = OptimizeExpression(I, Ops)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">  if (Value *V = OptimizeExpression(I, Ops)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">    if (V == I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">    if (V == I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">      // Self-referential expression in unreachable code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">      // Self-referential expression in unreachable code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">    // This expression tree simplified to something that isn't a tree,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">    // This expression tree simplified to something that isn't a tree,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">    // eliminate it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">    // eliminate it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Reassoc to scalar: " << *V << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Reassoc to scalar: " << *V << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">    I->replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">    I->replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">    if (Instruction *VI = dyn_cast<Instruction>(V))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">    if (Instruction *VI = dyn_cast<Instruction>(V))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine">      if (I->getDebugLoc())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine">      if (I->getDebugLoc())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">        VI->setDebugLoc(I->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">        VI->setDebugLoc(I->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">    RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">    RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">    ++NumAnnihil;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">    ++NumAnnihil;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">  // We want to sink immediates as deeply as possible except in the case where</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">  // We want to sink immediates as deeply as possible except in the case where</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine">  // this is a multiply tree used only by an add, and the immediate is a -1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine">  // this is a multiply tree used only by an add, and the immediate is a -1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">  // In this case we reassociate to put the negation on the outside so that we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">  // In this case we reassociate to put the negation on the outside so that we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">  // can fold the negation into the add: (-X)*Y + Z -> Z-X*Y</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">  // can fold the negation into the add: (-X)*Y + Z -> Z-X*Y</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">  if (I->hasOneUse()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">  if (I->hasOneUse()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">    if (I->getOpcode() == Instruction::Mul &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">    if (I->getOpcode() == Instruction::Mul &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">        cast<Instruction>(I->user_back())->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">        cast<Instruction>(I->user_back())->getOpcode() == Instruction::Add &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">        isa<ConstantInt>(Ops.back().Op) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">        isa<ConstantInt>(Ops.back().Op) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">        cast<ConstantInt>(Ops.back().Op)->isMinusOne()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">        cast<ConstantInt>(Ops.back().Op)->isMinusOne()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine">      ValueEntry Tmp = Ops.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine">      ValueEntry Tmp = Ops.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">      Ops.insert(Ops.begin(), Tmp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">      Ops.insert(Ops.begin(), Tmp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine">    } else if (I->getOpcode() == Instruction::FMul &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine">    } else if (I->getOpcode() == Instruction::FMul &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">               cast<Instruction>(I->user_back())->getOpcode() ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">               cast<Instruction>(I->user_back())->getOpcode() ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">                   Instruction::FAdd &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">                   Instruction::FAdd &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine">               isa<ConstantFP>(Ops.back().Op) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine">               isa<ConstantFP>(Ops.back().Op) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine">               cast<ConstantFP>(Ops.back().Op)->isExactlyValue(-1.0)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine">               cast<ConstantFP>(Ops.back().Op)->isExactlyValue(-1.0)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine">      ValueEntry Tmp = Ops.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine">      ValueEntry Tmp = Ops.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine">      Ops.insert(Ops.begin(), Tmp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine">      Ops.insert(Ops.begin(), Tmp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "RAOut:\t"; PrintOps(I, Ops); dbgs() << '\n');</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "RAOut:\t"; PrintOps(I, Ops); dbgs() << '\n');</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">  if (Ops.size() == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">  if (Ops.size() == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine">    if (Ops[0].Op == I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine">    if (Ops[0].Op == I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">      // Self-referential expression in unreachable code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">      // Self-referential expression in unreachable code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">    // This expression tree simplified to something that isn't a tree,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">    // This expression tree simplified to something that isn't a tree,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">    // eliminate it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">    // eliminate it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine">    I->replaceAllUsesWith(Ops[0].Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine">    I->replaceAllUsesWith(Ops[0].Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine">    if (Instruction *OI = dyn_cast<Instruction>(Ops[0].Op))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine">    if (Instruction *OI = dyn_cast<Instruction>(Ops[0].Op))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">      OI->setDebugLoc(I->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">      OI->setDebugLoc(I->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine">    RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine">    RedoInsts.insert(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine">  if (Ops.size() > 2 && Ops.size() <= GlobalReassociateLimit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine">  if (Ops.size() > 2 && Ops.size() <= GlobalReassociateLimit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">    // Find the pair with the highest count in the pairmap and move it to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">    // Find the pair with the highest count in the pairmap and move it to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">    // back of the list so that it can later be CSE'd.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">    // back of the list so that it can later be CSE'd.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine">    // example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine">    // example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine">    //   a*b*c*d*e</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine">    //   a*b*c*d*e</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine">    // if c*e is the most "popular" pair, we can express this as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine">    // if c*e is the most "popular" pair, we can express this as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">    //   (((c*e)*d)*b)*a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">    //   (((c*e)*d)*b)*a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine">    unsigned Max = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine">    unsigned Max = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">    unsigned BestRank = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">    unsigned BestRank = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">    std::pair<unsigned, unsigned> BestPair;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">    std::pair<unsigned, unsigned> BestPair;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">    unsigned Idx = I->getOpcode() - Instruction::BinaryOpsBegin;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">    unsigned Idx = I->getOpcode() - Instruction::BinaryOpsBegin;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">    unsigned LimitIdx = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">    unsigned LimitIdx = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">    // With the CSE-driven heuristic, we are about to slap two values at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">    // With the CSE-driven heuristic, we are about to slap two values at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine">    // beginning of the expression whereas they could live very late in the CFG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine">    // beginning of the expression whereas they could live very late in the CFG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine">    // When using the CSE-local heuristic we avoid creating dependences from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine">    // When using the CSE-local heuristic we avoid creating dependences from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">    // completely unrelated part of the CFG by limiting the expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">    // completely unrelated part of the CFG by limiting the expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">    // reordering on the values that live in the first seen basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">    // reordering on the values that live in the first seen basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine">    // The main idea is that we want to avoid forming expressions that would</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine">    // The main idea is that we want to avoid forming expressions that would</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">    // become loop dependent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">    // become loop dependent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine">    if (UseCSELocalOpt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine">    if (UseCSELocalOpt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">      const BasicBlock *FirstSeenBB = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">      const BasicBlock *FirstSeenBB = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">      int StartIdx = Ops.size() - 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">      int StartIdx = Ops.size() - 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine">      // Skip the first value of the expression since we need at least two</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine">      // Skip the first value of the expression since we need at least two</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">      // values to materialize an expression. I.e., even if this value is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">      // values to materialize an expression. I.e., even if this value is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">      // anchored in a different basic block, the actual first sub expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">      // anchored in a different basic block, the actual first sub expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine">      // will be anchored on the second value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine">      // will be anchored on the second value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine">      for (int i = StartIdx - 1; i != -1; --i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine">      for (int i = StartIdx - 1; i != -1; --i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">        const Value *Val = Ops[i].Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">        const Value *Val = Ops[i].Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">        const auto *CurrLeafInstr = dyn_cast<Instruction>(Val);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">        const auto *CurrLeafInstr = dyn_cast<Instruction>(Val);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">        const BasicBlock *SeenBB = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">        const BasicBlock *SeenBB = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine">        if (!CurrLeafInstr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine">        if (!CurrLeafInstr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">          // The value is free of any CFG dependencies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">          // The value is free of any CFG dependencies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">          // Do as if it lives in the entry block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">          // Do as if it lives in the entry block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine">          //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine">          //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">          // We do this to make sure all the values falling on this path are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">          // We do this to make sure all the values falling on this path are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">          // seen through the same anchor point. The rationale is these values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">          // seen through the same anchor point. The rationale is these values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">          // can be combined together to from a sub expression free of any CFG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">          // can be combined together to from a sub expression free of any CFG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine">          // dependencies so we want them to stay together.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine">          // dependencies so we want them to stay together.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine">          // We could be cleverer and postpone the anchor down to the first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine">          // We could be cleverer and postpone the anchor down to the first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">          // anchored value, but that's likely complicated to get right.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">          // anchored value, but that's likely complicated to get right.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine">          // E.g., we wouldn't want to do that if that means being stuck in a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine">          // E.g., we wouldn't want to do that if that means being stuck in a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">          // loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">          // loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">          //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">          //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">          // For instance, we wouldn't want to change:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">          // For instance, we wouldn't want to change:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine">          // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine">          // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">          // into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">          // into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">          // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">          // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine">          // Because all the sub expressions with arg2..N would be stuck between</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine">          // Because all the sub expressions with arg2..N would be stuck between</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">          // two loop dependent values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">          // two loop dependent values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine">          SeenBB = &I->getParent()->getParent()->getEntryBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine">          SeenBB = &I->getParent()->getParent()->getEntryBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">          SeenBB = CurrLeafInstr->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">          SeenBB = CurrLeafInstr->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine">        if (!FirstSeenBB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine">        if (!FirstSeenBB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine">          FirstSeenBB = SeenBB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine">          FirstSeenBB = SeenBB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine">        if (FirstSeenBB != SeenBB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine">        if (FirstSeenBB != SeenBB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine">          // ith value is in a different basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine">          // ith value is in a different basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">          // Rewind the index once to point to the last value on the same basic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">          // Rewind the index once to point to the last value on the same basic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine">          // block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine">          // block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine">          LimitIdx = i + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine">          LimitIdx = i + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << "CSE reordering: Consider values between ["</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine">          LLVM_DEBUG(dbgs() << "CSE reordering: Consider values between ["</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine">                            << LimitIdx << ", " << StartIdx << "]\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine">                            << LimitIdx << ", " << StartIdx << "]\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine">    for (unsigned i = Ops.size() - 1; i > LimitIdx; --i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine">    for (unsigned i = Ops.size() - 1; i > LimitIdx; --i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine">      // We must use int type to go below zero when LimitIdx is 0.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine">      // We must use int type to go below zero when LimitIdx is 0.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine">      for (int j = i - 1; j >= (int)LimitIdx; --j) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine">      for (int j = i - 1; j >= (int)LimitIdx; --j) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine">        unsigned Score = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine">        unsigned Score = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine">        Value *Op0 = Ops[i].Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine">        Value *Op0 = Ops[i].Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine">        Value *Op1 = Ops[j].Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine">        Value *Op1 = Ops[j].Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine">        if (std::less<Value *>()(Op1, Op0))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine">        if (std::less<Value *>()(Op1, Op0))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine">          std::swap(Op0, Op1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine">          std::swap(Op0, Op1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine">        auto it = PairMap[Idx].find({Op0, Op1});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine">        auto it = PairMap[Idx].find({Op0, Op1});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine">        if (it != PairMap[Idx].end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine">        if (it != PairMap[Idx].end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine">          // Functions like BreakUpSubtract() can erase the Values we're using</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine">          // Functions like BreakUpSubtract() can erase the Values we're using</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine">          // as keys and create new Values after we built the PairMap. There's a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine">          // as keys and create new Values after we built the PairMap. There's a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">          // small chance that the new nodes can have the same address as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">          // small chance that the new nodes can have the same address as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine">          // something already in the table. We shouldn't accumulate the stored</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine">          // something already in the table. We shouldn't accumulate the stored</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">          // score in that case as it refers to the wrong Value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">          // score in that case as it refers to the wrong Value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine">          if (it->second.isValid())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine">          if (it->second.isValid())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeLine">            Score += it->second.Score;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2508</td>
    <td class="codeLine">            Score += it->second.Score;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2509</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeLine">        unsigned MaxRank = std::max(Ops[i].Rank, Ops[j].Rank);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2511</td>
    <td class="codeLine">        unsigned MaxRank = std::max(Ops[i].Rank, Ops[j].Rank);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2512</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeLine">        // By construction, the operands are sorted in reverse order of their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2513</td>
    <td class="codeLine">        // By construction, the operands are sorted in reverse order of their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeLine">        // topological order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2514</td>
    <td class="codeLine">        // topological order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeLine">        // So we tend to form (sub) expressions with values that are close to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2515</td>
    <td class="codeLine">        // So we tend to form (sub) expressions with values that are close to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeLine">        // each other.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2516</td>
    <td class="codeLine">        // each other.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeLine">        //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2517</td>
    <td class="codeLine">        //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeLine">        // Now to expose more CSE opportunities we want to expose the pair of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2518</td>
    <td class="codeLine">        // Now to expose more CSE opportunities we want to expose the pair of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeLine">        // operands that occur the most (as statically computed in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2519</td>
    <td class="codeLine">        // operands that occur the most (as statically computed in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeLine">        // BuildPairMap.) as the first sub-expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2520</td>
    <td class="codeLine">        // BuildPairMap.) as the first sub-expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeLine">        //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2521</td>
    <td class="codeLine">        //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeLine">        // If two pairs occur as many times, we pick the one with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2522</td>
    <td class="codeLine">        // If two pairs occur as many times, we pick the one with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeLine">        // lowest rank, meaning the one with both operands appearing first in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2523</td>
    <td class="codeLine">        // lowest rank, meaning the one with both operands appearing first in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeLine">        // the topological order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2524</td>
    <td class="codeLine">        // the topological order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeLine">        if (Score > Max || (Score == Max && MaxRank < BestRank)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2525</td>
    <td class="codeLine">        if (Score > Max || (Score == Max && MaxRank < BestRank)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeLine">          BestPair = {j, i};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2526</td>
    <td class="codeLine">          BestPair = {j, i};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeLine">          Max = Score;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2527</td>
    <td class="codeLine">          Max = Score;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeLine">          BestRank = MaxRank;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2528</td>
    <td class="codeLine">          BestRank = MaxRank;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2529</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2530</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2531</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeLine">    if (Max > 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2532</td>
    <td class="codeLine">    if (Max > 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeLine">      auto Op0 = Ops[BestPair.first];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2533</td>
    <td class="codeLine">      auto Op0 = Ops[BestPair.first];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeLine">      auto Op1 = Ops[BestPair.second];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2534</td>
    <td class="codeLine">      auto Op1 = Ops[BestPair.second];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeLine">      Ops.erase(&Ops[BestPair.second]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2535</td>
    <td class="codeLine">      Ops.erase(&Ops[BestPair.second]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeLine">      Ops.erase(&Ops[BestPair.first]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2536</td>
    <td class="codeLine">      Ops.erase(&Ops[BestPair.first]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeLine">      Ops.push_back(Op0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2537</td>
    <td class="codeLine">      Ops.push_back(Op0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeLine">      Ops.push_back(Op1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2538</td>
    <td class="codeLine">      Ops.push_back(Op1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2539</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2540</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "RAOut after CSE reorder:\t"; PrintOps(I, Ops);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2541</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "RAOut after CSE reorder:\t"; PrintOps(I, Ops);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeLine">             dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2542</td>
    <td class="codeLine">             dbgs() << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeLine">  // Now that we ordered and optimized the expressions, splat them back into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2543</td>
    <td class="codeLine">  // Now that we ordered and optimized the expressions, splat them back into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeLine">  // the expression tree, removing any unneeded nodes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2544</td>
    <td class="codeLine">  // the expression tree, removing any unneeded nodes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeLine">  RewriteExprTree(I, Ops);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2545</td>
    <td class="codeLine">  RewriteExprTree(I, Ops);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2546</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeLine">void</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2548</td>
    <td class="codeLine">void</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeLine">ReassociatePass::BuildPairMap(ReversePostOrderTraversal<Function *> &RPOT) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2549</td>
    <td class="codeLine">ReassociatePass::BuildPairMap(ReversePostOrderTraversal<Function *> &RPOT) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeLine">  // Make a "pairmap" of how often each operand pair occurs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2550</td>
    <td class="codeLine">  // Make a "pairmap" of how often each operand pair occurs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeLine">  for (BasicBlock *BI : RPOT) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2551</td>
    <td class="codeLine">  for (BasicBlock *BI : RPOT) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeLine">    for (Instruction &I : *BI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2552</td>
    <td class="codeLine">    for (Instruction &I : *BI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeLine">      if (!I.isAssociative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2553</td>
    <td class="codeLine">      if (!I.isAssociative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2554</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeLine">      // Ignore nodes that aren't at the root of trees.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2556</td>
    <td class="codeLine">      // Ignore nodes that aren't at the root of trees.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeLine">      if (I.hasOneUse() && I.user_back()->getOpcode() == I.getOpcode())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2557</td>
    <td class="codeLine">      if (I.hasOneUse() && I.user_back()->getOpcode() == I.getOpcode())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2558</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeLine">      // Collect all operands in a single reassociable expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2560</td>
    <td class="codeLine">      // Collect all operands in a single reassociable expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeLine">      // Since Reassociate has already been run once, we can assume things</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2561</td>
    <td class="codeLine">      // Since Reassociate has already been run once, we can assume things</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeLine">      // are already canonical according to Reassociation's regime.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2562</td>
    <td class="codeLine">      // are already canonical according to Reassociation's regime.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeLine">      SmallVector<Value *, 8> Worklist = { I.getOperand(0), I.getOperand(1) };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2563</td>
    <td class="codeLine">      SmallVector<Value *, 8> Worklist = { I.getOperand(0), I.getOperand(1) };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeLine">      SmallVector<Value *, 8> Ops;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2564</td>
    <td class="codeLine">      SmallVector<Value *, 8> Ops;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeLine">      while (!Worklist.empty() && Ops.size() <= GlobalReassociateLimit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2565</td>
    <td class="codeLine">      while (!Worklist.empty() && Ops.size() <= GlobalReassociateLimit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeLine">        Value *Op = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2566</td>
    <td class="codeLine">        Value *Op = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeLine">        Instruction *OpI = dyn_cast<Instruction>(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2567</td>
    <td class="codeLine">        Instruction *OpI = dyn_cast<Instruction>(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeLine">        if (!OpI || OpI->getOpcode() != I.getOpcode() || !OpI->hasOneUse()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2568</td>
    <td class="codeLine">        if (!OpI || OpI->getOpcode() != I.getOpcode() || !OpI->hasOneUse()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeLine">          Ops.push_back(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2569</td>
    <td class="codeLine">          Ops.push_back(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2570</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2571</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeLine">        // Be paranoid about self-referencing expressions in unreachable code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2572</td>
    <td class="codeLine">        // Be paranoid about self-referencing expressions in unreachable code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeLine">        if (OpI->getOperand(0) != OpI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2573</td>
    <td class="codeLine">        if (OpI->getOperand(0) != OpI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeLine">          Worklist.push_back(OpI->getOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2574</td>
    <td class="codeLine">          Worklist.push_back(OpI->getOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeLine">        if (OpI->getOperand(1) != OpI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2575</td>
    <td class="codeLine">        if (OpI->getOperand(1) != OpI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeLine">          Worklist.push_back(OpI->getOperand(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2576</td>
    <td class="codeLine">          Worklist.push_back(OpI->getOperand(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2577</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeLine">      // Skip extremely long expressions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2578</td>
    <td class="codeLine">      // Skip extremely long expressions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeLine">      if (Ops.size() > GlobalReassociateLimit)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2579</td>
    <td class="codeLine">      if (Ops.size() > GlobalReassociateLimit)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2580</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeLine">      // Add all pairwise combinations of operands to the pair map.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2582</td>
    <td class="codeLine">      // Add all pairwise combinations of operands to the pair map.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeLine">      unsigned BinaryIdx = I.getOpcode() - Instruction::BinaryOpsBegin;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2583</td>
    <td class="codeLine">      unsigned BinaryIdx = I.getOpcode() - Instruction::BinaryOpsBegin;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeLine">      SmallSet<std::pair<Value *, Value*>, 32> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2584</td>
    <td class="codeLine">      SmallSet<std::pair<Value *, Value*>, 32> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeLine">      for (unsigned i = 0; i < Ops.size() - 1; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2585</td>
    <td class="codeLine">      for (unsigned i = 0; i < Ops.size() - 1; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeLine">        for (unsigned j = i + 1; j < Ops.size(); ++j) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2586</td>
    <td class="codeLine">        for (unsigned j = i + 1; j < Ops.size(); ++j) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeLine">          // Canonicalize operand orderings.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2587</td>
    <td class="codeLine">          // Canonicalize operand orderings.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeLine">          Value *Op0 = Ops[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2588</td>
    <td class="codeLine">          Value *Op0 = Ops[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeLine">          Value *Op1 = Ops[j];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2589</td>
    <td class="codeLine">          Value *Op1 = Ops[j];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeLine">          if (std::less<Value *>()(Op1, Op0))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2590</td>
    <td class="codeLine">          if (std::less<Value *>()(Op1, Op0))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeLine">            std::swap(Op0, Op1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2591</td>
    <td class="codeLine">            std::swap(Op0, Op1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeLine">          if (!Visited.insert({Op0, Op1}).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2592</td>
    <td class="codeLine">          if (!Visited.insert({Op0, Op1}).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2593</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeLine">          auto res = PairMap[BinaryIdx].insert({{Op0, Op1}, {Op0, Op1, 1}});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2594</td>
    <td class="codeLine">          auto res = PairMap[BinaryIdx].insert({{Op0, Op1}, {Op0, Op1, 1}});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeLine">          if (!res.second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2595</td>
    <td class="codeLine">          if (!res.second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeLine">            // If either key value has been erased then we've got the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2596</td>
    <td class="codeLine">            // If either key value has been erased then we've got the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeLine">            // address by coincidence. That can't happen here because nothing is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2597</td>
    <td class="codeLine">            // address by coincidence. That can't happen here because nothing is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeLine">            // erasing values but it can happen by the time we're querying the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2598</td>
    <td class="codeLine">            // erasing values but it can happen by the time we're querying the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeLine">            // map.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2599</td>
    <td class="codeLine">            // map.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeLine">            assert(res.first->second.isValid() && "WeakVH invalidated");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2600</td>
    <td class="codeLine">            assert(res.first->second.isValid() && "WeakVH invalidated");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeLine">            ++res.first->second.Score;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2601</td>
    <td class="codeLine">            ++res.first->second.Score;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2602</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2603</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2604</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2605</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2606</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2607</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2608</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeLine">PreservedAnalyses ReassociatePass::run(Function &F, FunctionAnalysisManager &) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2609</td>
    <td class="codeLine">PreservedAnalyses ReassociatePass::run(Function &F, FunctionAnalysisManager &) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeLine">  // Get the functions basic blocks in Reverse Post Order. This order is used by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2610</td>
    <td class="codeLine">  // Get the functions basic blocks in Reverse Post Order. This order is used by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeLine">  // BuildRankMap to pre calculate ranks correctly. It also excludes dead basic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2611</td>
    <td class="codeLine">  // BuildRankMap to pre calculate ranks correctly. It also excludes dead basic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeLine">  // blocks (it has been seen that the analysis in this pass could hang when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2612</td>
    <td class="codeLine">  // blocks (it has been seen that the analysis in this pass could hang when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeLine">  // analysing dead basic blocks).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2613</td>
    <td class="codeLine">  // analysing dead basic blocks).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeLine">  ReversePostOrderTraversal<Function *> RPOT(&F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2614</td>
    <td class="codeLine">  ReversePostOrderTraversal<Function *> RPOT(&F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeLine">  // Calculate the rank map for F.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2616</td>
    <td class="codeLine">  // Calculate the rank map for F.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeLine">  BuildRankMap(F, RPOT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2617</td>
    <td class="codeLine">  BuildRankMap(F, RPOT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeLine">  // Build the pair map before running reassociate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2619</td>
    <td class="codeLine">  // Build the pair map before running reassociate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeLine">  // Technically this would be more accurate if we did it after one round</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2620</td>
    <td class="codeLine">  // Technically this would be more accurate if we did it after one round</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeLine">  // of reassociation, but in practice it doesn't seem to help much on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2621</td>
    <td class="codeLine">  // of reassociation, but in practice it doesn't seem to help much on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeLine">  // real-world code, so don't waste the compile time running reassociate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2622</td>
    <td class="codeLine">  // real-world code, so don't waste the compile time running reassociate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeLine">  // twice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2623</td>
    <td class="codeLine">  // twice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeLine">  // If a user wants, they could expicitly run reassociate twice in their</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2624</td>
    <td class="codeLine">  // If a user wants, they could expicitly run reassociate twice in their</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeLine">  // pass pipeline for further potential gains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2625</td>
    <td class="codeLine">  // pass pipeline for further potential gains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeLine">  // It might also be possible to update the pair map during runtime, but the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2626</td>
    <td class="codeLine">  // It might also be possible to update the pair map during runtime, but the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeLine">  // overhead of that may be large if there's many reassociable chains.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2627</td>
    <td class="codeLine">  // overhead of that may be large if there's many reassociable chains.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeLine">  BuildPairMap(RPOT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2628</td>
    <td class="codeLine">  BuildPairMap(RPOT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2629</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeLine">  MadeChange = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2630</td>
    <td class="codeLine">  MadeChange = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeLine">  // Traverse the same blocks that were analysed by BuildRankMap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2632</td>
    <td class="codeLine">  // Traverse the same blocks that were analysed by BuildRankMap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeLine">  for (BasicBlock *BI : RPOT) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2633</td>
    <td class="codeLine">  for (BasicBlock *BI : RPOT) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeLine">    assert(RankMap.count(&*BI) && "BB should be ranked.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2634</td>
    <td class="codeLine">    assert(RankMap.count(&*BI) && "BB should be ranked.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeLine">    // Optimize every instruction in the basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2635</td>
    <td class="codeLine">    // Optimize every instruction in the basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeLine">    for (BasicBlock::iterator II = BI->begin(), IE = BI->end(); II != IE;)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2636</td>
    <td class="codeLine">    for (BasicBlock::iterator II = BI->begin(), IE = BI->end(); II != IE;)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeLine">      if (isInstructionTriviallyDead(&*II)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2637</td>
    <td class="codeLine">      if (isInstructionTriviallyDead(&*II)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeLine">        EraseInst(&*II++);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2638</td>
    <td class="codeLine">        EraseInst(&*II++);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2639</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeLine">        OptimizeInst(&*II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2640</td>
    <td class="codeLine">        OptimizeInst(&*II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeLine">        assert(II->getParent() == &*BI && "Moved to a different block!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2641</td>
    <td class="codeLine">        assert(II->getParent() == &*BI && "Moved to a different block!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeLine">        ++II;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2642</td>
    <td class="codeLine">        ++II;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2643</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeLine">    // Make a copy of all the instructions to be redone so we can remove dead</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2645</td>
    <td class="codeLine">    // Make a copy of all the instructions to be redone so we can remove dead</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeLine">    // instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2646</td>
    <td class="codeLine">    // instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeLine">    OrderedSet ToRedo(RedoInsts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2647</td>
    <td class="codeLine">    OrderedSet ToRedo(RedoInsts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeLine">    // Iterate over all instructions to be reevaluated and remove trivially dead</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2648</td>
    <td class="codeLine">    // Iterate over all instructions to be reevaluated and remove trivially dead</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeLine">    // instructions. If any operand of the trivially dead instruction becomes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2649</td>
    <td class="codeLine">    // instructions. If any operand of the trivially dead instruction becomes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeLine">    // dead mark it for deletion as well. Continue this process until all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2650</td>
    <td class="codeLine">    // dead mark it for deletion as well. Continue this process until all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeLine">    // trivially dead instructions have been removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2651</td>
    <td class="codeLine">    // trivially dead instructions have been removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeLine">    while (!ToRedo.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2652</td>
    <td class="codeLine">    while (!ToRedo.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeLine">      Instruction *I = ToRedo.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2653</td>
    <td class="codeLine">      Instruction *I = ToRedo.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeLine">      if (isInstructionTriviallyDead(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2654</td>
    <td class="codeLine">      if (isInstructionTriviallyDead(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeLine">        RecursivelyEraseDeadInsts(I, ToRedo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2655</td>
    <td class="codeLine">        RecursivelyEraseDeadInsts(I, ToRedo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeLine">        MadeChange = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2656</td>
    <td class="codeLine">        MadeChange = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2657</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2658</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2659</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeLine">    // Now that we have removed dead instructions, we can reoptimize the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2660</td>
    <td class="codeLine">    // Now that we have removed dead instructions, we can reoptimize the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeLine">    // remaining instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2661</td>
    <td class="codeLine">    // remaining instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeLine">    while (!RedoInsts.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2662</td>
    <td class="codeLine">    while (!RedoInsts.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeLine">      Instruction *I = RedoInsts.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2663</td>
    <td class="codeLine">      Instruction *I = RedoInsts.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeLine">      RedoInsts.erase(RedoInsts.begin());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2664</td>
    <td class="codeLine">      RedoInsts.erase(RedoInsts.begin());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeLine">      if (isInstructionTriviallyDead(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2665</td>
    <td class="codeLine">      if (isInstructionTriviallyDead(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeLine">        EraseInst(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2666</td>
    <td class="codeLine">        EraseInst(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2667</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeLine">        OptimizeInst(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2668</td>
    <td class="codeLine">        OptimizeInst(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2669</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2670</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeLine">  // We are done with the rank map and pair map.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2672</td>
    <td class="codeLine">  // We are done with the rank map and pair map.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeLine">  RankMap.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2673</td>
    <td class="codeLine">  RankMap.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeLine">  ValueRankMap.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2674</td>
    <td class="codeLine">  ValueRankMap.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeLine">  for (auto &Entry : PairMap)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2675</td>
    <td class="codeLine">  for (auto &Entry : PairMap)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeLine">    Entry.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2676</td>
    <td class="codeLine">    Entry.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2677</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeLine">  if (MadeChange) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2678</td>
    <td class="codeLine">  if (MadeChange) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeLine">    PreservedAnalyses PA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2679</td>
    <td class="codeLine">    PreservedAnalyses PA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeLine">    PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2680</td>
    <td class="codeLine">    PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeLine">    return PA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2681</td>
    <td class="codeLine">    return PA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2682</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeLine">  return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2684</td>
    <td class="codeLine">  return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2685</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2687</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeLine">  class ReassociateLegacyPass : public FunctionPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2689</td>
    <td class="codeLine">  class ReassociateLegacyPass : public FunctionPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeLine">    ReassociatePass Impl;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2690</td>
    <td class="codeLine">    ReassociatePass Impl;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2692</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeLine">    static char ID; // Pass identification, replacement for typeid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2693</td>
    <td class="codeLine">    static char ID; // Pass identification, replacement for typeid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2694</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeLine">    ReassociateLegacyPass() : FunctionPass(ID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2695</td>
    <td class="codeLine">    ReassociateLegacyPass() : FunctionPass(ID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeLine">      initializeReassociateLegacyPassPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2696</td>
    <td class="codeLine">      initializeReassociateLegacyPassPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2697</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeLine">    bool runOnFunction(Function &F) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2699</td>
    <td class="codeLine">    bool runOnFunction(Function &F) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeLine">      if (skipFunction(F))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2700</td>
    <td class="codeLine">      if (skipFunction(F))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2701</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeLine">      FunctionAnalysisManager DummyFAM;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2703</td>
    <td class="codeLine">      FunctionAnalysisManager DummyFAM;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeLine">      auto PA = Impl.run(F, DummyFAM);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2704</td>
    <td class="codeLine">      auto PA = Impl.run(F, DummyFAM);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeLine">      return !PA.areAllPreserved();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2705</td>
    <td class="codeLine">      return !PA.areAllPreserved();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2706</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2707</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeLine">    void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2708</td>
    <td class="codeLine">    void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeLine">      AU.setPreservesCFG();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2709</td>
    <td class="codeLine">      AU.setPreservesCFG();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeLine">      AU.addPreserved<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2710</td>
    <td class="codeLine">      AU.addPreserved<AAResultsWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeLine">      AU.addPreserved<BasicAAWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2711</td>
    <td class="codeLine">      AU.addPreserved<BasicAAWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeLine">      AU.addPreserved<GlobalsAAWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2712</td>
    <td class="codeLine">      AU.addPreserved<GlobalsAAWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2713</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2714</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2716</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2717</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeLine">char ReassociateLegacyPass::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2718</td>
    <td class="codeLine">char ReassociateLegacyPass::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS(ReassociateLegacyPass, "reassociate",</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">2720</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS(ReassociateLegacyPass, "reassociate",</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeLine">                "Reassociate expressions", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2721</td>
    <td class="codeLine">                "Reassociate expressions", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeLine">// Public interface to the Reassociate pass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2723</td>
    <td class="codeLine">// Public interface to the Reassociate pass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeLine">FunctionPass *llvm::createReassociatePass() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2724</td>
    <td class="codeLine">FunctionPass *llvm::createReassociatePass() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeLine">  return new ReassociateLegacyPass();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2725</td>
    <td class="codeLine">  return new ReassociateLegacyPass();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2726</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>