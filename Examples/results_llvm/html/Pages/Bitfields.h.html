<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Bitfields.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/ADT/Bitfields.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===-- llvm/ADT/Bitfield.h - Get and Set bits in an integer ---*- C++ -*--===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">/// \file</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">/// This file implements methods to test, set and extract typed bits from packed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">/// unsigned integers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">/// Why not C++ bitfields?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">/// ----------------------</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">/// C++ bitfields do not offer control over the bit layout nor consistent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">/// behavior when it comes to out of range values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">/// For instance, the layout is implementation defined and adjacent bits may be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">/// packed together but are not required to. This is problematic when storage is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">/// sparse and data must be stored in a particular integer type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">/// The methods provided in this file ensure precise control over the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">/// layout/storage as well as protection against out of range values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">/// Usage example</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">/// -------------</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">/// \code{.cpp}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">///  uint8_t Storage = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">///  // Store and retrieve a single bit as bool.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">///  using Bool = Bitfield::Element<bool, 0, 1>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">///  Bitfield::set<Bool>(Storage, true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">///  EXPECT_EQ(Storage, 0b00000001);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">///  //                          ^</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">///  // Store and retrieve a 2 bit typed enum.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">///  // Note: enum underlying type must be unsigned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">///  enum class SuitEnum : uint8_t { CLUBS, DIAMONDS, HEARTS, SPADES };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">///  // Note: enum maximum value needs to be passed in as last parameter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">///  using Suit = Bitfield::Element<SuitEnum, 1, 2, SuitEnum::SPADES>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">///  Bitfield::set<Suit>(Storage, SuitEnum::HEARTS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">///  EXPECT_EQ(Storage, 0b00000101);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">///  //                        ^^</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::HEARTS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">///  // Store and retrieve a 5 bit value as unsigned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">///  using Value = Bitfield::Element<unsigned, 3, 5>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">///  Bitfield::set<Value>(Storage, 10);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">///  EXPECT_EQ(Storage, 0b01010101);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">///  //                   ^^^^^</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 10U);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">///  // Interpret the same 5 bit value as signed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">///  using SignedValue = Bitfield::Element<int, 3, 5>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">///  Bitfield::set<SignedValue>(Storage, -2);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">///  EXPECT_EQ(Storage, 0b11110101);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">///  //                   ^^^^^</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -2);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">///  // Ability to efficiently test if a field is non zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">///  EXPECT_TRUE(Bitfield::test<Value>(Storage));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">///  // Alter Storage changes value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">///  Storage = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::CLUBS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 0U);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">///  Storage = 255;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), true);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::SPADES);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 31U);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -1);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">/// \endcode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">#ifndef LLVM_ADT_BITFIELDS_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">#define LLVM_ADT_BITFIELDS_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">#include <climits> // CHAR_BIT</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">#include <cstddef> // size_t</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">#include <cstdint> // uintXX_t</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">#include <limits>  // numeric_limits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">#include <type_traits></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">namespace bitfields_details {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">/// A struct defining useful bit patterns for n-bits integer types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">template <typename T, unsigned Bits> struct BitPatterns {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">  /// Bit patterns are forged using the equivalent `Unsigned` type because of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">  /// undefined operations over signed types (e.g. Bitwise shift operators).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">  /// Moreover same size casting from unsigned to signed is well defined but not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">  /// the other way around.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">  using Unsigned = std::make_unsigned_t<T>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">  static_assert(sizeof(Unsigned) == sizeof(T), "Types must have same size");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  static constexpr unsigned TypeBits = sizeof(Unsigned) * CHAR_BIT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">  static_assert(TypeBits >= Bits, "n-bit must fit in T");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">  /// e.g. with TypeBits == 8 and Bits == 6.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">  static constexpr Unsigned AllZeros = Unsigned(0);                  // 00000000</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">  static constexpr Unsigned AllOnes = ~Unsigned(0);                  // 11111111</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">  static constexpr Unsigned Umin = AllZeros;                         // 00000000</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">  static constexpr Unsigned Umax = AllOnes >> (TypeBits - Bits);     // 00111111</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">  static constexpr Unsigned SignBitMask = Unsigned(1) << (Bits - 1); // 00100000</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">  static constexpr Unsigned Smax = Umax >> 1U;                       // 00011111</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">  static constexpr Unsigned Smin = ~Smax;                            // 11100000</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">  static constexpr Unsigned SignExtend = Unsigned(Smin << 1U);       // 11000000</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">/// `Compressor` is used to manipulate the bits of a (possibly signed) integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">/// type so it can be packed and unpacked into a `bits` sized integer,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">/// `Compressor` is specialized on signed-ness so no runtime cost is incurred.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">/// The `pack` method also checks that the passed in `UserValue` is valid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">template <typename T, unsigned Bits, bool = std::is_unsigned<T>::value></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">struct Compressor {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">  static_assert(std::is_unsigned<T>::value, "T must be unsigned");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">  using BP = BitPatterns<T, Bits>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="coveredLine">  static T pack(T UserValue, T UserMaxValue) {</td>
    <td>47</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="coveredLine">    assert(UserValue <= UserMaxValue && "value is too big");</td>
    <td>47</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="coveredLine">    assert(UserValue <= BP::Umax && "value is too big");</td>
    <td>47</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="coveredLine">    return UserValue;</td>
    <td>47</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="coveredLine">  static T unpack(T StorageValue) { return StorageValue; }</td>
    <td>232</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">template <typename T, unsigned Bits> struct Compressor<T, Bits, false> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">  static_assert(std::is_signed<T>::value, "T must be signed");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">  using BP = BitPatterns<T, Bits>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">  static T pack(T UserValue, T UserMaxValue) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">    assert(UserValue <= UserMaxValue && "value is too big");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">    assert(UserValue <= T(BP::Smax) && "value is too big");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">    assert(UserValue >= T(BP::Smin) && "value is too small");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">    if (UserValue < 0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">      UserValue &= ~BP::SignExtend;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="">    return UserValue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">  static T unpack(T StorageValue) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">    if (StorageValue >= T(BP::SignBitMask))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">      StorageValue |= BP::SignExtend;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">    return StorageValue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">/// Impl is where Bifield description and Storage are put together to interact</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">/// with values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">template <typename Bitfield, typename StorageType> struct Impl {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">  static_assert(std::is_unsigned<StorageType>::value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">                "Storage must be unsigned");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">  using IntegerType = typename Bitfield::IntegerType;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">  using C = Compressor<IntegerType, Bitfield::Bits>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">  using BP = BitPatterns<StorageType, Bitfield::Bits>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">  static constexpr size_t StorageBits = sizeof(StorageType) * CHAR_BIT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">  static_assert(Bitfield::FirstBit <= StorageBits, "Data must fit in mask");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">  static_assert(Bitfield::LastBit <= StorageBits, "Data must fit in mask");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">  static constexpr StorageType Mask = BP::Umax << Bitfield::Shift;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">  /// Checks `UserValue` is within bounds and packs it between `FirstBit` and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">  /// `LastBit` of `Packed` leaving the rest unchanged.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="coveredLine">  static void update(StorageType &Packed, IntegerType UserValue) {</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="coveredLine">    const StorageType StorageValue = C::pack(UserValue, Bitfield::UserMaxValue);</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="coveredLine">    Packed &= ~Mask;</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="coveredLine">    Packed |= StorageValue << Bitfield::Shift;</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="coveredLine">  }</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">  /// Interprets bits between `FirstBit` and `LastBit` of `Packed` as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">  /// an`IntegerType`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="coveredLine">  static IntegerType extract(StorageType Packed) {</td>
    <td>110</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="coveredLine">    const StorageType StorageValue = (Packed & Mask) >> Bitfield::Shift;</td>
    <td>110</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="coveredLine">    return C::unpack(StorageValue);</td>
    <td>110</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">  /// Interprets bits between `FirstBit` and `LastBit` of `Packed` as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">  /// an`IntegerType`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">  static StorageType test(StorageType Packed) { return Packed & Mask; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">/// `Bitfield` deals with the following type:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">/// - unsigned enums</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">/// - signed and unsigned integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">/// - `bool`</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">/// Internally though we only manipulate integer with well defined and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">/// consistent semantics, this excludes typed enums and `bool` that are replaced</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">/// with their unsigned counterparts. The correct type is restored in the public</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">/// API.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">template <typename T, bool = std::is_enum<T>::value></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">struct ResolveUnderlyingType {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">  using type = std::underlying_type_t<T>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">template <typename T> struct ResolveUnderlyingType<T, false> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="">  using type = T;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">template <> struct ResolveUnderlyingType<bool, false> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">  /// In case sizeof(bool) != 1, replace `void` by an additionnal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  /// std::conditional.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">  using type = std::conditional_t<sizeof(bool) == 1, uint8_t, void>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">} // namespace bitfields_details</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">/// Holds functions to get, set or test bitfields.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">struct Bitfield {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">  /// Describes an element of a Bitfield. This type is then used with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">  /// Bitfield static member functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">  /// \tparam T         The type of the field once in unpacked form.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">  /// \tparam Offset    The position of the first bit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">  /// \tparam Size      The size of the field.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">  /// \tparam MaxValue  For enums the maximum enum allowed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">  template <typename T, unsigned Offset, unsigned Size,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">            T MaxValue = std::is_enum<T>::value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">                             ? T(0) // coupled with static_assert below</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">                             : std::numeric_limits<T>::max()></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  struct Element {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">    using Type = T;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">    using IntegerType =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">        typename bitfields_details::ResolveUnderlyingType<T>::type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">    static constexpr unsigned Shift = Offset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">    static constexpr unsigned Bits = Size;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">    static constexpr unsigned FirstBit = Offset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">    static constexpr unsigned LastBit = Shift + Bits - 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">    static constexpr unsigned NextBit = Shift + Bits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="">  private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">    template <typename, typename> friend struct bitfields_details::Impl;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">    static_assert(Bits > 0, "Bits must be non zero");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">    static constexpr size_t TypeBits = sizeof(IntegerType) * CHAR_BIT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="">    static_assert(Bits <= TypeBits, "Bits may not be greater than T size");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">    static_assert(!std::is_enum<T>::value || MaxValue != T(0),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">                  "Enum Bitfields must provide a MaxValue");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">    static_assert(!std::is_enum<T>::value ||</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">                      std::is_unsigned<IntegerType>::value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">                  "Enum must be unsigned");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">    static_assert(std::is_integral<IntegerType>::value &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">                      std::numeric_limits<IntegerType>::is_integer,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">                  "IntegerType must be an integer type");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">    static constexpr IntegerType UserMaxValue =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="">        static_cast<IntegerType>(MaxValue);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  /// Unpacks the field from the `Packed` value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">  template <typename Bitfield, typename StorageType></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="coveredLine">  static typename Bitfield::Type get(StorageType Packed) {</td>
    <td>110</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="coveredLine">    return static_cast<typename Bitfield::Type>(I::extract(Packed));</td>
    <td>110</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">  /// Return a non-zero value if the field is non-zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">  /// It is more efficient than `getField`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">  template <typename Bitfield, typename StorageType></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">  static StorageType test(StorageType Packed) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">    return I::test(Packed);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">  /// Sets the typed value in the provided `Packed` value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">  /// The method will asserts if the provided value is too big to fit in.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">  template <typename Bitfield, typename StorageType></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="coveredLine">  static void set(StorageType &Packed, typename Bitfield::Type Value) {</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="coveredLine">    I::update(Packed, static_cast<typename Bitfield::IntegerType>(Value));</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="coveredLine">  }</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">  /// Returns whether the two bitfields share common bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">  template <typename A, typename B> static constexpr bool isOverlapping() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">    return A::LastBit >= B::FirstBit && B::LastBit >= A::FirstBit;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">  template <typename A> static constexpr bool areContiguous() { return true; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">  template <typename A, typename B, typename... Others></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">  static constexpr bool areContiguous() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">    return A::NextBit == B::FirstBit && areContiguous<B, Others...>();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">} // namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">#endif // LLVM_ADT_BITFIELDS_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorIjLj5ELb1EE6unpackEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorIjLj3ELb1EE6unpackEj</td>
    <td class="numberOfCalls">99</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorIhLj1ELb1EE6unpackEh</td>
    <td class="numberOfCalls">67</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorIjLj10ELb1EE6unpackEj</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorIjLj6ELb1EE6unpackEj</td>
    <td class="numberOfCalls">153</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorIjLj2ELb1EE6unpackEj</td>
    <td class="numberOfCalls">15</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIjLj0ELj6ELj32EEEtE7extractEt</td>
    <td class="numberOfCalls">37</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_7CmpInst9PredicateELj0ELj6ELS5_41EEEtE7extractEt</td>
    <td class="numberOfCalls">25</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIjLj2ELj10ELj1023EEEtE7extractEt</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIbLj6ELj1ELb1EEEtE7extractEt</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIbLj7ELj1ELb1EEEtE7extractEt</td>
    <td class="numberOfCalls">21</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIbLj0ELj1ELb1EEEtE7extractEt</td>
    <td class="numberOfCalls">36</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIjLj1ELj6ELj32EEEtE7extractEt</td>
    <td class="numberOfCalls">91</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_14AtomicOrderingELj7ELj3ELS4_7EEEtE7extractEt</td>
    <td class="numberOfCalls">99</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIjLj8ELj6ELj32EEEtE7extractEt</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_14AtomicOrderingELj0ELj3ELS4_7EEEtE7extractEt</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_8CallInst12TailCallKindELj0ELj2ELS5_3EEEtE7extractEt</td>
    <td class="numberOfCalls">15</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_14AtomicOrderingELj1ELj3ELS4_7EEEtE7extractEt</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIjLj9ELj6ELj32EEEtE7extractEt</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_13AtomicRMWInst5BinOpELj4ELj5ELS5_16EEEtE7extractEt</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_14AtomicOrderingELj5ELj3ELS4_7EEEtE7extractEt</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_14AtomicOrderingELj2ELj3ELS4_7EEEtE7extractEt</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIbLj1ELj1ELb1EEEtE7extractEt</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementINS_7CmpInst9PredicateELj0ELj6ELS4_41EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">25</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementIjLj2ELj10ELj1023EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementIjLj0ELj6ELj32EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">37</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementIbLj6ELj1ELb1EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementIbLj7ELj1ELb1EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">21</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementIbLj0ELj1ELb1EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">36</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementIjLj1ELj6ELj32EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">91</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementINS_14AtomicOrderingELj7ELj3ELS3_7EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">99</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementINS_14AtomicOrderingELj0ELj3ELS3_7EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementIjLj8ELj6ELj32EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementIbLj1ELj1ELb1EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementINS_14AtomicOrderingELj2ELj3ELS3_7EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementINS_14AtomicOrderingELj5ELj3ELS3_7EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementINS_13AtomicRMWInst5BinOpELj4ELj5ELS4_16EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementIjLj9ELj6ELj32EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementINS_14AtomicOrderingELj1ELj3ELS3_7EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementINS_8CallInst12TailCallKindELj0ELj2ELS4_3EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">15</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorIjLj2ELb1EE4packEjj</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorItLj15ELb1EE4packEtt</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorIjLj6ELb1EE4packEjj</td>
    <td class="numberOfCalls">26</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorIjLj10ELb1EE4packEjj</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorIhLj1ELb1EE4packEhh</td>
    <td class="numberOfCalls">30</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorIjLj5ELb1EE4packEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorIjLj3ELb1EE4packEjj</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details10CompressorItLj15ELb1EE6unpackEt</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementItLj0ELj15ELt65535EEEtE6updateERtt</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIjLj2ELj10ELj1023EEEtE6updateERtj</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIbLj0ELj1ELb1EEEtE6updateERth</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_7CmpInst9PredicateELj0ELj6ELS5_41EEEtE6updateERtj</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIjLj0ELj6ELj32EEEtE6updateERtj</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIbLj6ELj1ELb1EEEtE6updateERth</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIbLj7ELj1ELb1EEEtE6updateERth</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_14AtomicOrderingELj7ELj3ELS4_7EEEtE6updateERtj</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_8CallInst12TailCallKindELj0ELj2ELS5_3EEEtE6updateERtj</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_14AtomicOrderingELj1ELj3ELS4_7EEEtE6updateERtj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIjLj9ELj6ELj32EEEtE6updateERtj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIjLj1ELj6ELj32EEEtE6updateERtj</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_13AtomicRMWInst5BinOpELj4ELj5ELS5_16EEEtE6updateERtj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_14AtomicOrderingELj5ELj3ELS4_7EEEtE6updateERtj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_14AtomicOrderingELj2ELj3ELS4_7EEEtE6updateERtj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIbLj1ELj1ELb1EEEtE6updateERth</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementIjLj8ELj6ELj32EEEtE6updateERtj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementINS_14AtomicOrderingELj0ELj3ELS4_7EEEtE6updateERtj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17bitfields_details4ImplINS_8Bitfield7ElementItLj0ELj15ELt65535EEEtE7extractEt</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3getINS0_7ElementItLj0ELj15ELt65535EEEtEENT_4TypeET0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementIbLj7ELj1ELb1EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementINS_14AtomicOrderingELj2ELj3ELS3_7EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementINS_7CmpInst9PredicateELj0ELj6ELS4_41EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementIjLj8ELj6ELj32EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementIjLj2ELj10ELj1023EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementINS_14AtomicOrderingELj0ELj3ELS3_7EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementINS_14AtomicOrderingELj5ELj3ELS3_7EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementINS_14AtomicOrderingELj7ELj3ELS3_7EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementIjLj1ELj6ELj32EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementINS_13AtomicRMWInst5BinOpELj4ELj5ELS4_16EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementIjLj9ELj6ELj32EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementIbLj6ELj1ELb1EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementIjLj0ELj6ELj32EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementINS_14AtomicOrderingELj1ELj3ELS3_7EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementINS_8CallInst12TailCallKindELj0ELj2ELS4_3EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementItLj0ELj15ELt65535EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementIbLj1ELj1ELb1EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8Bitfield3setINS0_7ElementIbLj0ELj1ELb1EEEtEEvRT0_NT_4TypeE</td>
    <td class="numberOfCalls">18</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- llvm/ADT/Bitfield.h - Get and Set bits in an integer ---*- C++ -*--===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- llvm/ADT/Bitfield.h - Get and Set bits in an integer ---*- C++ -*--===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">///</td>
    <td class="lineNumber">8</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file</td>
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">/// This file implements methods to test, set and extract typed bits from packed</td>
    <td class="lineNumber">10</td>
    <td class="codeline">/// This file implements methods to test, set and extract typed bits from packed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">/// unsigned integers.</td>
    <td class="lineNumber">11</td>
    <td class="codeline">/// unsigned integers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">///</td>
    <td class="lineNumber">12</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">/// Why not C++ bitfields?</td>
    <td class="lineNumber">13</td>
    <td class="codeline">/// Why not C++ bitfields?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">/// ----------------------</td>
    <td class="lineNumber">14</td>
    <td class="codeline">/// ----------------------</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">/// C++ bitfields do not offer control over the bit layout nor consistent</td>
    <td class="lineNumber">15</td>
    <td class="codeline">/// C++ bitfields do not offer control over the bit layout nor consistent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">/// behavior when it comes to out of range values.</td>
    <td class="lineNumber">16</td>
    <td class="codeline">/// behavior when it comes to out of range values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">/// For instance, the layout is implementation defined and adjacent bits may be</td>
    <td class="lineNumber">17</td>
    <td class="codeline">/// For instance, the layout is implementation defined and adjacent bits may be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">/// packed together but are not required to. This is problematic when storage is</td>
    <td class="lineNumber">18</td>
    <td class="codeline">/// packed together but are not required to. This is problematic when storage is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">/// sparse and data must be stored in a particular integer type.</td>
    <td class="lineNumber">19</td>
    <td class="codeline">/// sparse and data must be stored in a particular integer type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">///</td>
    <td class="lineNumber">20</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">/// The methods provided in this file ensure precise control over the</td>
    <td class="lineNumber">21</td>
    <td class="codeline">/// The methods provided in this file ensure precise control over the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">/// layout/storage as well as protection against out of range values.</td>
    <td class="lineNumber">22</td>
    <td class="codeline">/// layout/storage as well as protection against out of range values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">///</td>
    <td class="lineNumber">23</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">/// Usage example</td>
    <td class="lineNumber">24</td>
    <td class="codeline">/// Usage example</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">/// -------------</td>
    <td class="lineNumber">25</td>
    <td class="codeline">/// -------------</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">/// \code{.cpp}</td>
    <td class="lineNumber">26</td>
    <td class="codeline">/// \code{.cpp}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">///  uint8_t Storage = 0;</td>
    <td class="lineNumber">27</td>
    <td class="codeline">///  uint8_t Storage = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">///</td>
    <td class="lineNumber">28</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">///  // Store and retrieve a single bit as bool.</td>
    <td class="lineNumber">29</td>
    <td class="codeline">///  // Store and retrieve a single bit as bool.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">///  using Bool = Bitfield::Element<bool, 0, 1>;</td>
    <td class="lineNumber">30</td>
    <td class="codeline">///  using Bool = Bitfield::Element<bool, 0, 1>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">///  Bitfield::set<Bool>(Storage, true);</td>
    <td class="lineNumber">31</td>
    <td class="codeline">///  Bitfield::set<Bool>(Storage, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">///  EXPECT_EQ(Storage, 0b00000001);</td>
    <td class="lineNumber">32</td>
    <td class="codeline">///  EXPECT_EQ(Storage, 0b00000001);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">///  //                          ^</td>
    <td class="lineNumber">33</td>
    <td class="codeline">///  //                          ^</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), true);</td>
    <td class="lineNumber">34</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">///</td>
    <td class="lineNumber">35</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">///  // Store and retrieve a 2 bit typed enum.</td>
    <td class="lineNumber">36</td>
    <td class="codeline">///  // Store and retrieve a 2 bit typed enum.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">///  // Note: enum underlying type must be unsigned.</td>
    <td class="lineNumber">37</td>
    <td class="codeline">///  // Note: enum underlying type must be unsigned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">///  enum class SuitEnum : uint8_t { CLUBS, DIAMONDS, HEARTS, SPADES };</td>
    <td class="lineNumber">38</td>
    <td class="codeline">///  enum class SuitEnum : uint8_t { CLUBS, DIAMONDS, HEARTS, SPADES };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">///  // Note: enum maximum value needs to be passed in as last parameter.</td>
    <td class="lineNumber">39</td>
    <td class="codeline">///  // Note: enum maximum value needs to be passed in as last parameter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">///  using Suit = Bitfield::Element<SuitEnum, 1, 2, SuitEnum::SPADES>;</td>
    <td class="lineNumber">40</td>
    <td class="codeline">///  using Suit = Bitfield::Element<SuitEnum, 1, 2, SuitEnum::SPADES>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">///  Bitfield::set<Suit>(Storage, SuitEnum::HEARTS);</td>
    <td class="lineNumber">41</td>
    <td class="codeline">///  Bitfield::set<Suit>(Storage, SuitEnum::HEARTS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">///  EXPECT_EQ(Storage, 0b00000101);</td>
    <td class="lineNumber">42</td>
    <td class="codeline">///  EXPECT_EQ(Storage, 0b00000101);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">///  //                        ^^</td>
    <td class="lineNumber">43</td>
    <td class="codeline">///  //                        ^^</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::HEARTS);</td>
    <td class="lineNumber">44</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::HEARTS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">///</td>
    <td class="lineNumber">45</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">///  // Store and retrieve a 5 bit value as unsigned.</td>
    <td class="lineNumber">46</td>
    <td class="codeline">///  // Store and retrieve a 5 bit value as unsigned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">///  using Value = Bitfield::Element<unsigned, 3, 5>;</td>
    <td class="lineNumber">47</td>
    <td class="codeline">///  using Value = Bitfield::Element<unsigned, 3, 5>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">///  Bitfield::set<Value>(Storage, 10);</td>
    <td class="lineNumber">48</td>
    <td class="codeline">///  Bitfield::set<Value>(Storage, 10);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">///  EXPECT_EQ(Storage, 0b01010101);</td>
    <td class="lineNumber">49</td>
    <td class="codeline">///  EXPECT_EQ(Storage, 0b01010101);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">///  //                   ^^^^^</td>
    <td class="lineNumber">50</td>
    <td class="codeline">///  //                   ^^^^^</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 10U);</td>
    <td class="lineNumber">51</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 10U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">///</td>
    <td class="lineNumber">52</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">///  // Interpret the same 5 bit value as signed.</td>
    <td class="lineNumber">53</td>
    <td class="codeline">///  // Interpret the same 5 bit value as signed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">///  using SignedValue = Bitfield::Element<int, 3, 5>;</td>
    <td class="lineNumber">54</td>
    <td class="codeline">///  using SignedValue = Bitfield::Element<int, 3, 5>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">///  Bitfield::set<SignedValue>(Storage, -2);</td>
    <td class="lineNumber">55</td>
    <td class="codeline">///  Bitfield::set<SignedValue>(Storage, -2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">///  EXPECT_EQ(Storage, 0b11110101);</td>
    <td class="lineNumber">56</td>
    <td class="codeline">///  EXPECT_EQ(Storage, 0b11110101);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">///  //                   ^^^^^</td>
    <td class="lineNumber">57</td>
    <td class="codeline">///  //                   ^^^^^</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -2);</td>
    <td class="lineNumber">58</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">///</td>
    <td class="lineNumber">59</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">///  // Ability to efficiently test if a field is non zero.</td>
    <td class="lineNumber">60</td>
    <td class="codeline">///  // Ability to efficiently test if a field is non zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">///  EXPECT_TRUE(Bitfield::test<Value>(Storage));</td>
    <td class="lineNumber">61</td>
    <td class="codeline">///  EXPECT_TRUE(Bitfield::test<Value>(Storage));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">///</td>
    <td class="lineNumber">62</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">///  // Alter Storage changes value.</td>
    <td class="lineNumber">63</td>
    <td class="codeline">///  // Alter Storage changes value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">///  Storage = 0;</td>
    <td class="lineNumber">64</td>
    <td class="codeline">///  Storage = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), false);</td>
    <td class="lineNumber">65</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::CLUBS);</td>
    <td class="lineNumber">66</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::CLUBS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 0U);</td>
    <td class="lineNumber">67</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 0U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), 0);</td>
    <td class="lineNumber">68</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">///</td>
    <td class="lineNumber">69</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">///  Storage = 255;</td>
    <td class="lineNumber">70</td>
    <td class="codeline">///  Storage = 255;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), true);</td>
    <td class="lineNumber">71</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::SPADES);</td>
    <td class="lineNumber">72</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::SPADES);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 31U);</td>
    <td class="lineNumber">73</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 31U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -1);</td>
    <td class="lineNumber">74</td>
    <td class="codeline">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">/// \endcode</td>
    <td class="lineNumber">75</td>
    <td class="codeline">/// \endcode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">///</td>
    <td class="lineNumber">76</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">77</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline"></td>
    <td class="lineNumber">78</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">#ifndef LLVM_ADT_BITFIELDS_H</td>
    <td class="lineNumber">79</td>
    <td class="codeline">#ifndef LLVM_ADT_BITFIELDS_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">#define LLVM_ADT_BITFIELDS_H</td>
    <td class="lineNumber">80</td>
    <td class="codeline">#define LLVM_ADT_BITFIELDS_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">82</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">#include <climits> // CHAR_BIT</td>
    <td class="lineNumber">83</td>
    <td class="codeline">#include <climits> // CHAR_BIT</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">#include <cstddef> // size_t</td>
    <td class="lineNumber">84</td>
    <td class="codeline">#include <cstddef> // size_t</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">#include <cstdint> // uintXX_t</td>
    <td class="lineNumber">85</td>
    <td class="codeline">#include <cstdint> // uintXX_t</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">#include <limits>  // numeric_limits</td>
    <td class="lineNumber">86</td>
    <td class="codeline">#include <limits>  // numeric_limits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">#include <type_traits></td>
    <td class="lineNumber">87</td>
    <td class="codeline">#include <type_traits></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">89</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline"></td>
    <td class="lineNumber">90</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">namespace bitfields_details {</td>
    <td class="lineNumber">91</td>
    <td class="codeline">namespace bitfields_details {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline"></td>
    <td class="lineNumber">92</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">/// A struct defining useful bit patterns for n-bits integer types.</td>
    <td class="lineNumber">93</td>
    <td class="codeline">/// A struct defining useful bit patterns for n-bits integer types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">template <typename T, unsigned Bits> struct BitPatterns {</td>
    <td class="lineNumber">94</td>
    <td class="codeline">template <typename T, unsigned Bits> struct BitPatterns {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">  /// Bit patterns are forged using the equivalent `Unsigned` type because of</td>
    <td class="lineNumber">95</td>
    <td class="codeline">  /// Bit patterns are forged using the equivalent `Unsigned` type because of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">  /// undefined operations over signed types (e.g. Bitwise shift operators).</td>
    <td class="lineNumber">96</td>
    <td class="codeline">  /// undefined operations over signed types (e.g. Bitwise shift operators).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">  /// Moreover same size casting from unsigned to signed is well defined but not</td>
    <td class="lineNumber">97</td>
    <td class="codeline">  /// Moreover same size casting from unsigned to signed is well defined but not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">  /// the other way around.</td>
    <td class="lineNumber">98</td>
    <td class="codeline">  /// the other way around.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">  using Unsigned = std::make_unsigned_t<T>;</td>
    <td class="lineNumber">99</td>
    <td class="codeline">  using Unsigned = std::make_unsigned_t<T>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  static_assert(sizeof(Unsigned) == sizeof(T), "Types must have same size");</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  static_assert(sizeof(Unsigned) == sizeof(T), "Types must have same size");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline"></td>
    <td class="lineNumber">101</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  static constexpr unsigned TypeBits = sizeof(Unsigned) * CHAR_BIT;</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  static constexpr unsigned TypeBits = sizeof(Unsigned) * CHAR_BIT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">  static_assert(TypeBits >= Bits, "n-bit must fit in T");</td>
    <td class="lineNumber">103</td>
    <td class="codeline">  static_assert(TypeBits >= Bits, "n-bit must fit in T");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline"></td>
    <td class="lineNumber">104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">  /// e.g. with TypeBits == 8 and Bits == 6.</td>
    <td class="lineNumber">105</td>
    <td class="codeline">  /// e.g. with TypeBits == 8 and Bits == 6.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">  static constexpr Unsigned AllZeros = Unsigned(0);                  // 00000000</td>
    <td class="lineNumber">106</td>
    <td class="codeline">  static constexpr Unsigned AllZeros = Unsigned(0);                  // 00000000</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">  static constexpr Unsigned AllOnes = ~Unsigned(0);                  // 11111111</td>
    <td class="lineNumber">107</td>
    <td class="codeline">  static constexpr Unsigned AllOnes = ~Unsigned(0);                  // 11111111</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">  static constexpr Unsigned Umin = AllZeros;                         // 00000000</td>
    <td class="lineNumber">108</td>
    <td class="codeline">  static constexpr Unsigned Umin = AllZeros;                         // 00000000</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">  static constexpr Unsigned Umax = AllOnes >> (TypeBits - Bits);     // 00111111</td>
    <td class="lineNumber">109</td>
    <td class="codeline">  static constexpr Unsigned Umax = AllOnes >> (TypeBits - Bits);     // 00111111</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  static constexpr Unsigned SignBitMask = Unsigned(1) << (Bits - 1); // 00100000</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  static constexpr Unsigned SignBitMask = Unsigned(1) << (Bits - 1); // 00100000</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">  static constexpr Unsigned Smax = Umax >> 1U;                       // 00011111</td>
    <td class="lineNumber">111</td>
    <td class="codeline">  static constexpr Unsigned Smax = Umax >> 1U;                       // 00011111</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  static constexpr Unsigned Smin = ~Smax;                            // 11100000</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  static constexpr Unsigned Smin = ~Smax;                            // 11100000</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">  static constexpr Unsigned SignExtend = Unsigned(Smin << 1U);       // 11000000</td>
    <td class="lineNumber">113</td>
    <td class="codeline">  static constexpr Unsigned SignExtend = Unsigned(Smin << 1U);       // 11000000</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">};</td>
    <td class="lineNumber">114</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline"></td>
    <td class="lineNumber">115</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">/// `Compressor` is used to manipulate the bits of a (possibly signed) integer</td>
    <td class="lineNumber">116</td>
    <td class="codeline">/// `Compressor` is used to manipulate the bits of a (possibly signed) integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">/// type so it can be packed and unpacked into a `bits` sized integer,</td>
    <td class="lineNumber">117</td>
    <td class="codeline">/// type so it can be packed and unpacked into a `bits` sized integer,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">/// `Compressor` is specialized on signed-ness so no runtime cost is incurred.</td>
    <td class="lineNumber">118</td>
    <td class="codeline">/// `Compressor` is specialized on signed-ness so no runtime cost is incurred.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">/// The `pack` method also checks that the passed in `UserValue` is valid.</td>
    <td class="lineNumber">119</td>
    <td class="codeline">/// The `pack` method also checks that the passed in `UserValue` is valid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">template <typename T, unsigned Bits, bool = std::is_unsigned<T>::value></td>
    <td class="lineNumber">120</td>
    <td class="codeline">template <typename T, unsigned Bits, bool = std::is_unsigned<T>::value></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">struct Compressor {</td>
    <td class="lineNumber">121</td>
    <td class="codeline">struct Compressor {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">  static_assert(std::is_unsigned<T>::value, "T must be unsigned");</td>
    <td class="lineNumber">122</td>
    <td class="codeline">  static_assert(std::is_unsigned<T>::value, "T must be unsigned");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  using BP = BitPatterns<T, Bits>;</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  using BP = BitPatterns<T, Bits>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline"></td>
    <td class="lineNumber">124</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">  static T pack(T UserValue, T UserMaxValue) {</td>
    <td class="lineNumber">125</td>
    <td class="codeline">  static T pack(T UserValue, T UserMaxValue) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">    assert(UserValue <= UserMaxValue && "value is too big");</td>
    <td class="lineNumber">126</td>
    <td class="codeline">    assert(UserValue <= UserMaxValue && "value is too big");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">    assert(UserValue <= BP::Umax && "value is too big");</td>
    <td class="lineNumber">127</td>
    <td class="codeline">    assert(UserValue <= BP::Umax && "value is too big");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">    return UserValue;</td>
    <td class="lineNumber">128</td>
    <td class="codeline">    return UserValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">129</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
    <td class="lineNumber">130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">  static T unpack(T StorageValue) { return StorageValue; }</td>
    <td class="lineNumber">131</td>
    <td class="codeline">  static T unpack(T StorageValue) { return StorageValue; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">};</td>
    <td class="lineNumber">132</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline"></td>
    <td class="lineNumber">133</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">template <typename T, unsigned Bits> struct Compressor<T, Bits, false> {</td>
    <td class="lineNumber">134</td>
    <td class="codeline">template <typename T, unsigned Bits> struct Compressor<T, Bits, false> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">  static_assert(std::is_signed<T>::value, "T must be signed");</td>
    <td class="lineNumber">135</td>
    <td class="codeline">  static_assert(std::is_signed<T>::value, "T must be signed");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">  using BP = BitPatterns<T, Bits>;</td>
    <td class="lineNumber">136</td>
    <td class="codeline">  using BP = BitPatterns<T, Bits>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">  static T pack(T UserValue, T UserMaxValue) {</td>
    <td class="lineNumber">138</td>
    <td class="codeline">  static T pack(T UserValue, T UserMaxValue) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">    assert(UserValue <= UserMaxValue && "value is too big");</td>
    <td class="lineNumber">139</td>
    <td class="codeline">    assert(UserValue <= UserMaxValue && "value is too big");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">    assert(UserValue <= T(BP::Smax) && "value is too big");</td>
    <td class="lineNumber">140</td>
    <td class="codeline">    assert(UserValue <= T(BP::Smax) && "value is too big");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">    assert(UserValue >= T(BP::Smin) && "value is too small");</td>
    <td class="lineNumber">141</td>
    <td class="codeline">    assert(UserValue >= T(BP::Smin) && "value is too small");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">    if (UserValue < 0)</td>
    <td class="lineNumber">142</td>
    <td class="codeline">    if (UserValue < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">      UserValue &= ~BP::SignExtend;</td>
    <td class="lineNumber">143</td>
    <td class="codeline">      UserValue &= ~BP::SignExtend;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">    return UserValue;</td>
    <td class="lineNumber">144</td>
    <td class="codeline">    return UserValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">145</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline"></td>
    <td class="lineNumber">146</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  static T unpack(T StorageValue) {</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  static T unpack(T StorageValue) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">    if (StorageValue >= T(BP::SignBitMask))</td>
    <td class="lineNumber">148</td>
    <td class="codeline">    if (StorageValue >= T(BP::SignBitMask))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">      StorageValue |= BP::SignExtend;</td>
    <td class="lineNumber">149</td>
    <td class="codeline">      StorageValue |= BP::SignExtend;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">    return StorageValue;</td>
    <td class="lineNumber">150</td>
    <td class="codeline">    return StorageValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">151</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">};</td>
    <td class="lineNumber">152</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">/// Impl is where Bifield description and Storage are put together to interact</td>
    <td class="lineNumber">154</td>
    <td class="codeline">/// Impl is where Bifield description and Storage are put together to interact</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">/// with values.</td>
    <td class="lineNumber">155</td>
    <td class="codeline">/// with values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">template <typename Bitfield, typename StorageType> struct Impl {</td>
    <td class="lineNumber">156</td>
    <td class="codeline">template <typename Bitfield, typename StorageType> struct Impl {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  static_assert(std::is_unsigned<StorageType>::value,</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  static_assert(std::is_unsigned<StorageType>::value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">                "Storage must be unsigned");</td>
    <td class="lineNumber">158</td>
    <td class="codeline">                "Storage must be unsigned");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  using IntegerType = typename Bitfield::IntegerType;</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  using IntegerType = typename Bitfield::IntegerType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">  using C = Compressor<IntegerType, Bitfield::Bits>;</td>
    <td class="lineNumber">160</td>
    <td class="codeline">  using C = Compressor<IntegerType, Bitfield::Bits>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">  using BP = BitPatterns<StorageType, Bitfield::Bits>;</td>
    <td class="lineNumber">161</td>
    <td class="codeline">  using BP = BitPatterns<StorageType, Bitfield::Bits>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">  static constexpr size_t StorageBits = sizeof(StorageType) * CHAR_BIT;</td>
    <td class="lineNumber">163</td>
    <td class="codeline">  static constexpr size_t StorageBits = sizeof(StorageType) * CHAR_BIT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  static_assert(Bitfield::FirstBit <= StorageBits, "Data must fit in mask");</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  static_assert(Bitfield::FirstBit <= StorageBits, "Data must fit in mask");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">  static_assert(Bitfield::LastBit <= StorageBits, "Data must fit in mask");</td>
    <td class="lineNumber">165</td>
    <td class="codeline">  static_assert(Bitfield::LastBit <= StorageBits, "Data must fit in mask");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">  static constexpr StorageType Mask = BP::Umax << Bitfield::Shift;</td>
    <td class="lineNumber">166</td>
    <td class="codeline">  static constexpr StorageType Mask = BP::Umax << Bitfield::Shift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  /// Checks `UserValue` is within bounds and packs it between `FirstBit` and</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  /// Checks `UserValue` is within bounds and packs it between `FirstBit` and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  /// `LastBit` of `Packed` leaving the rest unchanged.</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  /// `LastBit` of `Packed` leaving the rest unchanged.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  static void update(StorageType &Packed, IntegerType UserValue) {</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  static void update(StorageType &Packed, IntegerType UserValue) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">    const StorageType StorageValue = C::pack(UserValue, Bitfield::UserMaxValue);</td>
    <td class="lineNumber">171</td>
    <td class="codeline">    const StorageType StorageValue = C::pack(UserValue, Bitfield::UserMaxValue);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">    Packed &= ~Mask;</td>
    <td class="lineNumber">172</td>
    <td class="codeline">    Packed &= ~Mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">    Packed |= StorageValue << Bitfield::Shift;</td>
    <td class="lineNumber">173</td>
    <td class="codeline">    Packed |= StorageValue << Bitfield::Shift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline"></td>
    <td class="lineNumber">175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">  /// Interprets bits between `FirstBit` and `LastBit` of `Packed` as</td>
    <td class="lineNumber">176</td>
    <td class="codeline">  /// Interprets bits between `FirstBit` and `LastBit` of `Packed` as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">  /// an`IntegerType`.</td>
    <td class="lineNumber">177</td>
    <td class="codeline">  /// an`IntegerType`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  static IntegerType extract(StorageType Packed) {</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  static IntegerType extract(StorageType Packed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">    const StorageType StorageValue = (Packed & Mask) >> Bitfield::Shift;</td>
    <td class="lineNumber">179</td>
    <td class="codeline">    const StorageType StorageValue = (Packed & Mask) >> Bitfield::Shift;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">    return C::unpack(StorageValue);</td>
    <td class="lineNumber">180</td>
    <td class="codeline">    return C::unpack(StorageValue);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">181</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline"></td>
    <td class="lineNumber">182</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  /// Interprets bits between `FirstBit` and `LastBit` of `Packed` as</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  /// Interprets bits between `FirstBit` and `LastBit` of `Packed` as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">  /// an`IntegerType`.</td>
    <td class="lineNumber">184</td>
    <td class="codeline">  /// an`IntegerType`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  static StorageType test(StorageType Packed) { return Packed & Mask; }</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  static StorageType test(StorageType Packed) { return Packed & Mask; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">};</td>
    <td class="lineNumber">186</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline"></td>
    <td class="lineNumber">187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">/// `Bitfield` deals with the following type:</td>
    <td class="lineNumber">188</td>
    <td class="codeline">/// `Bitfield` deals with the following type:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">/// - unsigned enums</td>
    <td class="lineNumber">189</td>
    <td class="codeline">/// - unsigned enums</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">/// - signed and unsigned integer</td>
    <td class="lineNumber">190</td>
    <td class="codeline">/// - signed and unsigned integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">/// - `bool`</td>
    <td class="lineNumber">191</td>
    <td class="codeline">/// - `bool`</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">/// Internally though we only manipulate integer with well defined and</td>
    <td class="lineNumber">192</td>
    <td class="codeline">/// Internally though we only manipulate integer with well defined and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">/// consistent semantics, this excludes typed enums and `bool` that are replaced</td>
    <td class="lineNumber">193</td>
    <td class="codeline">/// consistent semantics, this excludes typed enums and `bool` that are replaced</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">/// with their unsigned counterparts. The correct type is restored in the public</td>
    <td class="lineNumber">194</td>
    <td class="codeline">/// with their unsigned counterparts. The correct type is restored in the public</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">/// API.</td>
    <td class="lineNumber">195</td>
    <td class="codeline">/// API.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">template <typename T, bool = std::is_enum<T>::value></td>
    <td class="lineNumber">196</td>
    <td class="codeline">template <typename T, bool = std::is_enum<T>::value></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">struct ResolveUnderlyingType {</td>
    <td class="lineNumber">197</td>
    <td class="codeline">struct ResolveUnderlyingType {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">  using type = std::underlying_type_t<T>;</td>
    <td class="lineNumber">198</td>
    <td class="codeline">  using type = std::underlying_type_t<T>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">};</td>
    <td class="lineNumber">199</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">template <typename T> struct ResolveUnderlyingType<T, false> {</td>
    <td class="lineNumber">200</td>
    <td class="codeline">template <typename T> struct ResolveUnderlyingType<T, false> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  using type = T;</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  using type = T;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">};</td>
    <td class="lineNumber">202</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">template <> struct ResolveUnderlyingType<bool, false> {</td>
    <td class="lineNumber">203</td>
    <td class="codeline">template <> struct ResolveUnderlyingType<bool, false> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">  /// In case sizeof(bool) != 1, replace `void` by an additionnal</td>
    <td class="lineNumber">204</td>
    <td class="codeline">  /// In case sizeof(bool) != 1, replace `void` by an additionnal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  /// std::conditional.</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  /// std::conditional.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  using type = std::conditional_t<sizeof(bool) == 1, uint8_t, void>;</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  using type = std::conditional_t<sizeof(bool) == 1, uint8_t, void>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">};</td>
    <td class="lineNumber">207</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline"></td>
    <td class="lineNumber">208</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">} // namespace bitfields_details</td>
    <td class="lineNumber">209</td>
    <td class="codeline">} // namespace bitfields_details</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">/// Holds functions to get, set or test bitfields.</td>
    <td class="lineNumber">211</td>
    <td class="codeline">/// Holds functions to get, set or test bitfields.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">struct Bitfield {</td>
    <td class="lineNumber">212</td>
    <td class="codeline">struct Bitfield {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  /// Describes an element of a Bitfield. This type is then used with the</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  /// Describes an element of a Bitfield. This type is then used with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">  /// Bitfield static member functions.</td>
    <td class="lineNumber">214</td>
    <td class="codeline">  /// Bitfield static member functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">  /// \tparam T         The type of the field once in unpacked form.</td>
    <td class="lineNumber">215</td>
    <td class="codeline">  /// \tparam T         The type of the field once in unpacked form.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">  /// \tparam Offset    The position of the first bit.</td>
    <td class="lineNumber">216</td>
    <td class="codeline">  /// \tparam Offset    The position of the first bit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  /// \tparam Size      The size of the field.</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  /// \tparam Size      The size of the field.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  /// \tparam MaxValue  For enums the maximum enum allowed.</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  /// \tparam MaxValue  For enums the maximum enum allowed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  template <typename T, unsigned Offset, unsigned Size,</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  template <typename T, unsigned Offset, unsigned Size,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">            T MaxValue = std::is_enum<T>::value</td>
    <td class="lineNumber">220</td>
    <td class="codeline">            T MaxValue = std::is_enum<T>::value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">                             ? T(0) // coupled with static_assert below</td>
    <td class="lineNumber">221</td>
    <td class="codeline">                             ? T(0) // coupled with static_assert below</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">                             : std::numeric_limits<T>::max()></td>
    <td class="lineNumber">222</td>
    <td class="codeline">                             : std::numeric_limits<T>::max()></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  struct Element {</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  struct Element {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">    using Type = T;</td>
    <td class="lineNumber">224</td>
    <td class="codeline">    using Type = T;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">    using IntegerType =</td>
    <td class="lineNumber">225</td>
    <td class="codeline">    using IntegerType =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">        typename bitfields_details::ResolveUnderlyingType<T>::type;</td>
    <td class="lineNumber">226</td>
    <td class="codeline">        typename bitfields_details::ResolveUnderlyingType<T>::type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">    static constexpr unsigned Shift = Offset;</td>
    <td class="lineNumber">227</td>
    <td class="codeline">    static constexpr unsigned Shift = Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">    static constexpr unsigned Bits = Size;</td>
    <td class="lineNumber">228</td>
    <td class="codeline">    static constexpr unsigned Bits = Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">    static constexpr unsigned FirstBit = Offset;</td>
    <td class="lineNumber">229</td>
    <td class="codeline">    static constexpr unsigned FirstBit = Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">    static constexpr unsigned LastBit = Shift + Bits - 1;</td>
    <td class="lineNumber">230</td>
    <td class="codeline">    static constexpr unsigned LastBit = Shift + Bits - 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">    static constexpr unsigned NextBit = Shift + Bits;</td>
    <td class="lineNumber">231</td>
    <td class="codeline">    static constexpr unsigned NextBit = Shift + Bits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
    <td class="lineNumber">232</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  private:</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">    template <typename, typename> friend struct bitfields_details::Impl;</td>
    <td class="lineNumber">234</td>
    <td class="codeline">    template <typename, typename> friend struct bitfields_details::Impl;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline"></td>
    <td class="lineNumber">235</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">    static_assert(Bits > 0, "Bits must be non zero");</td>
    <td class="lineNumber">236</td>
    <td class="codeline">    static_assert(Bits > 0, "Bits must be non zero");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">    static constexpr size_t TypeBits = sizeof(IntegerType) * CHAR_BIT;</td>
    <td class="lineNumber">237</td>
    <td class="codeline">    static constexpr size_t TypeBits = sizeof(IntegerType) * CHAR_BIT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">    static_assert(Bits <= TypeBits, "Bits may not be greater than T size");</td>
    <td class="lineNumber">238</td>
    <td class="codeline">    static_assert(Bits <= TypeBits, "Bits may not be greater than T size");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    static_assert(!std::is_enum<T>::value || MaxValue != T(0),</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    static_assert(!std::is_enum<T>::value || MaxValue != T(0),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">                  "Enum Bitfields must provide a MaxValue");</td>
    <td class="lineNumber">240</td>
    <td class="codeline">                  "Enum Bitfields must provide a MaxValue");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">    static_assert(!std::is_enum<T>::value ||</td>
    <td class="lineNumber">241</td>
    <td class="codeline">    static_assert(!std::is_enum<T>::value ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">                      std::is_unsigned<IntegerType>::value,</td>
    <td class="lineNumber">242</td>
    <td class="codeline">                      std::is_unsigned<IntegerType>::value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">                  "Enum must be unsigned");</td>
    <td class="lineNumber">243</td>
    <td class="codeline">                  "Enum must be unsigned");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">    static_assert(std::is_integral<IntegerType>::value &&</td>
    <td class="lineNumber">244</td>
    <td class="codeline">    static_assert(std::is_integral<IntegerType>::value &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">                      std::numeric_limits<IntegerType>::is_integer,</td>
    <td class="lineNumber">245</td>
    <td class="codeline">                      std::numeric_limits<IntegerType>::is_integer,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">                  "IntegerType must be an integer type");</td>
    <td class="lineNumber">246</td>
    <td class="codeline">                  "IntegerType must be an integer type");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline"></td>
    <td class="lineNumber">247</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">    static constexpr IntegerType UserMaxValue =</td>
    <td class="lineNumber">248</td>
    <td class="codeline">    static constexpr IntegerType UserMaxValue =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">        static_cast<IntegerType>(MaxValue);</td>
    <td class="lineNumber">249</td>
    <td class="codeline">        static_cast<IntegerType>(MaxValue);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline"></td>
    <td class="lineNumber">251</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  /// Unpacks the field from the `Packed` value.</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  /// Unpacks the field from the `Packed` value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  template <typename Bitfield, typename StorageType></td>
    <td class="lineNumber">253</td>
    <td class="codeline">  template <typename Bitfield, typename StorageType></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  static typename Bitfield::Type get(StorageType Packed) {</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  static typename Bitfield::Type get(StorageType Packed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
    <td class="lineNumber">255</td>
    <td class="codeline">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">    return static_cast<typename Bitfield::Type>(I::extract(Packed));</td>
    <td class="lineNumber">256</td>
    <td class="codeline">    return static_cast<typename Bitfield::Type>(I::extract(Packed));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline"></td>
    <td class="lineNumber">258</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">  /// Return a non-zero value if the field is non-zero.</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  /// Return a non-zero value if the field is non-zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">  /// It is more efficient than `getField`.</td>
    <td class="lineNumber">260</td>
    <td class="codeline">  /// It is more efficient than `getField`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">  template <typename Bitfield, typename StorageType></td>
    <td class="lineNumber">261</td>
    <td class="codeline">  template <typename Bitfield, typename StorageType></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  static StorageType test(StorageType Packed) {</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  static StorageType test(StorageType Packed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
    <td class="lineNumber">263</td>
    <td class="codeline">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">    return I::test(Packed);</td>
    <td class="lineNumber">264</td>
    <td class="codeline">    return I::test(Packed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">265</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline"></td>
    <td class="lineNumber">266</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">  /// Sets the typed value in the provided `Packed` value.</td>
    <td class="lineNumber">267</td>
    <td class="codeline">  /// Sets the typed value in the provided `Packed` value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">  /// The method will asserts if the provided value is too big to fit in.</td>
    <td class="lineNumber">268</td>
    <td class="codeline">  /// The method will asserts if the provided value is too big to fit in.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  template <typename Bitfield, typename StorageType></td>
    <td class="lineNumber">269</td>
    <td class="codeline">  template <typename Bitfield, typename StorageType></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  static void set(StorageType &Packed, typename Bitfield::Type Value) {</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  static void set(StorageType &Packed, typename Bitfield::Type Value) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
    <td class="lineNumber">271</td>
    <td class="codeline">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">    I::update(Packed, static_cast<typename Bitfield::IntegerType>(Value));</td>
    <td class="lineNumber">272</td>
    <td class="codeline">    I::update(Packed, static_cast<typename Bitfield::IntegerType>(Value));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline"></td>
    <td class="lineNumber">274</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  /// Returns whether the two bitfields share common bits.</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  /// Returns whether the two bitfields share common bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  template <typename A, typename B> static constexpr bool isOverlapping() {</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  template <typename A, typename B> static constexpr bool isOverlapping() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">    return A::LastBit >= B::FirstBit && B::LastBit >= A::FirstBit;</td>
    <td class="lineNumber">277</td>
    <td class="codeline">    return A::LastBit >= B::FirstBit && B::LastBit >= A::FirstBit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline"></td>
    <td class="lineNumber">279</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  template <typename A> static constexpr bool areContiguous() { return true; }</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  template <typename A> static constexpr bool areContiguous() { return true; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">  template <typename A, typename B, typename... Others></td>
    <td class="lineNumber">281</td>
    <td class="codeline">  template <typename A, typename B, typename... Others></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">  static constexpr bool areContiguous() {</td>
    <td class="lineNumber">282</td>
    <td class="codeline">  static constexpr bool areContiguous() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">    return A::NextBit == B::FirstBit && areContiguous<B, Others...>();</td>
    <td class="lineNumber">283</td>
    <td class="codeline">    return A::NextBit == B::FirstBit && areContiguous<B, Others...>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">};</td>
    <td class="lineNumber">285</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">} // namespace llvm</td>
    <td class="lineNumber">287</td>
    <td class="codeline">} // namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">#endif // LLVM_ADT_BITFIELDS_H</td>
    <td class="lineNumber">289</td>
    <td class="codeline">#endif // LLVM_ADT_BITFIELDS_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline"></td>
    <td class="lineNumber">290</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- llvm/ADT/Bitfield.h - Get and Set bits in an integer ---*- C++ -*--===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- llvm/ADT/Bitfield.h - Get and Set bits in an integer ---*- C++ -*--===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">/// This file implements methods to test, set and extract typed bits from packed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">/// This file implements methods to test, set and extract typed bits from packed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">/// unsigned integers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">/// unsigned integers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">/// Why not C++ bitfields?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">/// Why not C++ bitfields?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">/// ----------------------</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">/// ----------------------</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">/// C++ bitfields do not offer control over the bit layout nor consistent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">/// C++ bitfields do not offer control over the bit layout nor consistent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">/// behavior when it comes to out of range values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">/// behavior when it comes to out of range values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">/// For instance, the layout is implementation defined and adjacent bits may be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">/// For instance, the layout is implementation defined and adjacent bits may be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">/// packed together but are not required to. This is problematic when storage is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">/// packed together but are not required to. This is problematic when storage is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">/// sparse and data must be stored in a particular integer type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">/// sparse and data must be stored in a particular integer type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">/// The methods provided in this file ensure precise control over the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">/// The methods provided in this file ensure precise control over the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">/// layout/storage as well as protection against out of range values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">/// layout/storage as well as protection against out of range values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">/// Usage example</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">/// Usage example</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">/// -------------</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">/// -------------</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">/// \code{.cpp}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">/// \code{.cpp}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">///  uint8_t Storage = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">///  uint8_t Storage = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">///  // Store and retrieve a single bit as bool.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">///  // Store and retrieve a single bit as bool.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">///  using Bool = Bitfield::Element<bool, 0, 1>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">///  using Bool = Bitfield::Element<bool, 0, 1>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">///  Bitfield::set<Bool>(Storage, true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">///  Bitfield::set<Bool>(Storage, true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">///  EXPECT_EQ(Storage, 0b00000001);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">///  EXPECT_EQ(Storage, 0b00000001);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">///  //                          ^</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">///  //                          ^</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">///  // Store and retrieve a 2 bit typed enum.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">///  // Store and retrieve a 2 bit typed enum.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">///  // Note: enum underlying type must be unsigned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">///  // Note: enum underlying type must be unsigned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">///  enum class SuitEnum : uint8_t { CLUBS, DIAMONDS, HEARTS, SPADES };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">///  enum class SuitEnum : uint8_t { CLUBS, DIAMONDS, HEARTS, SPADES };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">///  // Note: enum maximum value needs to be passed in as last parameter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">///  // Note: enum maximum value needs to be passed in as last parameter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">///  using Suit = Bitfield::Element<SuitEnum, 1, 2, SuitEnum::SPADES>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">///  using Suit = Bitfield::Element<SuitEnum, 1, 2, SuitEnum::SPADES>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">///  Bitfield::set<Suit>(Storage, SuitEnum::HEARTS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">///  Bitfield::set<Suit>(Storage, SuitEnum::HEARTS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">///  EXPECT_EQ(Storage, 0b00000101);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">///  EXPECT_EQ(Storage, 0b00000101);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">///  //                        ^^</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">///  //                        ^^</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::HEARTS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::HEARTS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">///  // Store and retrieve a 5 bit value as unsigned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">///  // Store and retrieve a 5 bit value as unsigned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">///  using Value = Bitfield::Element<unsigned, 3, 5>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">///  using Value = Bitfield::Element<unsigned, 3, 5>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">///  Bitfield::set<Value>(Storage, 10);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">///  Bitfield::set<Value>(Storage, 10);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">///  EXPECT_EQ(Storage, 0b01010101);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">///  EXPECT_EQ(Storage, 0b01010101);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">///  //                   ^^^^^</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">///  //                   ^^^^^</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 10U);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 10U);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">///  // Interpret the same 5 bit value as signed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">///  // Interpret the same 5 bit value as signed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">///  using SignedValue = Bitfield::Element<int, 3, 5>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">///  using SignedValue = Bitfield::Element<int, 3, 5>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">///  Bitfield::set<SignedValue>(Storage, -2);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">///  Bitfield::set<SignedValue>(Storage, -2);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">///  EXPECT_EQ(Storage, 0b11110101);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">///  EXPECT_EQ(Storage, 0b11110101);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">///  //                   ^^^^^</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">///  //                   ^^^^^</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -2);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -2);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">///  // Ability to efficiently test if a field is non zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">///  // Ability to efficiently test if a field is non zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">///  EXPECT_TRUE(Bitfield::test<Value>(Storage));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">///  EXPECT_TRUE(Bitfield::test<Value>(Storage));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">///  // Alter Storage changes value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">///  // Alter Storage changes value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">///  Storage = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">///  Storage = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::CLUBS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::CLUBS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 0U);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 0U);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">///  Storage = 255;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">///  Storage = 255;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), true);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Bool>(Storage), true);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::SPADES);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Suit>(Storage), SuitEnum::SPADES);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 31U);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<Value>(Storage), 31U);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -1);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">///  EXPECT_EQ(Bitfield::get<SignedValue>(Storage), -1);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">/// \endcode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">/// \endcode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">#ifndef LLVM_ADT_BITFIELDS_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">#ifndef LLVM_ADT_BITFIELDS_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">#define LLVM_ADT_BITFIELDS_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">#define LLVM_ADT_BITFIELDS_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">#include <climits> // CHAR_BIT</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">#include <climits> // CHAR_BIT</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">#include <cstddef> // size_t</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">#include <cstddef> // size_t</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">#include <cstdint> // uintXX_t</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">#include <cstdint> // uintXX_t</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">#include <limits>  // numeric_limits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">#include <limits>  // numeric_limits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">#include <type_traits></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">#include <type_traits></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">namespace bitfields_details {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">namespace bitfields_details {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">/// A struct defining useful bit patterns for n-bits integer types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">/// A struct defining useful bit patterns for n-bits integer types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">template <typename T, unsigned Bits> struct BitPatterns {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">template <typename T, unsigned Bits> struct BitPatterns {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">  /// Bit patterns are forged using the equivalent `Unsigned` type because of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">  /// Bit patterns are forged using the equivalent `Unsigned` type because of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">  /// undefined operations over signed types (e.g. Bitwise shift operators).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">  /// undefined operations over signed types (e.g. Bitwise shift operators).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">  /// Moreover same size casting from unsigned to signed is well defined but not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">  /// Moreover same size casting from unsigned to signed is well defined but not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">  /// the other way around.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">  /// the other way around.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">  using Unsigned = std::make_unsigned_t<T>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">  using Unsigned = std::make_unsigned_t<T>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  static_assert(sizeof(Unsigned) == sizeof(T), "Types must have same size");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  static_assert(sizeof(Unsigned) == sizeof(T), "Types must have same size");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  static constexpr unsigned TypeBits = sizeof(Unsigned) * CHAR_BIT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  static constexpr unsigned TypeBits = sizeof(Unsigned) * CHAR_BIT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">  static_assert(TypeBits >= Bits, "n-bit must fit in T");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">  static_assert(TypeBits >= Bits, "n-bit must fit in T");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">  /// e.g. with TypeBits == 8 and Bits == 6.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">  /// e.g. with TypeBits == 8 and Bits == 6.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">  static constexpr Unsigned AllZeros = Unsigned(0);                  // 00000000</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">  static constexpr Unsigned AllZeros = Unsigned(0);                  // 00000000</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">  static constexpr Unsigned AllOnes = ~Unsigned(0);                  // 11111111</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">  static constexpr Unsigned AllOnes = ~Unsigned(0);                  // 11111111</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">  static constexpr Unsigned Umin = AllZeros;                         // 00000000</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">  static constexpr Unsigned Umin = AllZeros;                         // 00000000</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">  static constexpr Unsigned Umax = AllOnes >> (TypeBits - Bits);     // 00111111</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">  static constexpr Unsigned Umax = AllOnes >> (TypeBits - Bits);     // 00111111</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  static constexpr Unsigned SignBitMask = Unsigned(1) << (Bits - 1); // 00100000</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  static constexpr Unsigned SignBitMask = Unsigned(1) << (Bits - 1); // 00100000</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">  static constexpr Unsigned Smax = Umax >> 1U;                       // 00011111</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">  static constexpr Unsigned Smax = Umax >> 1U;                       // 00011111</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">  static constexpr Unsigned Smin = ~Smax;                            // 11100000</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">  static constexpr Unsigned Smin = ~Smax;                            // 11100000</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">  static constexpr Unsigned SignExtend = Unsigned(Smin << 1U);       // 11000000</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">  static constexpr Unsigned SignExtend = Unsigned(Smin << 1U);       // 11000000</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">/// `Compressor` is used to manipulate the bits of a (possibly signed) integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">/// `Compressor` is used to manipulate the bits of a (possibly signed) integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">/// type so it can be packed and unpacked into a `bits` sized integer,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">/// type so it can be packed and unpacked into a `bits` sized integer,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">/// `Compressor` is specialized on signed-ness so no runtime cost is incurred.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">/// `Compressor` is specialized on signed-ness so no runtime cost is incurred.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">/// The `pack` method also checks that the passed in `UserValue` is valid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">/// The `pack` method also checks that the passed in `UserValue` is valid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">template <typename T, unsigned Bits, bool = std::is_unsigned<T>::value></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">template <typename T, unsigned Bits, bool = std::is_unsigned<T>::value></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">struct Compressor {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">struct Compressor {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">  static_assert(std::is_unsigned<T>::value, "T must be unsigned");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">  static_assert(std::is_unsigned<T>::value, "T must be unsigned");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  using BP = BitPatterns<T, Bits>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  using BP = BitPatterns<T, Bits>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine coveredLine">  static T pack(T UserValue, T UserMaxValue) {</td>
    <td class="lineNumber">25</td>
    <td class="lineNumber">125</td>
    <td class="codeLine coveredLine">  static T pack(T UserValue, T UserMaxValue) {</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine coveredLine">    assert(UserValue <= UserMaxValue && "value is too big");</td>
    <td class="lineNumber">25</td>
    <td class="lineNumber">126</td>
    <td class="codeLine coveredLine">    assert(UserValue <= UserMaxValue && "value is too big");</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine coveredLine">    assert(UserValue <= BP::Umax && "value is too big");</td>
    <td class="lineNumber">25</td>
    <td class="lineNumber">127</td>
    <td class="codeLine coveredLine">    assert(UserValue <= BP::Umax && "value is too big");</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine coveredLine">    return UserValue;</td>
    <td class="lineNumber">25</td>
    <td class="lineNumber">128</td>
    <td class="codeLine coveredLine">    return UserValue;</td>
    <td class="lineNumber">22</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine coveredLine">  static T unpack(T StorageValue) { return StorageValue; }</td>
    <td class="lineNumber">130</td>
    <td class="lineNumber">131</td>
    <td class="codeLine coveredLine">  static T unpack(T StorageValue) { return StorageValue; }</td>
    <td class="lineNumber">102</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">template <typename T, unsigned Bits> struct Compressor<T, Bits, false> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">template <typename T, unsigned Bits> struct Compressor<T, Bits, false> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">  static_assert(std::is_signed<T>::value, "T must be signed");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">  static_assert(std::is_signed<T>::value, "T must be signed");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">  using BP = BitPatterns<T, Bits>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">  using BP = BitPatterns<T, Bits>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">  static T pack(T UserValue, T UserMaxValue) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">  static T pack(T UserValue, T UserMaxValue) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">    assert(UserValue <= UserMaxValue && "value is too big");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">    assert(UserValue <= UserMaxValue && "value is too big");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">    assert(UserValue <= T(BP::Smax) && "value is too big");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">    assert(UserValue <= T(BP::Smax) && "value is too big");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">    assert(UserValue >= T(BP::Smin) && "value is too small");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">    assert(UserValue >= T(BP::Smin) && "value is too small");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">    if (UserValue < 0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">    if (UserValue < 0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">      UserValue &= ~BP::SignExtend;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">      UserValue &= ~BP::SignExtend;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">    return UserValue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">    return UserValue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  static T unpack(T StorageValue) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  static T unpack(T StorageValue) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">    if (StorageValue >= T(BP::SignBitMask))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">    if (StorageValue >= T(BP::SignBitMask))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">      StorageValue |= BP::SignExtend;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">      StorageValue |= BP::SignExtend;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">    return StorageValue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">    return StorageValue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">/// Impl is where Bifield description and Storage are put together to interact</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">/// Impl is where Bifield description and Storage are put together to interact</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">/// with values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">/// with values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">template <typename Bitfield, typename StorageType> struct Impl {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">template <typename Bitfield, typename StorageType> struct Impl {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  static_assert(std::is_unsigned<StorageType>::value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  static_assert(std::is_unsigned<StorageType>::value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">                "Storage must be unsigned");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">                "Storage must be unsigned");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">  using IntegerType = typename Bitfield::IntegerType;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">  using IntegerType = typename Bitfield::IntegerType;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">  using C = Compressor<IntegerType, Bitfield::Bits>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">  using C = Compressor<IntegerType, Bitfield::Bits>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">  using BP = BitPatterns<StorageType, Bitfield::Bits>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">  using BP = BitPatterns<StorageType, Bitfield::Bits>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">  static constexpr size_t StorageBits = sizeof(StorageType) * CHAR_BIT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">  static constexpr size_t StorageBits = sizeof(StorageType) * CHAR_BIT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  static_assert(Bitfield::FirstBit <= StorageBits, "Data must fit in mask");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  static_assert(Bitfield::FirstBit <= StorageBits, "Data must fit in mask");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">  static_assert(Bitfield::LastBit <= StorageBits, "Data must fit in mask");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">  static_assert(Bitfield::LastBit <= StorageBits, "Data must fit in mask");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">  static constexpr StorageType Mask = BP::Umax << Bitfield::Shift;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">  static constexpr StorageType Mask = BP::Umax << Bitfield::Shift;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">  /// Checks `UserValue` is within bounds and packs it between `FirstBit` and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">  /// Checks `UserValue` is within bounds and packs it between `FirstBit` and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  /// `LastBit` of `Packed` leaving the rest unchanged.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  /// `LastBit` of `Packed` leaving the rest unchanged.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine coveredLine">  static void update(StorageType &Packed, IntegerType UserValue) {</td>
    <td class="lineNumber">31</td>
    <td class="lineNumber">170</td>
    <td class="codeLine coveredLine">  static void update(StorageType &Packed, IntegerType UserValue) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine coveredLine">    const StorageType StorageValue = C::pack(UserValue, Bitfield::UserMaxValue);</td>
    <td class="lineNumber">31</td>
    <td class="lineNumber">171</td>
    <td class="codeLine coveredLine">    const StorageType StorageValue = C::pack(UserValue, Bitfield::UserMaxValue);</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine coveredLine">    Packed &= ~Mask;</td>
    <td class="lineNumber">31</td>
    <td class="lineNumber">172</td>
    <td class="codeLine coveredLine">    Packed &= ~Mask;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine coveredLine">    Packed |= StorageValue << Bitfield::Shift;</td>
    <td class="lineNumber">31</td>
    <td class="lineNumber">173</td>
    <td class="codeLine coveredLine">    Packed |= StorageValue << Bitfield::Shift;</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">31</td>
    <td class="lineNumber">174</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">  /// Interprets bits between `FirstBit` and `LastBit` of `Packed` as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">  /// Interprets bits between `FirstBit` and `LastBit` of `Packed` as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">  /// an`IntegerType`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">  /// an`IntegerType`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine coveredLine">  static IntegerType extract(StorageType Packed) {</td>
    <td class="lineNumber">63</td>
    <td class="lineNumber">178</td>
    <td class="codeLine coveredLine">  static IntegerType extract(StorageType Packed) {</td>
    <td class="lineNumber">47</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine coveredLine">    const StorageType StorageValue = (Packed & Mask) >> Bitfield::Shift;</td>
    <td class="lineNumber">63</td>
    <td class="lineNumber">179</td>
    <td class="codeLine coveredLine">    const StorageType StorageValue = (Packed & Mask) >> Bitfield::Shift;</td>
    <td class="lineNumber">47</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine coveredLine">    return C::unpack(StorageValue);</td>
    <td class="lineNumber">63</td>
    <td class="lineNumber">180</td>
    <td class="codeLine coveredLine">    return C::unpack(StorageValue);</td>
    <td class="lineNumber">47</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  /// Interprets bits between `FirstBit` and `LastBit` of `Packed` as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  /// Interprets bits between `FirstBit` and `LastBit` of `Packed` as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">  /// an`IntegerType`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">  /// an`IntegerType`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  static StorageType test(StorageType Packed) { return Packed & Mask; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  static StorageType test(StorageType Packed) { return Packed & Mask; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">/// `Bitfield` deals with the following type:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">/// `Bitfield` deals with the following type:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">/// - unsigned enums</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">/// - unsigned enums</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">/// - signed and unsigned integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">/// - signed and unsigned integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">/// - `bool`</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">/// - `bool`</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">/// Internally though we only manipulate integer with well defined and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">/// Internally though we only manipulate integer with well defined and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">/// consistent semantics, this excludes typed enums and `bool` that are replaced</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">/// consistent semantics, this excludes typed enums and `bool` that are replaced</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">/// with their unsigned counterparts. The correct type is restored in the public</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">/// with their unsigned counterparts. The correct type is restored in the public</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">/// API.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">/// API.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">template <typename T, bool = std::is_enum<T>::value></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">template <typename T, bool = std::is_enum<T>::value></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">struct ResolveUnderlyingType {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">struct ResolveUnderlyingType {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">  using type = std::underlying_type_t<T>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">  using type = std::underlying_type_t<T>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">template <typename T> struct ResolveUnderlyingType<T, false> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">template <typename T> struct ResolveUnderlyingType<T, false> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">  using type = T;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">  using type = T;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">template <> struct ResolveUnderlyingType<bool, false> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">template <> struct ResolveUnderlyingType<bool, false> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">  /// In case sizeof(bool) != 1, replace `void` by an additionnal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">  /// In case sizeof(bool) != 1, replace `void` by an additionnal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  /// std::conditional.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  /// std::conditional.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  using type = std::conditional_t<sizeof(bool) == 1, uint8_t, void>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  using type = std::conditional_t<sizeof(bool) == 1, uint8_t, void>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">} // namespace bitfields_details</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">} // namespace bitfields_details</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">/// Holds functions to get, set or test bitfields.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">/// Holds functions to get, set or test bitfields.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">struct Bitfield {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">struct Bitfield {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  /// Describes an element of a Bitfield. This type is then used with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  /// Describes an element of a Bitfield. This type is then used with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">  /// Bitfield static member functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">  /// Bitfield static member functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">  /// \tparam T         The type of the field once in unpacked form.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">  /// \tparam T         The type of the field once in unpacked form.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">  /// \tparam Offset    The position of the first bit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">  /// \tparam Offset    The position of the first bit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">  /// \tparam Size      The size of the field.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">  /// \tparam Size      The size of the field.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">  /// \tparam MaxValue  For enums the maximum enum allowed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">  /// \tparam MaxValue  For enums the maximum enum allowed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  template <typename T, unsigned Offset, unsigned Size,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  template <typename T, unsigned Offset, unsigned Size,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">            T MaxValue = std::is_enum<T>::value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">            T MaxValue = std::is_enum<T>::value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">                             ? T(0) // coupled with static_assert below</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">                             ? T(0) // coupled with static_assert below</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">                             : std::numeric_limits<T>::max()></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">                             : std::numeric_limits<T>::max()></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  struct Element {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  struct Element {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">    using Type = T;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">    using Type = T;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">    using IntegerType =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">    using IntegerType =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">        typename bitfields_details::ResolveUnderlyingType<T>::type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">        typename bitfields_details::ResolveUnderlyingType<T>::type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">    static constexpr unsigned Shift = Offset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">    static constexpr unsigned Shift = Offset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">    static constexpr unsigned Bits = Size;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">    static constexpr unsigned Bits = Size;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">    static constexpr unsigned FirstBit = Offset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">    static constexpr unsigned FirstBit = Offset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">    static constexpr unsigned LastBit = Shift + Bits - 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">    static constexpr unsigned LastBit = Shift + Bits - 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">    static constexpr unsigned NextBit = Shift + Bits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">    static constexpr unsigned NextBit = Shift + Bits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">    template <typename, typename> friend struct bitfields_details::Impl;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">    template <typename, typename> friend struct bitfields_details::Impl;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">    static_assert(Bits > 0, "Bits must be non zero");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">    static_assert(Bits > 0, "Bits must be non zero");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">    static constexpr size_t TypeBits = sizeof(IntegerType) * CHAR_BIT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">    static constexpr size_t TypeBits = sizeof(IntegerType) * CHAR_BIT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">    static_assert(Bits <= TypeBits, "Bits may not be greater than T size");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">    static_assert(Bits <= TypeBits, "Bits may not be greater than T size");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">    static_assert(!std::is_enum<T>::value || MaxValue != T(0),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">    static_assert(!std::is_enum<T>::value || MaxValue != T(0),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">                  "Enum Bitfields must provide a MaxValue");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">                  "Enum Bitfields must provide a MaxValue");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">    static_assert(!std::is_enum<T>::value ||</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">    static_assert(!std::is_enum<T>::value ||</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">                      std::is_unsigned<IntegerType>::value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">                      std::is_unsigned<IntegerType>::value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">                  "Enum must be unsigned");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">                  "Enum must be unsigned");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">    static_assert(std::is_integral<IntegerType>::value &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">    static_assert(std::is_integral<IntegerType>::value &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">                      std::numeric_limits<IntegerType>::is_integer,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">                      std::numeric_limits<IntegerType>::is_integer,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">                  "IntegerType must be an integer type");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">                  "IntegerType must be an integer type");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">    static constexpr IntegerType UserMaxValue =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">    static constexpr IntegerType UserMaxValue =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">        static_cast<IntegerType>(MaxValue);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">        static_cast<IntegerType>(MaxValue);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  /// Unpacks the field from the `Packed` value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  /// Unpacks the field from the `Packed` value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  template <typename Bitfield, typename StorageType></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  template <typename Bitfield, typename StorageType></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine coveredLine">  static typename Bitfield::Type get(StorageType Packed) {</td>
    <td class="lineNumber">63</td>
    <td class="lineNumber">254</td>
    <td class="codeLine coveredLine">  static typename Bitfield::Type get(StorageType Packed) {</td>
    <td class="lineNumber">47</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine coveredLine">    return static_cast<typename Bitfield::Type>(I::extract(Packed));</td>
    <td class="lineNumber">63</td>
    <td class="lineNumber">256</td>
    <td class="codeLine coveredLine">    return static_cast<typename Bitfield::Type>(I::extract(Packed));</td>
    <td class="lineNumber">47</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">  /// Return a non-zero value if the field is non-zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">  /// Return a non-zero value if the field is non-zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">  /// It is more efficient than `getField`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">  /// It is more efficient than `getField`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">  template <typename Bitfield, typename StorageType></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">  template <typename Bitfield, typename StorageType></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">  static StorageType test(StorageType Packed) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  static StorageType test(StorageType Packed) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">    return I::test(Packed);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">    return I::test(Packed);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">  /// Sets the typed value in the provided `Packed` value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">  /// Sets the typed value in the provided `Packed` value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">  /// The method will asserts if the provided value is too big to fit in.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">  /// The method will asserts if the provided value is too big to fit in.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  template <typename Bitfield, typename StorageType></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  template <typename Bitfield, typename StorageType></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine coveredLine">  static void set(StorageType &Packed, typename Bitfield::Type Value) {</td>
    <td class="lineNumber">31</td>
    <td class="lineNumber">270</td>
    <td class="codeLine coveredLine">  static void set(StorageType &Packed, typename Bitfield::Type Value) {</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">    using I = bitfields_details::Impl<Bitfield, StorageType>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine coveredLine">    I::update(Packed, static_cast<typename Bitfield::IntegerType>(Value));</td>
    <td class="lineNumber">31</td>
    <td class="lineNumber">272</td>
    <td class="codeLine coveredLine">    I::update(Packed, static_cast<typename Bitfield::IntegerType>(Value));</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">31</td>
    <td class="lineNumber">273</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">28</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">  /// Returns whether the two bitfields share common bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  /// Returns whether the two bitfields share common bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  template <typename A, typename B> static constexpr bool isOverlapping() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  template <typename A, typename B> static constexpr bool isOverlapping() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">    return A::LastBit >= B::FirstBit && B::LastBit >= A::FirstBit;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">    return A::LastBit >= B::FirstBit && B::LastBit >= A::FirstBit;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  template <typename A> static constexpr bool areContiguous() { return true; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  template <typename A> static constexpr bool areContiguous() { return true; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">  template <typename A, typename B, typename... Others></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">  template <typename A, typename B, typename... Others></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">  static constexpr bool areContiguous() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">  static constexpr bool areContiguous() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">    return A::NextBit == B::FirstBit && areContiguous<B, Others...>();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">    return A::NextBit == B::FirstBit && areContiguous<B, Others...>();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">#endif // LLVM_ADT_BITFIELDS_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">#endif // LLVM_ADT_BITFIELDS_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>