<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Hashing.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/ADT/Hashing.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This file implements the newly proposed standard C++ interfaces for hashing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// arbitrary data and building hash functions for user-defined types. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">// interface was originally proposed in N3333[1] and is currently under review</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">// for inclusion in a future TR and/or standard.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">// The primary interfaces provide are comprised of one type and three functions:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">//  -- 'hash_code' class is an opaque type representing the hash code for some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">//     data. It is the intended product of hashing, and can be used to implement</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">//     hash tables, checksumming, and other common uses of hashes. It is not an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">//     integer type (although it can be converted to one) because it is risky</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">//     to assume much about the internals of a hash_code. In particular, each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">//     execution of the program has a high probability of producing a different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">//     hash_code for a given input. Thus their values are not stable to save or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">//     persist, and should only be used during the execution for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">//     construction of hashing datastructures.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">//  -- 'hash_value' is a function designed to be overloaded for each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">//     user-defined type which wishes to be used within a hashing context. It</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">//     should be overloaded within the user-defined type's namespace and found</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">//     via ADL. Overloads for primitive types are provided by this library.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">//  -- 'hash_combine' and 'hash_combine_range' are functions designed to aid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">//      programmers in easily and intuitively combining a set of data into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">//      a single hash_code for their object. They should only logically be used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">//      within the implementation of a 'hash_value' routine or similar context.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">// Note that 'hash_combine_range' contains very special logic for hashing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">// a contiguous array of integers or pointers. This logic is *extremely* fast,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">// on a modern Intel "Gainestown" Xeon (Nehalem uarch) @2.2 GHz, these were</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">// benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">// under 32-bytes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#ifndef LLVM_ADT_HASHING_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">#define LLVM_ADT_HASHING_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">#include "llvm/Support/DataTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">#include "llvm/Support/SwapByteOrder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">#include "llvm/Support/type_traits.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">#include <cstring></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">#include <optional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">#include <string></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">#include <tuple></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">template <typename T, typename Enable> struct DenseMapInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">/// An opaque object representing a hash code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">/// This object represents the result of hashing some entity. It is intended to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">/// be used to implement hashtables or other hashing-based data structures.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">/// While it wraps and exposes a numeric value, this value should not be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">/// trusted to be stable or predictable across processes or executions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">/// In order to obtain the hash_code for an object 'x':</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">/// \code</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">///   using llvm::hash_value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">///   llvm::hash_code code = hash_value(x);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">/// \endcode</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">class hash_code {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">  size_t value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">  /// Default construct a hash_code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">  /// Note that this leaves the value uninitialized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">  hash_code() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">  /// Form a hash code directly from a numerical value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="coveredLine">  hash_code(size_t value) : value(value) {}</td>
    <td>1699</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">  /// Convert the hash code to its numerical value for use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="coveredLine">  /*explicit*/ operator size_t() const { return value; }</td>
    <td>1689</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">  friend bool operator==(const hash_code &lhs, const hash_code &rhs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">    return lhs.value == rhs.value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">  friend bool operator!=(const hash_code &lhs, const hash_code &rhs) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">    return lhs.value != rhs.value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">  /// Allow a hash_code to be directly run through hash_value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="coveredLine">  friend size_t hash_value(const hash_code &code) { return code.value; }</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">/// Compute a hash_code for any integer value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">/// Note that this function is intended to compute the same hash_code for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">/// a particular value without regard to the pre-promotion type. This is in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">/// contrast to hash_combine which may produce different hash_codes for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">/// differing argument types even if they would implicit promote to a common</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">/// type without changing the value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">/// Compute a hash_code for a pointer's address.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">/// N.B.: This hashes the *address*. Not the value and not the type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">template <typename T> hash_code hash_value(const T *ptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">/// Compute a hash_code for a pair of objects.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">template <typename T, typename U></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">hash_code hash_value(const std::pair<T, U> &arg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">/// Compute a hash_code for a tuple.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">template <typename... Ts></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">hash_code hash_value(const std::tuple<Ts...> &arg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">/// Compute a hash_code for a standard string.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">hash_code hash_value(const std::basic_string<T> &arg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">/// Compute a hash_code for a standard string.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">template <typename T> hash_code hash_value(const std::optional<T> &arg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">/// Override the execution seed with a fixed value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">/// This hashing library uses a per-execution seed designed to change on each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">/// run with high probability in order to ensure that the hash codes are not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">/// attackable and to ensure that output which is intended to be stable does</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">/// not rely on the particulars of the hash codes produced.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">/// That said, there are use cases where it is important to be able to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">/// reproduce *exactly* a specific behavior. To that end, we provide a function</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">/// which will forcibly set the seed to a fixed value. This must be done at the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">/// start of the program, before any hashes are computed. Also, it cannot be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">/// undone. This makes it thread-hostile and very hard to use outside of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">/// immediately on start of a simple program designed for reproducible</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">/// behavior.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">void set_fixed_execution_hash_seed(uint64_t fixed_value);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">// All of the implementation details of actually computing the various hash</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">// code values are held within this namespace. These routines are included in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">// the header file mainly to allow inlining and constant propagation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">namespace hashing {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="coveredLine">inline uint64_t fetch64(const char *p) {</td>
    <td>15800</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">  uint64_t result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="coveredLine">  memcpy(&result, p, sizeof(result));</td>
    <td>15800</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">  if (sys::IsBigEndianHost)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">    sys::swapByteOrder(result);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="coveredLine">  return result;</td>
    <td>15800</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="coveredLine">inline uint32_t fetch32(const char *p) {</td>
    <td>436</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">  uint32_t result;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="coveredLine">  memcpy(&result, p, sizeof(result));</td>
    <td>436</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">  if (sys::IsBigEndianHost)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">    sys::swapByteOrder(result);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="coveredLine">  return result;</td>
    <td>436</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">/// Some primes between 2^63 and 2^64 for various uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">static constexpr uint64_t k0 = 0xc3a5c85c97cb3127ULL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">static constexpr uint64_t k1 = 0xb492b66fbe98f273ULL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">static constexpr uint64_t k2 = 0x9ae16a3b2f90404fULL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">static constexpr uint64_t k3 = 0xc949d7c7509e6557ULL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="">/// Bitwise right rotate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">/// Normally this will compile to a single instruction, especially if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="">/// shift is a manifest constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="coveredLine">inline uint64_t rotate(uint64_t val, size_t shift) {</td>
    <td>693</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">  // Avoid shifting by 64: doing so yields an undefined result.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="coveredLine">  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));</td>
    <td>693</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="coveredLine">inline uint64_t shift_mix(uint64_t val) {</td>
    <td>1188</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="coveredLine">  return val ^ (val >> 47);</td>
    <td>1188</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="coveredLine">inline uint64_t hash_16_bytes(uint64_t low, uint64_t high) {</td>
    <td>2538</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">  // Murmur-inspired hashing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="coveredLine">  const uint64_t kMul = 0x9ddfea08eb382d69ULL;</td>
    <td>2538</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="coveredLine">  uint64_t a = (low ^ high) * kMul;</td>
    <td>2538</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="coveredLine">  a ^= (a >> 47);</td>
    <td>2538</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="coveredLine">  uint64_t b = (high ^ a) * kMul;</td>
    <td>2538</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="coveredLine">  b ^= (b >> 47);</td>
    <td>2538</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="coveredLine">  b *= kMul;</td>
    <td>2538</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="coveredLine">  return b;</td>
    <td>2538</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="uncoveredLine">inline uint64_t hash_1to3_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="uncoveredLine">  uint8_t a = s[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">  uint8_t b = s[len >> 1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="uncoveredLine">  uint8_t c = s[len - 1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="uncoveredLine">  uint32_t y = static_cast<uint32_t>(a) + (static_cast<uint32_t>(b) << 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="uncoveredLine">  uint32_t z = static_cast<uint32_t>(len) + (static_cast<uint32_t>(c) << 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">  return shift_mix(y * k2 ^ z * k3 ^ seed) * k2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="coveredLine">inline uint64_t hash_4to8_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td>218</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="coveredLine">  uint64_t a = fetch32(s);</td>
    <td>218</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="coveredLine">  return hash_16_bytes(len + (a << 3), seed ^ fetch32(s + len - 4));</td>
    <td>218</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="coveredLine">inline uint64_t hash_9to16_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td>693</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="coveredLine">  uint64_t a = fetch64(s);</td>
    <td>693</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="coveredLine">  uint64_t b = fetch64(s + len - 8);</td>
    <td>693</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="coveredLine">  return hash_16_bytes(seed ^ a, rotate(b + len, len)) ^ b;</td>
    <td>693</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="coveredLine">inline uint64_t hash_17to32_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td>317</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="coveredLine">  uint64_t a = fetch64(s) * k1;</td>
    <td>317</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="coveredLine">  uint64_t b = fetch64(s + 8);</td>
    <td>317</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="coveredLine">  uint64_t c = fetch64(s + len - 8) * k2;</td>
    <td>317</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="coveredLine">  uint64_t d = fetch64(s + len - 16) * k0;</td>
    <td>317</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="coveredLine">  return hash_16_bytes(llvm::rotr<uint64_t>(a - b, 43) +</td>
    <td>317</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="coveredLine">                           llvm::rotr<uint64_t>(c ^ seed, 30) + d,</td>
    <td>317</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="coveredLine">                       a + llvm::rotr<uint64_t>(b ^ k3, 20) - c + len + seed);</td>
    <td>634</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="coveredLine">inline uint64_t hash_33to64_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="coveredLine">  uint64_t z = fetch64(s + 24);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="coveredLine">  uint64_t a = fetch64(s) + (len + fetch64(s + len - 16)) * k0;</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="coveredLine">  uint64_t b = llvm::rotr<uint64_t>(a + z, 52);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="coveredLine">  uint64_t c = llvm::rotr<uint64_t>(a, 37);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="coveredLine">  a += fetch64(s + 8);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="coveredLine">  c += llvm::rotr<uint64_t>(a, 7);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="coveredLine">  a += fetch64(s + 16);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="coveredLine">  uint64_t vf = a + z;</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="coveredLine">  uint64_t vs = b + llvm::rotr<uint64_t>(a, 31) + c;</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="coveredLine">  a = fetch64(s + 16) + fetch64(s + len - 32);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="coveredLine">  z = fetch64(s + len - 8);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="coveredLine">  b = llvm::rotr<uint64_t>(a + z, 52);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="coveredLine">  c = llvm::rotr<uint64_t>(a, 37);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="coveredLine">  a += fetch64(s + len - 24);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="coveredLine">  c += llvm::rotr<uint64_t>(a, 7);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="coveredLine">  a += fetch64(s + len - 16);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="coveredLine">  uint64_t wf = a + z;</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="coveredLine">  uint64_t ws = b + llvm::rotr<uint64_t>(a, 31) + c;</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="coveredLine">  uint64_t r = shift_mix((vf + ws) * k2 + (wf + vs) * k0);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="coveredLine">  return shift_mix((seed ^ (r * k0)) + vs) * k2;</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="coveredLine">inline uint64_t hash_short(const char *s, size_t length, uint64_t seed) {</td>
    <td>1433</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="coveredLine">  if (length >= 4 && length <= 8)</td>
    <td>1433</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="coveredLine">    return hash_4to8_bytes(s, length, seed);</td>
    <td>218</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="coveredLine">  if (length > 8 && length <= 16)</td>
    <td>1215</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="coveredLine">    return hash_9to16_bytes(s, length, seed);</td>
    <td>693</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="coveredLine">  if (length > 16 && length <= 32)</td>
    <td>522</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="coveredLine">    return hash_17to32_bytes(s, length, seed);</td>
    <td>317</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="coveredLine">  if (length > 32)</td>
    <td>205</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="coveredLine">    return hash_33to64_bytes(s, length, seed);</td>
    <td>201</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="coveredLine">  if (length != 0)</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">    return hash_1to3_bytes(s, length, seed);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="coveredLine">  return k2 ^ seed;</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">/// The intermediate state used during hashing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">/// Currently, the algorithm for computing hash codes is based on CityHash and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="">/// keeps 56 bytes of arbitrary state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">struct hash_state {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">  uint64_t h0 = 0, h1 = 0, h2 = 0, h3 = 0, h4 = 0, h5 = 0, h6 = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">  /// Create a new hash_state structure and initialize it based on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">  /// seed and the first 64-byte chunk.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">  /// This effectively performs the initial mix.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="coveredLine">  static hash_state create(const char *s, uint64_t seed) {</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="coveredLine">    hash_state state = {0,</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">                        seed,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="coveredLine">                        hash_16_bytes(seed, k1),</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="coveredLine">                        llvm::rotr<uint64_t>(seed ^ k1, 49),</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="coveredLine">                        seed * k1,</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="coveredLine">                        shift_mix(seed),</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="coveredLine">                        0};</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="coveredLine">    state.h6 = hash_16_bytes(state.h4, state.h5);</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="coveredLine">    state.mix(s);</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="coveredLine">    return state;</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  /// Mix 32-bytes from the input sequence into the 16-bytes of 'a'</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">  /// and 'b', including whatever is already in 'a' and 'b'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="coveredLine">  static void mix_32_bytes(const char *s, uint64_t &a, uint64_t &b) {</td>
    <td>1856</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="coveredLine">    a += fetch64(s);</td>
    <td>1856</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="coveredLine">    uint64_t c = fetch64(s + 24);</td>
    <td>1856</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="coveredLine">    b = llvm::rotr<uint64_t>(b + a + c, 21);</td>
    <td>1856</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="coveredLine">    uint64_t d = a;</td>
    <td>1856</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="coveredLine">    a += fetch64(s + 8) + fetch64(s + 16);</td>
    <td>1856</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="coveredLine">    b += llvm::rotr<uint64_t>(a, 44) + d;</td>
    <td>1856</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="coveredLine">    a += c;</td>
    <td>1856</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="coveredLine">  }</td>
    <td>1856</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">  /// Mix in a 64-byte buffer of data.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">  /// We mix all 64 bytes even when the chunk length is smaller, but we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">  /// record the actual length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="coveredLine">  void mix(const char *s) {</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="coveredLine">    h0 = llvm::rotr<uint64_t>(h0 + h1 + h3 + fetch64(s + 8), 37) * k1;</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="coveredLine">    h1 = llvm::rotr<uint64_t>(h1 + h4 + fetch64(s + 48), 42) * k1;</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="coveredLine">    h0 ^= h6;</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="coveredLine">    h1 += h3 + fetch64(s + 40);</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="coveredLine">    h2 = llvm::rotr<uint64_t>(h2 + h5, 33) * k1;</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="coveredLine">    h3 = h4 * k1;</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="coveredLine">    h4 = h0 + h5;</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="coveredLine">    mix_32_bytes(s, h3, h4);</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="coveredLine">    h5 = h2 + h6;</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="coveredLine">    h6 = h1 + fetch64(s + 16);</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="coveredLine">    mix_32_bytes(s + 32, h5, h6);</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="coveredLine">    std::swap(h2, h0);</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="coveredLine">  }</td>
    <td>928</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">  /// Compute the final 64-bit hash code value based on the current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">  /// state and the length of bytes hashed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="coveredLine">  uint64_t finalize(size_t length) {</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="coveredLine">    return hash_16_bytes(hash_16_bytes(h3, h5) + shift_mix(h1) * k1 + h2,</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="coveredLine">                         hash_16_bytes(h4, h6) + shift_mix(length) * k1 + h0);</td>
    <td>524</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">/// A global, fixed seed-override variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">/// This variable can be set using the \see llvm::set_fixed_execution_seed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">/// function. See that function for details. Do not, under any circumstances,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">/// set or read this variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">extern uint64_t fixed_seed_override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="coveredLine">inline uint64_t get_execution_seed() {</td>
    <td>1695</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">  // FIXME: This needs to be a per-execution seed. This is just a placeholder</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">  // implementation. Switching to a per-execution seed is likely to flush out</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">  // instability bugs and so will happen as its own commit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">  // However, if there is a fixed seed override set the first time this is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">  // called, return that instead of the per-execution seed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="coveredLine">  const uint64_t seed_prime = 0xff51afd7ed558ccdULL;</td>
    <td>1695</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="coveredLine">  static uint64_t seed = fixed_seed_override ? fixed_seed_override : seed_prime;</td>
    <td>1695</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="coveredLine">  return seed;</td>
    <td>1695</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">/// Trait to indicate whether a type's bits can be hashed directly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">/// A type trait which is true if we want to combine values for hashing by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">/// reading the underlying data. It is false if values of this type must</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">/// first be passed to hash_value, and the resulting hash_codes combined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">// FIXME: We want to replace is_integral_or_enum and is_pointer here with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">// a predicate which asserts that comparing the underlying storage of two</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">// values of the type for equality is equivalent to comparing the two values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">// for equality. For all the platforms we care about, this holds for integers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">// and pointers, but there are platforms where it doesn't and we would like to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">// support user-defined types which happen to satisfy this property.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">template <typename T> struct is_hashable_data</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">  : std::integral_constant<bool, ((is_integral_or_enum<T>::value ||</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">                                   std::is_pointer<T>::value) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">                                  64 % sizeof(T) == 0)> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">// Special case std::pair to detect when both types are viable and when there</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">// is no alignment-derived padding in the pair. This is a bit of a lie because</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">// std::pair isn't truly POD, but it's close enough in all reasonable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">// implementations for our use case of hashing the underlying data.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="">template <typename T, typename U> struct is_hashable_data<std::pair<T, U> ></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">  : std::integral_constant<bool, (is_hashable_data<T>::value &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">                                  is_hashable_data<U>::value &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">                                  (sizeof(T) + sizeof(U)) ==</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">                                   sizeof(std::pair<T, U>))> {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">/// Helper to get the hashable data representation for a type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="">/// This variant is enabled when the type itself can be used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">std::enable_if_t<is_hashable_data<T>::value, T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="coveredLine">get_hashable_data(const T &value) {</td>
    <td>105</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="coveredLine">  return value;</td>
    <td>105</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="">/// Helper to get the hashable data representation for a type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">/// This variant is enabled when we must first call hash_value and use the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">/// result as our data.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">std::enable_if_t<!is_hashable_data<T>::value, size_t></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="coveredLine">get_hashable_data(const T &value) {</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">  using ::llvm::hash_value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="coveredLine">  return hash_value(value);</td>
    <td>6</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">/// Helper to store data from a value into a buffer and advance the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">/// pointer into that buffer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">/// This routine first checks whether there is enough space in the provided</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">/// buffer, and if not immediately returns false. If there is space, it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">/// copies the underlying bytes of value into the buffer, advances the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="">/// buffer_ptr past the copied bytes, and returns true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="coveredLine">bool store_and_advance(char *&buffer_ptr, char *buffer_end, const T& value,</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">                       size_t offset = 0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="coveredLine">  size_t store_size = sizeof(value) - offset;</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="coveredLine">  if (buffer_ptr + store_size > buffer_end)</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="coveredLine">  const char *value_data = reinterpret_cast<const char *>(&value);</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="coveredLine">  memcpy(buffer_ptr, value_data + offset, store_size);</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="coveredLine">  buffer_ptr += store_size;</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="coveredLine">  return true;</td>
    <td>26</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">/// Implement the combining of integral values into a hash_code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">/// This overload is selected when the value type of the iterator is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">/// integral. Rather than computing a hash_code for each object and then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">/// combining them, this (as an optimization) directly combines the integers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">template <typename InputIteratorT></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="coveredLine">hash_code hash_combine_range_impl(InputIteratorT first, InputIteratorT last) {</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="coveredLine">  const uint64_t seed = get_execution_seed();</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="coveredLine">  char buffer[64], *buffer_ptr = buffer;</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="coveredLine">  char *const buffer_end = std::end(buffer);</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="coveredLine">  while (first != last && store_and_advance(buffer_ptr, buffer_end,</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="coveredLine">                                            get_hashable_data(*first)))</td>
    <td>21</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="coveredLine">    ++first;</td>
    <td>9</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="coveredLine">  if (first == last)</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="coveredLine">    return hash_short(buffer, buffer_ptr - buffer, seed);</td>
    <td>3</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="uncoveredLine">  assert(buffer_ptr == buffer_end);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="uncoveredLine">  hash_state state = state.create(buffer, seed);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">  size_t length = 64;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">  while (first != last) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">    // Fill up the buffer. We don't clear it, which re-mixes the last round</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">    // when only a partial 64-byte chunk is left.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="uncoveredLine">    buffer_ptr = buffer;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="uncoveredLine">    while (first != last && store_and_advance(buffer_ptr, buffer_end,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="uncoveredLine">                                              get_hashable_data(*first)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="uncoveredLine">      ++first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">    // Rotate the buffer if we did a partial fill in order to simulate doing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">    // a mix of the last 64-bytes. That is how the algorithm works when we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">    // have a contiguous byte sequence, and we want to emulate that here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">    std::rotate(buffer, buffer_ptr, buffer_end);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">    // Mix this chunk into the current state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="uncoveredLine">    state.mix(buffer);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">    length += buffer_ptr - buffer;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="uncoveredLine">  return state.finalize(length);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">/// Implement the combining of integral values into a hash_code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">/// This overload is selected when the value type of the iterator is integral</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">/// and when the input iterator is actually a pointer. Rather than computing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">/// a hash_code for each object and then combining them, this (as an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">/// optimization) directly combines the integers. Also, because the integers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">/// are stored in contiguous memory, this routine avoids copying each value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">/// and directly reads from the underlying memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">template <typename ValueT></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">std::enable_if_t<is_hashable_data<ValueT>::value, hash_code></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="coveredLine">hash_combine_range_impl(ValueT *first, ValueT *last) {</td>
    <td>1627</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="coveredLine">  const uint64_t seed = get_execution_seed();</td>
    <td>1627</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="coveredLine">  const char *s_begin = reinterpret_cast<const char *>(first);</td>
    <td>1627</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="coveredLine">  const char *s_end = reinterpret_cast<const char *>(last);</td>
    <td>1627</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="coveredLine">  const size_t length = std::distance(s_begin, s_end);</td>
    <td>1627</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="coveredLine">  if (length <= 64)</td>
    <td>1627</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="coveredLine">    return hash_short(s_begin, length, seed);</td>
    <td>1365</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="coveredLine">  const char *s_aligned_end = s_begin + (length & ~63);</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="coveredLine">  hash_state state = state.create(s_begin, seed);</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="coveredLine">  s_begin += 64;</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="coveredLine">  while (s_begin != s_aligned_end) {</td>
    <td>666</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="coveredLine">    state.mix(s_begin);</td>
    <td>404</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="coveredLine">    s_begin += 64;</td>
    <td>404</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="coveredLine">  if (length & 63)</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="coveredLine">    state.mix(s_end - 64);</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="coveredLine">  return state.finalize(length);</td>
    <td>262</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">} // namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">} // namespace hashing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">/// Compute a hash_code for a sequence of values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">/// This hashes a sequence of values. It produces the same hash_code as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">/// 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="">/// and is significantly faster given pointers and types which can be hashed as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">/// a sequence of bytes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">template <typename InputIteratorT></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="coveredLine">hash_code hash_combine_range(InputIteratorT first, InputIteratorT last) {</td>
    <td>1617</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="coveredLine">  return ::llvm::hashing::detail::hash_combine_range_impl(first, last);</td>
    <td>1617</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">// Implementation details for hash_combine.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">namespace hashing {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">/// Helper class to manage the recursive combining of hash_combine</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">/// arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">/// This class exists to manage the state and various calls involved in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">/// recursive combining of arguments used in hash_combine. It is particularly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">/// useful at minimizing the code in the recursive calls to ease the pain</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">/// caused by a lack of variadic functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">struct hash_combine_recursive_helper {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="">  char buffer[64] = {};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">  hash_state state;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">  const uint64_t seed;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">  /// Construct a recursive hash combining helper.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">  /// This sets up the state for a recursive hash combine, including getting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">  /// the seed and buffer setup.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="coveredLine">  hash_combine_recursive_helper()</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="coveredLine">    : seed(get_execution_seed()) {}</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">  /// Combine one chunk of data into the current in-flight hash.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">  /// This merges one chunk of data into the hash. First it tries to buffer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">  /// the data. If the buffer is full, it hashes the buffer into its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">  /// hash_state, empties it, and then merges the new chunk in. This also</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">  /// handles cases where the data straddles the end of the buffer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">  template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="coveredLine">  char *combine_data(size_t &length, char *buffer_ptr, char *buffer_end, T data) {</td>
    <td>92</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="coveredLine">    if (!store_and_advance(buffer_ptr, buffer_end, data)) {</td>
    <td>92</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">      // Check for skew which prevents the buffer from being packed, and do</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">      // a partial store into the buffer to fill it. This is only a concern</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">      // with the variadic combine because that formation can have varying</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">      // argument types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">      size_t partial_store_size = buffer_end - buffer_ptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="uncoveredLine">      memcpy(buffer_ptr, &data, partial_store_size);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">      // If the store fails, our buffer is full and ready to hash. We have to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">      // either initialize the hash state (on the first full buffer) or mix</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">      // this buffer into the existing hash state. Length tracks the *hashed*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">      // length, not the buffered length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="uncoveredLine">      if (length == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">        state = state.create(buffer, seed);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="uncoveredLine">        length = 64;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">        // Mix this chunk into the current state and bump length up by 64.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">        state.mix(buffer);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="uncoveredLine">        length += 64;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">      // Reset the buffer_ptr to the head of the buffer for the next chunk of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">      // data.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="uncoveredLine">      buffer_ptr = buffer;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">      // Try again to store into the buffer -- this cannot fail as we only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">      // store types smaller than the buffer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="uncoveredLine">      if (!store_and_advance(buffer_ptr, buffer_end, data,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">                             partial_store_size))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="uncoveredLine">        llvm_unreachable("buffer smaller than stored type");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="coveredLine">    return buffer_ptr;</td>
    <td>92</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">  /// Recursive, variadic combining method.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">  /// This function recurses through each argument, combining that argument</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">  /// into a single hash.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">  template <typename T, typename ...Ts></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="coveredLine">  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end,</td>
    <td>7</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">                    const T &arg, const Ts &...args) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="coveredLine">    buffer_ptr = combine_data(length, buffer_ptr, buffer_end, get_hashable_data(arg));</td>
    <td>7</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">    // Recurse to the next argument.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="coveredLine">    return combine(length, buffer_ptr, buffer_end, args...);</td>
    <td>7</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">  /// Base case for recursive, variadic combining.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">  /// The base case when combining arguments recursively is reached when all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">  /// arguments have been handled. It flushes the remaining buffer and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">  /// constructs a hash_code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="coveredLine">  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end) {</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">    // Check whether the entire set of values fit in the buffer. If so, we'll</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">    // use the optimized short hashing routine and skip state entirely.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="coveredLine">    if (length == 0)</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="coveredLine">      return hash_short(buffer, buffer_ptr - buffer, seed);</td>
    <td>59</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">    // Mix the final buffer, rotating it if we did a partial fill in order to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">    // simulate doing a mix of the last 64-bytes. That is how the algorithm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">    // works when we have a contiguous byte sequence, and we want to emulate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">    // that here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="uncoveredLine">    std::rotate(buffer, buffer_ptr, buffer_end);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">    // Mix this chunk into the current state.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="uncoveredLine">    state.mix(buffer);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">    length += buffer_ptr - buffer;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="uncoveredLine">    return state.finalize(length);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">} // namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">} // namespace hashing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">/// Combine values into a single hash_code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">/// This routine accepts a varying number of arguments of any type. It will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">/// attempt to combine them into a single hash_code. For user-defined types it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">/// attempts to call a \see hash_value overload (via ADL) for the type. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="">/// integer and pointer types it directly combines their data into the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="">/// resulting hash_code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">/// The result is suitable for returning from a user's hash_value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">/// *implementation* for their user-defined type. Consumers of a type should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">/// *not* call this routine, they should instead call 'hash_value'.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="coveredLine">template <typename ...Ts> hash_code hash_combine(const Ts &...args) {</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">  // Recursively hash each argument using a helper class.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="coveredLine">  ::llvm::hashing::detail::hash_combine_recursive_helper helper;</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="coveredLine">  return helper.combine(0, helper.buffer, helper.buffer + 64, args...);</td>
    <td>10</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">// Implementation details for implementations of hash_value overloads provided</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">// here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">namespace hashing {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">namespace detail {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">/// Helper to hash the value of a single integer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">/// Overloads for smaller integer types are not provided to ensure consistent</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">/// behavior in the presence of integral promotions. Essentially,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="">/// "hash_value('4')" and "hash_value('0' + 4)" should be the same.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">inline hash_code hash_integer_value(uint64_t value) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">  // Similar to hash_4to8_bytes but using a seed instead of length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">  const uint64_t seed = get_execution_seed();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">  const char *s = reinterpret_cast<const char *>(&value);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">  const uint64_t a = fetch32(s);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">  return hash_16_bytes(seed + (a << 3), fetch32(s + 4));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">} // namespace detail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">} // namespace hashing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">// Declared and documented above, but defined here so that any of the hashing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">// infrastructure is available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">  return ::llvm::hashing::detail::hash_integer_value(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">      static_cast<uint64_t>(value));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">// Declared and documented above, but defined here so that any of the hashing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">// infrastructure is available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">template <typename T> hash_code hash_value(const T *ptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">  return ::llvm::hashing::detail::hash_integer_value(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">    reinterpret_cast<uintptr_t>(ptr));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="">// Declared and documented above, but defined here so that any of the hashing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">// infrastructure is available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">template <typename T, typename U></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">hash_code hash_value(const std::pair<T, U> &arg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">  return hash_combine(arg.first, arg.second);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">template <typename... Ts> hash_code hash_value(const std::tuple<Ts...> &arg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="">  return std::apply([](const auto &...xs) { return hash_combine(xs...); }, arg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">// Declared and documented above, but defined here so that any of the hashing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">// infrastructure is available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="">hash_code hash_value(const std::basic_string<T> &arg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">  return hash_combine_range(arg.begin(), arg.end());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">template <typename T> hash_code hash_value(const std::optional<T> &arg) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">  return arg ? hash_combine(true, *arg) : hash_value(false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">template <> struct DenseMapInfo<hash_code, void> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="">  static inline hash_code getEmptyKey() { return hash_code(-1); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">  static inline hash_code getTombstoneKey() { return hash_code(-2); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">  static unsigned getHashValue(hash_code val) { return val; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">  static bool isEqual(hash_code LHS, hash_code RHS) { return LHS == RHS; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="">} // namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm9hash_codeC2Em</td>
    <td class="numberOfCalls">1699</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm9hash_codecvmEv</td>
    <td class="numberOfCalls">1689</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm10hash_valueERKNS_9hash_codeE</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail7fetch64EPKc</td>
    <td class="numberOfCalls">15800</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail7fetch32EPKc</td>
    <td class="numberOfCalls">436</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail6rotateEmm</td>
    <td class="numberOfCalls">693</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail9shift_mixEm</td>
    <td class="numberOfCalls">1188</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail13hash_16_bytesEmm</td>
    <td class="numberOfCalls">2538</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail15hash_1to3_bytesEPKcmm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail15hash_4to8_bytesEPKcmm</td>
    <td class="numberOfCalls">218</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail16hash_9to16_bytesEPKcmm</td>
    <td class="numberOfCalls">693</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17hash_17to32_bytesEPKcmm</td>
    <td class="numberOfCalls">317</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17hash_33to64_bytesEPKcmm</td>
    <td class="numberOfCalls">201</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail10hash_shortEPKcmm</td>
    <td class="numberOfCalls">1433</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail10hash_state6createEPKcm</td>
    <td class="numberOfCalls">262</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail10hash_state12mix_32_bytesEPKcRmS5_</td>
    <td class="numberOfCalls">1856</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail10hash_state3mixEPKc</td>
    <td class="numberOfCalls">928</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail10hash_state8finalizeEm</td>
    <td class="numberOfCalls">262</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail18get_execution_seedEv</td>
    <td class="numberOfCalls">1695</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIbEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES5_E4typeERKS5_</td>
    <td class="numberOfCalls">36</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPKNS_4TypeEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES8_E4typeERKS8_</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataINS_9StringRefEEENSt9enable_ifIXntsrNS1_16is_hashable_dataIT_EE5valueEmE4typeERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataINS_9hash_codeEEENSt9enable_ifIXntsrNS1_16is_hashable_dataIT_EE5valueEmE4typeERKS6_</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPKNS_4TypeEEEbRPcS6_RKT_m</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIbEEbRPcS3_RKT_m</td>
    <td class="numberOfCalls">36</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceImEEbRPcS3_RKT_m</td>
    <td class="numberOfCalls">17</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail23hash_combine_range_implIKPNS_4TypeEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS8_SD_</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail23hash_combine_range_implIKjEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS6_SB_</td>
    <td class="numberOfCalls">791</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18hash_combine_rangeIPKjEENS_9hash_codeET_S4_</td>
    <td class="numberOfCalls">791</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18hash_combine_rangeIPKPNS_4TypeEEENS_9hash_codeET_S6_</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helperC2Ev</td>
    <td class="numberOfCalls">59</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataImEEPcRmS4_S4_T_</td>
    <td class="numberOfCalls">17</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPKNS_4TypeEEEPcRmS7_S7_T_</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIbEEPcRmS4_S4_T_</td>
    <td class="numberOfCalls">36</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJbEEES4_mPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPKNS_4TypeEJNS_9hash_codeEbEEES7_mPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9StringRefEJNS_9hash_codeES5_EEES5_mPcS6_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIbJEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">36</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJS4_EEES4_mPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJEEES4_mPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineEmPcS3_</td>
    <td class="numberOfCalls">59</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_9hash_codeEbEEES1_DpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPKNS_4TypeENS_9hash_codeEbEEES4_DpRKT_</td>
    <td class="numberOfCalls">6</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_9StringRefENS_9hash_codeES2_EEES2_DpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIjEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES5_E4typeERKS5_</td>
    <td class="numberOfCalls">92</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIhEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES5_E4typeERKS5_</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPNS_9ArrayTypeEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES7_E4typeERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataItEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES5_E4typeERKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPNS_10StructTypeEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES7_E4typeERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPNS_10VectorTypeEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES7_E4typeERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPNS_4TypeEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES7_E4typeERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPNS_4TypeEEEbRPcS5_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPNS_10VectorTypeEEEbRPcS5_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPNS_10StructTypeEEEbRPcS5_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPNS_9ArrayTypeEEEbRPcS5_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIjEEbRPcS3_RKT_m</td>
    <td class="numberOfCalls">92</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIhEEbRPcS3_RKT_m</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceItEEbRPcS3_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail23hash_combine_range_implIKiEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS6_SB_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail23hash_combine_range_implIKPNS_8ConstantEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS8_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18hash_combine_rangeIPKiEENS_9hash_codeET_S4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18hash_combine_rangeIPKPNS_8ConstantEEENS_9hash_codeET_S6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataItEEPcRmS4_S4_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPNS_9ArrayTypeEEEPcRmS6_S6_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPNS_10StructTypeEEEPcRmS6_S6_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPNS_10VectorTypeEEEPcRmS6_S6_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPNS_4TypeEEEPcRmS6_S6_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIhEEPcRmS4_S4_T_</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIjEEPcRmS4_S4_T_</td>
    <td class="numberOfCalls">92</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJPNS_4TypeEEEES4_mPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_4TypeEJEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJS4_PNS_4TypeEEEES4_mPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineItJNS_9hash_codeES4_PNS_4TypeEEEES4_mPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_4TypeEJjEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_10VectorTypeEJjEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_10StructTypeEJjEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_9ArrayTypeEJjEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIhJhtNS_9hash_codeES4_PNS_4TypeEEEES4_mPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIhJtNS_9hash_codeES4_PNS_4TypeEEEES4_mPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_10VectorTypeEjEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJhhtNS_9hash_codeES1_PNS_4TypeEEEES1_DpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_4TypeEjEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_9ArrayTypeEjEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_10StructTypeEjEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIlEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES5_E4typeERKS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPNS_8MDStringEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES7_E4typeERKS7_</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPNS_8MetadataEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES7_E4typeERKS7_</td>
    <td class="numberOfCalls">84</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIiEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES5_E4typeERKS5_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataImEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES5_E4typeERKS5_</td>
    <td class="numberOfCalls">11</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataINS_5APIntEEENSt9enable_ifIXntsrNS1_16is_hashable_dataIT_EE5valueEmE4typeERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPNS_8MDStringEEEbRPcS5_RKT_m</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPNS_8MetadataEEEbRPcS5_RKT_m</td>
    <td class="numberOfCalls">84</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIlEEbRPcS3_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIiEEbRPcS3_RKT_m</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail23hash_combine_range_implIKmEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS6_SB_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail23hash_combine_range_implIKPNS_15ValueAsMetadataEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS8_SD_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18hash_combine_rangeIPKPNS_15ValueAsMetadataEEENS_9hash_codeET_S6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18hash_combine_rangeIPKmEENS_9hash_codeET_S4_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPNS_8MetadataEEEPcRmS6_S6_T_</td>
    <td class="numberOfCalls">84</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPNS_8MDStringEEEPcRmS6_S6_T_</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIiEEPcRmS4_S4_T_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIlEEPcRmS4_S4_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJPNS_8MetadataEjS7_S7_S7_S7_S7_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MDStringEmjjEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MDStringEPNS_8MetadataEjS7_S7_jEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJPNS_8MetadataEEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MDStringEPNS_8MetadataEjEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIlJPNS_8MetadataES5_S5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJhPNS_8MetadataEEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJPNS_8MetadataES7_S7_jEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJS5_jjEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJS5_jEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJPNS_8MDStringEEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJS5_PNS_8MDStringES5_jEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJPNS_8MDStringES7_S7_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJPNS_8MetadataEbEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MDStringEPNS_8MetadataEbS7_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJPNS_8MDStringES7_S5_jS5_bbS5_S5_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJPNS_8MDStringES5_jS5_jjS5_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MetadataEjjS5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIbJbPNS_8MetadataES5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MetadataEEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJjPNS_8MetadataEEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJbbS5_S5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MDStringEPNS_8MetadataEEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJjPNS_8MetadataEEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJjjS5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MetadataEbbS5_S5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJjPNS_8MDStringES5_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJS5_jPNS_8MetadataEEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_5APIntEJPNS_8MDStringEEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJjS5_bbS5_S5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIbJPNS_8MetadataEEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJS5_S5_S5_S5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MetadataES5_jEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJS5_jPNS_8MDStringES5_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MDStringES5_jPNS_8MetadataEEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJjPNS_8MetadataES5_bEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">30</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJjPNS_8MDStringEEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJS5_iS5_S5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJS5_S5_S5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJS5_PNS_8MetadataEjS7_bbS7_S7_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJjS5_S5_S5_S5_S5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIhJPNS_8MetadataEEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJiS5_S5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJS5_S5_jEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJjjEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJjEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJPNS_8MDStringES5_jEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJS5_S5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJbEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">30</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJPNS_8MetadataEbS7_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJjS5_jjS5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJPNS_8MetadataEjS7_jjS7_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJjEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJjPNS_8MDStringES7_jS5_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJS5_S5_jPNS_8MDStringES5_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MDStringES5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MetadataES5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJjS5_S5_jEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineImJjjEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJS5_bEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">30</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJjEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJPNS_8MetadataEjEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJmjjEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIiJPNS_8MDStringES5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJS5_S5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJS5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MDStringEEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MetadataES5_bEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">30</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">9</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJbS5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJPNS_8MetadataEjS7_bbS7_S7_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIbJPNS_8MetadataES5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJjPNS_8MetadataES5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJjPNS_8MDStringES5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MetadataES5_S5_jPNS_8MDStringES5_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJPNS_8MetadataEjS5_S5_jS7_EEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJS5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MetadataEJPNS_8MDStringEjEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MDStringEJPNS_8MetadataEjS7_S7_jEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MetadataES5_S5_S5_S5_EEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MetadataES2_jEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjjPNS_8MetadataES2_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjjPNS_8MDStringES2_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjPNS_8MetadataES2_S2_jPNS_8MDStringES2_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MDStringEPNS_8MetadataEjS2_S2_jS4_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MetadataES2_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MetadataEPNS_8MDStringEjEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MetadataEPNS_8MDStringES2_jS2_jjS2_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">5</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MetadataEPNS_8MDStringES4_S2_jS2_bbS2_S2_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjPNS_8MDStringEPNS_8MetadataEbS4_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MDStringEPNS_8MetadataEbEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MetadataEPNS_8MDStringES4_S4_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MetadataES2_PNS_8MDStringES2_jEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MetadataEPNS_8MDStringEEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjhPNS_8MetadataEEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">4</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MetadataES2_jjEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MDStringEPNS_8MetadataES4_S4_jEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MDStringES2_iS2_S2_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjjPNS_8MetadataES2_bEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">30</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjjPNS_8MDStringEEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJlPNS_8MetadataES2_S2_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MetadataES2_S2_S2_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_5APIntEPNS_8MDStringEEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjPNS_8MDStringEmjjEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">1</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjPNS_8MDStringEPNS_8MetadataEjEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MDStringEPNS_8MetadataEEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjPNS_8MDStringEPNS_8MetadataEjS4_S4_jEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJPNS_8MDStringEPNS_8MetadataEjS4_S4_S4_S4_S4_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPKNS_8MetadataEEEbRPcS6_RKT_m</td>
    <td class="numberOfCalls">9</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail23hash_combine_range_implIPKNS_9MDOperandEEENS_9hash_codeET_S7_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail23hash_combine_range_implIKPNS_8MetadataEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS8_SD_</td>
    <td class="numberOfCalls">13</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18hash_combine_rangeIPKNS_9MDOperandEEENS_9hash_codeET_S5_</td>
    <td class="numberOfCalls">3</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18hash_combine_rangeIPKPNS_8MetadataEEENS_9hash_codeET_S6_</td>
    <td class="numberOfCalls">13</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPKNS_10ConstantFPEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES8_E4typeERKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPNS_17MachineBasicBlockEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES7_E4typeERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataINS_14MachineOperand18MachineOperandTypeEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES7_E4typeERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPKNS_11GlobalValueEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES8_E4typeERKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPKNS_12BlockAddressEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES8_E4typeERKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPKNS_11ConstantIntEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES8_E4typeERKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPKNS_6MDNodeEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES8_E4typeERKS8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPNS_8MCSymbolEEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES7_E4typeERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataINS_8ArrayRefIiEEEENSt9enable_ifIXntsrNS1_16is_hashable_dataIT_EE5valueEmE4typeERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceINS_14MachineOperand18MachineOperandTypeEEEbRPcS5_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPKNS_11ConstantIntEEEbRPcS6_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPKNS_10ConstantFPEEEbRPcS6_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPNS_17MachineBasicBlockEEEbRPcS5_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPKNS_11GlobalValueEEEbRPcS6_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPKNS_12BlockAddressEEEbRPcS6_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPKNS_6MDNodeEEEbRPcS6_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPNS_8MCSymbolEEEbRPcS5_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPKNS_11ConstantIntEEEPcRmS7_S7_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataINS_14MachineOperand18MachineOperandTypeEEEPcRmS6_S6_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPKNS_10ConstantFPEEEPcRmS7_S7_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPNS_17MachineBasicBlockEEEPcRmS6_S6_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPKNS_11GlobalValueEEEPcRmS7_S7_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPKNS_12BlockAddressEEEPcRmS7_S7_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPKNS_6MDNodeEEEPcRmS7_S7_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPNS_8MCSymbolEEEPcRmS6_S6_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjPKNS_10ConstantFPEEEENS_9hash_codeEmPcSA_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjmEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjPKNS_12BlockAddressElEEENS_9hash_codeEmPcSA_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjPKNS_11GlobalValueElEEENS_9hash_codeEmPcSA_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjlNS_9StringRefEEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjilEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjiEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjPNS_17MachineBasicBlockEEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_17MachineBasicBlockEJEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjPKNS_11ConstantIntEEEENS_9hash_codeEmPcSA_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjlEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjjbEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPKNS_12BlockAddressEJlEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineImJEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPKNS_6MDNodeEJEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPNS_8MCSymbolEJEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_8ArrayRefIiEEJEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9StringRefEJEEENS_9hash_codeEmPcS6_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPKNS_6MDNodeEEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPKNS_10ConstantFPEEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_17MachineBasicBlockEEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJiEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJilEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJlNS_9StringRefEEEENS_9hash_codeEmPcS6_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPKNS_11GlobalValueElEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPKNS_12BlockAddressElEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJmEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjPNS_8MCSymbolEEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPNS_8MCSymbolEEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJNS_8ArrayRefIiEEEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIiJlEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIiJEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJbEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIlJEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPKNS_11ConstantIntEJEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPKNS_10ConstantFPEJEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjPKNS_6MDNodeEEEENS_9hash_codeEmPcSA_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjjjEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjjEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperand18MachineOperandTypeEJjNS_8ArrayRefIiEEEEENS_9hash_codeEmPcS9_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPKNS_11GlobalValueEJlEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJjjEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIlJNS_9StringRefEEEENS_9hash_codeEmPcS6_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJjbEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJlEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJPKNS_11ConstantIntEEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjPNS_8MCSymbolEEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjNS_8ArrayRefIiEEEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjjEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjjjEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjilEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjPKNS_6MDNodeEEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjmEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjPKNS_12BlockAddressElEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjPKNS_11GlobalValueElEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjlNS_9StringRefEEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjjbEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjlEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjPKNS_11ConstantIntEEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjPKNS_10ConstantFPEEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjPNS_17MachineBasicBlockEEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperand18MachineOperandTypeEjiEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataIPKcEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueES7_E4typeERKS7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17get_hashable_dataINS_14MachineOperandEEENSt9enable_ifIXntsrNS1_16is_hashable_dataIT_EE5valueEmE4typeERKS6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail17store_and_advanceIPKcEEbRPcS5_RKT_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper12combine_dataIPKcEEPcRmS6_S6_T_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJPKNS_11GlobalValueEEEES4_mPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJPKcEEES4_mPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJiEEES4_mPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperandEJS4_S4_S4_EEENS_9hash_codeEmPcS6_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperandEJEEENS_9hash_codeEmPcS6_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJPKNS_12BlockAddressEEEES4_mPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperandEJS4_EEENS_9hash_codeEmPcS6_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJPNS_8MCSymbolEEEES4_mPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPKNS_12BlockAddressEJEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPKNS_11GlobalValueEJEEENS_9hash_codeEmPcS8_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIPKcJEEENS_9hash_codeEmPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJPNS_17MachineBasicBlockEEEES4_mPcS7_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_14MachineOperandEJS4_S4_EEENS_9hash_codeEmPcS6_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_9hash_codeEPNS_8MCSymbolEEEES1_DpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_9hash_codeEPNS_17MachineBasicBlockEEEES1_DpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_9hash_codeEPKcEEES1_DpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_9hash_codeEPKNS_12BlockAddressEEEES1_DpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_9hash_codeEPKNS_11GlobalValueEEEES1_DpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_14MachineOperandES1_S1_S1_EEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_9hash_codeEiEEES1_DpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjjEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail23hash_combine_range_implIjEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS5_SA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18hash_combine_rangeIPjEENS_9hash_codeET_S3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIjJjNS_9hash_codeEEEES4_mPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjjNS_9hash_codeEEEES1_DpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineIbJjEEENS_9hash_codeEmPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail29hash_combine_recursive_helper7combineINS_9hash_codeEJjEEES4_mPcS5_RKT_DpRKT0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJbjEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJNS_9hash_codeEjEEES1_DpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail23hash_combine_range_implIKcEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS6_SB_</td>
    <td class="numberOfCalls">820</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18hash_combine_rangeIPKcEENS_9hash_codeET_S4_</td>
    <td class="numberOfCalls">820</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm7hashing6detail23hash_combine_range_implImEENSt9enable_ifIXsrNS1_16is_hashable_dataIT_EE5valueENS_9hash_codeEE4typeEPS5_SA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18hash_combine_rangeIPmEENS_9hash_codeET_S3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjmEEENS_9hash_codeEDpRKT_</td>
    <td class="numberOfCalls">10</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12hash_combineIJjNS_9hash_codeEEEES1_DpRKT_</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This file implements the newly proposed standard C++ interfaces for hashing</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This file implements the newly proposed standard C++ interfaces for hashing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// arbitrary data and building hash functions for user-defined types. This</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// arbitrary data and building hash functions for user-defined types. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">// interface was originally proposed in N3333[1] and is currently under review</td>
    <td class="lineNumber">11</td>
    <td class="codeline">// interface was originally proposed in N3333[1] and is currently under review</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">// for inclusion in a future TR and/or standard.</td>
    <td class="lineNumber">12</td>
    <td class="codeline">// for inclusion in a future TR and/or standard.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">// The primary interfaces provide are comprised of one type and three functions:</td>
    <td class="lineNumber">14</td>
    <td class="codeline">// The primary interfaces provide are comprised of one type and three functions:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">//</td>
    <td class="lineNumber">15</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">//  -- 'hash_code' class is an opaque type representing the hash code for some</td>
    <td class="lineNumber">16</td>
    <td class="codeline">//  -- 'hash_code' class is an opaque type representing the hash code for some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">//     data. It is the intended product of hashing, and can be used to implement</td>
    <td class="lineNumber">17</td>
    <td class="codeline">//     data. It is the intended product of hashing, and can be used to implement</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">//     hash tables, checksumming, and other common uses of hashes. It is not an</td>
    <td class="lineNumber">18</td>
    <td class="codeline">//     hash tables, checksumming, and other common uses of hashes. It is not an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">//     integer type (although it can be converted to one) because it is risky</td>
    <td class="lineNumber">19</td>
    <td class="codeline">//     integer type (although it can be converted to one) because it is risky</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">//     to assume much about the internals of a hash_code. In particular, each</td>
    <td class="lineNumber">20</td>
    <td class="codeline">//     to assume much about the internals of a hash_code. In particular, each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">//     execution of the program has a high probability of producing a different</td>
    <td class="lineNumber">21</td>
    <td class="codeline">//     execution of the program has a high probability of producing a different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">//     hash_code for a given input. Thus their values are not stable to save or</td>
    <td class="lineNumber">22</td>
    <td class="codeline">//     hash_code for a given input. Thus their values are not stable to save or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">//     persist, and should only be used during the execution for the</td>
    <td class="lineNumber">23</td>
    <td class="codeline">//     persist, and should only be used during the execution for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">//     construction of hashing datastructures.</td>
    <td class="lineNumber">24</td>
    <td class="codeline">//     construction of hashing datastructures.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">//</td>
    <td class="lineNumber">25</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">//  -- 'hash_value' is a function designed to be overloaded for each</td>
    <td class="lineNumber">26</td>
    <td class="codeline">//  -- 'hash_value' is a function designed to be overloaded for each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">//     user-defined type which wishes to be used within a hashing context. It</td>
    <td class="lineNumber">27</td>
    <td class="codeline">//     user-defined type which wishes to be used within a hashing context. It</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">//     should be overloaded within the user-defined type's namespace and found</td>
    <td class="lineNumber">28</td>
    <td class="codeline">//     should be overloaded within the user-defined type's namespace and found</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">//     via ADL. Overloads for primitive types are provided by this library.</td>
    <td class="lineNumber">29</td>
    <td class="codeline">//     via ADL. Overloads for primitive types are provided by this library.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">//</td>
    <td class="lineNumber">30</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">//  -- 'hash_combine' and 'hash_combine_range' are functions designed to aid</td>
    <td class="lineNumber">31</td>
    <td class="codeline">//  -- 'hash_combine' and 'hash_combine_range' are functions designed to aid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">//      programmers in easily and intuitively combining a set of data into</td>
    <td class="lineNumber">32</td>
    <td class="codeline">//      programmers in easily and intuitively combining a set of data into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">//      a single hash_code for their object. They should only logically be used</td>
    <td class="lineNumber">33</td>
    <td class="codeline">//      a single hash_code for their object. They should only logically be used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">//      within the implementation of a 'hash_value' routine or similar context.</td>
    <td class="lineNumber">34</td>
    <td class="codeline">//      within the implementation of a 'hash_value' routine or similar context.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">//</td>
    <td class="lineNumber">35</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">// Note that 'hash_combine_range' contains very special logic for hashing</td>
    <td class="lineNumber">36</td>
    <td class="codeline">// Note that 'hash_combine_range' contains very special logic for hashing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">// a contiguous array of integers or pointers. This logic is *extremely* fast,</td>
    <td class="lineNumber">37</td>
    <td class="codeline">// a contiguous array of integers or pointers. This logic is *extremely* fast,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">// on a modern Intel "Gainestown" Xeon (Nehalem uarch) @2.2 GHz, these were</td>
    <td class="lineNumber">38</td>
    <td class="codeline">// on a modern Intel "Gainestown" Xeon (Nehalem uarch) @2.2 GHz, these were</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">// benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys</td>
    <td class="lineNumber">39</td>
    <td class="codeline">// benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">// under 32-bytes.</td>
    <td class="lineNumber">40</td>
    <td class="codeline">// under 32-bytes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">//</td>
    <td class="lineNumber">41</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">42</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline"></td>
    <td class="lineNumber">43</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#ifndef LLVM_ADT_HASHING_H</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#ifndef LLVM_ADT_HASHING_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">#define LLVM_ADT_HASHING_H</td>
    <td class="lineNumber">45</td>
    <td class="codeline">#define LLVM_ADT_HASHING_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline"></td>
    <td class="lineNumber">46</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/Support/DataTypes.h"</td>
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/Support/DataTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/Support/SwapByteOrder.h"</td>
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/Support/SwapByteOrder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/Support/type_traits.h"</td>
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/Support/type_traits.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">51</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">52</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">#include <cstring></td>
    <td class="lineNumber">53</td>
    <td class="codeline">#include <cstring></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">#include <optional></td>
    <td class="lineNumber">54</td>
    <td class="codeline">#include <optional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">#include <string></td>
    <td class="lineNumber">55</td>
    <td class="codeline">#include <string></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">#include <tuple></td>
    <td class="lineNumber">56</td>
    <td class="codeline">#include <tuple></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">57</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
    <td class="lineNumber">58</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">59</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">template <typename T, typename Enable> struct DenseMapInfo;</td>
    <td class="lineNumber">60</td>
    <td class="codeline">template <typename T, typename Enable> struct DenseMapInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline"></td>
    <td class="lineNumber">61</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">/// An opaque object representing a hash code.</td>
    <td class="lineNumber">62</td>
    <td class="codeline">/// An opaque object representing a hash code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">///</td>
    <td class="lineNumber">63</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">/// This object represents the result of hashing some entity. It is intended to</td>
    <td class="lineNumber">64</td>
    <td class="codeline">/// This object represents the result of hashing some entity. It is intended to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">/// be used to implement hashtables or other hashing-based data structures.</td>
    <td class="lineNumber">65</td>
    <td class="codeline">/// be used to implement hashtables or other hashing-based data structures.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">/// While it wraps and exposes a numeric value, this value should not be</td>
    <td class="lineNumber">66</td>
    <td class="codeline">/// While it wraps and exposes a numeric value, this value should not be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">/// trusted to be stable or predictable across processes or executions.</td>
    <td class="lineNumber">67</td>
    <td class="codeline">/// trusted to be stable or predictable across processes or executions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">///</td>
    <td class="lineNumber">68</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">/// In order to obtain the hash_code for an object 'x':</td>
    <td class="lineNumber">69</td>
    <td class="codeline">/// In order to obtain the hash_code for an object 'x':</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">/// \code</td>
    <td class="lineNumber">70</td>
    <td class="codeline">/// \code</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">///   using llvm::hash_value;</td>
    <td class="lineNumber">71</td>
    <td class="codeline">///   using llvm::hash_value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">///   llvm::hash_code code = hash_value(x);</td>
    <td class="lineNumber">72</td>
    <td class="codeline">///   llvm::hash_code code = hash_value(x);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">/// \endcode</td>
    <td class="lineNumber">73</td>
    <td class="codeline">/// \endcode</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">class hash_code {</td>
    <td class="lineNumber">74</td>
    <td class="codeline">class hash_code {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">  size_t value;</td>
    <td class="lineNumber">75</td>
    <td class="codeline">  size_t value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline"></td>
    <td class="lineNumber">76</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">77</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">  /// Default construct a hash_code.</td>
    <td class="lineNumber">78</td>
    <td class="codeline">  /// Default construct a hash_code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">  /// Note that this leaves the value uninitialized.</td>
    <td class="lineNumber">79</td>
    <td class="codeline">  /// Note that this leaves the value uninitialized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">  hash_code() = default;</td>
    <td class="lineNumber">80</td>
    <td class="codeline">  hash_code() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">  /// Form a hash code directly from a numerical value.</td>
    <td class="lineNumber">82</td>
    <td class="codeline">  /// Form a hash code directly from a numerical value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">  hash_code(size_t value) : value(value) {}</td>
    <td class="lineNumber">83</td>
    <td class="codeline">  hash_code(size_t value) : value(value) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline"></td>
    <td class="lineNumber">84</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">  /// Convert the hash code to its numerical value for use.</td>
    <td class="lineNumber">85</td>
    <td class="codeline">  /// Convert the hash code to its numerical value for use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">  /*explicit*/ operator size_t() const { return value; }</td>
    <td class="lineNumber">86</td>
    <td class="codeline">  /*explicit*/ operator size_t() const { return value; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline"></td>
    <td class="lineNumber">87</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">  friend bool operator==(const hash_code &lhs, const hash_code &rhs) {</td>
    <td class="lineNumber">88</td>
    <td class="codeline">  friend bool operator==(const hash_code &lhs, const hash_code &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">    return lhs.value == rhs.value;</td>
    <td class="lineNumber">89</td>
    <td class="codeline">    return lhs.value == rhs.value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">90</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">  friend bool operator!=(const hash_code &lhs, const hash_code &rhs) {</td>
    <td class="lineNumber">91</td>
    <td class="codeline">  friend bool operator!=(const hash_code &lhs, const hash_code &rhs) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">    return lhs.value != rhs.value;</td>
    <td class="lineNumber">92</td>
    <td class="codeline">    return lhs.value != rhs.value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">93</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline"></td>
    <td class="lineNumber">94</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">  /// Allow a hash_code to be directly run through hash_value.</td>
    <td class="lineNumber">95</td>
    <td class="codeline">  /// Allow a hash_code to be directly run through hash_value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">  friend size_t hash_value(const hash_code &code) { return code.value; }</td>
    <td class="lineNumber">96</td>
    <td class="codeline">  friend size_t hash_value(const hash_code &code) { return code.value; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">};</td>
    <td class="lineNumber">97</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline"></td>
    <td class="lineNumber">98</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">/// Compute a hash_code for any integer value.</td>
    <td class="lineNumber">99</td>
    <td class="codeline">/// Compute a hash_code for any integer value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">///</td>
    <td class="lineNumber">100</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">/// Note that this function is intended to compute the same hash_code for</td>
    <td class="lineNumber">101</td>
    <td class="codeline">/// Note that this function is intended to compute the same hash_code for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">/// a particular value without regard to the pre-promotion type. This is in</td>
    <td class="lineNumber">102</td>
    <td class="codeline">/// a particular value without regard to the pre-promotion type. This is in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">/// contrast to hash_combine which may produce different hash_codes for</td>
    <td class="lineNumber">103</td>
    <td class="codeline">/// contrast to hash_combine which may produce different hash_codes for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">/// differing argument types even if they would implicit promote to a common</td>
    <td class="lineNumber">104</td>
    <td class="codeline">/// differing argument types even if they would implicit promote to a common</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">/// type without changing the value.</td>
    <td class="lineNumber">105</td>
    <td class="codeline">/// type without changing the value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">106</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value);</td>
    <td class="lineNumber">107</td>
    <td class="codeline">std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline"></td>
    <td class="lineNumber">108</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">/// Compute a hash_code for a pointer's address.</td>
    <td class="lineNumber">109</td>
    <td class="codeline">/// Compute a hash_code for a pointer's address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">///</td>
    <td class="lineNumber">110</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">/// N.B.: This hashes the *address*. Not the value and not the type.</td>
    <td class="lineNumber">111</td>
    <td class="codeline">/// N.B.: This hashes the *address*. Not the value and not the type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">template <typename T> hash_code hash_value(const T *ptr);</td>
    <td class="lineNumber">112</td>
    <td class="codeline">template <typename T> hash_code hash_value(const T *ptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline"></td>
    <td class="lineNumber">113</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">/// Compute a hash_code for a pair of objects.</td>
    <td class="lineNumber">114</td>
    <td class="codeline">/// Compute a hash_code for a pair of objects.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">template <typename T, typename U></td>
    <td class="lineNumber">115</td>
    <td class="codeline">template <typename T, typename U></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">hash_code hash_value(const std::pair<T, U> &arg);</td>
    <td class="lineNumber">116</td>
    <td class="codeline">hash_code hash_value(const std::pair<T, U> &arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline"></td>
    <td class="lineNumber">117</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">/// Compute a hash_code for a tuple.</td>
    <td class="lineNumber">118</td>
    <td class="codeline">/// Compute a hash_code for a tuple.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">template <typename... Ts></td>
    <td class="lineNumber">119</td>
    <td class="codeline">template <typename... Ts></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">hash_code hash_value(const std::tuple<Ts...> &arg);</td>
    <td class="lineNumber">120</td>
    <td class="codeline">hash_code hash_value(const std::tuple<Ts...> &arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">/// Compute a hash_code for a standard string.</td>
    <td class="lineNumber">122</td>
    <td class="codeline">/// Compute a hash_code for a standard string.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">123</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">hash_code hash_value(const std::basic_string<T> &arg);</td>
    <td class="lineNumber">124</td>
    <td class="codeline">hash_code hash_value(const std::basic_string<T> &arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">/// Compute a hash_code for a standard string.</td>
    <td class="lineNumber">126</td>
    <td class="codeline">/// Compute a hash_code for a standard string.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">template <typename T> hash_code hash_value(const std::optional<T> &arg);</td>
    <td class="lineNumber">127</td>
    <td class="codeline">template <typename T> hash_code hash_value(const std::optional<T> &arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline"></td>
    <td class="lineNumber">128</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">/// Override the execution seed with a fixed value.</td>
    <td class="lineNumber">129</td>
    <td class="codeline">/// Override the execution seed with a fixed value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">///</td>
    <td class="lineNumber">130</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">/// This hashing library uses a per-execution seed designed to change on each</td>
    <td class="lineNumber">131</td>
    <td class="codeline">/// This hashing library uses a per-execution seed designed to change on each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">/// run with high probability in order to ensure that the hash codes are not</td>
    <td class="lineNumber">132</td>
    <td class="codeline">/// run with high probability in order to ensure that the hash codes are not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">/// attackable and to ensure that output which is intended to be stable does</td>
    <td class="lineNumber">133</td>
    <td class="codeline">/// attackable and to ensure that output which is intended to be stable does</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">/// not rely on the particulars of the hash codes produced.</td>
    <td class="lineNumber">134</td>
    <td class="codeline">/// not rely on the particulars of the hash codes produced.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">///</td>
    <td class="lineNumber">135</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">/// That said, there are use cases where it is important to be able to</td>
    <td class="lineNumber">136</td>
    <td class="codeline">/// That said, there are use cases where it is important to be able to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">/// reproduce *exactly* a specific behavior. To that end, we provide a function</td>
    <td class="lineNumber">137</td>
    <td class="codeline">/// reproduce *exactly* a specific behavior. To that end, we provide a function</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">/// which will forcibly set the seed to a fixed value. This must be done at the</td>
    <td class="lineNumber">138</td>
    <td class="codeline">/// which will forcibly set the seed to a fixed value. This must be done at the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">/// start of the program, before any hashes are computed. Also, it cannot be</td>
    <td class="lineNumber">139</td>
    <td class="codeline">/// start of the program, before any hashes are computed. Also, it cannot be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">/// undone. This makes it thread-hostile and very hard to use outside of</td>
    <td class="lineNumber">140</td>
    <td class="codeline">/// undone. This makes it thread-hostile and very hard to use outside of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">/// immediately on start of a simple program designed for reproducible</td>
    <td class="lineNumber">141</td>
    <td class="codeline">/// immediately on start of a simple program designed for reproducible</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">/// behavior.</td>
    <td class="lineNumber">142</td>
    <td class="codeline">/// behavior.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">void set_fixed_execution_hash_seed(uint64_t fixed_value);</td>
    <td class="lineNumber">143</td>
    <td class="codeline">void set_fixed_execution_hash_seed(uint64_t fixed_value);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline"></td>
    <td class="lineNumber">144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">// All of the implementation details of actually computing the various hash</td>
    <td class="lineNumber">146</td>
    <td class="codeline">// All of the implementation details of actually computing the various hash</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">// code values are held within this namespace. These routines are included in</td>
    <td class="lineNumber">147</td>
    <td class="codeline">// code values are held within this namespace. These routines are included in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">// the header file mainly to allow inlining and constant propagation.</td>
    <td class="lineNumber">148</td>
    <td class="codeline">// the header file mainly to allow inlining and constant propagation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">namespace hashing {</td>
    <td class="lineNumber">149</td>
    <td class="codeline">namespace hashing {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">150</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline"></td>
    <td class="lineNumber">151</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">inline uint64_t fetch64(const char *p) {</td>
    <td class="lineNumber">152</td>
    <td class="codeline">inline uint64_t fetch64(const char *p) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">  uint64_t result;</td>
    <td class="lineNumber">153</td>
    <td class="codeline">  uint64_t result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">  memcpy(&result, p, sizeof(result));</td>
    <td class="lineNumber">154</td>
    <td class="codeline">  memcpy(&result, p, sizeof(result));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">  if (sys::IsBigEndianHost)</td>
    <td class="lineNumber">155</td>
    <td class="codeline">  if (sys::IsBigEndianHost)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">    sys::swapByteOrder(result);</td>
    <td class="lineNumber">156</td>
    <td class="codeline">    sys::swapByteOrder(result);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  return result;</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  return result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">}</td>
    <td class="lineNumber">158</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline"></td>
    <td class="lineNumber">159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">inline uint32_t fetch32(const char *p) {</td>
    <td class="lineNumber">160</td>
    <td class="codeline">inline uint32_t fetch32(const char *p) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">  uint32_t result;</td>
    <td class="lineNumber">161</td>
    <td class="codeline">  uint32_t result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">  memcpy(&result, p, sizeof(result));</td>
    <td class="lineNumber">162</td>
    <td class="codeline">  memcpy(&result, p, sizeof(result));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">  if (sys::IsBigEndianHost)</td>
    <td class="lineNumber">163</td>
    <td class="codeline">  if (sys::IsBigEndianHost)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">    sys::swapByteOrder(result);</td>
    <td class="lineNumber">164</td>
    <td class="codeline">    sys::swapByteOrder(result);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">  return result;</td>
    <td class="lineNumber">165</td>
    <td class="codeline">  return result;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">}</td>
    <td class="lineNumber">166</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
    <td class="lineNumber">167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">/// Some primes between 2^63 and 2^64 for various uses.</td>
    <td class="lineNumber">168</td>
    <td class="codeline">/// Some primes between 2^63 and 2^64 for various uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">static constexpr uint64_t k0 = 0xc3a5c85c97cb3127ULL;</td>
    <td class="lineNumber">169</td>
    <td class="codeline">static constexpr uint64_t k0 = 0xc3a5c85c97cb3127ULL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">static constexpr uint64_t k1 = 0xb492b66fbe98f273ULL;</td>
    <td class="lineNumber">170</td>
    <td class="codeline">static constexpr uint64_t k1 = 0xb492b66fbe98f273ULL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">static constexpr uint64_t k2 = 0x9ae16a3b2f90404fULL;</td>
    <td class="lineNumber">171</td>
    <td class="codeline">static constexpr uint64_t k2 = 0x9ae16a3b2f90404fULL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">static constexpr uint64_t k3 = 0xc949d7c7509e6557ULL;</td>
    <td class="lineNumber">172</td>
    <td class="codeline">static constexpr uint64_t k3 = 0xc949d7c7509e6557ULL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline"></td>
    <td class="lineNumber">173</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">/// Bitwise right rotate.</td>
    <td class="lineNumber">174</td>
    <td class="codeline">/// Bitwise right rotate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">/// Normally this will compile to a single instruction, especially if the</td>
    <td class="lineNumber">175</td>
    <td class="codeline">/// Normally this will compile to a single instruction, especially if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">/// shift is a manifest constant.</td>
    <td class="lineNumber">176</td>
    <td class="codeline">/// shift is a manifest constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">inline uint64_t rotate(uint64_t val, size_t shift) {</td>
    <td class="lineNumber">177</td>
    <td class="codeline">inline uint64_t rotate(uint64_t val, size_t shift) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  // Avoid shifting by 64: doing so yields an undefined result.</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  // Avoid shifting by 64: doing so yields an undefined result.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">}</td>
    <td class="lineNumber">180</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">inline uint64_t shift_mix(uint64_t val) {</td>
    <td class="lineNumber">182</td>
    <td class="codeline">inline uint64_t shift_mix(uint64_t val) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  return val ^ (val >> 47);</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  return val ^ (val >> 47);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">}</td>
    <td class="lineNumber">184</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">inline uint64_t hash_16_bytes(uint64_t low, uint64_t high) {</td>
    <td class="lineNumber">186</td>
    <td class="codeline">inline uint64_t hash_16_bytes(uint64_t low, uint64_t high) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  // Murmur-inspired hashing.</td>
    <td class="lineNumber">187</td>
    <td class="codeline">  // Murmur-inspired hashing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">  const uint64_t kMul = 0x9ddfea08eb382d69ULL;</td>
    <td class="lineNumber">188</td>
    <td class="codeline">  const uint64_t kMul = 0x9ddfea08eb382d69ULL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  uint64_t a = (low ^ high) * kMul;</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  uint64_t a = (low ^ high) * kMul;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  a ^= (a >> 47);</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  a ^= (a >> 47);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  uint64_t b = (high ^ a) * kMul;</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  uint64_t b = (high ^ a) * kMul;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">  b ^= (b >> 47);</td>
    <td class="lineNumber">192</td>
    <td class="codeline">  b ^= (b >> 47);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  b *= kMul;</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  b *= kMul;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">  return b;</td>
    <td class="lineNumber">194</td>
    <td class="codeline">  return b;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">}</td>
    <td class="lineNumber">195</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline"></td>
    <td class="lineNumber">196</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">inline uint64_t hash_1to3_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">197</td>
    <td class="codeline">inline uint64_t hash_1to3_bytes(const char *s, size_t len, uint64_t seed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">  uint8_t a = s[0];</td>
    <td class="lineNumber">198</td>
    <td class="codeline">  uint8_t a = s[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">  uint8_t b = s[len >> 1];</td>
    <td class="lineNumber">199</td>
    <td class="codeline">  uint8_t b = s[len >> 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">  uint8_t c = s[len - 1];</td>
    <td class="lineNumber">200</td>
    <td class="codeline">  uint8_t c = s[len - 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  uint32_t y = static_cast<uint32_t>(a) + (static_cast<uint32_t>(b) << 8);</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  uint32_t y = static_cast<uint32_t>(a) + (static_cast<uint32_t>(b) << 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">  uint32_t z = static_cast<uint32_t>(len) + (static_cast<uint32_t>(c) << 2);</td>
    <td class="lineNumber">202</td>
    <td class="codeline">  uint32_t z = static_cast<uint32_t>(len) + (static_cast<uint32_t>(c) << 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">  return shift_mix(y * k2 ^ z * k3 ^ seed) * k2;</td>
    <td class="lineNumber">203</td>
    <td class="codeline">  return shift_mix(y * k2 ^ z * k3 ^ seed) * k2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">}</td>
    <td class="lineNumber">204</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline"></td>
    <td class="lineNumber">205</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">inline uint64_t hash_4to8_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">206</td>
    <td class="codeline">inline uint64_t hash_4to8_bytes(const char *s, size_t len, uint64_t seed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  uint64_t a = fetch32(s);</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  uint64_t a = fetch32(s);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  return hash_16_bytes(len + (a << 3), seed ^ fetch32(s + len - 4));</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  return hash_16_bytes(len + (a << 3), seed ^ fetch32(s + len - 4));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">}</td>
    <td class="lineNumber">209</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">inline uint64_t hash_9to16_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">211</td>
    <td class="codeline">inline uint64_t hash_9to16_bytes(const char *s, size_t len, uint64_t seed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  uint64_t a = fetch64(s);</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  uint64_t a = fetch64(s);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  uint64_t b = fetch64(s + len - 8);</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  uint64_t b = fetch64(s + len - 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">  return hash_16_bytes(seed ^ a, rotate(b + len, len)) ^ b;</td>
    <td class="lineNumber">214</td>
    <td class="codeline">  return hash_16_bytes(seed ^ a, rotate(b + len, len)) ^ b;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">}</td>
    <td class="lineNumber">215</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline"></td>
    <td class="lineNumber">216</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">inline uint64_t hash_17to32_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">217</td>
    <td class="codeline">inline uint64_t hash_17to32_bytes(const char *s, size_t len, uint64_t seed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  uint64_t a = fetch64(s) * k1;</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  uint64_t a = fetch64(s) * k1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  uint64_t b = fetch64(s + 8);</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  uint64_t b = fetch64(s + 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">  uint64_t c = fetch64(s + len - 8) * k2;</td>
    <td class="lineNumber">220</td>
    <td class="codeline">  uint64_t c = fetch64(s + len - 8) * k2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  uint64_t d = fetch64(s + len - 16) * k0;</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  uint64_t d = fetch64(s + len - 16) * k0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">  return hash_16_bytes(llvm::rotr<uint64_t>(a - b, 43) +</td>
    <td class="lineNumber">222</td>
    <td class="codeline">  return hash_16_bytes(llvm::rotr<uint64_t>(a - b, 43) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">                           llvm::rotr<uint64_t>(c ^ seed, 30) + d,</td>
    <td class="lineNumber">223</td>
    <td class="codeline">                           llvm::rotr<uint64_t>(c ^ seed, 30) + d,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">                       a + llvm::rotr<uint64_t>(b ^ k3, 20) - c + len + seed);</td>
    <td class="lineNumber">224</td>
    <td class="codeline">                       a + llvm::rotr<uint64_t>(b ^ k3, 20) - c + len + seed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">}</td>
    <td class="lineNumber">225</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline"></td>
    <td class="lineNumber">226</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">inline uint64_t hash_33to64_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">227</td>
    <td class="codeline">inline uint64_t hash_33to64_bytes(const char *s, size_t len, uint64_t seed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">  uint64_t z = fetch64(s + 24);</td>
    <td class="lineNumber">228</td>
    <td class="codeline">  uint64_t z = fetch64(s + 24);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  uint64_t a = fetch64(s) + (len + fetch64(s + len - 16)) * k0;</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  uint64_t a = fetch64(s) + (len + fetch64(s + len - 16)) * k0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  uint64_t b = llvm::rotr<uint64_t>(a + z, 52);</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  uint64_t b = llvm::rotr<uint64_t>(a + z, 52);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  uint64_t c = llvm::rotr<uint64_t>(a, 37);</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  uint64_t c = llvm::rotr<uint64_t>(a, 37);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  a += fetch64(s + 8);</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  a += fetch64(s + 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  c += llvm::rotr<uint64_t>(a, 7);</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  c += llvm::rotr<uint64_t>(a, 7);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">  a += fetch64(s + 16);</td>
    <td class="lineNumber">234</td>
    <td class="codeline">  a += fetch64(s + 16);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  uint64_t vf = a + z;</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  uint64_t vf = a + z;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">  uint64_t vs = b + llvm::rotr<uint64_t>(a, 31) + c;</td>
    <td class="lineNumber">236</td>
    <td class="codeline">  uint64_t vs = b + llvm::rotr<uint64_t>(a, 31) + c;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  a = fetch64(s + 16) + fetch64(s + len - 32);</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  a = fetch64(s + 16) + fetch64(s + len - 32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  z = fetch64(s + len - 8);</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  z = fetch64(s + len - 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  b = llvm::rotr<uint64_t>(a + z, 52);</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  b = llvm::rotr<uint64_t>(a + z, 52);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  c = llvm::rotr<uint64_t>(a, 37);</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  c = llvm::rotr<uint64_t>(a, 37);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  a += fetch64(s + len - 24);</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  a += fetch64(s + len - 24);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  c += llvm::rotr<uint64_t>(a, 7);</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  c += llvm::rotr<uint64_t>(a, 7);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  a += fetch64(s + len - 16);</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  a += fetch64(s + len - 16);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  uint64_t wf = a + z;</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  uint64_t wf = a + z;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">  uint64_t ws = b + llvm::rotr<uint64_t>(a, 31) + c;</td>
    <td class="lineNumber">245</td>
    <td class="codeline">  uint64_t ws = b + llvm::rotr<uint64_t>(a, 31) + c;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  uint64_t r = shift_mix((vf + ws) * k2 + (wf + vs) * k0);</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  uint64_t r = shift_mix((vf + ws) * k2 + (wf + vs) * k0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  return shift_mix((seed ^ (r * k0)) + vs) * k2;</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  return shift_mix((seed ^ (r * k0)) + vs) * k2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">}</td>
    <td class="lineNumber">248</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline"></td>
    <td class="lineNumber">249</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">inline uint64_t hash_short(const char *s, size_t length, uint64_t seed) {</td>
    <td class="lineNumber">250</td>
    <td class="codeline">inline uint64_t hash_short(const char *s, size_t length, uint64_t seed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  if (length >= 4 && length <= 8)</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  if (length >= 4 && length <= 8)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">    return hash_4to8_bytes(s, length, seed);</td>
    <td class="lineNumber">252</td>
    <td class="codeline">    return hash_4to8_bytes(s, length, seed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  if (length > 8 && length <= 16)</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  if (length > 8 && length <= 16)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">    return hash_9to16_bytes(s, length, seed);</td>
    <td class="lineNumber">254</td>
    <td class="codeline">    return hash_9to16_bytes(s, length, seed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  if (length > 16 && length <= 32)</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  if (length > 16 && length <= 32)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">    return hash_17to32_bytes(s, length, seed);</td>
    <td class="lineNumber">256</td>
    <td class="codeline">    return hash_17to32_bytes(s, length, seed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  if (length > 32)</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  if (length > 32)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">    return hash_33to64_bytes(s, length, seed);</td>
    <td class="lineNumber">258</td>
    <td class="codeline">    return hash_33to64_bytes(s, length, seed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine diffFirst">  if (length != 0)</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  if (length != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">    return hash_1to3_bytes(s, length, seed);</td>
    <td class="lineNumber">260</td>
    <td class="codeline">    return hash_1to3_bytes(s, length, seed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
    <td class="lineNumber">261</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine diffFirst">  return k2 ^ seed;</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  return k2 ^ seed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">}</td>
    <td class="lineNumber">263</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline"></td>
    <td class="lineNumber">264</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">/// The intermediate state used during hashing.</td>
    <td class="lineNumber">265</td>
    <td class="codeline">/// The intermediate state used during hashing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">/// Currently, the algorithm for computing hash codes is based on CityHash and</td>
    <td class="lineNumber">266</td>
    <td class="codeline">/// Currently, the algorithm for computing hash codes is based on CityHash and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">/// keeps 56 bytes of arbitrary state.</td>
    <td class="lineNumber">267</td>
    <td class="codeline">/// keeps 56 bytes of arbitrary state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">struct hash_state {</td>
    <td class="lineNumber">268</td>
    <td class="codeline">struct hash_state {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  uint64_t h0 = 0, h1 = 0, h2 = 0, h3 = 0, h4 = 0, h5 = 0, h6 = 0;</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  uint64_t h0 = 0, h1 = 0, h2 = 0, h3 = 0, h4 = 0, h5 = 0, h6 = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline"></td>
    <td class="lineNumber">270</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  /// Create a new hash_state structure and initialize it based on the</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  /// Create a new hash_state structure and initialize it based on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">  /// seed and the first 64-byte chunk.</td>
    <td class="lineNumber">272</td>
    <td class="codeline">  /// seed and the first 64-byte chunk.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  /// This effectively performs the initial mix.</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  /// This effectively performs the initial mix.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  static hash_state create(const char *s, uint64_t seed) {</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  static hash_state create(const char *s, uint64_t seed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">    hash_state state = {0,</td>
    <td class="lineNumber">275</td>
    <td class="codeline">    hash_state state = {0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">                        seed,</td>
    <td class="lineNumber">276</td>
    <td class="codeline">                        seed,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">                        hash_16_bytes(seed, k1),</td>
    <td class="lineNumber">277</td>
    <td class="codeline">                        hash_16_bytes(seed, k1),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">                        llvm::rotr<uint64_t>(seed ^ k1, 49),</td>
    <td class="lineNumber">278</td>
    <td class="codeline">                        llvm::rotr<uint64_t>(seed ^ k1, 49),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">                        seed * k1,</td>
    <td class="lineNumber">279</td>
    <td class="codeline">                        seed * k1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">                        shift_mix(seed),</td>
    <td class="lineNumber">280</td>
    <td class="codeline">                        shift_mix(seed),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">                        0};</td>
    <td class="lineNumber">281</td>
    <td class="codeline">                        0};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">    state.h6 = hash_16_bytes(state.h4, state.h5);</td>
    <td class="lineNumber">282</td>
    <td class="codeline">    state.h6 = hash_16_bytes(state.h4, state.h5);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">    state.mix(s);</td>
    <td class="lineNumber">283</td>
    <td class="codeline">    state.mix(s);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">    return state;</td>
    <td class="lineNumber">284</td>
    <td class="codeline">    return state;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  /// Mix 32-bytes from the input sequence into the 16-bytes of 'a'</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  /// Mix 32-bytes from the input sequence into the 16-bytes of 'a'</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  /// and 'b', including whatever is already in 'a' and 'b'.</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  /// and 'b', including whatever is already in 'a' and 'b'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  static void mix_32_bytes(const char *s, uint64_t &a, uint64_t &b) {</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  static void mix_32_bytes(const char *s, uint64_t &a, uint64_t &b) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">    a += fetch64(s);</td>
    <td class="lineNumber">290</td>
    <td class="codeline">    a += fetch64(s);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">    uint64_t c = fetch64(s + 24);</td>
    <td class="lineNumber">291</td>
    <td class="codeline">    uint64_t c = fetch64(s + 24);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">    b = llvm::rotr<uint64_t>(b + a + c, 21);</td>
    <td class="lineNumber">292</td>
    <td class="codeline">    b = llvm::rotr<uint64_t>(b + a + c, 21);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">    uint64_t d = a;</td>
    <td class="lineNumber">293</td>
    <td class="codeline">    uint64_t d = a;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">    a += fetch64(s + 8) + fetch64(s + 16);</td>
    <td class="lineNumber">294</td>
    <td class="codeline">    a += fetch64(s + 8) + fetch64(s + 16);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">    b += llvm::rotr<uint64_t>(a, 44) + d;</td>
    <td class="lineNumber">295</td>
    <td class="codeline">    b += llvm::rotr<uint64_t>(a, 44) + d;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">    a += c;</td>
    <td class="lineNumber">296</td>
    <td class="codeline">    a += c;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">297</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline"></td>
    <td class="lineNumber">298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  /// Mix in a 64-byte buffer of data.</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  /// Mix in a 64-byte buffer of data.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">  /// We mix all 64 bytes even when the chunk length is smaller, but we</td>
    <td class="lineNumber">300</td>
    <td class="codeline">  /// We mix all 64 bytes even when the chunk length is smaller, but we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  /// record the actual length.</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  /// record the actual length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  void mix(const char *s) {</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  void mix(const char *s) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">    h0 = llvm::rotr<uint64_t>(h0 + h1 + h3 + fetch64(s + 8), 37) * k1;</td>
    <td class="lineNumber">303</td>
    <td class="codeline">    h0 = llvm::rotr<uint64_t>(h0 + h1 + h3 + fetch64(s + 8), 37) * k1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">    h1 = llvm::rotr<uint64_t>(h1 + h4 + fetch64(s + 48), 42) * k1;</td>
    <td class="lineNumber">304</td>
    <td class="codeline">    h1 = llvm::rotr<uint64_t>(h1 + h4 + fetch64(s + 48), 42) * k1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">    h0 ^= h6;</td>
    <td class="lineNumber">305</td>
    <td class="codeline">    h0 ^= h6;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">    h1 += h3 + fetch64(s + 40);</td>
    <td class="lineNumber">306</td>
    <td class="codeline">    h1 += h3 + fetch64(s + 40);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">    h2 = llvm::rotr<uint64_t>(h2 + h5, 33) * k1;</td>
    <td class="lineNumber">307</td>
    <td class="codeline">    h2 = llvm::rotr<uint64_t>(h2 + h5, 33) * k1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    h3 = h4 * k1;</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    h3 = h4 * k1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">    h4 = h0 + h5;</td>
    <td class="lineNumber">309</td>
    <td class="codeline">    h4 = h0 + h5;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">    mix_32_bytes(s, h3, h4);</td>
    <td class="lineNumber">310</td>
    <td class="codeline">    mix_32_bytes(s, h3, h4);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">    h5 = h2 + h6;</td>
    <td class="lineNumber">311</td>
    <td class="codeline">    h5 = h2 + h6;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    h6 = h1 + fetch64(s + 16);</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    h6 = h1 + fetch64(s + 16);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">    mix_32_bytes(s + 32, h5, h6);</td>
    <td class="lineNumber">313</td>
    <td class="codeline">    mix_32_bytes(s + 32, h5, h6);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">    std::swap(h2, h0);</td>
    <td class="lineNumber">314</td>
    <td class="codeline">    std::swap(h2, h0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">315</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
    <td class="lineNumber">316</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">  /// Compute the final 64-bit hash code value based on the current</td>
    <td class="lineNumber">317</td>
    <td class="codeline">  /// Compute the final 64-bit hash code value based on the current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">  /// state and the length of bytes hashed.</td>
    <td class="lineNumber">318</td>
    <td class="codeline">  /// state and the length of bytes hashed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">  uint64_t finalize(size_t length) {</td>
    <td class="lineNumber">319</td>
    <td class="codeline">  uint64_t finalize(size_t length) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">    return hash_16_bytes(hash_16_bytes(h3, h5) + shift_mix(h1) * k1 + h2,</td>
    <td class="lineNumber">320</td>
    <td class="codeline">    return hash_16_bytes(hash_16_bytes(h3, h5) + shift_mix(h1) * k1 + h2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">                         hash_16_bytes(h4, h6) + shift_mix(length) * k1 + h0);</td>
    <td class="lineNumber">321</td>
    <td class="codeline">                         hash_16_bytes(h4, h6) + shift_mix(length) * k1 + h0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">322</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">};</td>
    <td class="lineNumber">323</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline"></td>
    <td class="lineNumber">324</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline"></td>
    <td class="lineNumber">325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">/// A global, fixed seed-override variable.</td>
    <td class="lineNumber">326</td>
    <td class="codeline">/// A global, fixed seed-override variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">///</td>
    <td class="lineNumber">327</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">/// This variable can be set using the \see llvm::set_fixed_execution_seed</td>
    <td class="lineNumber">328</td>
    <td class="codeline">/// This variable can be set using the \see llvm::set_fixed_execution_seed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">/// function. See that function for details. Do not, under any circumstances,</td>
    <td class="lineNumber">329</td>
    <td class="codeline">/// function. See that function for details. Do not, under any circumstances,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">/// set or read this variable.</td>
    <td class="lineNumber">330</td>
    <td class="codeline">/// set or read this variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">extern uint64_t fixed_seed_override;</td>
    <td class="lineNumber">331</td>
    <td class="codeline">extern uint64_t fixed_seed_override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline"></td>
    <td class="lineNumber">332</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">inline uint64_t get_execution_seed() {</td>
    <td class="lineNumber">333</td>
    <td class="codeline">inline uint64_t get_execution_seed() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">  // FIXME: This needs to be a per-execution seed. This is just a placeholder</td>
    <td class="lineNumber">334</td>
    <td class="codeline">  // FIXME: This needs to be a per-execution seed. This is just a placeholder</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">  // implementation. Switching to a per-execution seed is likely to flush out</td>
    <td class="lineNumber">335</td>
    <td class="codeline">  // implementation. Switching to a per-execution seed is likely to flush out</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">  // instability bugs and so will happen as its own commit.</td>
    <td class="lineNumber">336</td>
    <td class="codeline">  // instability bugs and so will happen as its own commit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">  // However, if there is a fixed seed override set the first time this is</td>
    <td class="lineNumber">338</td>
    <td class="codeline">  // However, if there is a fixed seed override set the first time this is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">  // called, return that instead of the per-execution seed.</td>
    <td class="lineNumber">339</td>
    <td class="codeline">  // called, return that instead of the per-execution seed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">  const uint64_t seed_prime = 0xff51afd7ed558ccdULL;</td>
    <td class="lineNumber">340</td>
    <td class="codeline">  const uint64_t seed_prime = 0xff51afd7ed558ccdULL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">  static uint64_t seed = fixed_seed_override ? fixed_seed_override : seed_prime;</td>
    <td class="lineNumber">341</td>
    <td class="codeline">  static uint64_t seed = fixed_seed_override ? fixed_seed_override : seed_prime;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">  return seed;</td>
    <td class="lineNumber">342</td>
    <td class="codeline">  return seed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">}</td>
    <td class="lineNumber">343</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline"></td>
    <td class="lineNumber">345</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">/// Trait to indicate whether a type's bits can be hashed directly.</td>
    <td class="lineNumber">346</td>
    <td class="codeline">/// Trait to indicate whether a type's bits can be hashed directly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">///</td>
    <td class="lineNumber">347</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">/// A type trait which is true if we want to combine values for hashing by</td>
    <td class="lineNumber">348</td>
    <td class="codeline">/// A type trait which is true if we want to combine values for hashing by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">/// reading the underlying data. It is false if values of this type must</td>
    <td class="lineNumber">349</td>
    <td class="codeline">/// reading the underlying data. It is false if values of this type must</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">/// first be passed to hash_value, and the resulting hash_codes combined.</td>
    <td class="lineNumber">350</td>
    <td class="codeline">/// first be passed to hash_value, and the resulting hash_codes combined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">//</td>
    <td class="lineNumber">351</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">// FIXME: We want to replace is_integral_or_enum and is_pointer here with</td>
    <td class="lineNumber">352</td>
    <td class="codeline">// FIXME: We want to replace is_integral_or_enum and is_pointer here with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">// a predicate which asserts that comparing the underlying storage of two</td>
    <td class="lineNumber">353</td>
    <td class="codeline">// a predicate which asserts that comparing the underlying storage of two</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">// values of the type for equality is equivalent to comparing the two values</td>
    <td class="lineNumber">354</td>
    <td class="codeline">// values of the type for equality is equivalent to comparing the two values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">// for equality. For all the platforms we care about, this holds for integers</td>
    <td class="lineNumber">355</td>
    <td class="codeline">// for equality. For all the platforms we care about, this holds for integers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">// and pointers, but there are platforms where it doesn't and we would like to</td>
    <td class="lineNumber">356</td>
    <td class="codeline">// and pointers, but there are platforms where it doesn't and we would like to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">// support user-defined types which happen to satisfy this property.</td>
    <td class="lineNumber">357</td>
    <td class="codeline">// support user-defined types which happen to satisfy this property.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">template <typename T> struct is_hashable_data</td>
    <td class="lineNumber">358</td>
    <td class="codeline">template <typename T> struct is_hashable_data</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">  : std::integral_constant<bool, ((is_integral_or_enum<T>::value ||</td>
    <td class="lineNumber">359</td>
    <td class="codeline">  : std::integral_constant<bool, ((is_integral_or_enum<T>::value ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">                                   std::is_pointer<T>::value) &&</td>
    <td class="lineNumber">360</td>
    <td class="codeline">                                   std::is_pointer<T>::value) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">                                  64 % sizeof(T) == 0)> {};</td>
    <td class="lineNumber">361</td>
    <td class="codeline">                                  64 % sizeof(T) == 0)> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">// Special case std::pair to detect when both types are viable and when there</td>
    <td class="lineNumber">363</td>
    <td class="codeline">// Special case std::pair to detect when both types are viable and when there</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">// is no alignment-derived padding in the pair. This is a bit of a lie because</td>
    <td class="lineNumber">364</td>
    <td class="codeline">// is no alignment-derived padding in the pair. This is a bit of a lie because</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">// std::pair isn't truly POD, but it's close enough in all reasonable</td>
    <td class="lineNumber">365</td>
    <td class="codeline">// std::pair isn't truly POD, but it's close enough in all reasonable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">// implementations for our use case of hashing the underlying data.</td>
    <td class="lineNumber">366</td>
    <td class="codeline">// implementations for our use case of hashing the underlying data.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">template <typename T, typename U> struct is_hashable_data<std::pair<T, U> ></td>
    <td class="lineNumber">367</td>
    <td class="codeline">template <typename T, typename U> struct is_hashable_data<std::pair<T, U> ></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">  : std::integral_constant<bool, (is_hashable_data<T>::value &&</td>
    <td class="lineNumber">368</td>
    <td class="codeline">  : std::integral_constant<bool, (is_hashable_data<T>::value &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">                                  is_hashable_data<U>::value &&</td>
    <td class="lineNumber">369</td>
    <td class="codeline">                                  is_hashable_data<U>::value &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">                                  (sizeof(T) + sizeof(U)) ==</td>
    <td class="lineNumber">370</td>
    <td class="codeline">                                  (sizeof(T) + sizeof(U)) ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">                                   sizeof(std::pair<T, U>))> {};</td>
    <td class="lineNumber">371</td>
    <td class="codeline">                                   sizeof(std::pair<T, U>))> {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline"></td>
    <td class="lineNumber">372</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">/// Helper to get the hashable data representation for a type.</td>
    <td class="lineNumber">373</td>
    <td class="codeline">/// Helper to get the hashable data representation for a type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">/// This variant is enabled when the type itself can be used.</td>
    <td class="lineNumber">374</td>
    <td class="codeline">/// This variant is enabled when the type itself can be used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">375</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">std::enable_if_t<is_hashable_data<T>::value, T></td>
    <td class="lineNumber">376</td>
    <td class="codeline">std::enable_if_t<is_hashable_data<T>::value, T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">get_hashable_data(const T &value) {</td>
    <td class="lineNumber">377</td>
    <td class="codeline">get_hashable_data(const T &value) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">  return value;</td>
    <td class="lineNumber">378</td>
    <td class="codeline">  return value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">}</td>
    <td class="lineNumber">379</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">/// Helper to get the hashable data representation for a type.</td>
    <td class="lineNumber">380</td>
    <td class="codeline">/// Helper to get the hashable data representation for a type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">/// This variant is enabled when we must first call hash_value and use the</td>
    <td class="lineNumber">381</td>
    <td class="codeline">/// This variant is enabled when we must first call hash_value and use the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">/// result as our data.</td>
    <td class="lineNumber">382</td>
    <td class="codeline">/// result as our data.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">383</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">std::enable_if_t<!is_hashable_data<T>::value, size_t></td>
    <td class="lineNumber">384</td>
    <td class="codeline">std::enable_if_t<!is_hashable_data<T>::value, size_t></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">get_hashable_data(const T &value) {</td>
    <td class="lineNumber">385</td>
    <td class="codeline">get_hashable_data(const T &value) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">  using ::llvm::hash_value;</td>
    <td class="lineNumber">386</td>
    <td class="codeline">  using ::llvm::hash_value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">  return hash_value(value);</td>
    <td class="lineNumber">387</td>
    <td class="codeline">  return hash_value(value);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">}</td>
    <td class="lineNumber">388</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">/// Helper to store data from a value into a buffer and advance the</td>
    <td class="lineNumber">390</td>
    <td class="codeline">/// Helper to store data from a value into a buffer and advance the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">/// pointer into that buffer.</td>
    <td class="lineNumber">391</td>
    <td class="codeline">/// pointer into that buffer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">///</td>
    <td class="lineNumber">392</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">/// This routine first checks whether there is enough space in the provided</td>
    <td class="lineNumber">393</td>
    <td class="codeline">/// This routine first checks whether there is enough space in the provided</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">/// buffer, and if not immediately returns false. If there is space, it</td>
    <td class="lineNumber">394</td>
    <td class="codeline">/// buffer, and if not immediately returns false. If there is space, it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">/// copies the underlying bytes of value into the buffer, advances the</td>
    <td class="lineNumber">395</td>
    <td class="codeline">/// copies the underlying bytes of value into the buffer, advances the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">/// buffer_ptr past the copied bytes, and returns true.</td>
    <td class="lineNumber">396</td>
    <td class="codeline">/// buffer_ptr past the copied bytes, and returns true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">397</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">bool store_and_advance(char *&buffer_ptr, char *buffer_end, const T& value,</td>
    <td class="lineNumber">398</td>
    <td class="codeline">bool store_and_advance(char *&buffer_ptr, char *buffer_end, const T& value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">                       size_t offset = 0) {</td>
    <td class="lineNumber">399</td>
    <td class="codeline">                       size_t offset = 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  size_t store_size = sizeof(value) - offset;</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  size_t store_size = sizeof(value) - offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">  if (buffer_ptr + store_size > buffer_end)</td>
    <td class="lineNumber">401</td>
    <td class="codeline">  if (buffer_ptr + store_size > buffer_end)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">402</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">  const char *value_data = reinterpret_cast<const char *>(&value);</td>
    <td class="lineNumber">403</td>
    <td class="codeline">  const char *value_data = reinterpret_cast<const char *>(&value);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  memcpy(buffer_ptr, value_data + offset, store_size);</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  memcpy(buffer_ptr, value_data + offset, store_size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  buffer_ptr += store_size;</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  buffer_ptr += store_size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">406</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">}</td>
    <td class="lineNumber">407</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline"></td>
    <td class="lineNumber">408</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">/// Implement the combining of integral values into a hash_code.</td>
    <td class="lineNumber">409</td>
    <td class="codeline">/// Implement the combining of integral values into a hash_code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">///</td>
    <td class="lineNumber">410</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">/// This overload is selected when the value type of the iterator is</td>
    <td class="lineNumber">411</td>
    <td class="codeline">/// This overload is selected when the value type of the iterator is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">/// integral. Rather than computing a hash_code for each object and then</td>
    <td class="lineNumber">412</td>
    <td class="codeline">/// integral. Rather than computing a hash_code for each object and then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">/// combining them, this (as an optimization) directly combines the integers.</td>
    <td class="lineNumber">413</td>
    <td class="codeline">/// combining them, this (as an optimization) directly combines the integers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">template <typename InputIteratorT></td>
    <td class="lineNumber">414</td>
    <td class="codeline">template <typename InputIteratorT></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine diffFirst">hash_code hash_combine_range_impl(InputIteratorT first, InputIteratorT last) {</td>
    <td class="lineNumber">415</td>
    <td class="codeline">hash_code hash_combine_range_impl(InputIteratorT first, InputIteratorT last) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine diffFirst">  const uint64_t seed = get_execution_seed();</td>
    <td class="lineNumber">416</td>
    <td class="codeline">  const uint64_t seed = get_execution_seed();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine diffFirst">  char buffer[64], *buffer_ptr = buffer;</td>
    <td class="lineNumber">417</td>
    <td class="codeline">  char buffer[64], *buffer_ptr = buffer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine diffFirst">  char *const buffer_end = std::end(buffer);</td>
    <td class="lineNumber">418</td>
    <td class="codeline">  char *const buffer_end = std::end(buffer);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine diffFirst">  while (first != last && store_and_advance(buffer_ptr, buffer_end,</td>
    <td class="lineNumber">419</td>
    <td class="codeline">  while (first != last && store_and_advance(buffer_ptr, buffer_end,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine diffFirst">                                            get_hashable_data(*first)))</td>
    <td class="lineNumber">420</td>
    <td class="codeline">                                            get_hashable_data(*first)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine diffFirst">    ++first;</td>
    <td class="lineNumber">421</td>
    <td class="codeline">    ++first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine diffFirst">  if (first == last)</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  if (first == last)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine diffFirst">    return hash_short(buffer, buffer_ptr - buffer, seed);</td>
    <td class="lineNumber">423</td>
    <td class="codeline">    return hash_short(buffer, buffer_ptr - buffer, seed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  assert(buffer_ptr == buffer_end);</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  assert(buffer_ptr == buffer_end);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
    <td class="lineNumber">425</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  hash_state state = state.create(buffer, seed);</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  hash_state state = state.create(buffer, seed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  size_t length = 64;</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  size_t length = 64;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  while (first != last) {</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  while (first != last) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">    // Fill up the buffer. We don't clear it, which re-mixes the last round</td>
    <td class="lineNumber">429</td>
    <td class="codeline">    // Fill up the buffer. We don't clear it, which re-mixes the last round</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">    // when only a partial 64-byte chunk is left.</td>
    <td class="lineNumber">430</td>
    <td class="codeline">    // when only a partial 64-byte chunk is left.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">    buffer_ptr = buffer;</td>
    <td class="lineNumber">431</td>
    <td class="codeline">    buffer_ptr = buffer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">    while (first != last && store_and_advance(buffer_ptr, buffer_end,</td>
    <td class="lineNumber">432</td>
    <td class="codeline">    while (first != last && store_and_advance(buffer_ptr, buffer_end,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">                                              get_hashable_data(*first)))</td>
    <td class="lineNumber">433</td>
    <td class="codeline">                                              get_hashable_data(*first)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">      ++first;</td>
    <td class="lineNumber">434</td>
    <td class="codeline">      ++first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline"></td>
    <td class="lineNumber">435</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">    // Rotate the buffer if we did a partial fill in order to simulate doing</td>
    <td class="lineNumber">436</td>
    <td class="codeline">    // Rotate the buffer if we did a partial fill in order to simulate doing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">    // a mix of the last 64-bytes. That is how the algorithm works when we</td>
    <td class="lineNumber">437</td>
    <td class="codeline">    // a mix of the last 64-bytes. That is how the algorithm works when we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">    // have a contiguous byte sequence, and we want to emulate that here.</td>
    <td class="lineNumber">438</td>
    <td class="codeline">    // have a contiguous byte sequence, and we want to emulate that here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">    std::rotate(buffer, buffer_ptr, buffer_end);</td>
    <td class="lineNumber">439</td>
    <td class="codeline">    std::rotate(buffer, buffer_ptr, buffer_end);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline"></td>
    <td class="lineNumber">440</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">    // Mix this chunk into the current state.</td>
    <td class="lineNumber">441</td>
    <td class="codeline">    // Mix this chunk into the current state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">    state.mix(buffer);</td>
    <td class="lineNumber">442</td>
    <td class="codeline">    state.mix(buffer);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">    length += buffer_ptr - buffer;</td>
    <td class="lineNumber">443</td>
    <td class="codeline">    length += buffer_ptr - buffer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">444</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline"></td>
    <td class="lineNumber">445</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">  return state.finalize(length);</td>
    <td class="lineNumber">446</td>
    <td class="codeline">  return state.finalize(length);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">}</td>
    <td class="lineNumber">447</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline"></td>
    <td class="lineNumber">448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">/// Implement the combining of integral values into a hash_code.</td>
    <td class="lineNumber">449</td>
    <td class="codeline">/// Implement the combining of integral values into a hash_code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">///</td>
    <td class="lineNumber">450</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">/// This overload is selected when the value type of the iterator is integral</td>
    <td class="lineNumber">451</td>
    <td class="codeline">/// This overload is selected when the value type of the iterator is integral</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">/// and when the input iterator is actually a pointer. Rather than computing</td>
    <td class="lineNumber">452</td>
    <td class="codeline">/// and when the input iterator is actually a pointer. Rather than computing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">/// a hash_code for each object and then combining them, this (as an</td>
    <td class="lineNumber">453</td>
    <td class="codeline">/// a hash_code for each object and then combining them, this (as an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">/// optimization) directly combines the integers. Also, because the integers</td>
    <td class="lineNumber">454</td>
    <td class="codeline">/// optimization) directly combines the integers. Also, because the integers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">/// are stored in contiguous memory, this routine avoids copying each value</td>
    <td class="lineNumber">455</td>
    <td class="codeline">/// are stored in contiguous memory, this routine avoids copying each value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">/// and directly reads from the underlying memory.</td>
    <td class="lineNumber">456</td>
    <td class="codeline">/// and directly reads from the underlying memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">template <typename ValueT></td>
    <td class="lineNumber">457</td>
    <td class="codeline">template <typename ValueT></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">std::enable_if_t<is_hashable_data<ValueT>::value, hash_code></td>
    <td class="lineNumber">458</td>
    <td class="codeline">std::enable_if_t<is_hashable_data<ValueT>::value, hash_code></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">hash_combine_range_impl(ValueT *first, ValueT *last) {</td>
    <td class="lineNumber">459</td>
    <td class="codeline">hash_combine_range_impl(ValueT *first, ValueT *last) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">  const uint64_t seed = get_execution_seed();</td>
    <td class="lineNumber">460</td>
    <td class="codeline">  const uint64_t seed = get_execution_seed();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">  const char *s_begin = reinterpret_cast<const char *>(first);</td>
    <td class="lineNumber">461</td>
    <td class="codeline">  const char *s_begin = reinterpret_cast<const char *>(first);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">  const char *s_end = reinterpret_cast<const char *>(last);</td>
    <td class="lineNumber">462</td>
    <td class="codeline">  const char *s_end = reinterpret_cast<const char *>(last);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">  const size_t length = std::distance(s_begin, s_end);</td>
    <td class="lineNumber">463</td>
    <td class="codeline">  const size_t length = std::distance(s_begin, s_end);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  if (length <= 64)</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  if (length <= 64)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">    return hash_short(s_begin, length, seed);</td>
    <td class="lineNumber">465</td>
    <td class="codeline">    return hash_short(s_begin, length, seed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  const char *s_aligned_end = s_begin + (length & ~63);</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  const char *s_aligned_end = s_begin + (length & ~63);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">  hash_state state = state.create(s_begin, seed);</td>
    <td class="lineNumber">468</td>
    <td class="codeline">  hash_state state = state.create(s_begin, seed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">  s_begin += 64;</td>
    <td class="lineNumber">469</td>
    <td class="codeline">  s_begin += 64;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">  while (s_begin != s_aligned_end) {</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  while (s_begin != s_aligned_end) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">    state.mix(s_begin);</td>
    <td class="lineNumber">471</td>
    <td class="codeline">    state.mix(s_begin);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">    s_begin += 64;</td>
    <td class="lineNumber">472</td>
    <td class="codeline">    s_begin += 64;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">473</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  if (length & 63)</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  if (length & 63)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">    state.mix(s_end - 64);</td>
    <td class="lineNumber">475</td>
    <td class="codeline">    state.mix(s_end - 64);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline"></td>
    <td class="lineNumber">476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  return state.finalize(length);</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  return state.finalize(length);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">}</td>
    <td class="lineNumber">478</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline"></td>
    <td class="lineNumber">479</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">} // namespace detail</td>
    <td class="lineNumber">480</td>
    <td class="codeline">} // namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">} // namespace hashing</td>
    <td class="lineNumber">481</td>
    <td class="codeline">} // namespace hashing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline"></td>
    <td class="lineNumber">482</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline"></td>
    <td class="lineNumber">483</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">/// Compute a hash_code for a sequence of values.</td>
    <td class="lineNumber">484</td>
    <td class="codeline">/// Compute a hash_code for a sequence of values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">///</td>
    <td class="lineNumber">485</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">/// This hashes a sequence of values. It produces the same hash_code as</td>
    <td class="lineNumber">486</td>
    <td class="codeline">/// This hashes a sequence of values. It produces the same hash_code as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">/// 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences</td>
    <td class="lineNumber">487</td>
    <td class="codeline">/// 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">/// and is significantly faster given pointers and types which can be hashed as</td>
    <td class="lineNumber">488</td>
    <td class="codeline">/// and is significantly faster given pointers and types which can be hashed as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">/// a sequence of bytes.</td>
    <td class="lineNumber">489</td>
    <td class="codeline">/// a sequence of bytes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">template <typename InputIteratorT></td>
    <td class="lineNumber">490</td>
    <td class="codeline">template <typename InputIteratorT></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">hash_code hash_combine_range(InputIteratorT first, InputIteratorT last) {</td>
    <td class="lineNumber">491</td>
    <td class="codeline">hash_code hash_combine_range(InputIteratorT first, InputIteratorT last) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">  return ::llvm::hashing::detail::hash_combine_range_impl(first, last);</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  return ::llvm::hashing::detail::hash_combine_range_impl(first, last);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">}</td>
    <td class="lineNumber">493</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline"></td>
    <td class="lineNumber">494</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline"></td>
    <td class="lineNumber">495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">// Implementation details for hash_combine.</td>
    <td class="lineNumber">496</td>
    <td class="codeline">// Implementation details for hash_combine.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">namespace hashing {</td>
    <td class="lineNumber">497</td>
    <td class="codeline">namespace hashing {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">498</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline"></td>
    <td class="lineNumber">499</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">/// Helper class to manage the recursive combining of hash_combine</td>
    <td class="lineNumber">500</td>
    <td class="codeline">/// Helper class to manage the recursive combining of hash_combine</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">/// arguments.</td>
    <td class="lineNumber">501</td>
    <td class="codeline">/// arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">///</td>
    <td class="lineNumber">502</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">/// This class exists to manage the state and various calls involved in the</td>
    <td class="lineNumber">503</td>
    <td class="codeline">/// This class exists to manage the state and various calls involved in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">/// recursive combining of arguments used in hash_combine. It is particularly</td>
    <td class="lineNumber">504</td>
    <td class="codeline">/// recursive combining of arguments used in hash_combine. It is particularly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">/// useful at minimizing the code in the recursive calls to ease the pain</td>
    <td class="lineNumber">505</td>
    <td class="codeline">/// useful at minimizing the code in the recursive calls to ease the pain</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">/// caused by a lack of variadic functions.</td>
    <td class="lineNumber">506</td>
    <td class="codeline">/// caused by a lack of variadic functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">struct hash_combine_recursive_helper {</td>
    <td class="lineNumber">507</td>
    <td class="codeline">struct hash_combine_recursive_helper {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  char buffer[64] = {};</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  char buffer[64] = {};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  hash_state state;</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  hash_state state;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">  const uint64_t seed;</td>
    <td class="lineNumber">510</td>
    <td class="codeline">  const uint64_t seed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline"></td>
    <td class="lineNumber">511</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">512</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">  /// Construct a recursive hash combining helper.</td>
    <td class="lineNumber">513</td>
    <td class="codeline">  /// Construct a recursive hash combining helper.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">514</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">  /// This sets up the state for a recursive hash combine, including getting</td>
    <td class="lineNumber">515</td>
    <td class="codeline">  /// This sets up the state for a recursive hash combine, including getting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">  /// the seed and buffer setup.</td>
    <td class="lineNumber">516</td>
    <td class="codeline">  /// the seed and buffer setup.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">  hash_combine_recursive_helper()</td>
    <td class="lineNumber">517</td>
    <td class="codeline">  hash_combine_recursive_helper()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">    : seed(get_execution_seed()) {}</td>
    <td class="lineNumber">518</td>
    <td class="codeline">    : seed(get_execution_seed()) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline"></td>
    <td class="lineNumber">519</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">  /// Combine one chunk of data into the current in-flight hash.</td>
    <td class="lineNumber">520</td>
    <td class="codeline">  /// Combine one chunk of data into the current in-flight hash.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">521</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">  /// This merges one chunk of data into the hash. First it tries to buffer</td>
    <td class="lineNumber">522</td>
    <td class="codeline">  /// This merges one chunk of data into the hash. First it tries to buffer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  /// the data. If the buffer is full, it hashes the buffer into its</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  /// the data. If the buffer is full, it hashes the buffer into its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">  /// hash_state, empties it, and then merges the new chunk in. This also</td>
    <td class="lineNumber">524</td>
    <td class="codeline">  /// hash_state, empties it, and then merges the new chunk in. This also</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  /// handles cases where the data straddles the end of the buffer.</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  /// handles cases where the data straddles the end of the buffer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">  template <typename T></td>
    <td class="lineNumber">526</td>
    <td class="codeline">  template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  char *combine_data(size_t &length, char *buffer_ptr, char *buffer_end, T data) {</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  char *combine_data(size_t &length, char *buffer_ptr, char *buffer_end, T data) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">    if (!store_and_advance(buffer_ptr, buffer_end, data)) {</td>
    <td class="lineNumber">528</td>
    <td class="codeline">    if (!store_and_advance(buffer_ptr, buffer_end, data)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">      // Check for skew which prevents the buffer from being packed, and do</td>
    <td class="lineNumber">529</td>
    <td class="codeline">      // Check for skew which prevents the buffer from being packed, and do</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">      // a partial store into the buffer to fill it. This is only a concern</td>
    <td class="lineNumber">530</td>
    <td class="codeline">      // a partial store into the buffer to fill it. This is only a concern</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">      // with the variadic combine because that formation can have varying</td>
    <td class="lineNumber">531</td>
    <td class="codeline">      // with the variadic combine because that formation can have varying</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">      // argument types.</td>
    <td class="lineNumber">532</td>
    <td class="codeline">      // argument types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">      size_t partial_store_size = buffer_end - buffer_ptr;</td>
    <td class="lineNumber">533</td>
    <td class="codeline">      size_t partial_store_size = buffer_end - buffer_ptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">      memcpy(buffer_ptr, &data, partial_store_size);</td>
    <td class="lineNumber">534</td>
    <td class="codeline">      memcpy(buffer_ptr, &data, partial_store_size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline"></td>
    <td class="lineNumber">535</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">      // If the store fails, our buffer is full and ready to hash. We have to</td>
    <td class="lineNumber">536</td>
    <td class="codeline">      // If the store fails, our buffer is full and ready to hash. We have to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">      // either initialize the hash state (on the first full buffer) or mix</td>
    <td class="lineNumber">537</td>
    <td class="codeline">      // either initialize the hash state (on the first full buffer) or mix</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">      // this buffer into the existing hash state. Length tracks the *hashed*</td>
    <td class="lineNumber">538</td>
    <td class="codeline">      // this buffer into the existing hash state. Length tracks the *hashed*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">      // length, not the buffered length.</td>
    <td class="lineNumber">539</td>
    <td class="codeline">      // length, not the buffered length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">      if (length == 0) {</td>
    <td class="lineNumber">540</td>
    <td class="codeline">      if (length == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">        state = state.create(buffer, seed);</td>
    <td class="lineNumber">541</td>
    <td class="codeline">        state = state.create(buffer, seed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">        length = 64;</td>
    <td class="lineNumber">542</td>
    <td class="codeline">        length = 64;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">543</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">        // Mix this chunk into the current state and bump length up by 64.</td>
    <td class="lineNumber">544</td>
    <td class="codeline">        // Mix this chunk into the current state and bump length up by 64.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">        state.mix(buffer);</td>
    <td class="lineNumber">545</td>
    <td class="codeline">        state.mix(buffer);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">        length += 64;</td>
    <td class="lineNumber">546</td>
    <td class="codeline">        length += 64;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">547</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">      // Reset the buffer_ptr to the head of the buffer for the next chunk of</td>
    <td class="lineNumber">548</td>
    <td class="codeline">      // Reset the buffer_ptr to the head of the buffer for the next chunk of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">      // data.</td>
    <td class="lineNumber">549</td>
    <td class="codeline">      // data.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">      buffer_ptr = buffer;</td>
    <td class="lineNumber">550</td>
    <td class="codeline">      buffer_ptr = buffer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline"></td>
    <td class="lineNumber">551</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">      // Try again to store into the buffer -- this cannot fail as we only</td>
    <td class="lineNumber">552</td>
    <td class="codeline">      // Try again to store into the buffer -- this cannot fail as we only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">      // store types smaller than the buffer.</td>
    <td class="lineNumber">553</td>
    <td class="codeline">      // store types smaller than the buffer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">      if (!store_and_advance(buffer_ptr, buffer_end, data,</td>
    <td class="lineNumber">554</td>
    <td class="codeline">      if (!store_and_advance(buffer_ptr, buffer_end, data,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">                             partial_store_size))</td>
    <td class="lineNumber">555</td>
    <td class="codeline">                             partial_store_size))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">        llvm_unreachable("buffer smaller than stored type");</td>
    <td class="lineNumber">556</td>
    <td class="codeline">        llvm_unreachable("buffer smaller than stored type");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">557</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">    return buffer_ptr;</td>
    <td class="lineNumber">558</td>
    <td class="codeline">    return buffer_ptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">559</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline"></td>
    <td class="lineNumber">560</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">  /// Recursive, variadic combining method.</td>
    <td class="lineNumber">561</td>
    <td class="codeline">  /// Recursive, variadic combining method.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">562</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  /// This function recurses through each argument, combining that argument</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  /// This function recurses through each argument, combining that argument</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">  /// into a single hash.</td>
    <td class="lineNumber">564</td>
    <td class="codeline">  /// into a single hash.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">  template <typename T, typename ...Ts></td>
    <td class="lineNumber">565</td>
    <td class="codeline">  template <typename T, typename ...Ts></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end,</td>
    <td class="lineNumber">566</td>
    <td class="codeline">  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">                    const T &arg, const Ts &...args) {</td>
    <td class="lineNumber">567</td>
    <td class="codeline">                    const T &arg, const Ts &...args) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">    buffer_ptr = combine_data(length, buffer_ptr, buffer_end, get_hashable_data(arg));</td>
    <td class="lineNumber">568</td>
    <td class="codeline">    buffer_ptr = combine_data(length, buffer_ptr, buffer_end, get_hashable_data(arg));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline"></td>
    <td class="lineNumber">569</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">    // Recurse to the next argument.</td>
    <td class="lineNumber">570</td>
    <td class="codeline">    // Recurse to the next argument.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">    return combine(length, buffer_ptr, buffer_end, args...);</td>
    <td class="lineNumber">571</td>
    <td class="codeline">    return combine(length, buffer_ptr, buffer_end, args...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">572</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline"></td>
    <td class="lineNumber">573</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">  /// Base case for recursive, variadic combining.</td>
    <td class="lineNumber">574</td>
    <td class="codeline">  /// Base case for recursive, variadic combining.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">575</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  /// The base case when combining arguments recursively is reached when all</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  /// The base case when combining arguments recursively is reached when all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  /// arguments have been handled. It flushes the remaining buffer and</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  /// arguments have been handled. It flushes the remaining buffer and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">  /// constructs a hash_code.</td>
    <td class="lineNumber">578</td>
    <td class="codeline">  /// constructs a hash_code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end) {</td>
    <td class="lineNumber">579</td>
    <td class="codeline">  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">    // Check whether the entire set of values fit in the buffer. If so, we'll</td>
    <td class="lineNumber">580</td>
    <td class="codeline">    // Check whether the entire set of values fit in the buffer. If so, we'll</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">    // use the optimized short hashing routine and skip state entirely.</td>
    <td class="lineNumber">581</td>
    <td class="codeline">    // use the optimized short hashing routine and skip state entirely.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">    if (length == 0)</td>
    <td class="lineNumber">582</td>
    <td class="codeline">    if (length == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">      return hash_short(buffer, buffer_ptr - buffer, seed);</td>
    <td class="lineNumber">583</td>
    <td class="codeline">      return hash_short(buffer, buffer_ptr - buffer, seed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline"></td>
    <td class="lineNumber">584</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">    // Mix the final buffer, rotating it if we did a partial fill in order to</td>
    <td class="lineNumber">585</td>
    <td class="codeline">    // Mix the final buffer, rotating it if we did a partial fill in order to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">    // simulate doing a mix of the last 64-bytes. That is how the algorithm</td>
    <td class="lineNumber">586</td>
    <td class="codeline">    // simulate doing a mix of the last 64-bytes. That is how the algorithm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">    // works when we have a contiguous byte sequence, and we want to emulate</td>
    <td class="lineNumber">587</td>
    <td class="codeline">    // works when we have a contiguous byte sequence, and we want to emulate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">    // that here.</td>
    <td class="lineNumber">588</td>
    <td class="codeline">    // that here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">    std::rotate(buffer, buffer_ptr, buffer_end);</td>
    <td class="lineNumber">589</td>
    <td class="codeline">    std::rotate(buffer, buffer_ptr, buffer_end);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">    // Mix this chunk into the current state.</td>
    <td class="lineNumber">591</td>
    <td class="codeline">    // Mix this chunk into the current state.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">    state.mix(buffer);</td>
    <td class="lineNumber">592</td>
    <td class="codeline">    state.mix(buffer);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    length += buffer_ptr - buffer;</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    length += buffer_ptr - buffer;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline"></td>
    <td class="lineNumber">594</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">    return state.finalize(length);</td>
    <td class="lineNumber">595</td>
    <td class="codeline">    return state.finalize(length);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">};</td>
    <td class="lineNumber">597</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline"></td>
    <td class="lineNumber">598</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">} // namespace detail</td>
    <td class="lineNumber">599</td>
    <td class="codeline">} // namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">} // namespace hashing</td>
    <td class="lineNumber">600</td>
    <td class="codeline">} // namespace hashing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline"></td>
    <td class="lineNumber">601</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">/// Combine values into a single hash_code.</td>
    <td class="lineNumber">602</td>
    <td class="codeline">/// Combine values into a single hash_code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">///</td>
    <td class="lineNumber">603</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">/// This routine accepts a varying number of arguments of any type. It will</td>
    <td class="lineNumber">604</td>
    <td class="codeline">/// This routine accepts a varying number of arguments of any type. It will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">/// attempt to combine them into a single hash_code. For user-defined types it</td>
    <td class="lineNumber">605</td>
    <td class="codeline">/// attempt to combine them into a single hash_code. For user-defined types it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">/// attempts to call a \see hash_value overload (via ADL) for the type. For</td>
    <td class="lineNumber">606</td>
    <td class="codeline">/// attempts to call a \see hash_value overload (via ADL) for the type. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">/// integer and pointer types it directly combines their data into the</td>
    <td class="lineNumber">607</td>
    <td class="codeline">/// integer and pointer types it directly combines their data into the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">/// resulting hash_code.</td>
    <td class="lineNumber">608</td>
    <td class="codeline">/// resulting hash_code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">///</td>
    <td class="lineNumber">609</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">/// The result is suitable for returning from a user's hash_value</td>
    <td class="lineNumber">610</td>
    <td class="codeline">/// The result is suitable for returning from a user's hash_value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">/// *implementation* for their user-defined type. Consumers of a type should</td>
    <td class="lineNumber">611</td>
    <td class="codeline">/// *implementation* for their user-defined type. Consumers of a type should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">/// *not* call this routine, they should instead call 'hash_value'.</td>
    <td class="lineNumber">612</td>
    <td class="codeline">/// *not* call this routine, they should instead call 'hash_value'.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">template <typename ...Ts> hash_code hash_combine(const Ts &...args) {</td>
    <td class="lineNumber">613</td>
    <td class="codeline">template <typename ...Ts> hash_code hash_combine(const Ts &...args) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">  // Recursively hash each argument using a helper class.</td>
    <td class="lineNumber">614</td>
    <td class="codeline">  // Recursively hash each argument using a helper class.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  ::llvm::hashing::detail::hash_combine_recursive_helper helper;</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  ::llvm::hashing::detail::hash_combine_recursive_helper helper;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  return helper.combine(0, helper.buffer, helper.buffer + 64, args...);</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  return helper.combine(0, helper.buffer, helper.buffer + 64, args...);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">}</td>
    <td class="lineNumber">617</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">// Implementation details for implementations of hash_value overloads provided</td>
    <td class="lineNumber">619</td>
    <td class="codeline">// Implementation details for implementations of hash_value overloads provided</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">// here.</td>
    <td class="lineNumber">620</td>
    <td class="codeline">// here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">namespace hashing {</td>
    <td class="lineNumber">621</td>
    <td class="codeline">namespace hashing {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">namespace detail {</td>
    <td class="lineNumber">622</td>
    <td class="codeline">namespace detail {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline"></td>
    <td class="lineNumber">623</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">/// Helper to hash the value of a single integer.</td>
    <td class="lineNumber">624</td>
    <td class="codeline">/// Helper to hash the value of a single integer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">///</td>
    <td class="lineNumber">625</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">/// Overloads for smaller integer types are not provided to ensure consistent</td>
    <td class="lineNumber">626</td>
    <td class="codeline">/// Overloads for smaller integer types are not provided to ensure consistent</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">/// behavior in the presence of integral promotions. Essentially,</td>
    <td class="lineNumber">627</td>
    <td class="codeline">/// behavior in the presence of integral promotions. Essentially,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">/// "hash_value('4')" and "hash_value('0' + 4)" should be the same.</td>
    <td class="lineNumber">628</td>
    <td class="codeline">/// "hash_value('4')" and "hash_value('0' + 4)" should be the same.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">inline hash_code hash_integer_value(uint64_t value) {</td>
    <td class="lineNumber">629</td>
    <td class="codeline">inline hash_code hash_integer_value(uint64_t value) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">  // Similar to hash_4to8_bytes but using a seed instead of length.</td>
    <td class="lineNumber">630</td>
    <td class="codeline">  // Similar to hash_4to8_bytes but using a seed instead of length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">  const uint64_t seed = get_execution_seed();</td>
    <td class="lineNumber">631</td>
    <td class="codeline">  const uint64_t seed = get_execution_seed();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  const char *s = reinterpret_cast<const char *>(&value);</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  const char *s = reinterpret_cast<const char *>(&value);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  const uint64_t a = fetch32(s);</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  const uint64_t a = fetch32(s);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  return hash_16_bytes(seed + (a << 3), fetch32(s + 4));</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  return hash_16_bytes(seed + (a << 3), fetch32(s + 4));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">}</td>
    <td class="lineNumber">635</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline"></td>
    <td class="lineNumber">636</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">} // namespace detail</td>
    <td class="lineNumber">637</td>
    <td class="codeline">} // namespace detail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">} // namespace hashing</td>
    <td class="lineNumber">638</td>
    <td class="codeline">} // namespace hashing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline"></td>
    <td class="lineNumber">639</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">// Declared and documented above, but defined here so that any of the hashing</td>
    <td class="lineNumber">640</td>
    <td class="codeline">// Declared and documented above, but defined here so that any of the hashing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">// infrastructure is available.</td>
    <td class="lineNumber">641</td>
    <td class="codeline">// infrastructure is available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">642</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value) {</td>
    <td class="lineNumber">643</td>
    <td class="codeline">std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">  return ::llvm::hashing::detail::hash_integer_value(</td>
    <td class="lineNumber">644</td>
    <td class="codeline">  return ::llvm::hashing::detail::hash_integer_value(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">      static_cast<uint64_t>(value));</td>
    <td class="lineNumber">645</td>
    <td class="codeline">      static_cast<uint64_t>(value));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">}</td>
    <td class="lineNumber">646</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline"></td>
    <td class="lineNumber">647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">// Declared and documented above, but defined here so that any of the hashing</td>
    <td class="lineNumber">648</td>
    <td class="codeline">// Declared and documented above, but defined here so that any of the hashing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">// infrastructure is available.</td>
    <td class="lineNumber">649</td>
    <td class="codeline">// infrastructure is available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">template <typename T> hash_code hash_value(const T *ptr) {</td>
    <td class="lineNumber">650</td>
    <td class="codeline">template <typename T> hash_code hash_value(const T *ptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  return ::llvm::hashing::detail::hash_integer_value(</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  return ::llvm::hashing::detail::hash_integer_value(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">    reinterpret_cast<uintptr_t>(ptr));</td>
    <td class="lineNumber">652</td>
    <td class="codeline">    reinterpret_cast<uintptr_t>(ptr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">}</td>
    <td class="lineNumber">653</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline"></td>
    <td class="lineNumber">654</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">// Declared and documented above, but defined here so that any of the hashing</td>
    <td class="lineNumber">655</td>
    <td class="codeline">// Declared and documented above, but defined here so that any of the hashing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">// infrastructure is available.</td>
    <td class="lineNumber">656</td>
    <td class="codeline">// infrastructure is available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">template <typename T, typename U></td>
    <td class="lineNumber">657</td>
    <td class="codeline">template <typename T, typename U></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">hash_code hash_value(const std::pair<T, U> &arg) {</td>
    <td class="lineNumber">658</td>
    <td class="codeline">hash_code hash_value(const std::pair<T, U> &arg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">  return hash_combine(arg.first, arg.second);</td>
    <td class="lineNumber">659</td>
    <td class="codeline">  return hash_combine(arg.first, arg.second);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">}</td>
    <td class="lineNumber">660</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline"></td>
    <td class="lineNumber">661</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">template <typename... Ts> hash_code hash_value(const std::tuple<Ts...> &arg) {</td>
    <td class="lineNumber">662</td>
    <td class="codeline">template <typename... Ts> hash_code hash_value(const std::tuple<Ts...> &arg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">  return std::apply([](const auto &...xs) { return hash_combine(xs...); }, arg);</td>
    <td class="lineNumber">663</td>
    <td class="codeline">  return std::apply([](const auto &...xs) { return hash_combine(xs...); }, arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">}</td>
    <td class="lineNumber">664</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline"></td>
    <td class="lineNumber">665</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">// Declared and documented above, but defined here so that any of the hashing</td>
    <td class="lineNumber">666</td>
    <td class="codeline">// Declared and documented above, but defined here so that any of the hashing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">// infrastructure is available.</td>
    <td class="lineNumber">667</td>
    <td class="codeline">// infrastructure is available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">668</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">hash_code hash_value(const std::basic_string<T> &arg) {</td>
    <td class="lineNumber">669</td>
    <td class="codeline">hash_code hash_value(const std::basic_string<T> &arg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">  return hash_combine_range(arg.begin(), arg.end());</td>
    <td class="lineNumber">670</td>
    <td class="codeline">  return hash_combine_range(arg.begin(), arg.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">}</td>
    <td class="lineNumber">671</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">template <typename T> hash_code hash_value(const std::optional<T> &arg) {</td>
    <td class="lineNumber">673</td>
    <td class="codeline">template <typename T> hash_code hash_value(const std::optional<T> &arg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  return arg ? hash_combine(true, *arg) : hash_value(false);</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  return arg ? hash_combine(true, *arg) : hash_value(false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">}</td>
    <td class="lineNumber">675</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">template <> struct DenseMapInfo<hash_code, void> {</td>
    <td class="lineNumber">677</td>
    <td class="codeline">template <> struct DenseMapInfo<hash_code, void> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">  static inline hash_code getEmptyKey() { return hash_code(-1); }</td>
    <td class="lineNumber">678</td>
    <td class="codeline">  static inline hash_code getEmptyKey() { return hash_code(-1); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  static inline hash_code getTombstoneKey() { return hash_code(-2); }</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  static inline hash_code getTombstoneKey() { return hash_code(-2); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">  static unsigned getHashValue(hash_code val) { return val; }</td>
    <td class="lineNumber">680</td>
    <td class="codeline">  static unsigned getHashValue(hash_code val) { return val; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">  static bool isEqual(hash_code LHS, hash_code RHS) { return LHS == RHS; }</td>
    <td class="lineNumber">681</td>
    <td class="codeline">  static bool isEqual(hash_code LHS, hash_code RHS) { return LHS == RHS; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">};</td>
    <td class="lineNumber">682</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">} // namespace llvm</td>
    <td class="lineNumber">684</td>
    <td class="codeline">} // namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">686</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline"></td>
    <td class="lineNumber">687</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- llvm/ADT/Hashing.h - Utilities for hashing --------------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file implements the newly proposed standard C++ interfaces for hashing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file implements the newly proposed standard C++ interfaces for hashing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// arbitrary data and building hash functions for user-defined types. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// arbitrary data and building hash functions for user-defined types. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">// interface was originally proposed in N3333[1] and is currently under review</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">// interface was originally proposed in N3333[1] and is currently under review</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">// for inclusion in a future TR and/or standard.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">// for inclusion in a future TR and/or standard.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">// The primary interfaces provide are comprised of one type and three functions:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">// The primary interfaces provide are comprised of one type and three functions:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">//  -- 'hash_code' class is an opaque type representing the hash code for some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">//  -- 'hash_code' class is an opaque type representing the hash code for some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">//     data. It is the intended product of hashing, and can be used to implement</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">//     data. It is the intended product of hashing, and can be used to implement</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">//     hash tables, checksumming, and other common uses of hashes. It is not an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">//     hash tables, checksumming, and other common uses of hashes. It is not an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">//     integer type (although it can be converted to one) because it is risky</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">//     integer type (although it can be converted to one) because it is risky</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">//     to assume much about the internals of a hash_code. In particular, each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">//     to assume much about the internals of a hash_code. In particular, each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">//     execution of the program has a high probability of producing a different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">//     execution of the program has a high probability of producing a different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">//     hash_code for a given input. Thus their values are not stable to save or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">//     hash_code for a given input. Thus their values are not stable to save or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">//     persist, and should only be used during the execution for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">//     persist, and should only be used during the execution for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">//     construction of hashing datastructures.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">//     construction of hashing datastructures.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">//  -- 'hash_value' is a function designed to be overloaded for each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">//  -- 'hash_value' is a function designed to be overloaded for each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">//     user-defined type which wishes to be used within a hashing context. It</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">//     user-defined type which wishes to be used within a hashing context. It</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">//     should be overloaded within the user-defined type's namespace and found</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">//     should be overloaded within the user-defined type's namespace and found</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">//     via ADL. Overloads for primitive types are provided by this library.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">//     via ADL. Overloads for primitive types are provided by this library.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">//  -- 'hash_combine' and 'hash_combine_range' are functions designed to aid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">//  -- 'hash_combine' and 'hash_combine_range' are functions designed to aid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">//      programmers in easily and intuitively combining a set of data into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">//      programmers in easily and intuitively combining a set of data into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">//      a single hash_code for their object. They should only logically be used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">//      a single hash_code for their object. They should only logically be used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">//      within the implementation of a 'hash_value' routine or similar context.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">//      within the implementation of a 'hash_value' routine or similar context.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">// Note that 'hash_combine_range' contains very special logic for hashing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">// Note that 'hash_combine_range' contains very special logic for hashing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">// a contiguous array of integers or pointers. This logic is *extremely* fast,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">// a contiguous array of integers or pointers. This logic is *extremely* fast,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">// on a modern Intel "Gainestown" Xeon (Nehalem uarch) @2.2 GHz, these were</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">// on a modern Intel "Gainestown" Xeon (Nehalem uarch) @2.2 GHz, these were</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">// benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">// benchmarked at over 6.5 GiB/s for large keys, and <20 cycles/hash for keys</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">// under 32-bytes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">// under 32-bytes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#ifndef LLVM_ADT_HASHING_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#ifndef LLVM_ADT_HASHING_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">#define LLVM_ADT_HASHING_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">#define LLVM_ADT_HASHING_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/Support/DataTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/Support/DataTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/Support/SwapByteOrder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/Support/SwapByteOrder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/Support/type_traits.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/Support/type_traits.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">#include <cstring></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">#include <cstring></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">#include <string></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">#include <string></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">template <typename T, typename Enable> struct DenseMapInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">template <typename T, typename Enable> struct DenseMapInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">/// An opaque object representing a hash code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">/// An opaque object representing a hash code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">/// This object represents the result of hashing some entity. It is intended to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">/// This object represents the result of hashing some entity. It is intended to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">/// be used to implement hashtables or other hashing-based data structures.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">/// be used to implement hashtables or other hashing-based data structures.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">/// While it wraps and exposes a numeric value, this value should not be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">/// While it wraps and exposes a numeric value, this value should not be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">/// trusted to be stable or predictable across processes or executions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">/// trusted to be stable or predictable across processes or executions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">/// In order to obtain the hash_code for an object 'x':</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">/// In order to obtain the hash_code for an object 'x':</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">/// \code</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">/// \code</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">///   using llvm::hash_value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">///   using llvm::hash_value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">///   llvm::hash_code code = hash_value(x);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">///   llvm::hash_code code = hash_value(x);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">/// \endcode</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">/// \endcode</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">class hash_code {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">class hash_code {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">  size_t value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">  size_t value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">  /// Default construct a hash_code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">  /// Default construct a hash_code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">  /// Note that this leaves the value uninitialized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">  /// Note that this leaves the value uninitialized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">  hash_code() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">  hash_code() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">  /// Form a hash code directly from a numerical value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">  /// Form a hash code directly from a numerical value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine coveredLine">  hash_code(size_t value) : value(value) {}</td>
    <td class="lineNumber">934</td>
    <td class="lineNumber">83</td>
    <td class="codeLine coveredLine">  hash_code(size_t value) : value(value) {}</td>
    <td class="lineNumber">765</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">  /// Convert the hash code to its numerical value for use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">  /// Convert the hash code to its numerical value for use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine coveredLine">  /*explicit*/ operator size_t() const { return value; }</td>
    <td class="lineNumber">927</td>
    <td class="lineNumber">86</td>
    <td class="codeLine coveredLine">  /*explicit*/ operator size_t() const { return value; }</td>
    <td class="lineNumber">762</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">  friend bool operator==(const hash_code &lhs, const hash_code &rhs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">  friend bool operator==(const hash_code &lhs, const hash_code &rhs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">    return lhs.value == rhs.value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">    return lhs.value == rhs.value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">  friend bool operator!=(const hash_code &lhs, const hash_code &rhs) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">  friend bool operator!=(const hash_code &lhs, const hash_code &rhs) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">    return lhs.value != rhs.value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">    return lhs.value != rhs.value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">  /// Allow a hash_code to be directly run through hash_value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">  /// Allow a hash_code to be directly run through hash_value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine coveredLine">  friend size_t hash_value(const hash_code &code) { return code.value; }</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">96</td>
    <td class="codeLine coveredLine">  friend size_t hash_value(const hash_code &code) { return code.value; }</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">/// Compute a hash_code for any integer value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">/// Compute a hash_code for any integer value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">/// Note that this function is intended to compute the same hash_code for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">/// Note that this function is intended to compute the same hash_code for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">/// a particular value without regard to the pre-promotion type. This is in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">/// a particular value without regard to the pre-promotion type. This is in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">/// contrast to hash_combine which may produce different hash_codes for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">/// contrast to hash_combine which may produce different hash_codes for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">/// differing argument types even if they would implicit promote to a common</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">/// differing argument types even if they would implicit promote to a common</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">/// type without changing the value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">/// type without changing the value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">/// Compute a hash_code for a pointer's address.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">/// Compute a hash_code for a pointer's address.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">/// N.B.: This hashes the *address*. Not the value and not the type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">/// N.B.: This hashes the *address*. Not the value and not the type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">template <typename T> hash_code hash_value(const T *ptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">template <typename T> hash_code hash_value(const T *ptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">/// Compute a hash_code for a pair of objects.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">/// Compute a hash_code for a pair of objects.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">template <typename T, typename U></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">template <typename T, typename U></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">hash_code hash_value(const std::pair<T, U> &arg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">hash_code hash_value(const std::pair<T, U> &arg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">/// Compute a hash_code for a tuple.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">/// Compute a hash_code for a tuple.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">template <typename... Ts></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">template <typename... Ts></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">hash_code hash_value(const std::tuple<Ts...> &arg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">hash_code hash_value(const std::tuple<Ts...> &arg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">/// Compute a hash_code for a standard string.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">/// Compute a hash_code for a standard string.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">hash_code hash_value(const std::basic_string<T> &arg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">hash_code hash_value(const std::basic_string<T> &arg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">/// Compute a hash_code for a standard string.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">/// Compute a hash_code for a standard string.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">template <typename T> hash_code hash_value(const std::optional<T> &arg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">template <typename T> hash_code hash_value(const std::optional<T> &arg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">/// Override the execution seed with a fixed value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">/// Override the execution seed with a fixed value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">/// This hashing library uses a per-execution seed designed to change on each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">/// This hashing library uses a per-execution seed designed to change on each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">/// run with high probability in order to ensure that the hash codes are not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">/// run with high probability in order to ensure that the hash codes are not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">/// attackable and to ensure that output which is intended to be stable does</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">/// attackable and to ensure that output which is intended to be stable does</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">/// not rely on the particulars of the hash codes produced.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">/// not rely on the particulars of the hash codes produced.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">/// That said, there are use cases where it is important to be able to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">/// That said, there are use cases where it is important to be able to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">/// reproduce *exactly* a specific behavior. To that end, we provide a function</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">/// reproduce *exactly* a specific behavior. To that end, we provide a function</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">/// which will forcibly set the seed to a fixed value. This must be done at the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">/// which will forcibly set the seed to a fixed value. This must be done at the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">/// start of the program, before any hashes are computed. Also, it cannot be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">/// start of the program, before any hashes are computed. Also, it cannot be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">/// undone. This makes it thread-hostile and very hard to use outside of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">/// undone. This makes it thread-hostile and very hard to use outside of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">/// immediately on start of a simple program designed for reproducible</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">/// immediately on start of a simple program designed for reproducible</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">/// behavior.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">/// behavior.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">void set_fixed_execution_hash_seed(uint64_t fixed_value);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">void set_fixed_execution_hash_seed(uint64_t fixed_value);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">// All of the implementation details of actually computing the various hash</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">// All of the implementation details of actually computing the various hash</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">// code values are held within this namespace. These routines are included in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">// code values are held within this namespace. These routines are included in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">// the header file mainly to allow inlining and constant propagation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">// the header file mainly to allow inlining and constant propagation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">namespace hashing {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">namespace hashing {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine coveredLine">inline uint64_t fetch64(const char *p) {</td>
    <td class="lineNumber">8172</td>
    <td class="lineNumber">152</td>
    <td class="codeLine coveredLine">inline uint64_t fetch64(const char *p) {</td>
    <td class="lineNumber">7628</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">  uint64_t result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">  uint64_t result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine coveredLine">  memcpy(&result, p, sizeof(result));</td>
    <td class="lineNumber">8172</td>
    <td class="lineNumber">154</td>
    <td class="codeLine coveredLine">  memcpy(&result, p, sizeof(result));</td>
    <td class="lineNumber">7628</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">  if (sys::IsBigEndianHost)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">  if (sys::IsBigEndianHost)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">    sys::swapByteOrder(result);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">    sys::swapByteOrder(result);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine coveredLine">  return result;</td>
    <td class="lineNumber">8172</td>
    <td class="lineNumber">157</td>
    <td class="codeLine coveredLine">  return result;</td>
    <td class="lineNumber">7628</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine coveredLine">inline uint32_t fetch32(const char *p) {</td>
    <td class="lineNumber">274</td>
    <td class="lineNumber">160</td>
    <td class="codeLine coveredLine">inline uint32_t fetch32(const char *p) {</td>
    <td class="lineNumber">162</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">  uint32_t result;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">  uint32_t result;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine coveredLine">  memcpy(&result, p, sizeof(result));</td>
    <td class="lineNumber">274</td>
    <td class="lineNumber">162</td>
    <td class="codeLine coveredLine">  memcpy(&result, p, sizeof(result));</td>
    <td class="lineNumber">162</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">  if (sys::IsBigEndianHost)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">  if (sys::IsBigEndianHost)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">    sys::swapByteOrder(result);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">    sys::swapByteOrder(result);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine coveredLine">  return result;</td>
    <td class="lineNumber">274</td>
    <td class="lineNumber">165</td>
    <td class="codeLine coveredLine">  return result;</td>
    <td class="lineNumber">162</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">/// Some primes between 2^63 and 2^64 for various uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">/// Some primes between 2^63 and 2^64 for various uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">static constexpr uint64_t k0 = 0xc3a5c85c97cb3127ULL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">static constexpr uint64_t k0 = 0xc3a5c85c97cb3127ULL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">static constexpr uint64_t k1 = 0xb492b66fbe98f273ULL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">static constexpr uint64_t k1 = 0xb492b66fbe98f273ULL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">static constexpr uint64_t k2 = 0x9ae16a3b2f90404fULL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">static constexpr uint64_t k2 = 0x9ae16a3b2f90404fULL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">static constexpr uint64_t k3 = 0xc949d7c7509e6557ULL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">static constexpr uint64_t k3 = 0xc949d7c7509e6557ULL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">/// Bitwise right rotate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">/// Bitwise right rotate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">/// Normally this will compile to a single instruction, especially if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">/// Normally this will compile to a single instruction, especially if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">/// shift is a manifest constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">/// shift is a manifest constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine coveredLine">inline uint64_t rotate(uint64_t val, size_t shift) {</td>
    <td class="lineNumber">361</td>
    <td class="lineNumber">177</td>
    <td class="codeLine coveredLine">inline uint64_t rotate(uint64_t val, size_t shift) {</td>
    <td class="lineNumber">332</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  // Avoid shifting by 64: doing so yields an undefined result.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  // Avoid shifting by 64: doing so yields an undefined result.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine coveredLine">  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));</td>
    <td class="lineNumber">361</td>
    <td class="lineNumber">179</td>
    <td class="codeLine coveredLine">  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));</td>
    <td class="lineNumber">332</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine coveredLine">inline uint64_t shift_mix(uint64_t val) {</td>
    <td class="lineNumber">618</td>
    <td class="lineNumber">182</td>
    <td class="codeLine coveredLine">inline uint64_t shift_mix(uint64_t val) {</td>
    <td class="lineNumber">570</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine coveredLine">  return val ^ (val >> 47);</td>
    <td class="lineNumber">618</td>
    <td class="lineNumber">183</td>
    <td class="codeLine coveredLine">  return val ^ (val >> 47);</td>
    <td class="lineNumber">570</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine coveredLine">inline uint64_t hash_16_bytes(uint64_t low, uint64_t high) {</td>
    <td class="lineNumber">1345</td>
    <td class="lineNumber">186</td>
    <td class="codeLine coveredLine">inline uint64_t hash_16_bytes(uint64_t low, uint64_t high) {</td>
    <td class="lineNumber">1193</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">  // Murmur-inspired hashing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">  // Murmur-inspired hashing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine coveredLine">  const uint64_t kMul = 0x9ddfea08eb382d69ULL;</td>
    <td class="lineNumber">1345</td>
    <td class="lineNumber">188</td>
    <td class="codeLine coveredLine">  const uint64_t kMul = 0x9ddfea08eb382d69ULL;</td>
    <td class="lineNumber">1193</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine coveredLine">  uint64_t a = (low ^ high) * kMul;</td>
    <td class="lineNumber">1345</td>
    <td class="lineNumber">189</td>
    <td class="codeLine coveredLine">  uint64_t a = (low ^ high) * kMul;</td>
    <td class="lineNumber">1193</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine coveredLine">  a ^= (a >> 47);</td>
    <td class="lineNumber">1345</td>
    <td class="lineNumber">190</td>
    <td class="codeLine coveredLine">  a ^= (a >> 47);</td>
    <td class="lineNumber">1193</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine coveredLine">  uint64_t b = (high ^ a) * kMul;</td>
    <td class="lineNumber">1345</td>
    <td class="lineNumber">191</td>
    <td class="codeLine coveredLine">  uint64_t b = (high ^ a) * kMul;</td>
    <td class="lineNumber">1193</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine coveredLine">  b ^= (b >> 47);</td>
    <td class="lineNumber">1345</td>
    <td class="lineNumber">192</td>
    <td class="codeLine coveredLine">  b ^= (b >> 47);</td>
    <td class="lineNumber">1193</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine coveredLine">  b *= kMul;</td>
    <td class="lineNumber">1345</td>
    <td class="lineNumber">193</td>
    <td class="codeLine coveredLine">  b *= kMul;</td>
    <td class="lineNumber">1193</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine coveredLine">  return b;</td>
    <td class="lineNumber">1345</td>
    <td class="lineNumber">194</td>
    <td class="codeLine coveredLine">  return b;</td>
    <td class="lineNumber">1193</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">inline uint64_t hash_1to3_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">inline uint64_t hash_1to3_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">  uint8_t a = s[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">  uint8_t a = s[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">  uint8_t b = s[len >> 1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">  uint8_t b = s[len >> 1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">  uint8_t c = s[len - 1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">  uint8_t c = s[len - 1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">  uint32_t y = static_cast<uint32_t>(a) + (static_cast<uint32_t>(b) << 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">  uint32_t y = static_cast<uint32_t>(a) + (static_cast<uint32_t>(b) << 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">  uint32_t z = static_cast<uint32_t>(len) + (static_cast<uint32_t>(c) << 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">  uint32_t z = static_cast<uint32_t>(len) + (static_cast<uint32_t>(c) << 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">  return shift_mix(y * k2 ^ z * k3 ^ seed) * k2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">  return shift_mix(y * k2 ^ z * k3 ^ seed) * k2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine coveredLine">inline uint64_t hash_4to8_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">137</td>
    <td class="lineNumber">206</td>
    <td class="codeLine coveredLine">inline uint64_t hash_4to8_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">81</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine coveredLine">  uint64_t a = fetch32(s);</td>
    <td class="lineNumber">137</td>
    <td class="lineNumber">207</td>
    <td class="codeLine coveredLine">  uint64_t a = fetch32(s);</td>
    <td class="lineNumber">81</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine coveredLine">  return hash_16_bytes(len + (a << 3), seed ^ fetch32(s + len - 4));</td>
    <td class="lineNumber">137</td>
    <td class="lineNumber">208</td>
    <td class="codeLine coveredLine">  return hash_16_bytes(len + (a << 3), seed ^ fetch32(s + len - 4));</td>
    <td class="lineNumber">81</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine coveredLine">inline uint64_t hash_9to16_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">361</td>
    <td class="lineNumber">211</td>
    <td class="codeLine coveredLine">inline uint64_t hash_9to16_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">332</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine coveredLine">  uint64_t a = fetch64(s);</td>
    <td class="lineNumber">361</td>
    <td class="lineNumber">212</td>
    <td class="codeLine coveredLine">  uint64_t a = fetch64(s);</td>
    <td class="lineNumber">332</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine coveredLine">  uint64_t b = fetch64(s + len - 8);</td>
    <td class="lineNumber">361</td>
    <td class="lineNumber">213</td>
    <td class="codeLine coveredLine">  uint64_t b = fetch64(s + len - 8);</td>
    <td class="lineNumber">332</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine coveredLine">  return hash_16_bytes(seed ^ a, rotate(b + len, len)) ^ b;</td>
    <td class="lineNumber">361</td>
    <td class="lineNumber">214</td>
    <td class="codeLine coveredLine">  return hash_16_bytes(seed ^ a, rotate(b + len, len)) ^ b;</td>
    <td class="lineNumber">332</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine coveredLine">inline uint64_t hash_17to32_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">187</td>
    <td class="lineNumber">217</td>
    <td class="codeLine coveredLine">inline uint64_t hash_17to32_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine coveredLine">  uint64_t a = fetch64(s) * k1;</td>
    <td class="lineNumber">187</td>
    <td class="lineNumber">218</td>
    <td class="codeLine coveredLine">  uint64_t a = fetch64(s) * k1;</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine coveredLine">  uint64_t b = fetch64(s + 8);</td>
    <td class="lineNumber">187</td>
    <td class="lineNumber">219</td>
    <td class="codeLine coveredLine">  uint64_t b = fetch64(s + 8);</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine coveredLine">  uint64_t c = fetch64(s + len - 8) * k2;</td>
    <td class="lineNumber">187</td>
    <td class="lineNumber">220</td>
    <td class="codeLine coveredLine">  uint64_t c = fetch64(s + len - 8) * k2;</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine coveredLine">  uint64_t d = fetch64(s + len - 16) * k0;</td>
    <td class="lineNumber">187</td>
    <td class="lineNumber">221</td>
    <td class="codeLine coveredLine">  uint64_t d = fetch64(s + len - 16) * k0;</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine coveredLine">  return hash_16_bytes(llvm::rotr<uint64_t>(a - b, 43) +</td>
    <td class="lineNumber">187</td>
    <td class="lineNumber">222</td>
    <td class="codeLine coveredLine">  return hash_16_bytes(llvm::rotr<uint64_t>(a - b, 43) +</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine coveredLine">                           llvm::rotr<uint64_t>(c ^ seed, 30) + d,</td>
    <td class="lineNumber">187</td>
    <td class="lineNumber">223</td>
    <td class="codeLine coveredLine">                           llvm::rotr<uint64_t>(c ^ seed, 30) + d,</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine coveredLine">                       a + llvm::rotr<uint64_t>(b ^ k3, 20) - c + len + seed);</td>
    <td class="lineNumber">374</td>
    <td class="lineNumber">224</td>
    <td class="codeLine coveredLine">                       a + llvm::rotr<uint64_t>(b ^ k3, 20) - c + len + seed);</td>
    <td class="lineNumber">260</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine coveredLine">inline uint64_t hash_33to64_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">227</td>
    <td class="codeLine coveredLine">inline uint64_t hash_33to64_bytes(const char *s, size_t len, uint64_t seed) {</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine coveredLine">  uint64_t z = fetch64(s + 24);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">228</td>
    <td class="codeLine coveredLine">  uint64_t z = fetch64(s + 24);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine coveredLine">  uint64_t a = fetch64(s) + (len + fetch64(s + len - 16)) * k0;</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">229</td>
    <td class="codeLine coveredLine">  uint64_t a = fetch64(s) + (len + fetch64(s + len - 16)) * k0;</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine coveredLine">  uint64_t b = llvm::rotr<uint64_t>(a + z, 52);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">230</td>
    <td class="codeLine coveredLine">  uint64_t b = llvm::rotr<uint64_t>(a + z, 52);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine coveredLine">  uint64_t c = llvm::rotr<uint64_t>(a, 37);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">231</td>
    <td class="codeLine coveredLine">  uint64_t c = llvm::rotr<uint64_t>(a, 37);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine coveredLine">  a += fetch64(s + 8);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">232</td>
    <td class="codeLine coveredLine">  a += fetch64(s + 8);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine coveredLine">  c += llvm::rotr<uint64_t>(a, 7);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">233</td>
    <td class="codeLine coveredLine">  c += llvm::rotr<uint64_t>(a, 7);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine coveredLine">  a += fetch64(s + 16);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">234</td>
    <td class="codeLine coveredLine">  a += fetch64(s + 16);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine coveredLine">  uint64_t vf = a + z;</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">235</td>
    <td class="codeLine coveredLine">  uint64_t vf = a + z;</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine coveredLine">  uint64_t vs = b + llvm::rotr<uint64_t>(a, 31) + c;</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">236</td>
    <td class="codeLine coveredLine">  uint64_t vs = b + llvm::rotr<uint64_t>(a, 31) + c;</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine coveredLine">  a = fetch64(s + 16) + fetch64(s + len - 32);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">237</td>
    <td class="codeLine coveredLine">  a = fetch64(s + 16) + fetch64(s + len - 32);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine coveredLine">  z = fetch64(s + len - 8);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">238</td>
    <td class="codeLine coveredLine">  z = fetch64(s + len - 8);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine coveredLine">  b = llvm::rotr<uint64_t>(a + z, 52);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">239</td>
    <td class="codeLine coveredLine">  b = llvm::rotr<uint64_t>(a + z, 52);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine coveredLine">  c = llvm::rotr<uint64_t>(a, 37);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">240</td>
    <td class="codeLine coveredLine">  c = llvm::rotr<uint64_t>(a, 37);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine coveredLine">  a += fetch64(s + len - 24);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">241</td>
    <td class="codeLine coveredLine">  a += fetch64(s + len - 24);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine coveredLine">  c += llvm::rotr<uint64_t>(a, 7);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">242</td>
    <td class="codeLine coveredLine">  c += llvm::rotr<uint64_t>(a, 7);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine coveredLine">  a += fetch64(s + len - 16);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">243</td>
    <td class="codeLine coveredLine">  a += fetch64(s + len - 16);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine coveredLine">  uint64_t wf = a + z;</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">244</td>
    <td class="codeLine coveredLine">  uint64_t wf = a + z;</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine coveredLine">  uint64_t ws = b + llvm::rotr<uint64_t>(a, 31) + c;</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">245</td>
    <td class="codeLine coveredLine">  uint64_t ws = b + llvm::rotr<uint64_t>(a, 31) + c;</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine coveredLine">  uint64_t r = shift_mix((vf + ws) * k2 + (wf + vs) * k0);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">246</td>
    <td class="codeLine coveredLine">  uint64_t r = shift_mix((vf + ws) * k2 + (wf + vs) * k0);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine coveredLine">  return shift_mix((seed ^ (r * k0)) + vs) * k2;</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">247</td>
    <td class="codeLine coveredLine">  return shift_mix((seed ^ (r * k0)) + vs) * k2;</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine coveredLine">inline uint64_t hash_short(const char *s, size_t length, uint64_t seed) {</td>
    <td class="lineNumber">800</td>
    <td class="lineNumber">250</td>
    <td class="codeLine coveredLine">inline uint64_t hash_short(const char *s, size_t length, uint64_t seed) {</td>
    <td class="lineNumber">633</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine coveredLine">  if (length >= 4 && length <= 8)</td>
    <td class="lineNumber">800</td>
    <td class="lineNumber">251</td>
    <td class="codeLine coveredLine">  if (length >= 4 && length <= 8)</td>
    <td class="lineNumber">633</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine coveredLine">    return hash_4to8_bytes(s, length, seed);</td>
    <td class="lineNumber">137</td>
    <td class="lineNumber">252</td>
    <td class="codeLine coveredLine">    return hash_4to8_bytes(s, length, seed);</td>
    <td class="lineNumber">81</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine coveredLine">  if (length > 8 && length <= 16)</td>
    <td class="lineNumber">663</td>
    <td class="lineNumber">253</td>
    <td class="codeLine coveredLine">  if (length > 8 && length <= 16)</td>
    <td class="lineNumber">552</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine coveredLine">    return hash_9to16_bytes(s, length, seed);</td>
    <td class="lineNumber">361</td>
    <td class="lineNumber">254</td>
    <td class="codeLine coveredLine">    return hash_9to16_bytes(s, length, seed);</td>
    <td class="lineNumber">332</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine coveredLine">  if (length > 16 && length <= 32)</td>
    <td class="lineNumber">302</td>
    <td class="lineNumber">255</td>
    <td class="codeLine coveredLine">  if (length > 16 && length <= 32)</td>
    <td class="lineNumber">220</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine coveredLine">    return hash_17to32_bytes(s, length, seed);</td>
    <td class="lineNumber">187</td>
    <td class="lineNumber">256</td>
    <td class="codeLine coveredLine">    return hash_17to32_bytes(s, length, seed);</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine coveredLine">  if (length > 32)</td>
    <td class="lineNumber">115</td>
    <td class="lineNumber">257</td>
    <td class="codeLine coveredLine">  if (length > 32)</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine coveredLine">    return hash_33to64_bytes(s, length, seed);</td>
    <td class="lineNumber">111</td>
    <td class="lineNumber">258</td>
    <td class="codeLine coveredLine">    return hash_33to64_bytes(s, length, seed);</td>
    <td class="lineNumber">90</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine coveredLine">  if (length != 0)</td>
    <td class="lineNumber">4</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">  if (length != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">    return hash_1to3_bytes(s, length, seed);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">    return hash_1to3_bytes(s, length, seed);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine coveredLine">  return k2 ^ seed;</td>
    <td class="lineNumber">4</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">  return k2 ^ seed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">/// The intermediate state used during hashing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">/// The intermediate state used during hashing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">/// Currently, the algorithm for computing hash codes is based on CityHash and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">/// Currently, the algorithm for computing hash codes is based on CityHash and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">/// keeps 56 bytes of arbitrary state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">/// keeps 56 bytes of arbitrary state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">struct hash_state {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">struct hash_state {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  uint64_t h0 = 0, h1 = 0, h2 = 0, h3 = 0, h4 = 0, h5 = 0, h6 = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  uint64_t h0 = 0, h1 = 0, h2 = 0, h3 = 0, h4 = 0, h5 = 0, h6 = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  /// Create a new hash_state structure and initialize it based on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  /// Create a new hash_state structure and initialize it based on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">  /// seed and the first 64-byte chunk.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">  /// seed and the first 64-byte chunk.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">  /// This effectively performs the initial mix.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">  /// This effectively performs the initial mix.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine coveredLine">  static hash_state create(const char *s, uint64_t seed) {</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">274</td>
    <td class="codeLine coveredLine">  static hash_state create(const char *s, uint64_t seed) {</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine coveredLine">    hash_state state = {0,</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">275</td>
    <td class="codeLine coveredLine">    hash_state state = {0,</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">                        seed,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">                        seed,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine coveredLine">                        hash_16_bytes(seed, k1),</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">277</td>
    <td class="codeLine coveredLine">                        hash_16_bytes(seed, k1),</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine coveredLine">                        llvm::rotr<uint64_t>(seed ^ k1, 49),</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">278</td>
    <td class="codeLine coveredLine">                        llvm::rotr<uint64_t>(seed ^ k1, 49),</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine coveredLine">                        seed * k1,</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">279</td>
    <td class="codeLine coveredLine">                        seed * k1,</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine coveredLine">                        shift_mix(seed),</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">280</td>
    <td class="codeLine coveredLine">                        shift_mix(seed),</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine coveredLine">                        0};</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">281</td>
    <td class="codeLine coveredLine">                        0};</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine coveredLine">    state.h6 = hash_16_bytes(state.h4, state.h5);</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">282</td>
    <td class="codeLine coveredLine">    state.h6 = hash_16_bytes(state.h4, state.h5);</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine coveredLine">    state.mix(s);</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">283</td>
    <td class="codeLine coveredLine">    state.mix(s);</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine coveredLine">    return state;</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">284</td>
    <td class="codeLine coveredLine">    return state;</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  /// Mix 32-bytes from the input sequence into the 16-bytes of 'a'</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  /// Mix 32-bytes from the input sequence into the 16-bytes of 'a'</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  /// and 'b', including whatever is already in 'a' and 'b'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  /// and 'b', including whatever is already in 'a' and 'b'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine coveredLine">  static void mix_32_bytes(const char *s, uint64_t &a, uint64_t &b) {</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">289</td>
    <td class="codeLine coveredLine">  static void mix_32_bytes(const char *s, uint64_t &a, uint64_t &b) {</td>
    <td class="lineNumber">924</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine coveredLine">    a += fetch64(s);</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">290</td>
    <td class="codeLine coveredLine">    a += fetch64(s);</td>
    <td class="lineNumber">924</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine coveredLine">    uint64_t c = fetch64(s + 24);</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">291</td>
    <td class="codeLine coveredLine">    uint64_t c = fetch64(s + 24);</td>
    <td class="lineNumber">924</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine coveredLine">    b = llvm::rotr<uint64_t>(b + a + c, 21);</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">292</td>
    <td class="codeLine coveredLine">    b = llvm::rotr<uint64_t>(b + a + c, 21);</td>
    <td class="lineNumber">924</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine coveredLine">    uint64_t d = a;</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">293</td>
    <td class="codeLine coveredLine">    uint64_t d = a;</td>
    <td class="lineNumber">924</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine coveredLine">    a += fetch64(s + 8) + fetch64(s + 16);</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">294</td>
    <td class="codeLine coveredLine">    a += fetch64(s + 8) + fetch64(s + 16);</td>
    <td class="lineNumber">924</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine coveredLine">    b += llvm::rotr<uint64_t>(a, 44) + d;</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">295</td>
    <td class="codeLine coveredLine">    b += llvm::rotr<uint64_t>(a, 44) + d;</td>
    <td class="lineNumber">924</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine coveredLine">    a += c;</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">296</td>
    <td class="codeLine coveredLine">    a += c;</td>
    <td class="lineNumber">924</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">297</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">924</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  /// Mix in a 64-byte buffer of data.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  /// Mix in a 64-byte buffer of data.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">  /// We mix all 64 bytes even when the chunk length is smaller, but we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">  /// We mix all 64 bytes even when the chunk length is smaller, but we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  /// record the actual length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  /// record the actual length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine coveredLine">  void mix(const char *s) {</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">302</td>
    <td class="codeLine coveredLine">  void mix(const char *s) {</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine coveredLine">    h0 = llvm::rotr<uint64_t>(h0 + h1 + h3 + fetch64(s + 8), 37) * k1;</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">303</td>
    <td class="codeLine coveredLine">    h0 = llvm::rotr<uint64_t>(h0 + h1 + h3 + fetch64(s + 8), 37) * k1;</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine coveredLine">    h1 = llvm::rotr<uint64_t>(h1 + h4 + fetch64(s + 48), 42) * k1;</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">304</td>
    <td class="codeLine coveredLine">    h1 = llvm::rotr<uint64_t>(h1 + h4 + fetch64(s + 48), 42) * k1;</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine coveredLine">    h0 ^= h6;</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">305</td>
    <td class="codeLine coveredLine">    h0 ^= h6;</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine coveredLine">    h1 += h3 + fetch64(s + 40);</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">306</td>
    <td class="codeLine coveredLine">    h1 += h3 + fetch64(s + 40);</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine coveredLine">    h2 = llvm::rotr<uint64_t>(h2 + h5, 33) * k1;</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">307</td>
    <td class="codeLine coveredLine">    h2 = llvm::rotr<uint64_t>(h2 + h5, 33) * k1;</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine coveredLine">    h3 = h4 * k1;</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">308</td>
    <td class="codeLine coveredLine">    h3 = h4 * k1;</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine coveredLine">    h4 = h0 + h5;</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">309</td>
    <td class="codeLine coveredLine">    h4 = h0 + h5;</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine coveredLine">    mix_32_bytes(s, h3, h4);</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">310</td>
    <td class="codeLine coveredLine">    mix_32_bytes(s, h3, h4);</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine coveredLine">    h5 = h2 + h6;</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">311</td>
    <td class="codeLine coveredLine">    h5 = h2 + h6;</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine coveredLine">    h6 = h1 + fetch64(s + 16);</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">312</td>
    <td class="codeLine coveredLine">    h6 = h1 + fetch64(s + 16);</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine coveredLine">    mix_32_bytes(s + 32, h5, h6);</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">313</td>
    <td class="codeLine coveredLine">    mix_32_bytes(s + 32, h5, h6);</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine coveredLine">    std::swap(h2, h0);</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">314</td>
    <td class="codeLine coveredLine">    std::swap(h2, h0);</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">466</td>
    <td class="lineNumber">315</td>
    <td class="codeLine coveredLine">  }</td>
    <td class="lineNumber">462</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">  /// Compute the final 64-bit hash code value based on the current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">  /// Compute the final 64-bit hash code value based on the current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">  /// state and the length of bytes hashed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">  /// state and the length of bytes hashed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine coveredLine">  uint64_t finalize(size_t length) {</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">319</td>
    <td class="codeLine coveredLine">  uint64_t finalize(size_t length) {</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine coveredLine">    return hash_16_bytes(hash_16_bytes(h3, h5) + shift_mix(h1) * k1 + h2,</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">320</td>
    <td class="codeLine coveredLine">    return hash_16_bytes(hash_16_bytes(h3, h5) + shift_mix(h1) * k1 + h2,</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine coveredLine">                         hash_16_bytes(h4, h6) + shift_mix(length) * k1 + h0);</td>
    <td class="lineNumber">264</td>
    <td class="lineNumber">321</td>
    <td class="codeLine coveredLine">                         hash_16_bytes(h4, h6) + shift_mix(length) * k1 + h0);</td>
    <td class="lineNumber">260</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">/// A global, fixed seed-override variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">/// A global, fixed seed-override variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">/// This variable can be set using the \see llvm::set_fixed_execution_seed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">/// This variable can be set using the \see llvm::set_fixed_execution_seed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">/// function. See that function for details. Do not, under any circumstances,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">/// function. See that function for details. Do not, under any circumstances,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">/// set or read this variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">/// set or read this variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">extern uint64_t fixed_seed_override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">extern uint64_t fixed_seed_override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine coveredLine">inline uint64_t get_execution_seed() {</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">333</td>
    <td class="codeLine coveredLine">inline uint64_t get_execution_seed() {</td>
    <td class="lineNumber">763</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">  // FIXME: This needs to be a per-execution seed. This is just a placeholder</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">  // FIXME: This needs to be a per-execution seed. This is just a placeholder</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">  // implementation. Switching to a per-execution seed is likely to flush out</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">  // implementation. Switching to a per-execution seed is likely to flush out</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">  // instability bugs and so will happen as its own commit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">  // instability bugs and so will happen as its own commit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">  // However, if there is a fixed seed override set the first time this is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">  // However, if there is a fixed seed override set the first time this is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">  // called, return that instead of the per-execution seed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">  // called, return that instead of the per-execution seed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine coveredLine">  const uint64_t seed_prime = 0xff51afd7ed558ccdULL;</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">340</td>
    <td class="codeLine coveredLine">  const uint64_t seed_prime = 0xff51afd7ed558ccdULL;</td>
    <td class="lineNumber">763</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine coveredLine">  static uint64_t seed = fixed_seed_override ? fixed_seed_override : seed_prime;</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">341</td>
    <td class="codeLine coveredLine">  static uint64_t seed = fixed_seed_override ? fixed_seed_override : seed_prime;</td>
    <td class="lineNumber">763</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine coveredLine">  return seed;</td>
    <td class="lineNumber">932</td>
    <td class="lineNumber">342</td>
    <td class="codeLine coveredLine">  return seed;</td>
    <td class="lineNumber">763</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">/// Trait to indicate whether a type's bits can be hashed directly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">/// Trait to indicate whether a type's bits can be hashed directly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">/// A type trait which is true if we want to combine values for hashing by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">/// A type trait which is true if we want to combine values for hashing by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">/// reading the underlying data. It is false if values of this type must</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">/// reading the underlying data. It is false if values of this type must</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">/// first be passed to hash_value, and the resulting hash_codes combined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">/// first be passed to hash_value, and the resulting hash_codes combined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">// FIXME: We want to replace is_integral_or_enum and is_pointer here with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">// FIXME: We want to replace is_integral_or_enum and is_pointer here with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">// a predicate which asserts that comparing the underlying storage of two</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">// a predicate which asserts that comparing the underlying storage of two</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">// values of the type for equality is equivalent to comparing the two values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">// values of the type for equality is equivalent to comparing the two values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">// for equality. For all the platforms we care about, this holds for integers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">// for equality. For all the platforms we care about, this holds for integers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">// and pointers, but there are platforms where it doesn't and we would like to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">// and pointers, but there are platforms where it doesn't and we would like to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">// support user-defined types which happen to satisfy this property.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">// support user-defined types which happen to satisfy this property.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">template <typename T> struct is_hashable_data</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">template <typename T> struct is_hashable_data</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">  : std::integral_constant<bool, ((is_integral_or_enum<T>::value ||</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">  : std::integral_constant<bool, ((is_integral_or_enum<T>::value ||</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">                                   std::is_pointer<T>::value) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">                                   std::is_pointer<T>::value) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">                                  64 % sizeof(T) == 0)> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">                                  64 % sizeof(T) == 0)> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">// Special case std::pair to detect when both types are viable and when there</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">// Special case std::pair to detect when both types are viable and when there</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">// is no alignment-derived padding in the pair. This is a bit of a lie because</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">// is no alignment-derived padding in the pair. This is a bit of a lie because</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">// std::pair isn't truly POD, but it's close enough in all reasonable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">// std::pair isn't truly POD, but it's close enough in all reasonable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">// implementations for our use case of hashing the underlying data.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">// implementations for our use case of hashing the underlying data.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">template <typename T, typename U> struct is_hashable_data<std::pair<T, U> ></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">template <typename T, typename U> struct is_hashable_data<std::pair<T, U> ></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">  : std::integral_constant<bool, (is_hashable_data<T>::value &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">  : std::integral_constant<bool, (is_hashable_data<T>::value &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">                                  is_hashable_data<U>::value &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">                                  is_hashable_data<U>::value &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">                                  (sizeof(T) + sizeof(U)) ==</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">                                  (sizeof(T) + sizeof(U)) ==</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">                                   sizeof(std::pair<T, U>))> {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">                                   sizeof(std::pair<T, U>))> {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">/// Helper to get the hashable data representation for a type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">/// Helper to get the hashable data representation for a type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">/// This variant is enabled when the type itself can be used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">/// This variant is enabled when the type itself can be used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">std::enable_if_t<is_hashable_data<T>::value, T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">std::enable_if_t<is_hashable_data<T>::value, T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine coveredLine">get_hashable_data(const T &value) {</td>
    <td class="lineNumber">101</td>
    <td class="lineNumber">377</td>
    <td class="codeLine coveredLine">get_hashable_data(const T &value) {</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine coveredLine">  return value;</td>
    <td class="lineNumber">101</td>
    <td class="lineNumber">378</td>
    <td class="codeLine coveredLine">  return value;</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">/// Helper to get the hashable data representation for a type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">/// Helper to get the hashable data representation for a type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">/// This variant is enabled when we must first call hash_value and use the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">/// This variant is enabled when we must first call hash_value and use the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">/// result as our data.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">/// result as our data.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">std::enable_if_t<!is_hashable_data<T>::value, size_t></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">std::enable_if_t<!is_hashable_data<T>::value, size_t></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine coveredLine">get_hashable_data(const T &value) {</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">385</td>
    <td class="codeLine coveredLine">get_hashable_data(const T &value) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">  using ::llvm::hash_value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">  using ::llvm::hash_value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine coveredLine">  return hash_value(value);</td>
    <td class="lineNumber">5</td>
    <td class="lineNumber">387</td>
    <td class="codeLine coveredLine">  return hash_value(value);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">/// Helper to store data from a value into a buffer and advance the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">/// Helper to store data from a value into a buffer and advance the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">/// pointer into that buffer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">/// pointer into that buffer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">/// This routine first checks whether there is enough space in the provided</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">/// This routine first checks whether there is enough space in the provided</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">/// buffer, and if not immediately returns false. If there is space, it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">/// buffer, and if not immediately returns false. If there is space, it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">/// copies the underlying bytes of value into the buffer, advances the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">/// copies the underlying bytes of value into the buffer, advances the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">/// buffer_ptr past the copied bytes, and returns true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">/// buffer_ptr past the copied bytes, and returns true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine coveredLine">bool store_and_advance(char *&buffer_ptr, char *buffer_end, const T& value,</td>
    <td class="lineNumber">22</td>
    <td class="lineNumber">398</td>
    <td class="codeLine coveredLine">bool store_and_advance(char *&buffer_ptr, char *buffer_end, const T& value,</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">                       size_t offset = 0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">                       size_t offset = 0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine coveredLine">  size_t store_size = sizeof(value) - offset;</td>
    <td class="lineNumber">22</td>
    <td class="lineNumber">400</td>
    <td class="codeLine coveredLine">  size_t store_size = sizeof(value) - offset;</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine coveredLine">  if (buffer_ptr + store_size > buffer_end)</td>
    <td class="lineNumber">22</td>
    <td class="lineNumber">401</td>
    <td class="codeLine coveredLine">  if (buffer_ptr + store_size > buffer_end)</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine coveredLine">  const char *value_data = reinterpret_cast<const char *>(&value);</td>
    <td class="lineNumber">22</td>
    <td class="lineNumber">403</td>
    <td class="codeLine coveredLine">  const char *value_data = reinterpret_cast<const char *>(&value);</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine coveredLine">  memcpy(buffer_ptr, value_data + offset, store_size);</td>
    <td class="lineNumber">22</td>
    <td class="lineNumber">404</td>
    <td class="codeLine coveredLine">  memcpy(buffer_ptr, value_data + offset, store_size);</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine coveredLine">  buffer_ptr += store_size;</td>
    <td class="lineNumber">22</td>
    <td class="lineNumber">405</td>
    <td class="codeLine coveredLine">  buffer_ptr += store_size;</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine coveredLine">  return true;</td>
    <td class="lineNumber">22</td>
    <td class="lineNumber">406</td>
    <td class="codeLine coveredLine">  return true;</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">/// Implement the combining of integral values into a hash_code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">/// Implement the combining of integral values into a hash_code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">/// This overload is selected when the value type of the iterator is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">/// This overload is selected when the value type of the iterator is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">/// integral. Rather than computing a hash_code for each object and then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">/// integral. Rather than computing a hash_code for each object and then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">/// combining them, this (as an optimization) directly combines the integers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">/// combining them, this (as an optimization) directly combines the integers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">template <typename InputIteratorT></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">template <typename InputIteratorT></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine coveredLine">hash_code hash_combine_range_impl(InputIteratorT first, InputIteratorT last) {</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">hash_code hash_combine_range_impl(InputIteratorT first, InputIteratorT last) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine coveredLine">  const uint64_t seed = get_execution_seed();</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">  const uint64_t seed = get_execution_seed();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine coveredLine">  char buffer[64], *buffer_ptr = buffer;</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">  char buffer[64], *buffer_ptr = buffer;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine coveredLine">  char *const buffer_end = std::end(buffer);</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">  char *const buffer_end = std::end(buffer);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine coveredLine">  while (first != last && store_and_advance(buffer_ptr, buffer_end,</td>
    <td class="lineNumber">21</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">  while (first != last && store_and_advance(buffer_ptr, buffer_end,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine coveredLine">                                            get_hashable_data(*first)))</td>
    <td class="lineNumber">21</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">                                            get_hashable_data(*first)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine coveredLine">    ++first;</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">    ++first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine coveredLine">  if (first == last)</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  if (first == last)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine coveredLine">    return hash_short(buffer, buffer_ptr - buffer, seed);</td>
    <td class="lineNumber">3</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">    return hash_short(buffer, buffer_ptr - buffer, seed);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  assert(buffer_ptr == buffer_end);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  assert(buffer_ptr == buffer_end);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  hash_state state = state.create(buffer, seed);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  hash_state state = state.create(buffer, seed);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  size_t length = 64;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  size_t length = 64;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  while (first != last) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  while (first != last) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">    // Fill up the buffer. We don't clear it, which re-mixes the last round</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">    // Fill up the buffer. We don't clear it, which re-mixes the last round</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">    // when only a partial 64-byte chunk is left.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">    // when only a partial 64-byte chunk is left.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">    buffer_ptr = buffer;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">    buffer_ptr = buffer;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">    while (first != last && store_and_advance(buffer_ptr, buffer_end,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">    while (first != last && store_and_advance(buffer_ptr, buffer_end,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">                                              get_hashable_data(*first)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">                                              get_hashable_data(*first)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">      ++first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">      ++first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">    // Rotate the buffer if we did a partial fill in order to simulate doing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">    // Rotate the buffer if we did a partial fill in order to simulate doing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">    // a mix of the last 64-bytes. That is how the algorithm works when we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">    // a mix of the last 64-bytes. That is how the algorithm works when we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">    // have a contiguous byte sequence, and we want to emulate that here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">    // have a contiguous byte sequence, and we want to emulate that here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">    std::rotate(buffer, buffer_ptr, buffer_end);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">    std::rotate(buffer, buffer_ptr, buffer_end);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">    // Mix this chunk into the current state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">    // Mix this chunk into the current state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">    state.mix(buffer);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">    state.mix(buffer);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">    length += buffer_ptr - buffer;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">    length += buffer_ptr - buffer;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">  return state.finalize(length);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">  return state.finalize(length);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">/// Implement the combining of integral values into a hash_code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">/// Implement the combining of integral values into a hash_code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">/// This overload is selected when the value type of the iterator is integral</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">/// This overload is selected when the value type of the iterator is integral</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">/// and when the input iterator is actually a pointer. Rather than computing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">/// and when the input iterator is actually a pointer. Rather than computing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">/// a hash_code for each object and then combining them, this (as an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">/// a hash_code for each object and then combining them, this (as an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">/// optimization) directly combines the integers. Also, because the integers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">/// optimization) directly combines the integers. Also, because the integers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">/// are stored in contiguous memory, this routine avoids copying each value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">/// are stored in contiguous memory, this routine avoids copying each value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">/// and directly reads from the underlying memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">/// and directly reads from the underlying memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">template <typename ValueT></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">template <typename ValueT></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">std::enable_if_t<is_hashable_data<ValueT>::value, hash_code></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">std::enable_if_t<is_hashable_data<ValueT>::value, hash_code></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine coveredLine">hash_combine_range_impl(ValueT *first, ValueT *last) {</td>
    <td class="lineNumber">869</td>
    <td class="lineNumber">459</td>
    <td class="codeLine coveredLine">hash_combine_range_impl(ValueT *first, ValueT *last) {</td>
    <td class="lineNumber">758</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine coveredLine">  const uint64_t seed = get_execution_seed();</td>
    <td class="lineNumber">869</td>
    <td class="lineNumber">460</td>
    <td class="codeLine coveredLine">  const uint64_t seed = get_execution_seed();</td>
    <td class="lineNumber">758</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine coveredLine">  const char *s_begin = reinterpret_cast<const char *>(first);</td>
    <td class="lineNumber">869</td>
    <td class="lineNumber">461</td>
    <td class="codeLine coveredLine">  const char *s_begin = reinterpret_cast<const char *>(first);</td>
    <td class="lineNumber">758</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine coveredLine">  const char *s_end = reinterpret_cast<const char *>(last);</td>
    <td class="lineNumber">869</td>
    <td class="lineNumber">462</td>
    <td class="codeLine coveredLine">  const char *s_end = reinterpret_cast<const char *>(last);</td>
    <td class="lineNumber">758</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine coveredLine">  const size_t length = std::distance(s_begin, s_end);</td>
    <td class="lineNumber">869</td>
    <td class="lineNumber">463</td>
    <td class="codeLine coveredLine">  const size_t length = std::distance(s_begin, s_end);</td>
    <td class="lineNumber">758</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine coveredLine">  if (length <= 64)</td>
    <td class="lineNumber">869</td>
    <td class="lineNumber">464</td>
    <td class="codeLine coveredLine">  if (length <= 64)</td>
    <td class="lineNumber">758</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine coveredLine">    return hash_short(s_begin, length, seed);</td>
    <td class="lineNumber">737</td>
    <td class="lineNumber">465</td>
    <td class="codeLine coveredLine">    return hash_short(s_begin, length, seed);</td>
    <td class="lineNumber">628</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine coveredLine">  const char *s_aligned_end = s_begin + (length & ~63);</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">467</td>
    <td class="codeLine coveredLine">  const char *s_aligned_end = s_begin + (length & ~63);</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine coveredLine">  hash_state state = state.create(s_begin, seed);</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">468</td>
    <td class="codeLine coveredLine">  hash_state state = state.create(s_begin, seed);</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine coveredLine">  s_begin += 64;</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">469</td>
    <td class="codeLine coveredLine">  s_begin += 64;</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine coveredLine">  while (s_begin != s_aligned_end) {</td>
    <td class="lineNumber">334</td>
    <td class="lineNumber">470</td>
    <td class="codeLine coveredLine">  while (s_begin != s_aligned_end) {</td>
    <td class="lineNumber">332</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine coveredLine">    state.mix(s_begin);</td>
    <td class="lineNumber">202</td>
    <td class="lineNumber">471</td>
    <td class="codeLine coveredLine">    state.mix(s_begin);</td>
    <td class="lineNumber">202</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine coveredLine">    s_begin += 64;</td>
    <td class="lineNumber">202</td>
    <td class="lineNumber">472</td>
    <td class="codeLine coveredLine">    s_begin += 64;</td>
    <td class="lineNumber">202</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine coveredLine">  if (length & 63)</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">474</td>
    <td class="codeLine coveredLine">  if (length & 63)</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine coveredLine">    state.mix(s_end - 64);</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">475</td>
    <td class="codeLine coveredLine">    state.mix(s_end - 64);</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine coveredLine">  return state.finalize(length);</td>
    <td class="lineNumber">132</td>
    <td class="lineNumber">477</td>
    <td class="codeLine coveredLine">  return state.finalize(length);</td>
    <td class="lineNumber">130</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">} // namespace hashing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">} // namespace hashing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">/// Compute a hash_code for a sequence of values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">/// Compute a hash_code for a sequence of values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">/// This hashes a sequence of values. It produces the same hash_code as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">/// This hashes a sequence of values. It produces the same hash_code as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">/// 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">/// 'hash_combine(a, b, c, ...)', but can run over arbitrary sized sequences</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">/// and is significantly faster given pointers and types which can be hashed as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">/// and is significantly faster given pointers and types which can be hashed as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">/// a sequence of bytes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">/// a sequence of bytes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">template <typename InputIteratorT></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">template <typename InputIteratorT></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine coveredLine">hash_code hash_combine_range(InputIteratorT first, InputIteratorT last) {</td>
    <td class="lineNumber">862</td>
    <td class="lineNumber">491</td>
    <td class="codeLine coveredLine">hash_code hash_combine_range(InputIteratorT first, InputIteratorT last) {</td>
    <td class="lineNumber">755</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine coveredLine">  return ::llvm::hashing::detail::hash_combine_range_impl(first, last);</td>
    <td class="lineNumber">862</td>
    <td class="lineNumber">492</td>
    <td class="codeLine coveredLine">  return ::llvm::hashing::detail::hash_combine_range_impl(first, last);</td>
    <td class="lineNumber">755</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">// Implementation details for hash_combine.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">// Implementation details for hash_combine.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">namespace hashing {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">namespace hashing {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">/// Helper class to manage the recursive combining of hash_combine</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">/// Helper class to manage the recursive combining of hash_combine</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">/// arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">/// arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">/// This class exists to manage the state and various calls involved in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">/// This class exists to manage the state and various calls involved in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">/// recursive combining of arguments used in hash_combine. It is particularly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">/// recursive combining of arguments used in hash_combine. It is particularly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">/// useful at minimizing the code in the recursive calls to ease the pain</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">/// useful at minimizing the code in the recursive calls to ease the pain</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">/// caused by a lack of variadic functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">/// caused by a lack of variadic functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">struct hash_combine_recursive_helper {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">struct hash_combine_recursive_helper {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">  char buffer[64] = {};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">  char buffer[64] = {};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  hash_state state;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  hash_state state;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">  const uint64_t seed;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">  const uint64_t seed;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">  /// Construct a recursive hash combining helper.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">  /// Construct a recursive hash combining helper.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">  /// This sets up the state for a recursive hash combine, including getting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">  /// This sets up the state for a recursive hash combine, including getting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">  /// the seed and buffer setup.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">  /// the seed and buffer setup.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine coveredLine">  hash_combine_recursive_helper()</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">517</td>
    <td class="codeLine coveredLine">  hash_combine_recursive_helper()</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine coveredLine">    : seed(get_execution_seed()) {}</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">518</td>
    <td class="codeLine coveredLine">    : seed(get_execution_seed()) {}</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">  /// Combine one chunk of data into the current in-flight hash.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">  /// Combine one chunk of data into the current in-flight hash.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">  /// This merges one chunk of data into the hash. First it tries to buffer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">  /// This merges one chunk of data into the hash. First it tries to buffer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  /// the data. If the buffer is full, it hashes the buffer into its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  /// the data. If the buffer is full, it hashes the buffer into its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">  /// hash_state, empties it, and then merges the new chunk in. This also</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">  /// hash_state, empties it, and then merges the new chunk in. This also</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  /// handles cases where the data straddles the end of the buffer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  /// handles cases where the data straddles the end of the buffer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">  template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">  template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine coveredLine">  char *combine_data(size_t &length, char *buffer_ptr, char *buffer_end, T data) {</td>
    <td class="lineNumber">89</td>
    <td class="lineNumber">527</td>
    <td class="codeLine coveredLine">  char *combine_data(size_t &length, char *buffer_ptr, char *buffer_end, T data) {</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine coveredLine">    if (!store_and_advance(buffer_ptr, buffer_end, data)) {</td>
    <td class="lineNumber">89</td>
    <td class="lineNumber">528</td>
    <td class="codeLine coveredLine">    if (!store_and_advance(buffer_ptr, buffer_end, data)) {</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">      // Check for skew which prevents the buffer from being packed, and do</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">      // Check for skew which prevents the buffer from being packed, and do</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">      // a partial store into the buffer to fill it. This is only a concern</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">      // a partial store into the buffer to fill it. This is only a concern</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">      // with the variadic combine because that formation can have varying</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">      // with the variadic combine because that formation can have varying</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">      // argument types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">      // argument types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">      size_t partial_store_size = buffer_end - buffer_ptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">      size_t partial_store_size = buffer_end - buffer_ptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">      memcpy(buffer_ptr, &data, partial_store_size);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">      memcpy(buffer_ptr, &data, partial_store_size);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">      // If the store fails, our buffer is full and ready to hash. We have to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">      // If the store fails, our buffer is full and ready to hash. We have to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">      // either initialize the hash state (on the first full buffer) or mix</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">      // either initialize the hash state (on the first full buffer) or mix</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">      // this buffer into the existing hash state. Length tracks the *hashed*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">      // this buffer into the existing hash state. Length tracks the *hashed*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">      // length, not the buffered length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">      // length, not the buffered length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">      if (length == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">      if (length == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">        state = state.create(buffer, seed);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">        state = state.create(buffer, seed);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">        length = 64;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">        length = 64;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">        // Mix this chunk into the current state and bump length up by 64.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">        // Mix this chunk into the current state and bump length up by 64.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">        state.mix(buffer);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">        state.mix(buffer);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">        length += 64;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">        length += 64;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">      // Reset the buffer_ptr to the head of the buffer for the next chunk of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">      // Reset the buffer_ptr to the head of the buffer for the next chunk of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">      // data.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">      // data.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">      buffer_ptr = buffer;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">      buffer_ptr = buffer;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">      // Try again to store into the buffer -- this cannot fail as we only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">      // Try again to store into the buffer -- this cannot fail as we only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">      // store types smaller than the buffer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">      // store types smaller than the buffer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">      if (!store_and_advance(buffer_ptr, buffer_end, data,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">      if (!store_and_advance(buffer_ptr, buffer_end, data,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">                             partial_store_size))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">                             partial_store_size))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">        llvm_unreachable("buffer smaller than stored type");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">        llvm_unreachable("buffer smaller than stored type");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine coveredLine">    return buffer_ptr;</td>
    <td class="lineNumber">89</td>
    <td class="lineNumber">558</td>
    <td class="codeLine coveredLine">    return buffer_ptr;</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">  /// Recursive, variadic combining method.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">  /// Recursive, variadic combining method.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">  /// This function recurses through each argument, combining that argument</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">  /// This function recurses through each argument, combining that argument</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">  /// into a single hash.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">  /// into a single hash.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">  template <typename T, typename ...Ts></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">  template <typename T, typename ...Ts></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine coveredLine">  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end,</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">566</td>
    <td class="codeLine coveredLine">  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">                    const T &arg, const Ts &...args) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">                    const T &arg, const Ts &...args) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine coveredLine">    buffer_ptr = combine_data(length, buffer_ptr, buffer_end, get_hashable_data(arg));</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">568</td>
    <td class="codeLine coveredLine">    buffer_ptr = combine_data(length, buffer_ptr, buffer_end, get_hashable_data(arg));</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">    // Recurse to the next argument.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">    // Recurse to the next argument.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine coveredLine">    return combine(length, buffer_ptr, buffer_end, args...);</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">571</td>
    <td class="codeLine coveredLine">    return combine(length, buffer_ptr, buffer_end, args...);</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">  /// Base case for recursive, variadic combining.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">  /// Base case for recursive, variadic combining.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  /// The base case when combining arguments recursively is reached when all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  /// The base case when combining arguments recursively is reached when all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  /// arguments have been handled. It flushes the remaining buffer and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  /// arguments have been handled. It flushes the remaining buffer and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">  /// constructs a hash_code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">  /// constructs a hash_code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine coveredLine">  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end) {</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">579</td>
    <td class="codeLine coveredLine">  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end) {</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">    // Check whether the entire set of values fit in the buffer. If so, we'll</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">    // Check whether the entire set of values fit in the buffer. If so, we'll</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">    // use the optimized short hashing routine and skip state entirely.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">    // use the optimized short hashing routine and skip state entirely.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine coveredLine">    if (length == 0)</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">582</td>
    <td class="codeLine coveredLine">    if (length == 0)</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine coveredLine">      return hash_short(buffer, buffer_ptr - buffer, seed);</td>
    <td class="lineNumber">55</td>
    <td class="lineNumber">583</td>
    <td class="codeLine coveredLine">      return hash_short(buffer, buffer_ptr - buffer, seed);</td>
    <td class="lineNumber">4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">    // Mix the final buffer, rotating it if we did a partial fill in order to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">    // Mix the final buffer, rotating it if we did a partial fill in order to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">    // simulate doing a mix of the last 64-bytes. That is how the algorithm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">    // simulate doing a mix of the last 64-bytes. That is how the algorithm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">    // works when we have a contiguous byte sequence, and we want to emulate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">    // works when we have a contiguous byte sequence, and we want to emulate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">    // that here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">    // that here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">    std::rotate(buffer, buffer_ptr, buffer_end);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">    std::rotate(buffer, buffer_ptr, buffer_end);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">    // Mix this chunk into the current state.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">    // Mix this chunk into the current state.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">    state.mix(buffer);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">    state.mix(buffer);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    length += buffer_ptr - buffer;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    length += buffer_ptr - buffer;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">    return state.finalize(length);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">    return state.finalize(length);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">} // namespace hashing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">} // namespace hashing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">/// Combine values into a single hash_code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">/// Combine values into a single hash_code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">/// This routine accepts a varying number of arguments of any type. It will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">/// This routine accepts a varying number of arguments of any type. It will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">/// attempt to combine them into a single hash_code. For user-defined types it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">/// attempt to combine them into a single hash_code. For user-defined types it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">/// attempts to call a \see hash_value overload (via ADL) for the type. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">/// attempts to call a \see hash_value overload (via ADL) for the type. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">/// integer and pointer types it directly combines their data into the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">/// integer and pointer types it directly combines their data into the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">/// resulting hash_code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">/// resulting hash_code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">/// The result is suitable for returning from a user's hash_value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">/// The result is suitable for returning from a user's hash_value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">/// *implementation* for their user-defined type. Consumers of a type should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">/// *implementation* for their user-defined type. Consumers of a type should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">/// *not* call this routine, they should instead call 'hash_value'.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">/// *not* call this routine, they should instead call 'hash_value'.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine coveredLine">template <typename ...Ts> hash_code hash_combine(const Ts &...args) {</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">613</td>
    <td class="codeLine coveredLine">template <typename ...Ts> hash_code hash_combine(const Ts &...args) {</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">  // Recursively hash each argument using a helper class.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">  // Recursively hash each argument using a helper class.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine coveredLine">  ::llvm::hashing::detail::hash_combine_recursive_helper helper;</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">615</td>
    <td class="codeLine coveredLine">  ::llvm::hashing::detail::hash_combine_recursive_helper helper;</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine coveredLine">  return helper.combine(0, helper.buffer, helper.buffer + 64, args...);</td>
    <td class="lineNumber">7</td>
    <td class="lineNumber">616</td>
    <td class="codeLine coveredLine">  return helper.combine(0, helper.buffer, helper.buffer + 64, args...);</td>
    <td class="lineNumber">3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">// Implementation details for implementations of hash_value overloads provided</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">// Implementation details for implementations of hash_value overloads provided</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">// here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">// here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">namespace hashing {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">namespace hashing {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">namespace detail {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">/// Helper to hash the value of a single integer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">/// Helper to hash the value of a single integer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">/// Overloads for smaller integer types are not provided to ensure consistent</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">/// Overloads for smaller integer types are not provided to ensure consistent</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">/// behavior in the presence of integral promotions. Essentially,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">/// behavior in the presence of integral promotions. Essentially,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">/// "hash_value('4')" and "hash_value('0' + 4)" should be the same.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">/// "hash_value('4')" and "hash_value('0' + 4)" should be the same.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">inline hash_code hash_integer_value(uint64_t value) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">inline hash_code hash_integer_value(uint64_t value) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">  // Similar to hash_4to8_bytes but using a seed instead of length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">  // Similar to hash_4to8_bytes but using a seed instead of length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">  const uint64_t seed = get_execution_seed();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">  const uint64_t seed = get_execution_seed();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  const char *s = reinterpret_cast<const char *>(&value);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  const char *s = reinterpret_cast<const char *>(&value);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  const uint64_t a = fetch32(s);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  const uint64_t a = fetch32(s);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  return hash_16_bytes(seed + (a << 3), fetch32(s + 4));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  return hash_16_bytes(seed + (a << 3), fetch32(s + 4));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">} // namespace detail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">} // namespace hashing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">} // namespace hashing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">// Declared and documented above, but defined here so that any of the hashing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">// Declared and documented above, but defined here so that any of the hashing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">// infrastructure is available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">// infrastructure is available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">  return ::llvm::hashing::detail::hash_integer_value(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">  return ::llvm::hashing::detail::hash_integer_value(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">      static_cast<uint64_t>(value));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">      static_cast<uint64_t>(value));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">// Declared and documented above, but defined here so that any of the hashing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">// Declared and documented above, but defined here so that any of the hashing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">// infrastructure is available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">// infrastructure is available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">template <typename T> hash_code hash_value(const T *ptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">template <typename T> hash_code hash_value(const T *ptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  return ::llvm::hashing::detail::hash_integer_value(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  return ::llvm::hashing::detail::hash_integer_value(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">    reinterpret_cast<uintptr_t>(ptr));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">    reinterpret_cast<uintptr_t>(ptr));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">// Declared and documented above, but defined here so that any of the hashing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">// Declared and documented above, but defined here so that any of the hashing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">// infrastructure is available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">// infrastructure is available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">template <typename T, typename U></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">template <typename T, typename U></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">hash_code hash_value(const std::pair<T, U> &arg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">hash_code hash_value(const std::pair<T, U> &arg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">  return hash_combine(arg.first, arg.second);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">  return hash_combine(arg.first, arg.second);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">template <typename... Ts> hash_code hash_value(const std::tuple<Ts...> &arg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">template <typename... Ts> hash_code hash_value(const std::tuple<Ts...> &arg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">  return std::apply([](const auto &...xs) { return hash_combine(xs...); }, arg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">  return std::apply([](const auto &...xs) { return hash_combine(xs...); }, arg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">// Declared and documented above, but defined here so that any of the hashing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">// Declared and documented above, but defined here so that any of the hashing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">// infrastructure is available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">// infrastructure is available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">hash_code hash_value(const std::basic_string<T> &arg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">hash_code hash_value(const std::basic_string<T> &arg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">  return hash_combine_range(arg.begin(), arg.end());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">  return hash_combine_range(arg.begin(), arg.end());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">template <typename T> hash_code hash_value(const std::optional<T> &arg) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">template <typename T> hash_code hash_value(const std::optional<T> &arg) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  return arg ? hash_combine(true, *arg) : hash_value(false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  return arg ? hash_combine(true, *arg) : hash_value(false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">template <> struct DenseMapInfo<hash_code, void> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">template <> struct DenseMapInfo<hash_code, void> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">  static inline hash_code getEmptyKey() { return hash_code(-1); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">  static inline hash_code getEmptyKey() { return hash_code(-1); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  static inline hash_code getTombstoneKey() { return hash_code(-2); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  static inline hash_code getTombstoneKey() { return hash_code(-2); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">  static unsigned getHashValue(hash_code val) { return val; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">  static unsigned getHashValue(hash_code val) { return val; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">  static bool isEqual(hash_code LHS, hash_code RHS) { return LHS == RHS; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">  static bool isEqual(hash_code LHS, hash_code RHS) { return LHS == RHS; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">} // namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>